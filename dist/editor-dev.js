(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Mosaico = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/*global window, global*/
var util = require("util")
var assert = require("assert")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"]
    , [info, "info"]
    , [warn, "warn"]
    , [error, "error"]
    , [time, "time"]
    , [timeEnd, "timeEnd"]
    , [trace, "trace"]
    , [dir, "dir"]
    , [assert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = Date.now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = Date.now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function assert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"assert":21,"util":37}],2:[function(require,module,exports){
/*
   evol.colorpicker 3.2.2
   (c) 2015 Olivier Giulieri
   http://evoluteur.github.io/colorpicker/
*/
!function(a,b){var c=0,d=window.navigator.userAgent,e=d.indexOf("MSIE ")>0,f=e?"-ie":"",g=e?!1:/mozilla/.test(d.toLowerCase())&&!/webkit/.test(d.toLowerCase()),h=[],i=["ffffff","000000","eeece1","1f497d","4f81bd","c0504d","9bbb59","8064a2","4bacc6","f79646"],j=["f2f2f2","7f7f7f","ddd9c3","c6d9f0","dbe5f1","f2dcdb","ebf1dd","e5e0ec","dbeef3","fdeada","d8d8d8","595959","c4bd97","8db3e2","b8cce4","e5b9b7","d7e3bc","ccc1d9","b7dde8","fbd5b5","bfbfbf","3f3f3f","938953","548dd4","95b3d7","d99694","c3d69b","b2a2c7","92cddc","fac08f","a5a5a5","262626","494429","17365d","366092","953734","76923c","5f497a","31859b","e36c09","7f7f7f","0c0c0c","1d1b10","0f243e","244061","632423","4f6128","3f3151","205867","974806"],k=["c00000","ff0000","ffc000","ffff00","92d050","00b050","00b0f0","0070c0","002060","7030a0"],l=[["003366","336699","3366cc","003399","000099","0000cc","000066"],["006666","006699","0099cc","0066cc","0033cc","0000ff","3333ff","333399"],["669999","009999","33cccc","00ccff","0099ff","0066ff","3366ff","3333cc","666699"],["339966","00cc99","00ffcc","00ffff","33ccff","3399ff","6699ff","6666ff","6600ff","6600cc"],["339933","00cc66","00ff99","66ffcc","66ffff","66ccff","99ccff","9999ff","9966ff","9933ff","9900ff"],["006600","00cc00","00ff00","66ff99","99ffcc","ccffff","ccccff","cc99ff","cc66ff","cc33ff","cc00ff","9900cc"],["003300","009933","33cc33","66ff66","99ff99","ccffcc","ffffff","ffccff","ff99ff","ff66ff","ff00ff","cc00cc","660066"],["333300","009900","66ff33","99ff66","ccff99","ffffcc","ffcccc","ff99cc","ff66cc","ff33cc","cc0099","993399"],["336600","669900","99ff33","ccff66","ffff99","ffcc99","ff9999","ff6699","ff3399","cc3399","990099"],["666633","99cc00","ccff33","ffff66","ffcc66","ff9966","ff6666","ff0066","d60094","993366"],["a58800","cccc00","ffff00","ffcc00","ff9933","ff6600","ff0033","cc0066","660033"],["996633","cc9900","ff9900","cc6600","ff3300","ff0000","cc0000","990033"],["663300","996600","cc3300","993300","990000","800000","993333"]],m="#0000ffff",n=function(a){var b=a.toString(16);return 1==b.length&&(b="0"+b),b},o=function(a){return n(Number(a))},p=function(a){var b=n(a);return b+b+b},q=function(a){if(a.length>10){var b=1+a.indexOf("("),c=a.indexOf(")"),d=a.substring(b,c).split(",");return["#",o(d[0]),o(d[1]),o(d[2])].join("")}return a};a.widget("evol.colorpicker",{version:"3.2.1",options:{color:null,showOn:"both",hideButton:!1,displayIndicator:!0,transparentColor:!1,history:!0,defaultPalette:"theme",strings:"Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet."},_active:!1,_create:function(){var b=this;switch(this._paletteIdx="theme"==this.options.defaultPalette?1:2,this._id="evo-cp"+c++,this._enabled=!0,this.options.showOn=this.options.hideButton?"focus":this.options.showOn,this.element.get(0).tagName){case"INPUT":var d=this.options.color,h=this.element,i=("focus"===this.options.showOn?"":"evo-pointer ")+"evo-colorind"+(g?"-ff":f)+(this.options.hideButton?" evo-hidden-button":""),j="";if(this._isPopup=!0,this._palette=null,null!==d)h.val(d);else{var k=h.val();""!==k&&(d=this.options.color=k)}d===m?i+=" evo-transparent":j=null!==d?"background-color:"+d:"",h.addClass("colorPicker "+this._id).wrap('<div style="width:'+(this.options.hideButton?this.element.width():this.element.width()+32)+"px;"+(e?"margin-bottom:-21px;":"")+(g?"padding:1px 0;":"")+'"></div>').after('<div class="'+i+'" style="'+j+'"></div>').on("keyup onpaste",function(c){var d=a(this).val();d!=b.options.color&&b._setValue(d,!0)});var l=this.options.showOn;("both"===l||"focus"===l)&&h.on("focus",function(){b.showPalette()}),("both"===l||"button"===l)&&h.next().on("click",function(a){return a.stopPropagation(),b.showPalette(),!1});break;default:this._isPopup=!1,this._palette=this.element.html(this._paletteHTML()).attr("aria-haspopup","true"),this._bindColors()}if(this.options.history&&(d&&this._add2History(d),this.options.initialHistory)){var n=this.options.initialHistory;for(var o in n)this._add2History(n[o])}},_paletteHTML:function(){var a=this._paletteIdx=Math.abs(this._paletteIdx),b=this.options,c=b.strings.split(","),d='<div class="evo-pop'+f+' ui-widget ui-widget-content ui-corner-all"'+(this._isPopup?' style="position:absolute"':"")+"><span>"+this["_paletteHTML"+a]()+'</span><div class="evo-more"><a href="javascript:void(0)">'+c[1+a]+"</a>";return b.history&&(d+='<a href="javascript:void(0)" class="evo-hist">'+c[5]+"</a>"),d+="</div>",b.displayIndicator&&(d+=this._colorIndHTML(this.options.color)+this._colorIndHTML("")),d+="</div>"},_colorIndHTML:function(a){var b=e?"evo-colorbox-ie ":"",c="";return a?a===m?b+="evo-transparent":c="background-color:"+a:c="display:none",'<div class="evo-color" style="float:left"><div style="'+c+'" class="'+b+'"></div><span>'+(a?a:"")+"</span></div>"},_paletteHTML1:function(){for(var a=this.options,b=a.strings.split(","),c='<td style="background-color:#',d=e?'"><div style="width:2px;"></div></td>':'"><span/></td>',g='<tr><th colspan="10" class="ui-widget-content">',h='<table class="evo-palette'+f+'">'+g+b[0]+"</th></tr><tr>",l=0;10>l;l++)h+=c+i[l]+d;for(h+="</tr>",e||(h+='<tr><th colspan="10"></th></tr>'),h+='<tr class="top">',l=0;10>l;l++)h+=c+j[l]+d;for(var m=1;4>m;m++)for(h+='</tr><tr class="in">',l=0;10>l;l++)h+=c+j[10*m+l]+d;for(h+='</tr><tr class="bottom">',l=40;50>l;l++)h+=c+j[l]+d;for(h+="</tr>"+g,a.transparentColor&&(h+='<div class="evo-transparent evo-tr-box"></div>'),h+=b[1]+"</th></tr><tr>",l=0;10>l;l++)h+=c+k[l]+d;return h+="</tr></table>"},_paletteHTML2:function(){for(var a,b,c='<td style="background-color:#',d=e?'"><div style="width:5px;"></div></td>':'"><span/></td>',g='<table class="evo-palette2'+f+'"><tr>',h="</tr></table>",i='<div class="evo-palcenter">',j=0,k=l.length;k>j;j++){i+=g;var m=l[j];for(a=0,b=m.length;b>a;a++)i+=c+m[a]+d;i+=h}i+='<div class="evo-sep"/>';var n="";for(i+=g,a=255;a>10;a-=10)i+=c+p(a)+d,a-=10,n+=c+p(a)+d;return i+=h+g+n+h+"</div>"},_switchPalette:function(b){if(this._enabled){var c,d,e,f=this.options.strings.split(",");if(a(b).hasClass("evo-hist")){var g=['<table class="evo-palette"><tr><th class="ui-widget-content">',f[5],"</th></tr></tr></table>",'<div class="evo-cHist">'];if(0===h.length)g.push("<p>&nbsp;",f[6],"</p>");else for(var i=h.length-1;i>-1;i--)9===h[i].length?g.push('<div class="evo-transparent"></div>'):g.push('<div style="background-color:',h[i],'"></div>');g.push("</div>"),c=-this._paletteIdx,d=g.join(""),e=f[4]}else this._paletteIdx<0?(c=-this._paletteIdx,this._palette.find(".evo-hist").show()):c=2==this._paletteIdx?1:2,d=this["_paletteHTML"+c](),e=f[c+1],this._paletteIdx=c;this._paletteIdx=c;var j=this._palette.find(".evo-more").prev().html(d).end().children().eq(0).html(e);0>c&&j.next().hide()}},_downOrUpPositioning:function(){for(var a=this.element,b=0;null!==a&&100>b;){if("visible"!=a.css("overflow")){var c=this._palette.offset().top+this._palette.height(),d=a.offset().top+a.height(),e=this._palette.offset().top-this._palette.height()-this.element.outerHeight(),f=a.offset().top,g=c>d&&e>f;g?this._palette.css({bottom:this.element.outerHeight()+"px"}):this._palette.css({bottom:"auto"});break}if("HTML"==a[0].tagName)break;a=a.offsetParent(),b++}},showPalette:function(){if(this._enabled&&(this._active=!0,a(".colorPicker").not("."+this._id).colorpicker("hidePalette"),null===this._palette)){this._palette=this.element.next().after(this._paletteHTML()).next().on("click",function(a){return a.stopPropagation(),!1}),this._bindColors();var b=this;this._isPopup&&(this._downOrUpPositioning(),a(document.body).on("click."+b._id,function(a){a.target!=b.element.get(0)&&b.hidePalette()}).on("keyup."+b._id,function(a){27===a.keyCode&&b.hidePalette()}))}return this},hidePalette:function(){if(this._isPopup&&this._palette){a(document.body).off("click."+this._id);var b=this;this._palette.off("mouseover click","td,.evo-transparent").fadeOut(function(){b._palette.remove(),b._palette=b._cTxt=null}).find(".evo-more a").off("click")}return this},_bindColors:function(){var b=this,c=this.options,d=this._palette.find("div.evo-color"),e=c.history?"td,.evo-cHist>div":"td";c.transparentColor&&(e+=",.evo-transparent"),this._cTxt1=d.eq(0).children().eq(0),this._cTxt2=d.eq(1).children().eq(0),this._palette.on("click",e,function(c){if(b._enabled){var d=a(this);b._setValue(d.hasClass("evo-transparent")?m:q(d.attr("style").substring(17))),b._active=!1}}).on("mouseover",e,function(c){if(b._enabled){var d=a(this),e=d.hasClass("evo-transparent")?m:q(d.attr("style").substring(17));b.options.displayIndicator&&b._setColorInd(e,2),b._active&&b.element.trigger("mouseover.color",e)}}).find(".evo-more a").on("click",function(){b._switchPalette(this)})},val:function(a){return"undefined"==typeof a?this.options.color:(this._setValue(a),this)},_setValue:function(a,b){a=a.replace(/ /g,""),this.options.color=a,this._isPopup?(b||this.hidePalette(),this._setBoxColor(this.element.val(a).next(),a)):this._setColorInd(a,1),this.options.history&&this._paletteIdx>0&&this._add2History(a),this.element.trigger("change.color",a)},_setColorInd:function(a,b){var c=this["_cTxt"+b];this._setBoxColor(c,a),c.next().html(a)},_setBoxColor:function(a,b){b===m?a.addClass("evo-transparent").removeAttr("style"):a.removeClass("evo-transparent").attr("style","background-color:"+b)},_setOption:function(a,b){"color"==a?this._setValue(b,!0):this.options[a]=b},_add2History:function(a){for(var b=h.length,c=0;b>c;c++)if(a==h[c])return;b>27&&h.shift(),h.push(a)},clear:function(){this.hidePalette().val("")},enable:function(){var a=this.element;return this._isPopup?a.removeAttr("disabled"):a.css({opacity:"1","pointer-events":"auto"}),"focus"!==this.options.showOn&&this.element.next().addClass("evo-pointer"),a.removeAttr("aria-disabled"),this._enabled=!0,this},disable:function(){var a=this.element;return this._isPopup?a.attr("disabled","disabled"):(this.hidePalette(),a.css({opacity:"0.3","pointer-events":"none"})),"focus"!==this.options.showOn&&this.element.next().removeClass("evo-pointer"),a.attr("aria-disabled","true"),this._enabled=!1,this},isDisabled:function(){return!this._enabled},destroy:function(){a(document.body).off("click."+this._id),this._palette&&(this._palette.off("mouseover click","td,.evo-cHist>div,.evo-transparent").find(".evo-more a").off("click"),this._isPopup&&this._palette.remove(),this._palette=this._cTxt=null),this._isPopup&&this.element.next().off("click").remove().end().off("focus").unwrap(),this.element.removeClass("colorPicker "+this.id).empty(),a.Widget.prototype.destroy.call(this)}})}(jQuery);
},{}],3:[function(require,module,exports){
//     JavaScript Expression Parser (JSEP) <%= version %>
//     JSEP may be freely distributed under the MIT License
//     http://jsep.from.so/

/*global module: true, exports: true, console: true */
(function (root) {
	'use strict';
	// Node Types
	// ----------
	
	// This is the full set of types that any JSEP node can be.
	// Store them here to save space when minified
	var COMPOUND = 'Compound',
		IDENTIFIER = 'Identifier',
		MEMBER_EXP = 'MemberExpression',
		LITERAL = 'Literal',
		THIS_EXP = 'ThisExpression',
		CALL_EXP = 'CallExpression',
		UNARY_EXP = 'UnaryExpression',
		BINARY_EXP = 'BinaryExpression',
		LOGICAL_EXP = 'LogicalExpression',
		CONDITIONAL_EXP = 'ConditionalExpression',
		ARRAY_EXP = 'ArrayExpression',

		PERIOD_CODE = 46, // '.'
		COMMA_CODE  = 44, // ','
		SQUOTE_CODE = 39, // single quote
		DQUOTE_CODE = 34, // double quotes
		OPAREN_CODE = 40, // (
		CPAREN_CODE = 41, // )
		OBRACK_CODE = 91, // [
		CBRACK_CODE = 93, // ]
		QUMARK_CODE = 63, // ?
		SEMCOL_CODE = 59, // ;
		COLON_CODE  = 58, // :

		throwError = function(message, index) {
			var error = new Error(message + ' at character ' + index);
			error.index = index;
			error.description = message;
			throw error;
		},

	// Operations
	// ----------
	
	// Set `t` to `true` to save space (when minified, not gzipped)
		t = true,
	// Use a quickly-accessible map to store all of the unary operators
	// Values are set to `true` (it really doesn't matter)
		unary_ops = {'-': t, '!': t, '~': t, '+': t},
	// Also use a map for the binary operations but set their values to their
	// binary precedence for quick reference:
	// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
		binary_ops = {
			'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,
			'==': 6, '!=': 6, '===': 6, '!==': 6,
			'<': 7,  '>': 7,  '<=': 7,  '>=': 7, 
			'<<':8,  '>>': 8, '>>>': 8,
			'+': 9, '-': 9,
			'*': 10, '/': 10, '%': 10
		},
	// Get return the longest key length of any object
		getMaxKeyLen = function(obj) {
			var max_len = 0, len;
			for(var key in obj) {
				if((len = key.length) > max_len && obj.hasOwnProperty(key)) {
					max_len = len;
				}
			}
			return max_len;
		},
		max_unop_len = getMaxKeyLen(unary_ops),
		max_binop_len = getMaxKeyLen(binary_ops),
	// Literals
	// ----------
	// Store the values to return for the various literals we may encounter
		literals = {
			'true': true,
			'false': false,
			'null': null
		},
	// Except for `this`, which is special. This could be changed to something like `'self'` as well
		this_str = 'this',
	// Returns the precedence of a binary operator or `0` if it isn't a binary operator
		binaryPrecedence = function(op_val) {
			return binary_ops[op_val] || 0;
		},
	// Utility function (gets called from multiple places)
	// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
		createBinaryExpression = function (operator, left, right) {
			var type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;
			return {
				type: type,
				operator: operator,
				left: left,
				right: right
			};
		},
		// `ch` is a character code in the next three functions
		isDecimalDigit = function(ch) {
			return (ch >= 48 && ch <= 57); // 0...9
		},
		isIdentifierStart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator
		},
		isIdentifierPart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 48 && ch <= 57) || // 0...9
                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator
		},

		// Parsing
		// -------
		// `expr` is a string with the passed in expression
		jsep = function(expr) {
			// `index` stores the character number we are currently at while `length` is a constant
			// All of the gobbles below will modify `index` as we move along
			var index = 0,
				charAtFunc = expr.charAt,
				charCodeAtFunc = expr.charCodeAt,
				exprI = function(i) { return charAtFunc.call(expr, i); },
				exprICode = function(i) { return charCodeAtFunc.call(expr, i); },
				length = expr.length,

				// Push `index` up to the next non-space character
				gobbleSpaces = function() {
					var ch = exprICode(index);
					// space or tab
					while(ch === 32 || ch === 9) {
						ch = exprICode(++index);
					}
				},
				
				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function() {
					var test = gobbleBinaryExpression(),
						consequent, alternate;
					gobbleSpaces();
					if(exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if(!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if(exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if(!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},

				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function() {
					gobbleSpaces();
					var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
					while(tc_len > 0) {
						if(binary_ops.hasOwnProperty(to_check)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},

				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function() {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if(!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop)};

					right = gobbleToken();
					if(!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while((biop = gobbleBinaryOp())) {
						prec = binaryPrecedence(biop);

						if(prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if(!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while(i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node); 
						i -= 2;
					}
					return node;
				},

				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function() {
					var ch, to_check, tc_len;
					
					gobbleSpaces();
					ch = exprICode(index);

					if(isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if(isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis
						// `foo`, `bar.baz`
						return gobbleVariable();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while(tc_len > 0) {
							if(unary_ops.hasOwnProperty(to_check)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}
						
						return false;
					}
				},
				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function() {
					var number = '', ch, chCode;
					while(isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker
						number += exprI(index++);

						while(isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}
					
					ch = exprI(index);
					if(ch === 'e' || ch === 'E') { // exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if(ch === '+' || ch === '-') { // exponent sign
							number += exprI(index++);
						}
						while(isDecimalDigit(exprICode(index))) { //exponent itself
							number += exprI(index++);
						}
						if(!isDecimalDigit(exprICode(index-1)) ) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}
					

					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if(isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' +
									number + exprI(index) + ')', index);
					} else if(chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},

				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function() {
					var str = '', quote = exprI(index++), closed = false, ch;

					while(index < length) {
						ch = exprI(index++);
						if(ch === quote) {
							closed = true;
							break;
						} else if(ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch(ch) {
								case 'n': str += '\n'; break;
								case 'r': str += '\r'; break;
								case 't': str += '\t'; break;
								case 'b': str += '\b'; break;
								case 'f': str += '\f'; break;
								case 'v': str += '\x0B'; break;
								default : str += '\\' + ch;
							}
						} else {
							str += ch;
						}
					}

					if(!closed) {
						throwError('Unclosed quote after "'+str+'"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},
				
				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function() {
					var ch = exprICode(index), start = index, identifier;

					if(isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while(index < length) {
						ch = exprICode(index);
						if(isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if(literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if(identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},

				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function(termination) {
					var ch_i, args = [], node, closed = false;
					while(index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if(ch_i === termination) { // done parsing
							closed = true;
							index++;
							break;
						} else if (ch_i === COMMA_CODE) { // between expressions
							index++;
						} else {
							node = gobbleExpression();
							if(!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					if (!closed) {
						throwError('Expected ' + String.fromCharCode(termination), index);
					}
					return args;
				},

				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function() {
					var ch_i, node;
					ch_i = exprICode(index);
						
					if(ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if(ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if(ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if(ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if(ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},

				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function() {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if(exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},

				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function() {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},

				nodes = [], ch_i, node;
				
			while(index < length) {
				ch_i = exprICode(index);

				// Expressions can be separated by semicolons, commas, or just inferred without any
				// separators
				if(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
					index++; // ignore separators
				} else {
					// Try to gobble each expression individually
					if((node = gobbleExpression())) {
						nodes.push(node);
					// If we weren't able to find a binary expression and are out of room, then
					// the expression passed in probably has too much
					} else if(index < length) {
						throwError('Unexpected "' + exprI(index) + '"', index);
					}
				}
			}

			// If there's only one expression just try returning the expression
			if(nodes.length === 1) {
				return nodes[0];
			} else {
				return {
					type: COMPOUND,
					body: nodes
				};
			}
		};

	// To be filled in by the template
	jsep.version = '<%= version %>';
	jsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };

	/**
	 * @method jsep.addUnaryOp
	 * @param {string} op_name The name of the unary op to add
	 * @return jsep
	 */
	jsep.addUnaryOp = function(op_name) {
		max_unop_len = Math.max(op_name.length, max_unop_len);
		unary_ops[op_name] = t; return this;
	};

	/**
	 * @method jsep.addBinaryOp
	 * @param {string} op_name The name of the binary op to add
	 * @param {number} precedence The precedence of the binary op (can be a float)
	 * @return jsep
	 */
	jsep.addBinaryOp = function(op_name, precedence) {
		max_binop_len = Math.max(op_name.length, max_binop_len);
		binary_ops[op_name] = precedence;
		return this;
	};

	/**
	 * @method jsep.addLiteral
	 * @param {string} literal_name The name of the literal to add
	 * @param {*} literal_value The value of the literal
	 * @return jsep
	 */
	jsep.addLiteral = function(literal_name, literal_value) {
		literals[literal_name] = literal_value;
		return this;
	};

	/**
	 * @method jsep.removeUnaryOp
	 * @param {string} op_name The name of the unary op to remove
	 * @return jsep
	 */
	jsep.removeUnaryOp = function(op_name) {
		delete unary_ops[op_name];
		if(op_name.length === max_unop_len) {
			max_unop_len = getMaxKeyLen(unary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeBinaryOp
	 * @param {string} op_name The name of the binary op to remove
	 * @return jsep
	 */
	jsep.removeBinaryOp = function(op_name) {
		delete binary_ops[op_name];
		if(op_name.length === max_binop_len) {
			max_binop_len = getMaxKeyLen(binary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeLiteral
	 * @param {string} literal_name The name of the literal to remove
	 * @return jsep
	 */
	jsep.removeLiteral = function(literal_name) {
		delete literals[literal_name];
		return this;
	};

	// In desktop environments, have a way to restore the old value for `jsep`
	if (typeof exports === 'undefined') {
		var old_jsep = root.jsep;
		// The star of the show! It's a function!
		root.jsep = jsep;
		// And a courteous function willing to move out of the way for other similarly-named objects!
		jsep.noConflict = function() {
			if(root.jsep === jsep) {
				root.jsep = old_jsep;
			}
			return jsep;
		};
	} else {
		// In Node.JS environments
		if (typeof module !== 'undefined' && module.exports) {
			exports = module.exports = jsep;
		} else {
			exports.parse = jsep;
		}
	}
}(this));

},{}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');

module.exports = function makeJuiceClient(juiceClient) {

juiceClient.ignoredPseudos = ['hover', 'active', 'focus', 'visited', 'link'];
juiceClient.widthElements = ['TABLE', 'TD', 'IMG'];
juiceClient.heightElements = ['TABLE', 'TD', 'IMG'];
juiceClient.tableElements = ['TABLE', 'TD', 'TH', 'TR', 'TD', 'CAPTION', 'COLGROUP', 'COL', 'THEAD', 'TBODY', 'TFOOT'];
juiceClient.nonVisualElements = [ 'HEAD', 'TITLE', 'BASE', 'LINK', 'STYLE', 'META', 'SCRIPT', 'NOSCRIPT' ];
juiceClient.styleToAttribute = {
  'background-color': 'bgcolor',
  'background-image': 'background',
  'text-align': 'align',
  'vertical-align': 'valign'
};
juiceClient.excludedProperties = [];

juiceClient.juiceDocument = juiceDocument;
juiceClient.inlineDocument = inlineDocument;

function inlineDocument($, css, options) {

  options = options || {};
  var rules = utils.parseCSS(css);
  var editedElements = [];
  var styleAttributeName = 'style';
  
  if (options.styleAttributeName) {
    styleAttributeName = options.styleAttributeName;
  }

  rules.forEach(handleRule);
  editedElements.forEach(setStyleAttrs);

  if (options.inlinePseudoElements) {
    editedElements.forEach(inlinePseudoElements);
  }

  if (options.applyWidthAttributes) {
    editedElements.forEach(function(el) {
      setDimensionAttrs(el, 'width');
    });
  }

  if (options.applyHeightAttributes) {
    editedElements.forEach(function(el) {
      setDimensionAttrs(el, 'height');
    });
  }

  if (options.applyAttributesTableElements) {
    editedElements.forEach(setAttributesOnTableElements);
  }

  if (options.insertPreservedExtraCss && options.extraCss) {
    var preservedText = utils.getPreservedText(options.extraCss, {
      mediaQueries: options.preserveMediaQueries,
      fontFaces: options.preserveFontFaces
    });
    if (preservedText) {
      var $appendTo = null;
      if (options.insertPreservedExtraCss !== true) {
        $appendTo = $(options.insertPreservedExtraCss);
      } else {
        $appendTo = $('head');
        if (!$appendTo.length) { $appendTo = $('body'); }
        if (!$appendTo.length) { $appendTo = $.root(); }
      }

      $appendTo.first().append('<style>' + preservedText + '</style>');
    }
  }

  function handleRule(rule) {
    var sel = rule[0];
    var style = rule[1];
    var selector = new utils.Selector(sel);
    var parsedSelector = selector.parsed();
    var pseudoElementType = getPseudoElementType(parsedSelector);

    // skip rule if the selector has any pseudos which are ignored
    for (var i = 0; i < parsedSelector.length; ++i) {
      var subSel = parsedSelector[i];
      if (subSel.pseudos) {
        for (var j = 0; j < subSel.pseudos.length; ++j) {
          var subSelPseudo = subSel.pseudos[j];
          if (juiceClient.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {
            return;
          }
        }
      }
    }

    if (pseudoElementType) {
      var last = parsedSelector[parsedSelector.length - 1];
      var pseudos = last.pseudos;
      last.pseudos = filterElementPseudos(last.pseudos);
      sel = parsedSelector.toString();
      last.pseudos = pseudos;
    }

    var els;
    try {
      els = $(sel);
    } catch (err) {
      // skip invalid selector
      return;
    }

    els.each(function() {
      var el = this;

      if (el.name && juiceClient.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {
        return;
      }

      if (pseudoElementType) {
        var pseudoElPropName = 'pseudo' + pseudoElementType;
        var pseudoEl = el[pseudoElPropName];
        if (!pseudoEl) {
          pseudoEl = el[pseudoElPropName] = $('<span />').get(0);
          pseudoEl.pseudoElementType = pseudoElementType;
          pseudoEl.pseudoElementParent = el;
          el[pseudoElPropName] = pseudoEl;
        }
        el = pseudoEl;
      }

      if (!el.styleProps) {
        el.styleProps = {};

        // if the element has inline styles, fake selector with topmost specificity
        if ($(el).attr(styleAttributeName)) {
          var cssText = '* { ' + $(el).attr(styleAttributeName) + ' } ';
          addProps(utils.parseCSS(cssText)[0][1], new utils.Selector('<style>', true));
        }

        // store reference to an element we need to compile style="" attr for
        editedElements.push(el);
      }

      // go through the properties
      function addProps(style, selector) {
        for (var i = 0, l = style.length; i < l; i++) {
          if (style[i].type == 'property') {
            var name = style[i].name;
            var value = style[i].value;
            var important = style[i].value.match(/!important$/) !== null;
            if (important && !options.preserveImportant) value = value.replace(/\s*!important$/, '');
            // adds line number and column number for the properties as "additionalPriority" to the 
            // properties because in CSS the position directly affect the priority.
            var additionalPriority = [style[i].position.start.line, style[i].position.start.col];
            var prop = new utils.Property(name, value, selector, important ? 2 : 0, additionalPriority);
            var existing = el.styleProps[name];

            // if property name is not in the excluded properties array
            if (juiceClient.excludedProperties.indexOf(name) < 0) {
              if (existing && existing.compare(prop) === prop || !existing) {
                // deleting a property let us change the order (move it to the end in the setStyleAttrs loop)
                if (existing && existing.selector !== selector) {
                  delete el.styleProps[name];
                } else if (existing) {
                  // make "prop" a special composed property.
                  prop.nextProp = existing;
                }

                el.styleProps[name] = prop;
              }
            }
          }
        }
      }

      addProps(style, selector);
    });
  }

  function setStyleAttrs(el) {
    var l = Object.keys(el.styleProps).length;
    var props = [];
    // Here we loop each property and make sure to "expand"
    // linked "nextProp" properties happening when the same property
    // is declared multiple times in the same selector.
    Object.keys(el.styleProps).forEach(function(key) {
      var np = el.styleProps[key];
      while (typeof np !== 'undefined') {
        props.push(np);
        np = np.nextProp;
      }
    });
    // sort properties by their originating selector's specificity so that
    // props like "padding" and "padding-bottom" are resolved as expected.
    props.sort(function(a, b) {
      return a.compareFunc(b);
    });
    var string = props
      .filter(function(prop) {
        // Content becomes the innerHTML of pseudo elements, not used as a
        // style property
        return prop.prop !== 'content';
      })
      .map(function(prop) {
        return prop.prop + ': ' + prop.value.replace(/["]/g, '\'') + ';';
      })
      .join(' ');
    if (string) {
      $(el).attr(styleAttributeName, string);
    }
  }

  function inlinePseudoElements(el) {
    if (el.pseudoElementType && el.styleProps.content) {
      var parsed = parseContent(el.styleProps.content.value);
      if (parsed.img) {
        el.name = 'img';
        $(el).attr('src', parsed.img);
      } else {
        $(el).text(parsed);
      }
      var parent = el.pseudoElementParent;
      if (el.pseudoElementType === 'before') {
        $(parent).prepend(el);
      } else {
        $(parent).append(el);
      }
    }
  }

  function setDimensionAttrs(el, dimension) {
    if (!el.name) { return; }
    var elName = el.name.toUpperCase();
    if (juiceClient[dimension + 'Elements'].indexOf(elName) > -1) {
      for (var i in el.styleProps) {
        if (el.styleProps[i].prop === dimension) {
          if (el.styleProps[i].value.match(/px/)) {
            var pxSize = el.styleProps[i].value.replace('px', '');
            $(el).attr(dimension, pxSize);
            return;
          }
          if (juiceClient.tableElements.indexOf(elName) > -1 && el.styleProps[i].value.match(/\%/)) {
            $(el).attr(dimension, el.styleProps[i].value);
            return;
          }
        }
      }
    }
  }

  function setAttributesOnTableElements(el) {
    if (!el.name) { return; }
    var elName = el.name.toUpperCase();
    var styleProps = Object.keys(juiceClient.styleToAttribute);

    if (juiceClient.tableElements.indexOf(elName) > -1) {
      for (var i in el.styleProps) {
        if (styleProps.indexOf(el.styleProps[i].prop) > -1) {
          $(el).attr(juiceClient.styleToAttribute[el.styleProps[i].prop], el.styleProps[i].value);
        }
      }
    }
  }
}

function parseContent(content) {
  if (content === 'none' || content === 'normal') {
    return '';
  }

  var imageUrlMatch = content.match(/^\s*url\s*\(\s*(.*?)\s*\)\s*$/i);
  if (imageUrlMatch) {
    var url = imageUrlMatch[1].replace(/^['"]|['"]$/g, '');
    return { img: url };
  }

  // Naive parsing, assume well-formed value
  content = content.slice(1, content.length - 1);
  // Naive unescape, assume no unicode char codes
  content = content.replace(/\\/g, '');
  return content;
}

// Return "before" or "after" if the given selector is a pseudo element (e.g.,
// a::after).
function getPseudoElementType(selector) {
  if (selector.length === 0) {
    return;
  }

  var pseudos = selector[selector.length - 1].pseudos;
  if (!pseudos) {
    return;
  }

  for (var i = 0; i < pseudos.length; i++) {
    if (isPseudoElementName(pseudos[i])) {
      return pseudos[i].name;
    }
  }
}

function isPseudoElementName(pseudo) {
  return pseudo.name === 'before' || pseudo.name === 'after';
}

function filterElementPseudos(pseudos) {
  return pseudos.filter(function(pseudo) {
    return !isPseudoElementName(pseudo);
  });
}

function juiceDocument($, options) {
  options = utils.getDefaultOptions(options);
  var css = extractCssFromDocument($, options);
  css += '\n' + options.extraCss;
  inlineDocument($, css, options);
  return $;
}

function getStylesData($, options) {
  var results = [];
  var stylesList = $('style');
  var styleDataList, styleData, styleElement;
  stylesList.each(function() {
    styleElement = this;
    styleDataList = styleElement.childNodes;
    if (styleDataList.length !== 1) {
      return;
    }
    styleData = styleDataList[0].data;
    if (options.applyStyleTags && $(styleElement).attr('data-embed') === undefined) {
      results.push(styleData);
    }
    if (options.removeStyleTags && $(styleElement).attr('data-embed') === undefined) {
      var preservedText = utils.getPreservedText(styleElement.childNodes[0].nodeValue, {
        mediaQueries: options.preserveMediaQueries,
        fontFaces: options.preserveFontFaces
      });
      if (preservedText) {
        styleElement.childNodes[0].nodeValue = preservedText;
      } else {
        $(styleElement).remove();
      }
    }
    $(styleElement).removeAttr('data-embed');
  });
  return results;
}

function extractCssFromDocument($, options) {
  var results = getStylesData($, options);
  var css = results.join('\n');
  return css;
}

return juiceClient;

};
},{"./utils":7}],5:[function(require,module,exports){
'use strict';

module.exports = exports = Property;

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * CSS property constructor.
 *
 * @param {String} property
 * @param {String} value
 * @param {Selector} selector the property originates from
 * @param {Integer} priority 0 for normal properties, 2 for !important properties.
 * @param {Array} additional array of integers representing more detailed priorities (sorting)
 * @api public
 */

function Property(prop, value, selector, priority, additionalPriority) {
  this.prop = prop;
  this.value = value;
  this.selector = selector;
  this.priority = priority || 0;
  this.additionalPriority = additionalPriority || [];
}

/**
 * Compares with another Property based on Selector#specificity.
 *
 * @api public
 */

Property.prototype.compareFunc = function(property) {
  var a = [];
  a.push.apply(a, this.selector.specificity());
  a.push.apply(a, this.additionalPriority);
  a[0] += this.priority;
  var b = [];
  b.push.apply(b, property.selector.specificity());
  b.push.apply(b, property.additionalPriority);
  b[0] += property.priority;
  return utils.compareFunc(a, b);
};

Property.prototype.compare = function(property) {
  var winner = this.compareFunc(property);
  if (winner === 1) return this;
  return property;
};


/**
 * Returns CSS property
 *
 * @api public
 */

Property.prototype.toString = function() {
  return this.prop + ': ' + this.value.replace(/['"]+/g, '') + ';';
};

},{"./utils":7}],6:[function(require,module,exports){
'use strict';

var parser = require("./../../slick/parser");

module.exports = exports = Selector;

/**
 * CSS selector constructor.
 *
 * @param {String} selector text
 * @param {Array} optionally, precalculated specificity
 * @api public
 */

function Selector(text, styleAttribute) {
  this.text = text;
  this.spec = undefined;
  this.styleAttribute = styleAttribute || false;
}

/**
 * Get parsed selector.
 *
 * @api public
 */

Selector.prototype.parsed = function() {
  if (!this.tokens) { this.tokens = parse(this.text); }
  return this.tokens;
};

/**
 * Lazy specificity getter
 *
 * @api public
 */

Selector.prototype.specificity = function() {
  var styleAttribute = this.styleAttribute;
  if (!this.spec) { this.spec = specificity(this.text, this.parsed()); }
  return this.spec;

  function specificity(text, parsed) {
    var expressions = parsed || parse(text);
    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];
    var nots = [];

    for (var i = 0; i < expressions.length; i++) {
      var expression = expressions[i];
      var pseudos = expression.pseudos;

      // id awards a point in the second column
      if (expression.id) { spec[1]++; }

      // classes and attributes award a point each in the third column
      if (expression.attributes) { spec[2] += expression.attributes.length; }
      if (expression.classList) { spec[2] += expression.classList.length; }

      // tag awards a point in the fourth column
      if (expression.tag && expression.tag !== '*') { spec[3]++; }

      // pseudos award a point each in the fourth column
      if (pseudos) {
        spec[3] += pseudos.length;

        for (var p = 0; p < pseudos.length; p++) {
          if (pseudos[p].name === 'not') {
            nots.push(pseudos[p].value);
            spec[3]--;
          }
        }
      }
    }

    for (var ii = nots.length; ii--;) {
      var not = specificity(nots[ii]);
      for (var jj = 4; jj--;) { spec[jj] += not[jj]; }
    }

    return spec;
  }
};

/**
 * Parses a selector and returns the tokens.
 *
 * @param {String} selector
 * @api private.
 */

function parse(text) {
  try {
    return parser(text)[0];
  } catch (e) {
    return [];
  }
}

},{"./../../slick/parser":17}],7:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var mensch = require("./../../mensch/index.js");
var own = {}.hasOwnProperty;
var os = require('os');
var Selector = require('./selector');
var Property = require('./property');

exports.Selector = Selector;
exports.Property = Property;

/**
 * Returns an array of the selectors.
 *
 * @license Sizzle CSS Selector Engine - MIT
 * @param {String} selectorText from mensch
 * @api public
 */

exports.extract = function extract(selectorText) {
  var attr = 0;
  var sels = [];
  var sel = '';

  for (var i = 0, l = selectorText.length; i < l; i++) {
    var c = selectorText.charAt(i);

    if (attr) {
      if (']' === c || ')' === c) { attr--; }
      sel += c;
    } else {
      if (',' === c) {
        sels.push(sel);
        sel = '';
      } else {
        if ('[' === c || '(' === c) { attr++; }
        if (sel.length || (c !== ',' && c !== '\n' && c !== ' ')) { sel += c; }
      }
    }
  }

  if (sel.length) {
    sels.push(sel);
  }

  return sels;
};

/**
 * Returns a parse tree for a CSS source.
 * If it encounters multiple selectors separated by a comma, it splits the
 * tree.
 *
 * @param {String} css source
 * @api public
 */

exports.parseCSS = function(css) {
  var parsed = mensch.parse(css, {position: true, comments: true});
  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
  var ret = [];

  for (var i = 0, l = rules.length; i < l; i++) {
    if (rules[i].type == 'rule') {
      var rule = rules[i];
      var selectors = rule.selectors;

      for (var ii = 0, ll = selectors.length; ii < ll; ii++) {
        ret.push([selectors[ii], rule.declarations]);
      }
    }
  }

  return ret;
};

/**
 * Returns preserved text for a CSS source.
 *
 * @param {String} css source
 * @param {Object} options
 * @api public
 */

exports.getPreservedText = function(css, options) {
  var parsed = mensch.parse(css, {position: true, comments: true});
  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
  var preserved = [];
  var lastStart = null;

  for (var i = rules.length - 1; i >= 0; i--) {
    if ((options.fontFaces && rules[i].type === 'font-face') ||
        (options.mediaQueries && rules[i].type === 'media')) {
      preserved.push(
        mensch.stringify(
          { stylesheet: { rules: [ rules[i] ] }},
          { comments: false, indentation: '  ' }
        )
      );
    }
    lastStart = rules[i].position.start;
  }

  if (preserved.length === 0) return false;
  return os.EOL+preserved.join(os.EOL)+os.EOL;
};

exports.normalizeLineEndings = function(text) {
  return text.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n');
};


/**
 * Compares two specificity vectors, returning the winning one.
 *
 * @param {Array} vector a
 * @param {Array} vector b
 * @return {Array}
 * @api public
 */

exports.compareFunc = function(a, b) {
  var min = Math.min(a.length, b.length);
  for (var i = 0; i < min; i++) {
    if (a[i] === b[i]) { continue; }
    if (a[i] > b[i]) { return 1; }
    return -1;
  }

  return a.length-b.length;
};

exports.compare = function(a, b) {
  return exports.compareFunc(a, b) == 1 ? a : b;
};

exports.extend = function(obj, src) {
  for (var key in src) {
    if (own.call(src, key)) {
      obj[key] = src[key];
    }
  }
  return obj;
};

exports.getDefaultOptions = function(options) {
  var result = exports.extend({
    extraCss: '',
    insertPreservedExtraCss: true,
    applyStyleTags: true,
    removeStyleTags: true,
    preserveMediaQueries: true,
    preserveFontFaces: true,
    applyWidthAttributes: true,
    applyHeightAttributes: true,
    applyAttributesTableElements: true,
    url: ''
  }, options);

  result.webResources = result.webResources || {};

  return result;
};

},{"./../../mensch/index.js":12,"./property":5,"./selector":6,"os":25}],8:[function(require,module,exports){
(function (global){
// knockout-sortable 0.15.0 | (c) 2016 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
!function(a){if("function"==typeof define&&define.amd)define(["knockout","jquery","jquery-ui/sortable","jquery-ui/draggable"],a);else if("function"==typeof require&&"object"==typeof exports&&"object"==typeof module){var b=(typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null),c=(typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);(typeof window !== "undefined" ? window['jQuery']['ui']['sortable'] : typeof global !== "undefined" ? global['jQuery']['ui']['sortable'] : null),(typeof window !== "undefined" ? window['jQuery']['ui']['draggable'] : typeof global !== "undefined" ? global['jQuery']['ui']['draggable'] : null),a(b,c)}else a(window.ko,window.jQuery)}(function(a,b){var c="ko_sortItem",d="ko_sourceIndex",e="ko_sortList",f="ko_parentList",g="ko_dragItem",h=a.utils.unwrapObservable,i=a.utils.domData.get,j=a.utils.domData.set,k=b.ui&&b.ui.version,l=k&&k.indexOf("1.6.")&&k.indexOf("1.7.")&&(k.indexOf("1.8.")||"1.8.24"===k),m=function(b,d){a.utils.arrayForEach(b,function(a){1===a.nodeType&&(j(a,c,d),j(a,f,i(a.parentNode,e)))})},n=function(b,c){var d,e={},f=h(b())||{};return f.data?(e[c]=f.data,e.name=f.template):e[c]=b(),a.utils.arrayForEach(["afterAdd","afterRender","as","beforeRemove","includeDestroyed","templateEngine","templateOptions","nodes"],function(b){f.hasOwnProperty(b)?e[b]=f[b]:a.bindingHandlers.sortable.hasOwnProperty(b)&&(e[b]=a.bindingHandlers.sortable[b])}),"foreach"===c&&(e.afterRender?(d=e.afterRender,e.afterRender=function(a,b){m.call(b,a,b),d.call(b,a,b)}):e.afterRender=m),e},o=function(a,b){var c=h(b);if(c)for(var d=0;a>d;d++)c[d]&&h(c[d]._destroy)&&a++;return a},p=function(c,d){var e,f;d?(f=document.getElementById(d),f&&(e=new a.templateSources.domElement(f),e.text(b.trim(e.text())))):b(c).contents().each(function(){this&&1!==this.nodeType&&c.removeChild(this)})};a.bindingHandlers.sortable={init:function(k,m,q,r,s){var t,u,v=b(k),w=h(m())||{},x=n(m,"foreach"),y={};p(k,x.name),b.extend(!0,y,a.bindingHandlers.sortable),w.options&&y.options&&(a.utils.extend(y.options,w.options),delete w.options),a.utils.extend(y,w),y.connectClass&&(a.isObservable(y.allowDrop)||"function"==typeof y.allowDrop)?a.computed({read:function(){var b=h(y.allowDrop),c="function"==typeof b?b.call(this,x.foreach):b;a.utils.toggleDomNodeCssClass(k,y.connectClass,c)},disposeWhenNodeIsRemoved:k},this):a.utils.toggleDomNodeCssClass(k,y.connectClass,y.allowDrop),a.bindingHandlers.template.init(k,function(){return x},q,r,s),t=y.options.start,u=y.options.update,y.options.helper||(y.options.helper=function(a,c){return c.is("tr")&&c.children().each(function(){b(this).width(b(this).width())}),c});var z=setTimeout(function(){var m,n=y.options.receive;v.sortable(a.utils.extend(y.options,{start:function(b,c){var e=c.item[0];j(e,d,a.utils.arrayIndexOf(c.item.parent().children(),e)),c.item.find("input:focus").change(),t&&t.apply(this,arguments)},receive:function(a,b){"function"==typeof n&&n.call(this,a,b),m=i(b.item[0],g),m&&(m.clone&&(m=m.clone()),y.dragged&&(m=y.dragged.call(this,m,a,b)||m))},update:function(g,k){var n,p,q,r,s,t=k.item[0],v=k.item.parent()[0],w=i(t,c)||m;if(w||b(t).remove(),m=null,w&&this===v||!l&&b.contains(this,v)){if(n=i(t,f),q=i(t,d),p=i(t.parentNode,e),r=a.utils.arrayIndexOf(k.item.parent().children(),t),x.includeDestroyed||(q=o(q,n),r=o(r,p)),(y.beforeMove||y.afterMove)&&(s={item:w,sourceParent:n,sourceParentNode:n&&k.sender||t.parentNode,sourceIndex:q,targetParent:p,targetIndex:r,cancelDrop:!1},y.beforeMove&&y.beforeMove.call(this,s,g,k)),n?b(n===p?this:k.sender||this).sortable("cancel"):b(t).remove(),s&&s.cancelDrop)return;if(y.hasOwnProperty("strategyMove")&&y.strategyMove!==!1){if(r>=0)if(n)if(n!==p)n.splice(q,1),p.splice(r,0,w),j(t,c,null),k.item.remove();else{var z=h(n);n.valueWillMutate&&n.valueWillMutate(),z.splice(q,1),z.splice(r,0,w),n.valueHasMutated&&n.valueHasMutated()}else p.splice(r,0,w),j(t,c,null),k.item.remove()}else r>=0&&(n&&(n.splice(q,1),a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates(),a.options&&a.options.deferUpdates&&a.tasks.runEarly()),p.splice(r,0,w)),j(t,c,null);a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates(),y.afterMove&&y.afterMove.call(this,s,g,k)}u&&u.apply(this,arguments)},connectWith:y.connectClass?"."+y.connectClass:!1})),void 0!==y.isEnabled&&a.computed({read:function(){v.sortable(h(y.isEnabled)?"enable":"disable")},disposeWhenNodeIsRemoved:k})},0);return a.utils.domNodeDisposal.addDisposeCallback(k,function(){(v.data("ui-sortable")||v.data("sortable"))&&v.sortable("destroy"),a.utils.toggleDomNodeCssClass(k,y.connectClass,!1),clearTimeout(z)}),{controlsDescendantBindings:!0}},update:function(b,c,d,f,g){var h=n(c,"foreach");j(b,e,h.foreach),a.bindingHandlers.template.update(b,function(){return h},d,f,g)},connectClass:"ko_container",allowDrop:!0,afterMove:null,beforeMove:null,options:{}},a.bindingHandlers.draggable={init:function(c,d,e,f,i){var k=h(d())||{},l=k.options||{},m=a.utils.extend({},a.bindingHandlers.draggable.options),o=n(d,"data"),p=k.connectClass||a.bindingHandlers.draggable.connectClass,q=void 0!==k.isEnabled?k.isEnabled:a.bindingHandlers.draggable.isEnabled;return k="data"in k?k.data:k,j(c,g,k),a.utils.extend(m,l),m.connectToSortable=p?"."+p:!1,b(c).draggable(m),void 0!==q&&a.computed({read:function(){b(c).draggable(h(q)?"enable":"disable")},disposeWhenNodeIsRemoved:c}),a.utils.domNodeDisposal.addDisposeCallback(c,function(){b(c).draggable("destroy")}),a.bindingHandlers.template.init(c,function(){return o},e,f,i)},update:function(b,c,d,e,f){var g=n(c,"data");return a.bindingHandlers.template.update(b,function(){return g},d,e,f)},connectClass:a.bindingHandlers.sortable.connectClass,options:{helper:"clone"}}});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],9:[function(require,module,exports){
(function (global){
// Knockout UndoManager v0.2 | (c) 2015 Stefano Bagnara
// License: MIT (http://www.opensource.org/licenses/mit-license) 
// requires "ko.watch" method from knockout.reactor
(function (factory) {
  // Module systems magic dance.
  if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
    // CommonJS or Node: hard-coded dependency on "knockout"
    module.exports = factory((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null), require("./../knockoutjs-reactor/src/knockout.reactor.js"));
  } else if (typeof define === "function" && define["amd"]) {
    // AMD anonymous module with hard-coded dependency on "knockout"
    define(["knockout", "knockoutjs-reactor", "exports"], factory);
  } else {
    // <script> tag: use the global `ko` object
    factory(ko, ko.watch);
  }
}(function (ko, reactor) { 

  /// <summary>
  ///     Track last "levels" changes within the chained observable down to any given level and
  ///     supports undoing/redoing the changes.
  /// </summary>
  /// <param name="options" type="object">
  ///     { levels: 2 } -> Remember only last "levels" changes<br/>
  ///     { undoLabel: "Undo it (#COUNT)!" } -> Define a label for the undo command. "#COUNT#" sequence will be replaced with the stack length.<br/>
  ///     { redoLabel: "Redo it (#COUNT)!" } -> Define a label for the redo command. "#COUNT#" sequence will be replaced with the stack length.<br/>
  /// </param>
  var undoManager = function (model, options) {
    var undoStack = ko.observableArray();
    var redoStack = ko.observableArray();
    var lastPushedStack;
    var STATE_DOING = 0;
    var STATE_UNDOING = 1;
    var STATE_REDOING = 2;
    var state = STATE_DOING;

    var MODE_NORMAL = 0; // add to stack every change
    var MODE_IGNORE = 1; // do not add anything to the stack
    var MODE_ONCE = 2; // only one sequential change for each property is added to the stack
    var MODE_MERGE = 3; // merge next change with the last one
    var mode = MODE_NORMAL;

    var defaultOptions = {
      levels: 100,
      undoLabel: "undo (#COUNT#)",
      redoLabel: "redo (#COUNT#)"
    };
    
    if (typeof options == 'object') {
      options = ko.utils.extend(defaultOptions, options);
    } else {
      options = defaultOptions;
    }
  
    var _push = function (action) {
      // durante UNDO/REDO lavoriamo sempre in normale
      if (state == STATE_UNDOING) {
        _pushInt(action, redoStack);
      } else if (state == STATE_REDOING) {
        _pushInt(action, undoStack);
      } else if (state == STATE_DOING) {
        _pushInt(action, undoStack);
        redoStack.removeAll();
      }
    };
    
    var _tryMerge = function (prev, newAction) {
      if (typeof prev.mergedAction !== 'undefined') {
        return prev.mergedAction(newAction);
      } else return null;
    };

    var _pushInt = function (action, myStack) {
      /* gestione del merge di azioni: se l'ultima azione nello stack ha un metodo "mergedAction"
         proviamo ad invocarlo e se ci restituisce una funzione la usiamo al posto di entrambe */
      // console.log("UR", "_pushInt", myStack().length > 0 ? typeof myStack()[myStack().length - 1].mergedAction : "EMPTY");
      if (myStack().length > 0) {
        var merged = _tryMerge(myStack()[myStack().length - 1], action);
        // console.log("UR", "_pushInt.merged", merged, "MV", typeof action.mergeableMove, "MA", typeof action.mergeableAction, "MM", typeof action.mergeMe);
        if (merged !== null) {
          myStack()[myStack().length - 1] = merged;
          return;
        }
      }
      if (myStack().length >= options.levels) myStack.shift();
      lastPushedStack = myStack;
      myStack.push(action);
    };
    
    var _xdoCommand = function(label, workState, stack) {
      return {
        name: ko.computed(function() {
          return ko.utils.unwrapObservable(label).replace(/#COUNT#/, stack().length);
        }),
        enabled: ko.computed(function() {
          return stack().length !== 0;
        }),
        execute: function() {
          var action = stack.pop();
          if (action) {
            var prevState = state;
            state = workState;
            var oldMode = mode;
            mode = MODE_MERGE;
            // console.log("XDO", "before", label);
            action();
            // console.log("XDO", "after", label);
            _removeMergedAction(lastPushedStack);
            mode = oldMode;
            state = prevState;
          }
          return true;
        }
      };
    };

    var _removeMergedAction = function(myStack) {
      if (typeof myStack == 'undefined') throw "Unexpected operation: stack cleaner called with undefined stack";
      
      if (myStack().length > 0 && typeof myStack()[myStack().length - 1].mergedAction !== 'undefined') {
        // console.log("Removing mergedAction from stack");
        delete myStack()[myStack().length - 1].mergedAction;
      }
    };

    var _combinedFunction = function(first, second) {
      var res = (function(f1, f2) {
        f1();
        f2();
      }).bind(undefined, first, second);
      if (typeof first.mergedAction !== 'undefined') {
        res.mergedAction = first.mergedAction;
      }
      return res;
    };

    var executeUndoAction = function(child, value, item) {
      // console.log("executeUndoAction", child, value, item);
      if (typeof value !== 'undefined') {
        child(value);
      } else if (item) {
        if (item.status == 'deleted') {
          child.splice(item.index, 0, item.value);
        } else if (item.status == 'added') {
          child.splice(item.index, 1);
        } else {
          throw "Unsupproted item.status: "+item.status;
        }
      } else {
        throw "Unexpected condition: no item and no child.oldValues!";
      }
    };

    var makeUndoActionDefault = function(undoFunc, parents, child, oldVal, item) {
      return undoFunc.bind(undefined, child, oldVal, item);
    };

    var makeUndoAction = makeUndoActionDefault;

    var changePusher = function(parents, child, item) {
      var oldVal = typeof child.oldValues != 'undefined' ? child.oldValues[0] : undefined;
      var act = makeUndoAction(executeUndoAction, parents, child, oldVal, item);

      if (mode == MODE_IGNORE) return;

      if (mode == MODE_MERGE) {
        // console.log("UR", "mergemode");
        if (typeof act !== 'undefined') {
          act.mergedAction = function(newAction) {
            if (typeof newAction.mergeMe !== 'undefined' && newAction.mergeMe) {
              return _combinedFunction(newAction, this);
            } else return null;
          };
          act.mergeMe = true;
        }
      } else {
        if (typeof act !== 'undefined') {
          if (child.oldValues && mode == MODE_ONCE) {
            act.mergedAction = function(oldChild, oldItem, newAction) {
              if (typeof newAction.mergeableAction == 'object' && oldChild == newAction.mergeableAction.child) {
                // console.log("UR", "ignore update for property in MODE_ONCE");
                return this;
              } else return null;
            }.bind(act, child, item);
            act.mergeableAction = { child: child, item: item };
          }
          // console.log("UR", "item.status", item.status);
          // "item" is valued when an item is added/removed/reteined in an array
          // sometimes KO detect "moves" and add a "moved" property with the index but
          // this doesn't happen for example using knockout-sortable or when moving objects
          // between arrays.
          // So this ends up handling this with "mergeableMove" and "mergedAction": 
          if (item && item.status == 'deleted') {
            // TODO se sono in MODE = MERGE devo metteer una funzione di merge che accetta tutto.
            // altrimenti lascio questa.
            act.mergedAction = function(oldChild, oldItem, newAction) {
              // console.log("UR", "act.mergedAction", typeof newAction.mergeableMove);
              // a deleted action is able to merge with a added action if they apply to the same
              // object.
              if (typeof newAction.mergeableMove == 'object' && oldItem.value == newAction.mergeableMove.item.value) {
                // in this case I simply return a single action running both actions in sequence,
                // this way the "undo" will need to undo only once for a "move" operation.
                return _combinedFunction(newAction, this);
              } else {
                console.log("UR", "not mergeable", typeof newAction.mergeableMove);
              }

              return null;
            }.bind(act, child, item);
          }
          if (item && item.status == 'added') {
            // add a mergeableMove property that will be used by the next action "mergedAction" to see if this action
            // can be merged.
            act.mergeableMove = { child: child, item: item };
          }
        }
      }
      if (typeof act !== 'undefined') _push(act);
    };

    var reactorOptions = { depth: -1, oldValues: 1, mutable: true, /* tagParentsWithName: true */ tagFields: true };

    var context = {};
    var react = typeof reactor == 'function' ? reactor : ko.watch;
    var res = react(model, reactorOptions, changePusher, context);

    return {
      push: _push, 
      undoCommand: _xdoCommand(options.undoLabel, STATE_UNDOING, undoStack),
      redoCommand: _xdoCommand(options.redoLabel, STATE_REDOING, redoStack),
      reset: function() { undoStack.removeAll(); redoStack.removeAll(); },
      // setMode: function(newMode) { mode = newMode; _removeMergedAction(undoStack); },
      setModeOnce: function() { mode = MODE_ONCE; _removeMergedAction(undoStack); },
      setModeMerge: function() { mode = MODE_MERGE; _removeMergedAction(undoStack); },
      setModeNormal: function() { mode = MODE_NORMAL; _removeMergedAction(undoStack); },
      setModeIgnore: function() { mode = MODE_IGNORE; _removeMergedAction(undoStack); },
      setUndoActionMaker: function(maker) { makeUndoAction = maker; },
      dispose: function() { /* ko.unwatch(model, reactorOptions, changePusher); */ res.dispose(); }
    };
  };

  return undoManager;
  
}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../knockoutjs-reactor/src/knockout.reactor.js":11}],10:[function(require,module,exports){
(function (global){
// Knockout Fast Mapping v0.1
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function (factory) {
	// Module systems magic dance.

	if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
		// CommonJS or Node: hard-coded dependency on "knockout"
		factory((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null), exports);
	} else if (typeof define === "function" && define["amd"]) {
		// AMD anonymous module with hard-coded dependency on "knockout"
		define(["knockout", "exports"], factory);
	} else {
		// <script> tag: use the global `ko` object, attaching a `wrap` property
		factory(ko, ko.wrap = {});
	}
}(function (ko, exports) {
    
    // this function mimics ko.mapping
    exports.fromJS = function(jsObject, computedFunctions, observableObjects)
    {
        reset();
	return wrap(jsObject, computedFunctions, observableObjects);
    }

    // this function unwraps the outer for assigning the result to an observable
    // see https://github.com/SteveSanderson/knockout/issues/517
    exports.updateFromJS = function(observable, jsObject, computedFunctions, observableObjects)
    {
        reset();
	return observable(ko.utils.unwrapObservable(wrap(jsObject, computedFunctions, observableObjects)));
    }

    exports.fromJSON = function (jsonString, computedFunctions, observableObjects) {
	var parsed = ko.utils.parseJson(jsonString);
	arguments[0] = parsed;
	return exports.fromJS.apply(this, computedFunctions, observableObjects);
    };
    
    exports.toJS = function (observable) {
	return unwrap(observable);
    }

    exports.toJSON = function (observable) {
	var plainJavaScriptObject = exports.toJS(observable);
	return ko.utils.stringifyJson(plainJavaScriptObject);
    };

    function typeOf(value) {
	var s = typeof value;
	if (s === 'object') {
            if (value) {
                if (value.constructor == Date)
                    s = 'date';
		else if (Object.prototype.toString.call(value) == '[object Array]')
                    s = 'array';
            } else {
		s = 'null';
            }
	}
	return s;
    }

    // unwrapping
    function unwrapObject(o)
    {
	var t = {};

	for (var k in o)
	{
	    var v = o[k];

	    if (ko.isComputed(v))
		continue;

	    t[k] = unwrap(v);
	}

	return t;
    }

    function unwrapArray(a)
    {
	var r = [];

	if (!a || a.length == 0)
	    return r;
	
	for (var i = 0, l = a.length; i < l; ++i)
	    r.push(unwrap(a[i]));

	return r;
    }

    function unwrap(v)
    {
	var isObservable = ko.isObservable(v);

	if (isObservable)
	{
	    var val = v();

	    return unwrap(val);
	}
	else
	{
	    if (typeOf(v) == "array")
	    {
		return unwrapArray(v);
	    }
	    else if (typeOf(v) == "object")
	    {
		return unwrapObject(v);
	    }
	    else
	    {
		return v;
	    }
	}
    }

    function reset()
    {
        parents = [{obj: null, wrapped: null, lvl: ""}];
    }    
    
    // wrapping

    function wrapObject(o, computedFunctions, observableObjects)
    {
        // check for infinite recursion
        for (var i = 0; i < parents.length; ++i) {
            if (parents[i].obj === o) {
                return parents[i].wrapped;
            }
        }

	var t = {};

	for (var k in o)
	{
	    var v = o[k];

            parents.push({obj: o, wrapped: t, lvl: currentLvl() + "/" + k});

	    t[k] = wrap(v, computedFunctions, observableObjects);

            parents.pop();
	}

	if (computedFunctions && computedFunctions[currentLvl()])
	    t = computedFunctions[currentLvl()](t);

        if (hasES5Plugin())
            ko.track(t);

	if (observableObjects) return ko.observable(t);
	return t;
    }

    function wrapArray(a, computedFunctions, observableObjects)
    {
	var r = ko.observableArray();

	if (!a || a.length == 0)
	    return r;

	for (var i = 0, l = a.length; i < l; ++i)
	    r.push(wrap(a[i], computedFunctions, observableObjects));

	return r;
    }

    // a stack, used for two purposes:
    //  - circular reference checking
    //  - computed functions
    var parents;

    function currentLvl()
    {
	return parents[parents.length-1].lvl;
    }

    function wrap(v, computedFunctions, observableObjects)
    {
	if (typeOf(v) == "array")
	{
	    return wrapArray(v, computedFunctions, observableObjects);
	}
	else if (typeOf(v) == "object")
	{
	    return wrapObject(v, computedFunctions, observableObjects);
	}
	else
	{
            if (!hasES5Plugin() && typeof v !== 'function')
            {
	        var t = ko.observable();
	        t(v);
	        return t;
            } else
                return v;
	}
    }

    function hasES5Plugin()
    {
        return ko.track != null;
    }
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],11:[function(require,module,exports){
(function (global){
// Deep observer plugin for Knockout http://knockoutjs.com/
// (c) Ziad Jeeroburkhan
// License: MIT (http://www.opensource.org/licenses/mit-license.php)
// Version 1.3.8
; (function (factory) {
    // CommonJS
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        factory((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null));
        // AMD
    } else if (typeof define === 'function' && define.amd) {
        define(['knockout'], factory);
        // Normal script tag
    } else {
        factory(window.ko);
    }
}(function (ko) {
ko.subscribable.fn['watch'] = function (targetOrCallback, options, evaluatorCallback, context) {
    /// <summary>
    ///     Track and manage changes within the chained observable down to any given level. 
    /// </summary>
    /// <param name="targetOrCallback">
    ///      The subscription callback function or an object containing the subscribables to be watched.
    /// </param>
    /// <param name="options" type="object">
    ///     false -> Disables tracking on the chained observable.
    ///     { depth: 2 } -> Track all nested subscribables down to the 2nd level(default is 1).<br/>
    ///     { depth: -1 } -> Track all nested subscribables.<br/>
    ///     { hide: [...] } -> Property or array of properties to be ignored.<br/>
    ///     { hideArrays: true } -> Ignore all nested arrays.<br/>
    ///     { hideWrappedValues: true } -> Ignore observables wrapped under yet another parent observable.<br/>
    ///     { mutable: true } -> Dynamically adapt to changes made to the target structure through any subscribable.<br/>
    ///     { watchedOnly: true } -> Watch only subscribables tagged with .watch().<br/>
    ///     { beforeWatch: function(parents, child) {...} } -> Function called prior to creating a subscription. Returning false aborts the operation and ignores its children.<br/>
    ///     { wrap: true } -> Wrap all fields into observables. This happens on the fly for new array items(or child objects when mutable is set to true).<br/>
    ///     { beforeWrap: function(parents, field, value) {...} } -> Function called prior to wrapping a value into an observable. Returning false leaves it as it is.<br/>
    ///     { tagFields: true } -> Add the property '_fieldName' under each property for textual identification.<br/>
    ///     { tagFields: 'parentsOnly' } -> Same as above except that it is limited to parent properties only.<br/>
    ///     { oldValues: 3 } -> Keep the last three values for each subscribable under the property 'oldValues'.<br/>
    ///     { seal: true } -> Prevent any subsequent watcher from watching the target again.<br/>
    ///     { unloop: true } -> Avoid circular paths through the use of a breadcrumb property '_watcher' set at each node level.<br/>
    /// </param>
    /// <param name="evaluatorCallback" type="function">
    ///     The  callback function called during changes. Any return value is assigned to the chained observable.
    /// </param>

    var targetType = typeof targetOrCallback;

    if (targetType === 'boolean' || targetType === 'undefined') {
        // Turn on or off the watcher for the specified target along with any of its children.
        ko.watch(this, { enabled: targetOrCallback !== false });
    } else if (targetType === 'function' && !ko.isSubscribable(targetOrCallback)) {
        // Target the chained subscribable itself if no target subscribable or object was passed.
        ko.watch(this, options || {}, targetOrCallback, context || this);
    } else {
        ko.watch(targetOrCallback, options, evaluatorCallback, context || this);
    }

    return this;
};

ko['watch'] = function (target, options, evaluatorCallback, context) {
    /// <summary>
    ///     Track and manage changes within a specific target object down to any given level.
    /// </summary>
    /// <param name="target">
    ///     An object or function containing the targeted subscribable(s).
    /// </param>
    /// <param name="options" type="object">
    ///     { depth: 2 } -> Track all nested subscribables down to the 2nd level(default is 1).<br/>
    ///     { depth: -1 } -> Track all nested subscribables.<br/>
    ///     { hide: [...] } -> Property or array of properties to be ignored.<br/>
    ///     { hideArrays: true } -> Ignore all nested arrays.<br/>
    ///     { hideWrappedValues: true } -> Ignore observables wrapped under yet another parent observable.<br/>
    ///     { mutable: true } -> Dynamically adapt to changes made to the target structure through any subscribable.<br/>
    ///     { watchedOnly: true } -> Watch only subscribables tagged with .watch().<br/>
    ///     { beforeWatch: function(parents, child) {...} } -> Function called prior to creating a subscription. Returning false aborts the operation and ignores its children.<br/>
    ///     { wrap: true } -> Wrap all fields into observables. This happens on the fly for new array items(or child objects when mutable is set to true).<br/>
    ///     { beforeWrap: function(parents, field, value) {...} } -> Function called prior to wrapping a value into an observable. Returning false leaves it as it is.<br/>
    ///     { tagFields: true } -> Add the property '_fieldName' under each property for textual identification.<br/>
    ///     { tagFields: 'parentsOnly' } -> Same as above except that it is limited to parent properties only.<br/>
    ///     { oldValues: 3 } -> Keep the last three values for each subscribable under the property 'oldValues'.<br/>
    ///     { seal: true } -> Prevent any subsequent watcher from watching the target again.<br/>
    ///     { unloop: true } -> Avoid circular paths through the use of a breadcrumb property '_watcher' set at each node level.<br/>
    ///     { getter: function(parents, child, property) {...} } -> Function used to retrieve the property value from the given child. False can be returned to ignore the property.<br/>
    /// </param>
    /// <param name="evaluatorCallback" type="function">
    ///     The callback function called during changes.
    /// </param>

    if (typeof options === 'function') {
        context = context || evaluatorCallback;
        evaluatorCallback = options;
        options = {};
    }

    context = context || this;

    function watchChildren(child, parent, grandParents, unwatch, keepOffParentList, fieldName) {
        if (child && options.depth !== 0 && (options.depth === -1 || grandParents.length < (options.depth || 1))) {

            // Proceed on watched children only when in watched-only mode.
            if (options.watchedOnly && !child.watchable && child != target)
                return;

            // Setting the target as false prevents it from being watched later on.
            if (options.enabled === false || options.enabled === true)
                child.watchable = options.enabled;

            // Ignore watch-disabled objects.
            if (child.watchable === false)
                return;

            // Prevent subsequent watchers from watching the target when sealed.
            if (options.seal === true)
                child.watchable = false;

            var type = typeof child;

            if (type === 'object' || type === 'function') {
                // Bypass circular references.
                if (child._watcher === context)
                    return;

                // Ignore hidden objects. Also applies to any of their children.
                if (options.hide)
                    if (ko.utils.arrayIndexOf(options.hide, child) > -1)
                        return;

                // Merge parents. Using a fresh array so it is not referenced in the next recursion if any.
                var parents = [].concat(grandParents, parent && parent !== target ? parent : []);

                if (type === 'function') {
                    if (typeof child['notifySubscribers'] == 'function') {
                        // Target is a subscribable. Watch it.
                        if (evaluatorCallback) {
                            if (options.enabled === true && child.watchable === false)
                                // Only waking up an existing watcher. Let's not add another.
                                return;

                            if (unwatch || !options.beforeWatch || options.beforeWatch.call(context, parents, child, fieldName) !== false) {
                                var isArray = typeof child.pop === 'function';

                                if (unwatch) {
                                    disposeWatcher(child);
                                } else {
                                    assignWatcher(child, isArray, parents, keepOffParentList);
                                }

                                if (isArray) {
                                    watchChildren(child(), keepOffParentList ? null : child, parents, unwatch, true);
                                    return true;
                                } else {
                                    if (options.hideWrappedValues !== true)
                                        return watchChildren(child(), keepOffParentList ? null : child, parents, unwatch, true);
                                }
                            }
                        }
                    }
                } else {
                    if (Object.prototype.toString.call(child) === '[object Object]') {
                        ko.utils.objectForEach(child, function (property, sub) {
                            sub = options.getter ? options.getter.call(context, parents, child, property) : sub;
                            if (sub) {
                                if (options.wrap) {
                                    // Wrap simple objects and arrays into observables.
                                    var type = Object.prototype.toString.call(sub);
                                    if (type !== '[object Function]' && type !== '[object Object]') {
                                        if (!options.beforeWrap || options.beforeWrap.call(context, parents, child, sub) !== false) {
                                            sub = child[property] = type === '[object Array]'
                                                ? ko.observableArray(sub)
                                                : ko.observable(sub);
                                        }
                                    }
                                }

                                if (options.unloop)
                                    sub._watcher = unwatch ? undefined : context;

                                var hasChildren = watchChildren(sub, keepOffParentList ? null : child, parents, unwatch, null, property);

                                if (options.tagFields && sub._fieldName === undefined)
                                    if (hasChildren
                                        || (options.tagFields !== 'parentsOnly' && typeof sub === 'function' || typeof sub === 'object'))
                                        sub._fieldName = property;
                            }
                        });
                    } else { // '[object Array]'
                        if (options.hideArrays !== true)
                            for (var i = 0; i < child.length; i++)
                                watchChildren(child[i], keepOffParentList ? null : child, parents, unwatch);
                    }

                    return true;
                }
            }
        }
    }

    // Subscriptions are stored under either the _subscriptions field for the debug version
    // or the F, H or M fields when minified depending on the version used.
    // NOTE: we used to use ko.DEBUG to detect the debug versionbut it was removed in 3.4.0+,
    //       so we now check the existence of a "subscription" function.
    var subscriptionsField;
    switch (typeof ko.subscription == 'function' || ko.version) {
        case true: subscriptionsField = '_subscriptions'; break;
        case "3.0.0": subscriptionsField = 'F'; break;
        case "3.1.0": subscriptionsField = 'H'; break;
        case "3.2.0": subscriptionsField = 'M'; break;
        case "3.3.0": subscriptionsField = 'G'; break;
        case "3.4.0": subscriptionsField = 'K'; break;
        case "3.4.1": subscriptionsField = 'K'; break;
        default: throw "Unsupported Knockout version. Only v3.0.0 to v3.4.1 are supported when minified. Current version is " + ko.version;
    }

    function disposeWatcher(child) {
        var subsc = child[subscriptionsField];

        if (subsc) {
            if (subsc.change)
                for (var i = subsc.change.length - 1; i >= 0; i--)
                    if (subsc.change[i]._watcher === context)
                        subsc.change[i].dispose();

            if (subsc.beforeChange && (options.mutable || options.oldValues > 0))
                // Also clean up any before-change subscriptions used for tracking old values.
                for (var i = subsc.beforeChange.length - 1; i >= 0; i--)
                    if (subsc.beforeChange[i]._watcher === context)
                        subsc.beforeChange[i].dispose();

            if (subsc.arrayChange)
                for (var i = subsc.arrayChange.length - 1; i >= 0; i--)
                    if (subsc.arrayChange[i]._watcher === context)
                        subsc.arrayChange[i].dispose();
        } else {
            throw "Subscriptions field (." + subscriptionsField + ") not defined for observable child " + (child._fieldName || "");
        }
    }

    function assignWatcher(child, isArray, parents, keepOffParentList) {
        if (isArray) {
            // Child is an observable array. Watch all changes within it.
            child.subscribe(function (changes) {
                ko.utils.arrayForEach(changes, function (item) {
                    var returnValue = evaluatorCallback.call(context, parents, child, item);
                    if (returnValue !== undefined)
                        context(returnValue);

                    if (!item.moved) {
                        // Deleted or brand new item. Unwatch or watch it accordingly.
                        setTimeout(function () {
                            watchChildren(item.value, (keepOffParentList ? null : child), parents, item.status === 'deleted');
                        }, 0);
                    }
                });
            }, undefined, 'arrayChange')._watcher = context;

        } else {
            child.subscribe(function () {
                if (child.watchable !== false) {
                    var returnValue = evaluatorCallback.call(context, parents, child);

                    if (returnValue !== undefined)
                        context(returnValue);

                    if (options.mutable && typeof child() === 'object')
                        // Watch the new comer.
                        watchChildren(child(), (keepOffParentList ? null : child), parents);
                }

            }, null, 'change')._watcher = context;

            if (options.oldValues > 0 || options.mutable) {
                child.subscribe(function (oldValue) {
                    if (options.oldValues > 0) {
                        // Add old value to history list before every update.
                        var values = (child['oldValues']
                            ? child['oldValues']
                            : child['oldValues'] = []);

                        values.unshift(oldValue);

                        while (values.length > options.oldValues)
                            values.pop();
                    }

                    if (options.mutable && typeof oldValue === 'object')
                        // Clean up all subscriptions for the old child object.
                        watchChildren(oldValue, (keepOffParentList ? null : child), parents, false, true);

                }, null, 'beforeChange')._watcher = context;
            }
        }
    }

    // Use a computed when targeting a non-watchable function.
    if (typeof target === 'function' && !ko.isSubscribable(target))
        return ko.computed(target, evaluatorCallback, options);

    watchChildren(target, null, []);

    return {
        dispose: function () {
            watchChildren(target, null, [], true);
        }
    };
};

}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],12:[function(require,module,exports){
module.exports = {
    lex  : require('./lib/lexer'),
    parse: require('./lib/parser'),
    stringify: require('./lib/stringify')
};

},{"./lib/lexer":14,"./lib/parser":15,"./lib/stringify":16}],13:[function(require,module,exports){
(function (process){
exports = module.exports = debug;

function debug(label) {
  return _debug.bind(null, label);
}

function _debug(label) {
  var args = [].slice.call(arguments, 1);
  args.unshift('[' + label + ']');
  process.stderr.write(args.join(' ') + '\n');
}
}).call(this,require('_process'))

},{"_process":26}],14:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `lex()` and print the results.

var debug = require('./debug')('lex');

exports = module.exports = lex;

/**
 * Convert a CSS string into an array of lexical tokens.
 *
 * @param {String} css CSS
 * @returns {Array} lexical tokens
 */
function lex(css) {
  var start; // Debug timer start.

  var buffer = '';      // Character accumulator
  var ch;               // Current character
  var column = 0;       // Current source column number
  var cursor = -1;      // Current source cursor position
  var depth = 0;        // Current nesting depth
  var line = 1;         // Current source line number
  var state = 'before-selector'; // Current state
  var stack = [state];  // State stack
  var token = {};       // Current token
  var tokens = [];      // Token accumulator

  // Supported @-rules, in roughly descending order of usage probability.
  var atRules = [
    'media',
    'keyframes',
    { name: '-webkit-keyframes', type: 'keyframes', prefix: '-webkit-' },
    { name: '-moz-keyframes', type: 'keyframes', prefix: '-moz-' },
    { name: '-ms-keyframes', type: 'keyframes', prefix: '-ms-' },
    { name: '-o-keyframes', type: 'keyframes', prefix: '-o-' },
    'font-face',
    { name: 'import', state: 'before-at-value' },
    { name: 'charset', state: 'before-at-value' },
    'supports',
    'viewport',
    { name: 'namespace', state: 'before-at-value' },
    'document',
    { name: '-moz-document', type: 'document', prefix: '-moz-' },
    'page'
  ];

  // -- Functions ------------------------------------------------------------

  /**
   * Advance the character cursor and return the next character.
   *
   * @returns {String} The next character.
   */
  function getCh() {
    skip();
    return css[cursor];
  }

  /**
   * Return the state at the given index in the stack.
   * The stack is LIFO so indexing is from the right.
   *
   * @param {Number} [index=0] Index to return.
   * @returns {String} state
   */
  function getState(index) {
    return index ? stack[stack.length - 1 - index] : state;
  }

  /**
   * Look ahead for a string beginning from the next position. The string
   * being looked for must start at the next position.
   *
   * @param {String} str The string to look for.
   * @returns {Boolean} Whether the string was found.
   */
  function isNextString(str) {
    var start = cursor + 1;
    return (str === css.slice(start, start + str.length));
  }

  /**
   * Find the start position of a substring beginning from the next
   * position. The string being looked for may begin anywhere.
   *
   * @param {String} str The substring to look for.
   * @returns {Number|false} The position, or `false` if not found.
   */
  function find(str) {
    var pos = css.slice(cursor).indexOf(str);

    return pos > 0 ? pos : false;
  }

  /**
   * Determine whether a character is next.
   *
   * @param {String} ch Character.
   * @returns {Boolean} Whether the character is next.
   */
  function isNextChar(ch) {
    return ch === peek(1);
  }

  /**
   * Return the character at the given cursor offset. The offset is relative
   * to the cursor, so negative values move backwards.
   *
   * @param {Number} [offset=1] Cursor offset.
   * @returns {String} Character.
   */
  function peek(offset) {
    return css[cursor + (offset || 1)];
  }

  /**
   * Remove the current state from the stack and set the new current state.
   *
   * @returns {String} The removed state.
   */
  function popState() {
    var removed = stack.pop();
    state = stack[stack.length - 1];

    return removed;
  }

  /**
   * Set the current state and add it to the stack.
   *
   * @param {String} newState The new state.
   * @returns {Number} The new stack length.
   */
  function pushState(newState) {
    state = newState;
    stack.push(state);

    return stack.length;
  }

  /**
   * Replace the current state with a new state.
   *
   * @param {String} newState The new state.
   * @returns {String} The replaced state.
   */
  function replaceState(newState) {
    var previousState = state;
    stack[stack.length - 1] = state = newState;

    return previousState;
  }

  /**
   * Move the character cursor. Positive numbers move the cursor forward.
   * Negative numbers are not supported!
   *
   * @param {Number} [n=1] Number of characters to skip.
   */
  function skip(n) {
    if ((n || 1) == 1) {
      if (css[cursor] == '\n') {
        line++;
        column = 1;
      } else {
        column++;
      }
      cursor++;
    } else {
      var skipStr = css.slice(cursor, cursor + n).split('\n');
      if (skipStr.length > 1) {
        line += skipStr.length - 1;
        column = 1;
      }
      column += skipStr[skipStr.length - 1].length;
      cursor = cursor + n;
    }
  }

  /**
   * Add the current token to the pile and reset the buffer.
   */
  function addToken() {
    token.end = {
      line: line,
      col: column
    };

    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));

    tokens.push(token);

    buffer = '';
    token = {};
  }

  /**
   * Set the current token.
   *
   * @param {String} type Token type.
   */
  function initializeToken(type) {
    token = {
      type: type,
      start: {
        line: line,
        col : column
      }
    };
  }

  // -- Main Loop ------------------------------------------------------------

  /*
  The main loop is a state machine that reads in one character at a time,
  and determines what to do based on the current state and character.
  This is implemented as a series of nested `switch` statements and the
  case orders have been mildly optimized based on rough probabilities
  calculated by processing a small sample of real-world CSS.

  Further optimization (such as a dispatch table) shouldn't be necessary
  since the total number of cases is very low.
  */

  TIMER && (start = Date.now());

  while (ch = getCh()) {
    DEBUG && debug(ch, getState());

    // column += 1;

    switch (ch) {
    // Space
    case ' ':
      switch (getState()) {
      case 'selector':
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'at-value':
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;
      }
      break;

    // Newline or tab
    case '\n':
    case '\t':
    case '\r':
    case '\f':
      switch (getState()) {
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'comment':
      case 'single-string':
      case 'double-string':
      case 'selector':
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule if a semi-colon was omitted.
        if ('\n' === ch) {
          token.value = buffer.trim();
          addToken();
          popState();
        }
        break;
      }

      // if ('\n' === ch) {
      //   column = 0;
      //   line += 1;
      // }
      break;

    case ':':
      switch (getState()) {
      case 'name':
        token.name = buffer.trim();
        buffer = '';

        replaceState('before-value');
        break;

      case 'before-selector':
        buffer += ch;

        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case ';':
      switch (getState()) {
      case 'name':
      case 'before-value':
      case 'value':
        // Tokenize a declaration
        // if value is empty skip the declaration
        if (buffer.trim().length > 0) {
          token.value = buffer.trim(),
          addToken();
        }
        replaceState('before-name');
        break;

      case 'value-paren':
        // Insignificant semi-colon
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule
        token.value = buffer.trim();
        addToken();
        popState();
        break;

      case 'before-name':
        // Extraneous semi-colon
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case '{':
      switch (getState()) {
      case 'selector':
        // If the sequence is `\{` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        // Tokenize a selector
        token.text = buffer.trim();
        addToken();
        replaceState('before-name');
        depth = depth + 1;
        break;

      case 'at-group':
        // Tokenize an @-group
        token.name = buffer.trim();

        // XXX: @-rules are starting to get hairy
        switch (token.type) {
        case 'font-face':
        case 'viewport' :
        case 'page'     :
          pushState('before-name');
          break;

        default:
          pushState('before-selector');
        }

        addToken();
        depth = depth + 1;
        break;

      case 'name':
      case 'at-rule':
        // Tokenize a declaration or an @-rule
        token.name = buffer.trim();
        addToken();
        pushState('before-name');
        depth = depth + 1;
        break;

      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore braces in comments and strings
        buffer += ch;
        break;
      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;
      }

      break;

    case '}':
      switch (getState()) {
      case 'before-name':
      case 'name':
      case 'before-value':
      case 'value':
        // If the buffer contains anything, it is a value
        if (buffer) {
          token.value = buffer.trim();
        }

        // If the current token has a name and a value it should be tokenized.
        if (token.name && token.value) {
          addToken();
        }

        // Leave the block
        initializeToken('end');
        addToken();
        popState();

        // We might need to leave again.
        // XXX: What about 3 levels deep?
        if ('at-group' === getState()) {
          initializeToken('at-group-end');
          addToken();
          popState();
        }
        
        if (depth > 0) {
          depth = depth - 1;
        }

        break;

      case 'at-group':
      case 'before-selector':
      case 'selector':
        // If the sequence is `\}` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        if (depth > 0) {
          // Leave block if in an at-group
          if ('at-group' === getState(1)) {
            initializeToken('at-group-end');
            addToken();
          }
        }

        if (depth > 1) {
          popState();
        }

        if (depth > 0) {
          depth = depth - 1;
        }
        break;

      case 'double-string':
      case 'single-string':
      case 'comment':
        // Ignore braces in comments and strings.
        buffer += ch;
        break;
      }

      break;

    // Strings
    case '"':
    case "'":
      switch (getState()) {
      case 'double-string':
        if ('"' === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'single-string':
        if ("'" === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'before-at-value':
        replaceState('at-value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'before-value':
        replaceState('value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'comment':
        // Ignore strings within comments.
        break;

      default:
        if ('\\' !== peek(-1)) {
          pushState('"' === ch ? 'double-string' : 'single-string');
        }
      }

      buffer += ch;
      break;

    // Comments
    case '/':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore
        buffer += ch;
        break;

      case 'before-value':
      case 'selector':
      case 'name':
      case 'value':
        if (isNextChar('*')) {
          // Ignore comments in selectors, properties and values. They are
          // difficult to represent in the AST.
          var pos = find('*/');

          if (pos) {
            skip(pos + 1);
          }
        } else {
          if (getState() == 'before-value') replaceState('value');
          buffer += ch;
        }
        break;

      default:
        if (isNextChar('*')) {
          // Create a comment token
          initializeToken('comment');
          pushState('comment');
          skip();
        }
        else {
          buffer += ch;
        }
        break;
      }
      break;

    // Comment end or universal selector
    case '*':
      switch (getState()) {
      case 'comment':
        if (isNextChar('/')) {
          // Tokenize a comment
          token.text = buffer; // Don't trim()!
          skip();
          addToken();
          popState();
        }
        else {
          buffer += ch;
        }
        break;

      case 'before-selector':
        buffer += ch;
        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        buffer += ch;
      }
      break;

    // @-rules
    case '@':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;
      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        // Iterate over the supported @-rules and attempt to tokenize one.
        var tokenized = false;
        var name;
        var rule;

        for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
          rule = atRules[j];
          name = rule.name || rule;

          if (!isNextString(name)) { continue; }

          tokenized = true;

          initializeToken(name);
          pushState(rule.state || 'at-group');
          skip(name.length);

          if (rule.prefix) {
            token.prefix = rule.prefix;
          }

          if (rule.type) {
            token.type = rule.type;
          }
        }

        if (!tokenized) {
          // Keep on truckin' America!
          buffer += ch;
        }
        break;
      }
      break;

    // Parentheses are tracked to disambiguate semi-colons, such as within a
    // data URI.
    case '(':
      switch (getState()) {
      case 'value':
        pushState('value-paren');
        break;
      case 'before-value':
        replaceState('value');
        break;
      }

      buffer += ch;
      break;

    case ')':
      switch (getState()) {
      case 'value-paren':
        popState();
        break;
      case 'before-value':
        replaceState('value');
        break;
      }

      buffer += ch;
      break;

    default:
      switch (getState()) {
      case 'before-selector':
        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-name':
        initializeToken('property');
        replaceState('name');
        break;

      case 'before-value':
        replaceState('value');
        break;

      case 'before-at-value':
        replaceState('at-value');
        break;
      }

      buffer += ch;
      break;
    }
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return tokens;
}

},{"./debug":13}],15:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `parse()` and print the results.

var debug = require('./debug')('parse');
var lex = require('./lexer');

exports = module.exports = parse;

var _comments;   // Whether comments are allowed.
var _depth;      // Current block nesting depth.
var _position;   // Whether to include line/column position.
var _tokens;     // Array of lexical tokens.

/**
 * Convert a CSS string or array of lexical tokens into a `stringify`-able AST.
 *
 * @param {String} css CSS string or array of lexical token
 * @param {Object} [options]
 * @param {Boolean} [options.comments=false] allow comment nodes in the AST
 * @returns {Object} `stringify`-able AST
 */
function parse(css, options) {
  var start; // Debug timer start.

  options || (options = {});
  _comments = !!options.comments;
  _position = !!options.position;

  _depth = 0;

  // Operate on a copy of the given tokens, or the lex()'d CSS string.
  _tokens = Array.isArray(css) ? css.slice() : lex(css);

  var rule;
  var rules = [];
  var token;

  TIMER && (start = Date.now());

  while ((token = next())) {
    rule = parseToken(token);
    rule && rules.push(rule);
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return {
    type: "stylesheet",
    stylesheet: {
      rules: rules
    }
  };
}

// -- Functions --------------------------------------------------------------

/**
 * Build an AST node from a lexical token.
 *
 * @param {Object} token lexical token
 * @param {Object} [override] object hash of properties that override those
 *   already in the token, or that will be added to the token.
 * @returns {Object} AST node
 */
function astNode(token, override) {
  override || (override = {});

  var key;
  var keys = ['type', 'name', 'value'];
  var node = {};

  // Avoiding [].forEach for performance reasons.
  for (var i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (token[key]) {
      node[key] = override[key] || token[key];
    }
  }

  keys = Object.keys(override);

  for (i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (!node[key]) {
      node[key] = override[key];
    }
  }

  if (_position) {
    node.position = {
      start: token.start,
      end: token.end
    };
  }

  DEBUG && debug('astNode:', JSON.stringify(node, null, 2));

  return node;
}

/**
 * Remove a lexical token from the stack and return the removed token.
 *
 * @returns {Object} lexical token
 */
function next() {
  var token = _tokens.shift();
  DEBUG && debug('next:', JSON.stringify(token, null, 2));
  return token;
}

// -- Parse* Functions ---------------------------------------------------------

/**
 * Convert an @-group lexical token to an AST node.
 *
 * @param {Object} token @-group lexical token
 * @returns {Object} @-group AST node
 */
function parseAtGroup(token) {
  _depth = _depth + 1;

  // As the @-group token is assembled, relevant token values are captured here
  // temporarily. They will later be used as `tokenize()` overrides.
  var overrides = {};

  switch (token.type) {
  case 'font-face':
  case 'viewport' :
    overrides.declarations = parseDeclarations();
    break;

  case 'page':
    overrides.prefix = token.prefix;
    overrides.declarations = parseDeclarations();
    break;

  default:
    overrides.prefix = token.prefix;
    overrides.rules = parseRules();
  }

  return astNode(token, overrides);
}

/**
 * Convert an @import lexical token to an AST node.
 *
 * @param {Object} token @import lexical token
 * @returns {Object} @import AST node
 */
function parseAtImport(token) {
  return astNode(token);
}

/**
 * Convert an @charset token to an AST node.
 *
 * @param {Object} token @charset lexical token
 * @returns {Object} @charset node
 */
function parseCharset(token) {
  return astNode(token);
}

/**
 * Convert a comment token to an AST Node.
 *
 * @param {Object} token comment lexical token
 * @returns {Object} comment node
 */
function parseComment(token) {
  return astNode(token, {text: token.text});
}

function parseNamespace(token) {
  return astNode(token);
}

/**
 * Convert a property lexical token to a property AST node.
 *
 * @returns {Object} property node
 */
function parseProperty(token) {
  return astNode(token);
}

/**
 * Convert a selector lexical token to a selector AST node.
 *
 * @param {Object} token selector lexical token
 * @returns {Object} selector node
 */
function parseSelector(token) {
  function trim(str) {
    return str.trim();
  }

  return astNode(token, {
    type: 'rule',
    selectors: token.text.split(',').map(trim),
    declarations: parseDeclarations(token)
  });
}

/**
 * Convert a lexical token to an AST node.
 *
 * @returns {Object|undefined} AST node
 */
function parseToken(token) {
  switch (token.type) {
  // Cases are listed in roughly descending order of probability.
  case 'property': return parseProperty(token);

  case 'selector': return parseSelector(token);

  case 'at-group-end': _depth = _depth - 1; return;

  case 'media'     :
  case 'keyframes' :return parseAtGroup(token);

  case 'comment': if (_comments) { return parseComment(token); } break;

  case 'charset': return parseCharset(token);
  case 'import': return parseAtImport(token);

  case 'namespace': return parseNamespace(token);

  case 'font-face':
  case 'supports' :
  case 'viewport' :
  case 'document' :
  case 'page'     : return parseAtGroup(token);
  }

  DEBUG && debug('parseToken: unexpected token:', JSON.stringify(token));
}

// -- Parse Helper Functions ---------------------------------------------------

/**
 * Iteratively parses lexical tokens from the stack into AST nodes until a
 * conditional function returns `false`, at which point iteration terminates
 * and any AST nodes collected are returned.
 *
 * @param {Function} conditionFn
 *   @param {Object} token the lexical token being parsed
 *   @returns {Boolean} `true` if the token should be parsed, `false` otherwise
 * @return {Array} AST nodes
 */
function parseTokensWhile(conditionFn) {
  var node;
  var nodes = [];
  var token;

  while ((token = next()) && (conditionFn && conditionFn(token))) {
    node = parseToken(token);
    node && nodes.push(node);
  }

  // Place an unused non-`end` lexical token back onto the stack.
  if (token && token.type !== 'end') {
    _tokens.unshift(token);
  }

  return nodes;
}

/**
 * Convert a series of tokens into a sequence of declaration AST nodes.
 *
 * @returns {Array} declaration nodes
 */
function parseDeclarations() {
  return parseTokensWhile(function (token) {
    return (token.type === 'property' || token.type === 'comment');
  });
}

/**
 * Convert a series of tokens into a sequence of rule nodes.
 *
 * @returns {Array} rule nodes
 */
function parseRules() {
  return parseTokensWhile(function () { return _depth; });
}

},{"./debug":13,"./lexer":14}],16:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `stringify()` and print the results.

var debug = require('./debug')('stringify');

var _comments;      // Whether comments are allowed in the stringified CSS.
var _compress;      // Whether the stringified CSS should be compressed.
var _indentation;   // Indentation option value.
var _n;             // Compression-aware newline character.
var _s;             // Compression-aware space character.

exports = module.exports = stringify;

/**
 * Convert a `stringify`-able AST into a CSS string.
 *
 * @param {Object} `stringify`-able AST
 * @param {Object} [options]
 * @param {Boolean} [options.comments=false] allow comments in the CSS
 * @param {Boolean} [options.compress=false] compress whitespace
 * @param {String} [options.indentation=''] indentation sequence
 * @returns {String} CSS
 */
function stringify(ast, options) {
  var start; // Debug timer start.

  options || (options = {});
  _indentation = options.indentation || '';
  _compress = !!options.compress;
  _comments = !!options.comments;

  if (_compress) {
    _n = _s = '';
  } else {
    _n = '\n';
    _s = ' ';
  }

  TIMER && (start = Date.now());

  var css = reduce(ast.stylesheet.rules, stringifyNode).join('\n').trim();

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return css;
}

// -- Functions --------------------------------------------------------------

/**
 * Modify the indentation level, or return a compression-aware sequence of
 * spaces equal to the current indentation level.
 *
 * @param {Number} [level=undefined] indentation level modifier
 * @returns {String} sequence of spaces
 */
function indent(level) {
  this.level || (this.level = 1);

  if (level) {
    this.level += level;
    return;
  }

  if (_compress) { return ''; }

  return Array(this.level).join(_indentation || '');
}

// -- Stringify Functions ------------------------------------------------------

/**
 * Stringify an @-rule AST node.
 *
 * Use `stringifyAtGroup()` when dealing with @-groups that may contain blocks
 * such as @media.
 *
 * @param {String} type @-rule type. E.g., import, charset
 * @returns {String} Stringified @-rule
 */
function stringifyAtRule(node) {
  return '@' + node.type + ' ' + node.value + ';' + _n;
}

/**
 * Stringify an @-group AST node.
 *
 * Use `stringifyAtRule()` when dealing with @-rules that may not contain blocks
 * such as @import.
 *
 * @param {Object} node @-group AST node
 * @returns {String}
 */
function stringifyAtGroup(node) {
  var label = '';
  var prefix = node.prefix || '';

  if (node.name) {
    label = ' ' + node.name;
  }

  // FIXME: @-rule conditional logic is leaking everywhere.
  var chomp = node.type !== 'page';

  return '@' + prefix + node.type + label + _s + stringifyBlock(node, chomp) + _n;
}

/**
 * Stringify a comment AST node.
 *
 * @param {Object} node comment AST node
 * @returns {String}
 */
function stringifyComment(node) {
  if (!_comments) { return ''; }

  return '/*' + (node.text || '') + '*/' + _n;
}

/**
 * Stringify a rule AST node.
 *
 * @param {Object} node rule AST node
 * @returns {String}
 */
function stringifyRule(node) {
  var label;

  if (node.selectors) {
    label = node.selectors.join(',' + _n);
  } else {
    label = '@' + node.type;
    label += node.name ? ' ' + node.name : '';
  }

  return indent() + label + _s + stringifyBlock(node) + _n;
}


// -- Stringify Helper Functions -----------------------------------------------

/**
 * Reduce an array by applying a function to each item and retaining the truthy
 * results.
 *
 * When `item.type` is `'comment'` `stringifyComment` will be applied instead.
 *
 * @param {Array} items array to reduce
 * @param {Function} fn function to call for each item in the array
 *   @returns {Mixed} Truthy values will be retained, falsy values omitted
 * @returns {Array} retained results
 */
function reduce(items, fn) {
  return items.reduce(function (results, item) {
    var result = (item.type === 'comment') ? stringifyComment(item) : fn(item);
    result && results.push(result);
    return results;
  }, []);
}

/**
 * Stringify an AST node with the assumption that it represents a block of
 * declarations or other @-group contents.
 *
 * @param {Object} node AST node
 * @returns {String}
 */
// FIXME: chomp should not be a magic boolean parameter
function stringifyBlock(node, chomp) {
  var children = node.declarations;
  var fn = stringifyDeclaration;

  if (node.rules) {
    children = node.rules;
    fn = stringifyRule;
  }

  children = stringifyChildren(children, fn);
  children && (children = _n + children + (chomp ? '' : _n));

  return '{' + children + indent() + '}';
}

/**
 * Stringify an array of child AST nodes by calling the given stringify function
 * once for each child, and concatenating the results.
 *
 * @param {Array} children `node.rules` or `node.declarations`
 * @param {Function} fn stringify function
 * @returns {String}
 */
function stringifyChildren(children, fn) {
  if (!children) { return ''; }

  indent(1);
  var results = reduce(children, fn);
  indent(-1);

  if (!results.length) { return ''; }

  return results.join(_n);
}

/**
 * Stringify a declaration AST node.
 *
 * @param {Object} node declaration AST node
 * @returns {String}
 */
function stringifyDeclaration(node) {
  if (node.type === 'property') {
    return stringifyProperty(node);
  }

  DEBUG && debug('stringifyDeclaration: unexpected node:', JSON.stringify(node));
}

/**
 * Stringify an AST node.
 *
 * @param {Object} node AST node
 * @returns {String}
 */
function stringifyNode(node) {
  switch (node.type) {
  // Cases are listed in roughly descending order of probability.
  case 'rule': return stringifyRule(node);

  case 'media'    :
  case 'keyframes': return stringifyAtGroup(node);

  case 'comment': return stringifyComment(node);

  case 'import'   :
  case 'charset'  :
  case 'namespace': return stringifyAtRule(node);

  case 'font-face':
  case 'supports' :
  case 'viewport' :
  case 'document' :
  case 'page'     : return stringifyAtGroup(node);
  }

  DEBUG && debug('stringifyNode: unexpected node: ' + JSON.stringify(node));
}

/**
 * Stringify an AST property node.
 *
 * @param {Object} node AST property node
 * @returns {String}
 */
function stringifyProperty(node) {
  var name = node.name ? node.name + ':' + _s : '';

  return indent() + name + node.value + ';';
}

},{"./debug":13}],17:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],18:[function(require,module,exports){
// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);

},{}],19:[function(require,module,exports){
(function (global){
/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 */
/* global define */
(function (define) {
    define(['jquery'], function ($) {
        return (function () {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: 'error',
                info: 'info',
                success: 'success',
                warning: 'warning'
            };

            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: '2.1.3',
                warning: warning
            };

            var previousToast;

            return toastr;

            ////////////////

            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function getContainer(options, create) {
                if (!options) { options = getOptions(); }
                $container = $('#' + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }

            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function subscribe(callback) {
                listener = callback;
            }

            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }

            function remove($toastElement) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if ($toastElement && $(':focus', $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }

            // internal functions

            function clearContainer (options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }

            function clearToast ($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function () { removeToast($toastElement); }
                    });
                    return true;
                }
                return false;
            }

            function createContainer(options) {
                $container = $('<div/>')
                    .attr('id', options.containerId)
                    .addClass(options.positionClass);

                $container.appendTo($(options.target));
                return $container;
            }

            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: 'toast',
                    containerId: 'toast-container',
                    debug: false,

                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: 'swing', //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: 'fadeOut',
                    hideDuration: 1000,
                    hideEasing: 'swing',
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,
                    closeOnHover: true,

                    extendedTimeOut: 1000,
                    iconClasses: {
                        error: 'toast-error',
                        info: 'toast-info',
                        success: 'toast-success',
                        warning: 'toast-warning'
                    },
                    iconClass: 'toast-info',
                    positionClass: 'toast-top-right',
                    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                    titleClass: 'toast-title',
                    messageClass: 'toast-message',
                    escapeHtml: false,
                    target: 'body',
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: 'toast-close-button',
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false,
                    progressClass: 'toast-progress',
                    rtl: false
                };
            }

            function publish(args) {
                if (!listener) { return; }
                listener(args);
            }

            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;

                if (typeof (map.optionsOverride) !== 'undefined') {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }

                if (shouldExit(options, map)) { return; }

                toastId++;

                $container = getContainer(options, true);

                var intervalId = null;
                var $toastElement = $('<div/>');
                var $titleElement = $('<div/>');
                var $messageElement = $('<div/>');
                var $progressElement = $('<div/>');
                var $closeElement = $(options.closeHtml);
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: 'visible',
                    startTime: new Date(),
                    options: options,
                    map: map
                };

                personalizeToast();

                displayToast();

                handleEvents();

                publish(response);

                if (options.debug && console) {
                    console.log(response);
                }

                return $toastElement;

                function escapeHtml(source) {
                    if (source == null) {
                        source = '';
                    }

                    return source
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }

                function personalizeToast() {
                    setIcon();
                    setTitle();
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setRTL();
                    setSequence();
                    setAria();
                }

                function setAria() {
                    var ariaValue = '';
                    switch (map.iconClass) {
                        case 'toast-success':
                        case 'toast-info':
                            ariaValue =  'polite';
                            break;
                        default:
                            ariaValue = 'assertive';
                    }
                    $toastElement.attr('aria-live', ariaValue);
                }

                function handleEvents() {
                    if (options.closeOnHover) {
                        $toastElement.hover(stickAround, delayedHideToast);
                    }

                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }

                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function (event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }

                            if (options.onCloseClick) {
                                options.onCloseClick(event);
                            }

                            hideToast(true);
                        });
                    }

                    if (options.onclick) {
                        $toastElement.click(function (event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }

                function displayToast() {
                    $toastElement.hide();

                    $toastElement[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                    );

                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }

                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }

                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }

                function setTitle() {
                    if (map.title) {
                        var suffix = map.title;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.title);
                        }
                        $titleElement.append(suffix).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }

                function setMessage() {
                    if (map.message) {
                        var suffix = map.message;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.message);
                        }
                        $messageElement.append(suffix).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }

                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass(options.closeClass).attr('role', 'button');
                        $toastElement.prepend($closeElement);
                    }
                }

                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass(options.progressClass);
                        $toastElement.prepend($progressElement);
                    }
                }

                function setRTL() {
                    if (options.rtl) {
                        $toastElement.addClass('rtl');
                    }
                }

                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }

                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ?
                        options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(':focus', $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function () {
                            removeToast($toastElement);
                            clearTimeout(intervalId);
                            if (options.onHidden && response.state !== 'hidden') {
                                options.onHidden();
                            }
                            response.state = 'hidden';
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }

                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }

                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing}
                    );
                }

                function updateProgress() {
                    var percentage = ((progressBar.hideEta - (new Date().getTime())) / progressBar.maxHideTime) * 100;
                    $progressElement.width(percentage + '%');
                }
            }

            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }

            function removeToast($toastElement) {
                if (!$container) { $container = getContainer(); }
                if ($toastElement.is(':visible')) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }

        })();
    });
}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
    if (typeof module !== 'undefined' && module.exports) { //Node
        module.exports = factory((typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null));
    } else {
        window.toastr = factory(window.jQuery);
    }
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
var templateSystem = require('../src/js/bindings/choose-template.js');
document.addEventListener('DOMContentLoaded', function(event) {
  templateSystem.addTemplate("array", "<!-- ko foreach: $data --><!-- ko block: $data --><!-- /ko --><!-- /ko -->");
  templateSystem.addTemplate("block-show", "<!-- ko block: $data, scrollIntoView: $root.selectedBlock() === $data --><!-- /ko -->");
  templateSystem.addTemplate("block-wysiwyg", "<div class=\x22editable block\x22 data-drop-content=\x22Drop here\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here') }, click: function(obj, evt) { $root.selectBlock(obj); return true }, clickBubble: false, css: { selected: $root.selectedBlock() === $data }, scrollIntoView: $root.selectedBlock() === $data\x22>  <div class=\x22mo-blockselectionhelper\x22></div>  <div class=\x22tools\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: typeof $index != 'undefined' -->    <div title=\x22Drag this handle to move the block\x22 data-bind=\x22attr: { title: $root.t('Drag this handle to move the block') }\x22 class=\x22tool handle\x22><i class=\x22fa fa-fw fa-sort\x22></i></div>    <!-- ko if: $index() > 0 -->    <div title=\x22Move this block upside\x22 data-bind=\x22attr: { title: $root.t('Move this block upside') }\x22 class=\x22tool moveup\x22><i class=\x22fa fa-fw fa-sort-asc\x22 data-bind='click: $root.moveBlock.bind($element, $index, $parent, true)'></i></div>    <!-- /ko -->    <!-- ko if: $index() < $parent.blocks().length -1 -->    <div title=\x22Move this block downside\x22 data-bind=\x22attr: { title: $root.t('Move this block downside') }\x22 class=\x22tool movedown\x22><i class=\x22fa fa-fw fa-sort-desc\x22 data-bind='click: $root.moveBlock.bind($element, $index, $parent, false)'></i></div>    <!-- /ko -->    <div title=\x22Delete block\x22 class=\x22tool delete\x22 data-bind=\x22attr: { title: $root.t('Delete block') }, click: $root.removeBlock.bind($element, $rawData, $parent)\x22><i class=\x22fa fa-fw fa-trash-o\x22></i></div>    <div title=\x22Duplicate block\x22 class=\x22tool clone\x22 data-bind=\x22attr: { title: $root.t('Duplicate block') }, click: $root.duplicateBlock.bind($element, $index, $parent)\x22><i class=\x22fa fa-fw fa-files-o\x22></i></div>    <!-- /ko -->    <!-- ko if: typeof $data._nextVariant != 'undefined' --><div title=\x22Switch block variant\x22 class=\x22tool variant\x22 data-bind=\x22attr: { title: $root.t('Switch block variant') }, click: $data._nextVariant\x22><i class=\x22fa fa-fw fa-magic\x22></i></div><!-- /ko -->  </div>  <!-- ko block: $data --><!-- /ko --></div>");
  templateSystem.addTemplate("blocks-show", "<!-- ko template: { name: 'block-show', foreach: blocks } --><!-- /ko -->");
  templateSystem.addTemplate("blocks-wysiwyg", "<div class=\x22sortable-blocks-edit\x22 data-drop-content=\x22Drop here\x22 data-empty-content=\x22Drop here blocks from the Blocks tab\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here'), 'data-empty-content': $root.t('Drop here blocks from the &quot;Blocks&quot; tab') }, css: { 'empty': ko.utils.unwrapObservable(blocks).length == 0 }, extsortable: { connectClass: 'sortable-blocks-edit', template: 'block-wysiwyg', data: blocks, dragging: $root.dragging, beforeMove: $root.startMultiple, afterMove: $root.stopMultiple, options: { handle: '.handle', placeholder: $root.placeholderHelper } }\x22></div>");
  templateSystem.addTemplate("customstyle", "<div class=\x22customStyleHelp\x22 data-bind=\x22html: $root.t('Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class=&quot;customStyled&quot;><span>&quot;small cube&quot; </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul>')\x22>Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class=\x22customStyled\x22><span>\x22small cube\x22 </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul></div>");
  templateSystem.addTemplate("empty", "");
  templateSystem.addTemplate("error", "[<div style=\x22background-color: #fff0f0\x22 data-bind=\x22text: ko.toJS($data)\x22></div>]");
  templateSystem.addTemplate("img-wysiwyg", "<table tabfocus=\x220\x22 cellspacing=\x220\x22 cellpadding=\x220\x22 data-drop-content=\x22Drop here\x22 data-bind=\x22style: _stylebind, click: function(obj, evt) { $root.selectItem(_item, _data); return true; }, clickBubble: false, fudroppable: { activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }, droppable: { options: { accept: '.image', activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }, data: _src, dragged: $root.fileToImage }, css: { selecteditem: $root.isSelectedItem(_item) }, scrollIntoView: $root.isSelectedItem(_item), attr: { 'data-drop-content': $root.t('Drop here'), width: _width, height: _height, align: _align }\x22  class=\x22img-wysiwyg selectable-img\x22 style=\x22display: table;\x22><tr><td class=\x22uploadzone\x22>  <div class=\x22mo-imgselectionhelper\x22></div>  <div class=\x22mo-uploadzone\x22></div>  <div class=\x22img-size\x22 data-bind=\x22text: _size\x22>size</div>  <div class=\x22midtools\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: _src() != '' -->    <div title=\x22Remove image\x22 class=\x22tool delete\x22 data-bind=\x22attr: { title: $root.t('Remove image') }, click: _src.bind(_src, ''), clickBubble: false\x22><i class=\x22fa fa-fw fa-trash-o\x22></i></div>    <!-- ko if: typeof $root.editImage !== 'undefined' -->    <div title=\x22Open the image editing tool\x22 class=\x22tool edit\x22 data-bind=\x22attr: { title: $root.t('Open the image editing tool') }, click: $root.editImage.bind($element, _src), clickBubble: false\x22><i class=\x22fa fa-fw fa-pencil\x22></i></div>    <!-- /ko -->    <!-- /ko -->    <!-- ko if: _src() == '' -->    <div title=\x22Upload a new image\x22 data-bind=\x22attr: { title: $root.t('Upload a new image') }\x22 class=\x22tool upload\x22 style=\x22position: relative; overflow: hidden;\x22><i class=\x22fa fa-fw fa-upload\x22></i>      <input class=\x22fileupload nofile\x22 type=\x22file\x22 name=\x22files[]\x22 data-bind=\x22fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.loadMailingImage, canvasPreview: true }\x22 style=\x22z-index: 20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-size: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>    </div>    <!-- /ko -->  </div>  <!-- ko template: _template --><!-- /ko -->  <!-- ko if: _src() == '' -->    <!--    <img style=\x22display: block;\x22 class=\x22imgplaceholder\x22 width=\x22200\x22 src=\x22\x22 alt=\x22Insert an image here\x22 data-bind=\x22wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }\x22 />    -->    <span class=\x22fileuploadtext\x22 style=\x22text-align: center; display: -ms-flexbox; display: flex; align-items: center; flex-align: center; justify-content: center; padding: 1em; position: absolute; top: 0; left: 0; right: 0; bottom: 0;\x22><span class=\x22textMiddle\x22 style=\x22 text-shadow: 1px 1px 0 #FFFFFF, 0 0 10px #FFFFFF; font-weight: bold;\x22 data-bind=\x22text: $root.t('Drop an image here')\x22>Drop an image here</span></span>  <!-- /ko -->  <!-- ko if: _src() != '' -->  <!--    <img style=\x22display: block;\x22 width=\x22200\x22 src=\x22\x22 data-bind=\x22preloader: _src, wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }\x22 />    -->  <!-- /ko -->  <!-- pulsante per la cancellazione -->  <div title=\x22Drop an image here or click the upload button\x22 data-bind=\x22attr: { title: $root.t('Drop an image here or click the upload button') }, tooltips: {}\x22 class=\x22workzone\x22 style=\x22position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden;\x22>    <!-- ko if: _src.preloaded && _src() != _src.preloaded() -->PRELOADING....<!-- /ko -->    <!-- ko if: _src() != '' -->      <input class=\x22fileupload withfile\x22 type=\x22file\x22 name=\x22files[]\x22 data-bind=\x22fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.mailingGallery.unshift.bind($root.mailingGallery), canvasPreview: true }\x22 style=\x22z-index: -20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-zie: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>    <!-- /ko -->    <div class=\x22progress\x22 style=\x22opacity: .5; width: 80%; margin-left: 10%; position: absolute; bottom: 30%; height: 20px; border: 2px solid black;\x22>      <div class=\x22progress-bar progress-bar-success\x22 style=\x22height: 20px; background-color: black; \x22></div>    </div>  </div></table>");
  templateSystem.addTemplate("main", "<div id=\x22page\x22 style=\x22display: none;\x22 data-bind=\x22visible: true, css: { withToolbox: $root.showToolbox, withPreviewFrame: showPreviewFrame }\x22>  <div id=\x22main-edit-area\x22 data-bind=\x22click: function(obj, evt) { $root.selectBlock(null); return true; }, clickBubble: false\x22>    <!-- ko withProperties: { templateMode: 'wysiwyg', templateModeFallback: 'show' } -->    <div id=\x22main-wysiwyg-area\x22 data-bind=\x22wysiwygScrollfix: true, scrollable: true, fudroppable: { active: draggingImage }, css: { isdragging: dragging, isdraggingimg: draggingImage }, block: content\x22></div>    <!-- /ko -->  </div>  <div id=\x22toolbar\x22 class=\x22mo\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: typeof $root.undo != 'undefined' -->    <span data-bind=\x22buttonset: { }\x22 class=\x22leftButtons\x22>    <a title=\x22Undo last operation\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Undo last operation') }, click: $root.undo.execute, clickBubble: false, button: { disabled: !$root.undo.enabled(), icons: { primary: 'fa fa-reply' }, label: $root.undo.name, text: true }\x22>UNDO</a>    <a title=\x22Redo last operation\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Redo last operation') }, click: $root.redo.execute, clickBubble: false, button: { disabled: !$root.redo.enabled(), icons: { primary: 'fa fa-share' }, label: $root.redo.name, text: true }\x22>REDO</a>    </span>    <!-- ko if: $root.debug -->    <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.undoReset, clickBubble: false, button: { disabled: !$root.undo.enabled() && !$root.redo.enabled(), label: 'reset', text: true }\x22>RESET</a>    <!-- /ko -->    <!-- /ko -->    <span>    <input id=\x22showGallery\x22 type=\x22checkbox\x22 data-bind=\x22checked: $root.showGallery, button: { refreshOn: $root.showGallery,    icons: { primary: 'fa fa-fw fa-picture-o', secondary: null }, text: true, label: $root.t('Gallery') }\x22><label title=\x22Show image gallery\x22 for=\x22showGallery\x22 data-bind=\x22attr: { title: $root.t('Show image gallery') }\x22>show gallery</label></input>    </span>    <!-- ko template: {name: 'edit-name' } --># mailing name #<!-- /ko -->    <input id=\x22previewFrameToggle\x22 type=\x22checkbox\x22 data-bind=\x22checked: $root.showPreviewFrame, button: { refreshOn: $root.showPreviewFrame, icons: { primary: 'fa fa-fw fa-tablet', secondary: null }, text: false, label: $root.t('Preview') }\x22><label title=\x22Show live preview\x22 for=\x22previewFrameToggle\x22 data-bind=\x22attr: { title: $root.t('Show live preview') }\x22>PREVIEW</label></input>    <!-- ko if: $root.debug -->    <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.export, clickBubble: false, button: { label: 'export', text: true }\x22>EXPORT</a>    <input type=\x22checkbox\x22 data-bind=\x22checked: $root.debug\x22 /> debug    <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.loadDefaultBlocks, clickBubble: false, button: { icons: { primary: 'fa fa-fw fa-upload' }, label: 'Default', text: true }\x22>LOAD BLOCKS</a>    [<a id=\x22subscriptionsCount\x22 href=\x22javascript:viewModel.loopSubscriptionsCount()\x22>subs</a>]    <!-- /ko -->    <span data-bind=\x22visible: false\x22>    <input type=\x22checkbox\x22 data-bind=\x22checked: $root.showToolbox\x22 /> toolbox    </span>    <div class=\x22rightButtons\x22>    <!-- ko if: typeof $root.save !== 'undefined' -->    <a title=\x22Save template\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Save template') }, click: $root.save.execute, clickBubble: false, button: { disabled: !$root.save.enabled(), icons: { primary: 'fa fa-fw fa-cloud-upload' }, label: $root.t($root.save.name), text: true }\x22>SALVA</a>    <!-- /ko -->    <!-- ko if: typeof $root.test !== 'undefined' -->    <a title=\x22Show preview and send test\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Show preview and send test') }, click: $root.test.execute, clickBubble: false, button: { disabled: !$root.test.enabled(), icons: { primary: 'fa fa-fw fa-paper-plane' }, label: $root.t($root.test.name), text: true }\x22>TEST</a>    <!-- /ko -->    <!-- ko if: typeof $root.download !== 'undefined' -->    <form id=\x22downloadForm\x22 action=\x22#\x22 method=\x22POST\x22>    <input type=\x22hidden\x22 name=\x22action\x22 value=\x22download\x22 />    <input type=\x22hidden\x22 name=\x22filename\x22 value=\x22email.html\x22 id=\x22downloadHtmlFilename\x22 />    <input type=\x22hidden\x22 name=\x22html\x22 id=\x22downloadHtmlTextarea\x22 />    <a title=\x22Download template\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Download template') }, click: $root.download.execute, clickBubble: false, button: { disabled: !$root.download.enabled(), icons: { primary: 'fa fa-fw fa-download' }, label: $root.t($root.download.name), text: true }\x22>DOWNLOAD</a>    </form>    <!-- /ko -->    </div>  </div>  <!-- ko template: {name: 'dialog-select-image' } --># dialog image selection #<!-- /ko -->  <!-- ko if: $root.showToolbox -->  <div id=\x22main-toolbox\x22 class=\x22mo\x22 data-bind=\x22scrollable: true, withProperties: { templateMode: 'edit' }\x22>    <div data-bind=\x22template: { name: 'toolbox' }\x22></div>  </div>  <!-- /ko -->  <div id=\x22main-preview\x22 class=\x22mo\x22 data-bind=\x22scrollable: true, if: $root.showPreviewFrame\x22>    <div id=\x22preview-toolbar\x22>      <div data-bind=\x22visible: $root.showPreviewFrame, buttonset: { }\x22 style=\x22display: inline-block\x22>        <input id=\x22previewLarge\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22large\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'large', icons: { primary: 'fa fa-fw fa-desktop' } }\x22 />        <label for=\x22previewLarge\x22 title=\x22Large screen\x22 data-bind=\x22attr: { title: $root.t('Large screen') }\x22>Large screen</label>        <input id=\x22previewDesktop\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22desktop\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'desktop', icons: { primary: 'fa fa-fw fa-tablet' } }\x22 />        <label for=\x22previewDesktop\x22 title=\x22Tablet\x22 data-bind=\x22attr: { title: $root.t('Tablet') }\x22>Tablet</label>        <input id=\x22previewMobile\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22mobile\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'mobile', icons: { primary: 'fa fa-fw fa-mobile' } }\x22 />        <label for=\x22previewMobile\x22 title=\x22Smartphone\x22 data-bind=\x22attr: { title: $root.t('Smartphone') }\x22>Smartphone</label>      </div>    </div>    <div id=\x22frame-container\x22 data-bind=\x22css: { desktop: $root.previewMode() == 'desktop', mobile: $root.previewMode() == 'mobile', large: $root.previewMode() == 'large' }\x22>      <iframe data-bind=\x22bindIframe: $data\x22></iframe>    </div>  </div>  <div class=\x22mo\x22 id=\x22mo-body\x22></div>  <!-- TODO REMOVE ME  <div id=\x22incompatible-browser\x22 title=\x22Unsupported browser\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Usupported browser') }, html: '<p>Your browser is not supported.</p><p>Use a different browser or try updaring your browser.</p><p>Supported browsers: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>'\x22>    Unsupported browser  </div>  -->  <div id=\x22incompatible-template\x22 title=\x22Saved model is obsolete\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Saved model is obsolete') }, html: $root.t('<p>The saved model has been created with a previous, non completely compatible version, of the template</p><p>Some content or style in the model <b>COULD BE LOST</b> if you will <b>save</b></p><p>Contact us for more informations!</p>')\x22>    Incompatible template  </div>  <div id=\x22fake-image-editor\x22 title=\x22Fake image editor\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Fake image editor') }, html: $root.t('<p>Fake image editor</p>')\x22>    <p>Fake image editor</p>  </div></div><!-- ko if: $root.logoPath --><div id=\x22loading\x22 class=\x22loading\x22 style=\x22display: block; width: 300px; text-align: center; height: 32px; position: absolute; top:0; bottom: 0; left: 0; right: 0;  margin: auto;\x22 data-bind=\x22attr: { style: 'position: absolute; top: 5px; left: 6px; z-index: 150;'}, css: { loading: false }\x22>  <a href=\x22/\x22 data-bind=\x22attr: { href: $root.logoUrl, alt: $root.logoAlt }\x22><img data-bind=\x22attr: { src: $root.logoPath }\x22 width=\x2232\x22 height=\x2232\x22 alt=\x22mosaico\x22 border=\x220\x22 /></a>  <div style=\x22opacity: 0\x22 data-bind=\x22visible: false\x22>Oppps... !!</div></div><!-- /ko --><!-- ko template: {name: 'home-icon' } --># home-icon #<!-- /ko -->");
  templateSystem.addTemplate("toolbox", "<div id=\x22tooltabs\x22 class=\x22tabs_horizontal button_color\x22 data-bind=\x22tabs: { active: $root.selectedTool }\x22>  <ul>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Blocks ready to be added to the template\x22 data-local=\x22true\x22 href=\x22#toolblocks\x22 data-bind=\x22attr: { title: $root.t('Blocks ready to be added to the template') }\x22><i class=\x22fa fa-fw fa-cubes\x22></i> <span data-bind=\x22html: $root.t('Blocks')\x22>Blocks</span></a></li>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Edit content options\x22 href=\x22#toolcontents\x22 data-local=\x22true\x22 data-bind=\x22attr: { title: $root.t('Edit content options') }\x22><i class=\x22fa fa-fw fa-pencil\x22></i> <span data-bind=\x22html: $root.t('Content')\x22>Content</span></a></li>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Edit style options\x22 href=\x22#toolstyles\x22 data-local=\x22true\x22 data-bind=\x22attr: { title: $root.t('Edit style options') }\x22><i class=\x22fa fa-fw fa-paint-brush\x22></i> <span data-bind=\x22html: $root.t('Style')\x22>Style</span></a></li>  </ul>  <div id=\x22toolblocks\x22 data-bind=\x22scrollable: true\x22>    <div class=\x22block-list\x22 data-bind=\x22foreach: blockDefs\x22 style=\x22text-align: center\x22>      <div class=\x22draggable-item\x22 data-bind=\x22withProperties: { templateMode: 'show' }\x22>        <div class=\x22block\x22 data-bind=\x22extdraggable: { connectClass: 'sortable-blocks-edit', data: $data, dropContainer: '#main-wysiwyg-area', dragging: $root.dragging, 'options': { handle: '.handle', distance: 10, 'appendTo': '#page' } }, click: $root.addBlock\x22 style=\x22position: relative;\x22>          <div title=\x22Click or drag to add this block to the template\x22 class=\x22handle\x22 data-bind=\x22attr: { title: $root.t('Click or drag to add this block to the template') }, tooltips: {}\x22></div>          <img data-bind=\x22attr: { alt: $root.t('Block __name__', { name: ko.utils.unwrapObservable(type) }), src: $root.templatePath('edres/'+ko.utils.unwrapObservable(type)+'.png') }\x22 alt=\x22Block __name__\x22 />        </div>        <a href=\x22javascript:void(0)\x22 class=\x22addblockbutton\x22 data-bind=\x22click: $root.addBlock, button: { label: $root.t('Add') }\x22>Add</a>      </div>    </div>  </div>  <div id=\x22toolcontents\x22 data-bind=\x22scrollable: true\x22>    <!-- ko if: $root.selectedBlock() !== null -->    <div data-bind=\x22block: $root.selectedBlock\x22></div>    <!-- /ko -->    <!-- ko if: $root.selectedBlock() == null -->    <div class=\x22noSelectedBlock\x22 data-bind=\x22text: $root.t('By clicking on message parts you will select a block and content options, if any, will show here')\x22>By clicking on message parts you will select a block and content options, if any, will show here</div>    <!-- /ko -->    <!-- ko block: content --><!-- /ko -->  </div>  <div id=\x22toolstyles\x22 data-bind=\x22scrollable: true, withProperties: { templateMode: 'styler' }\x22>    <!-- ko if: typeof $root.content().theme === 'undefined' || typeof $root.content().theme().scheme === 'undefined' || $root.content().theme().scheme() === 'custom' -->      <!-- ko if: $root.selectedBlock() !== null -->      <div data-bind=\x22block: $root.selectedBlock, css: { workLocal: $root.selectedBlock().customStyle, workGlobal: typeof $root.selectedBlock().customStyle === 'undefined' || !$root.selectedBlock().customStyle() }\x22></div>      <!-- /ko -->      <!-- ko if: $root.selectedBlock() == null -->      <div class=\x22noSelectedBlock\x22 data-bind=\x22text: $root.t('By clicking on message parts you will select a block and style options, if available, will show here')\x22>By clicking on message parts you will select a block and style options, if available, will show here</div>      <!-- /ko -->      <div class=\x22workGlobalContent\x22>      <!-- ko block: content --><!-- /ko -->      </div>    <!-- /ko -->  </div></div><div id=\x22toolimages\x22 class=\x22slidebar\x22 data-bind=\x22scrollable: true, css: { hidden: $root.showGallery() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.showGallery.bind($element, false);\x22>X</div>  <span class=\x22pane-title\x22 data-bind=\x22text: $root.t('gallery-title')\x22>Galleries:</span>  <!-- ko if: $root.showGallery() -->  <div id=\x22toolimagestab\x22 class=\x22tabs_horizontal\x22 data-bind=\x22tabs: { active: $root.selectedImageTab }\x22>    <ul>      <li data-bind=\x22tooltips: {}\x22><a title=\x22gallery-mailing\x22 data-local=\x22true\x22 href=\x22#toolimagesgallery\x22 data-bind=\x22attr: { title: $root.t('gallery-mailing') }, text: $root.t('gallery-mailing')\x22>gallery-mailing</a></li>      <li data-bind=\x22tooltips: {}\x22><a title=\x22gallery-template\x22 data-local=\x22true\x22 href=\x22#toolimagesgallerytemplate\x22 data-bind=\x22attr: { title: $root.t('gallery-template') }, text: $root.t('gallery-template')\x22>gallery-template</a></li>    </ul>    <div id=\x22toolimagesgallery\x22 class=\x22gallery-panel\x22>      <!-- ko template: {name: 'gallery-upload', data: { type: 'mailing' } } --># mailing gallery fileupload #<!-- /ko -->    <!-- ko if: $root.mailingGalleryStatus() === false --><a class=\x22loadbutton\x22 title=\x22Show images from the gallery\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Show images from the gallery') }, click: $root.loadMailingGallery, button: { disabled: $root.mailingGalleryStatus, icons: { primary: 'fa fa-fw fa-picture-o' }, label: $root.mailingGalleryStatus() == 'loading' ? $root.t('Loading...') : $root.t('Load gallery'), text: true }\x22># load gallery #</a><!-- /ko -->    <!-- ko if: $root.mailingGalleryStatus() === 'loading' --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-loading')\x22>Loading mailing gallery…</div><!-- /ko -->    <!-- ko if: $root.mailingGalleryStatus() === 0 --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-empty')\x22>The mailing gallery is empty</div><!-- /ko -->    <!-- ko template: {name: 'gallery-images', data: { items: mailingGallery, type: 'mailing' } } --># mailing gallery #<!-- /ko -->    </div>    <div id=\x22toolimagesgallerytemplate\x22 class=\x22gallery-panel\x22>      <!-- ko template: {name: 'gallery-upload', data: { type: 'template' } } --># mailing template fileupload #<!-- /ko -->      <!-- ko if: $root.templateGalleryStatus() === false --><a class=\x22loadbutton\x22 title=\x22Show images from the gallery\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Show images from the gallery') }, click: $root.loadTemplateGallery, button: { disabled: $root.templateGalleryStatus, icons: { primary: 'fa fa-fw fa-picture-o' }, label: $root.templateGalleryStatus() == 'loading' ? $root.t('Loading...') : $root.t('Load gallery'), text: true }\x22># load gallery #</a><!-- /ko -->      <!-- ko if: $root.templateGalleryStatus() === 'loading' --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-loading')\x22>Loading template gallery...</div><!-- /ko -->      <!-- ko if: $root.templateGalleryStatus() === 0 --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-empty')\x22>The template gallery is empty</div><!-- /ko -->      <!-- ko template: {name: 'gallery-images', data: { items: templateGallery, type: 'template' } } --># template gallery #<!-- /ko -->    </div>  </div>  <!-- /ko --></div><div id=\x22tooldebug\x22 class=\x22slidebar\x22 data-bind=\x22css: { hidden: $root.debug() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.debug.bind($element, false);\x22>X</div>  <!-- ko if: $root.debug -->  Content:  <pre data-bind='text: ko.toJSON(content, null, 2)' style=\x22overflow: auto; height: 20%\x22></pre>  BlockDefs:  <pre data-bind='text: ko.toJSON(blockDefs, null, 2)' style=\x22overflow: auto; height: 20%\x22></pre>  <!-- /ko -->  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.exportHTMLtoTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Generate' }\x22>Output</a>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.exportJSONtoTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Export' }\x22>Export</a>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.importJSONfromTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Import' }\x22>Import</a>  <textarea id=\x22outputhtml\x22 rows=\x2210\x22 style=\x22width: 100%;\x22></textarea></div><div id=\x22tooltheme\x22 class=\x22ui-widget slidebar\x22 data-bind=\x22css: { hidden: $root.showTheme() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.showTheme.bind($element, false);\x22>X</div>  <!-- ko withProperties: { templateMode: 'styler' } -->    <!-- ko if: $root.showTheme -->      <!-- ko block: $root.content().theme --><!-- /ko -->    <!-- /ko -->  <!-- /ko --></div>");
  templateSystem.addTemplate("dialog-select-image", "<!-- ko if: $root.showDialogGallery() --><!-- should use ui-dialog --><aside id=\x22dialogGallery\x22 class=\x22mo\x22>  <div class=\x22tabs_horizontal\x22 data-bind=\x22tabs: { active: $root.selectedImageTab }\x22>    <div class=\x22close\x22 data-bind=\x22click: $root.closeDialogGallery;\x22>X</div>    <ul>      <li data-bind=\x22tooltips: {}\x22><a title=\x22gallery-mailing\x22 data-local=\x22true\x22 href=\x22#dialoggallerymailing\x22 data-bind=\x22attr: { title: $root.t('gallery-mailing') }, text: $root.t('gallery-mailing')\x22>gallery-mailing</a></li>      <li data-bind=\x22tooltips: {}\x22><a title=\x22gallery-template\x22 data-local=\x22true\x22 href=\x22#dialoggallerytemplate\x22 data-bind=\x22attr: { title: $root.t('gallery-template') }, text: $root.t('gallery-template')\x22>gallery-template</a></li>    </ul>    <div id=\x22dialoggallerymailing\x22 class=\x22gallery-panel\x22>      <!-- ko template: {name: 'gallery-upload', data: { type: 'mailing' } } --># mailing gallery fileupload #<!-- /ko -->      <!-- ko if: $root.mailingGalleryStatus() === false --><a class=\x22loadbutton\x22 title=\x22Show images from the gallery\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Show images from the gallery') }, click: $root.loadMailingGallery, button: { disabled: $root.mailingGalleryStatus, icons: { primary: 'fa fa-fw fa-picture-o' }, label: $root.mailingGalleryStatus() == 'loading' ? $root.t('Loading...') : $root.t('Load gallery'), text: true }\x22># load gallery #</a><!-- /ko -->      <!-- ko if: $root.mailingGalleryStatus() === 'loading' -->        <div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-loading')\x22>Loading mailing gallery…</div>      <!-- /ko -->      <!-- ko if: $root.mailingGalleryStatus() === 0 -->        <div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-empty')\x22>The mailing gallery is empty</div>      <!-- /ko -->      <div class=\x22dialog-gallery-wrapper\x22>        <ul data-bind=\x22foreach: mailingGallery\x22>          <!-- ko if: typeof thumbnailUrl != 'undefined' -->          <li data-bind=\x22click: $root.setBgImage.bind($element, name);\x22>            <img style=\x22display: block;\x22 data-bind=\x22attr: { src: thumbnailUrl }\x22/>          </li>          <!-- /ko -->        </ul>      </div>    </div>    <div id=\x22dialoggallerytemplate\x22 class=\x22gallery-panel\x22>      <!-- ko template: {name: 'gallery-upload', data: { type: 'template' } } --># mailing template fileupload #<!-- /ko -->      <!-- ko if: $root.templateGalleryStatus() === false --><a class=\x22loadbutton\x22 title=\x22Show images from the gallery\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Show images from the gallery') }, click: $root.loadTemplateGallery, button: { disabled: $root.templateGalleryStatus, icons: { primary: 'fa fa-fw fa-picture-o' }, label: $root.templateGalleryStatus() == 'loading' ? $root.t('Loading...') : $root.t('Load gallery'), text: true }\x22># load gallery #</a><!-- /ko -->      <!-- ko if: $root.templateGalleryStatus() === 'loading' -->        <div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-loading')\x22>Loading template gallery...</div>      <!-- /ko -->      <!-- ko if: $root.templateGalleryStatus() === 0 -->        <div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('gallery-mailing-empty')\x22>The template gallery is empty</div>      <!-- /ko -->      <div class=\x22dialog-gallery-wrapper\x22>        <ul data-bind=\x22foreach: templateGallery\x22>          <!-- ko if: typeof thumbnailUrl != 'undefined' -->          <li data-bind=\x22click: $root.setBgImage.bind($element, name);\x22>            <img style=\x22display: block;\x22 data-bind=\x22attr: { src: thumbnailUrl }\x22/>          </li>          <!-- /ko -->        </ul>      </div>    </div>  </div></aside><!-- /ko -->");
  templateSystem.addTemplate("edit-name", "<!-- ko if: $root.titleMode() == 'edit' || $root.titleMode() == 'saving' --><form class=\x22mailing-name\x22 data-bind=\x22submit: saveEditMailingName, submitBubble: false\x22>  <input type=\x22text\x22 data-bind=\x22value: $root.metadata.name, disable: $root.titleMode() == 'saving', hasFocus: $root.titleMode() == 'edit'\x22/>  <button type=\x22button\x22 data-bind=\x22click: cancelEditMailingName, clickBubble: false, disable: $root.titleMode() == 'saving',  button: { refreshOn: $root.showPreviewFrame, icons: { primary: 'fa fa-fw fa-times', secondary: null }, text: false, label: $root.t('edit-title-cancel') }\x22>cancel</button>  <button type=\x22submit\x22 data-bind=\x22disable: $root.titleMode() == 'saving',    button: { refreshOn: $root.showPreviewFrame, icons: { primary: 'fa fa-fw fa-check-circle', secondary: null }, text: false, label: $root.t('edit-title-save') }\x22>save</button></form><!-- /ko --><!-- ko if: $root.titleMode() == 'show' --><div class=\x22mailing-name\x22>  <p class=\x22ui-button\x22 data-bind=\x22event: { dblclick: enableEditMailingName }, dblclickBubble: false,    attr: { title: $root.t('edit-title-double-click') }\x22>    <span class=\x22ui-button-text\x22 data-bind=\x22text: $root.mailingName\x22></span>  </p></div><!-- /ko -->");
  templateSystem.addTemplate("gallery-images", "<aside class=\x22gallery-thumbs gallery-thumbs--custom\x22 data-bind=\x22attr: {'data-type': type}\x22>  <div data-bind=\x22foreach: items\x22>    <div class=\x22draggable-item\x22 data-bind=\x22if: typeof thumbnailUrl != 'undefined'\x22>      <button class=\x22gallery-thumbs__remove\x22 data-bind=\x22click: $root.removeImage.bind($data, $data, $parent.type)\x22>        <i class=\x22fa fa-times\x22></i>      </button>      <div class=\x22draggable image\x22 data-bind=\x22click: $root.addImage, extdraggable: { data: $data, dropContainer: '#main-wysiwyg-area', dragging: $root.draggingImage, 'options': { 'appendTo': '#page' } }, style: { backgroundImage: 'url(\\'' + thumbnailUrl + '\\')' }\x22>        <img title=\x22Drag this image and drop it on any template image placeholder\x22 style=\x22display: block;\x22 data-bind=\x22tooltips: {}, attr: { src: thumbnailUrl, 'title': $root.t('Drag this image and drop it on any template image placeholder') }\x22/>      </div>    </div>  </div></aside>");
  templateSystem.addTemplate("gallery-upload", "<div data-drop-content=\x22Drop here\x22 class=\x22img-dropzone pane uploadzone\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here') }, fudroppable: { activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }\x22>  <div class=\x22mo-uploadzone\x22>    <!-- ko if: type === 'mailing' -->      <input class=\x22fileupload\x22 type=\x22file\x22 multiple name=\x22files[]\x22 data-bind=\x22fileupload: { onerror: $root.notifier.error, onfile: $root.loadMailingImage }\x22>    <!-- /ko -->    <!-- ko if: type === 'template' -->      <input class=\x22fileupload\x22 type=\x22file\x22 multiple name=\x22files[]\x22 data-bind=\x22fileupload: { onerror: $root.notifier.error, onfile: $root.loadTemplateImage, uploadToTemplate: true }\x22>    <!-- /ko -->    <span data-bind=\x22text: $root.t('Click or drag files here')\x22>Click or drag files here</span>      <div class=\x22workzone\x22>        <div class=\x22progress\x22>          <div class=\x22progress-bar progress-bar-success\x22></div>        </div>      </div>  </div></div>");
  templateSystem.addTemplate("home-icon", "<div id=\x22loading\x22 class=\x22loading\x22 data-bind=\x22css: { loading: false }\x22>  <a href=\x22/\x22 alt=\x22mosaic-backend\x22 data-bind=\x22attr: { alt: $root.brandName }\x22>    <i class=\x22fa fa-home fa-2x\x22 aria-hidden=\x22true\x22></i>  </a>  <div style=\x22opacity: 0\x22 data-bind=\x22visible: false\x22>Oppps... !!</div></div>");
});

},{"../src/js/bindings/choose-template.js":47}],21:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":37}],22:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],23:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = find;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],24:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return basePickBy(object, props, function(value, key) {
    return key in object;
  });
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, props, predicate) {
  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = baseRest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = omit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],26:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],27:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],28:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],30:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":28,"./encode":29}],31:[function(require,module,exports){
module.exports = require('./lib/speakingurl');

},{"./lib/speakingurl":32}],32:[function(require,module,exports){
(function (root) {
    'use strict';

    /**
     * charMap
     * @type {Object}
     */
    var charMap = {

        // latin
        'À': 'A',
        'Á': 'A',
        'Â': 'A',
        'Ã': 'A',
        'Ä': 'Ae',
        'Å': 'A',
        'Æ': 'AE',
        'Ç': 'C',
        'È': 'E',
        'É': 'E',
        'Ê': 'E',
        'Ë': 'E',
        'Ì': 'I',
        'Í': 'I',
        'Î': 'I',
        'Ï': 'I',
        'Ð': 'D',
        'Ñ': 'N',
        'Ò': 'O',
        'Ó': 'O',
        'Ô': 'O',
        'Õ': 'O',
        'Ö': 'Oe',
        'Ő': 'O',
        'Ø': 'O',
        'Ù': 'U',
        'Ú': 'U',
        'Û': 'U',
        'Ü': 'Ue',
        'Ű': 'U',
        'Ý': 'Y',
        'Þ': 'TH',
        'ß': 'ss',
        'à': 'a',
        'á': 'a',
        'â': 'a',
        'ã': 'a',
        'ä': 'ae',
        'å': 'a',
        'æ': 'ae',
        'ç': 'c',
        'è': 'e',
        'é': 'e',
        'ê': 'e',
        'ë': 'e',
        'ì': 'i',
        'í': 'i',
        'î': 'i',
        'ï': 'i',
        'ð': 'd',
        'ñ': 'n',
        'ò': 'o',
        'ó': 'o',
        'ô': 'o',
        'õ': 'o',
        'ö': 'oe',
        'ő': 'o',
        'ø': 'o',
        'ù': 'u',
        'ú': 'u',
        'û': 'u',
        'ü': 'ue',
        'ű': 'u',
        'ý': 'y',
        'þ': 'th',
        'ÿ': 'y',
        'ẞ': 'SS',

        // language specific

        // Arabic
        'ا': 'a',
        'أ': 'a',
        'إ': 'i',
        'آ': 'aa',
        'ؤ': 'u',
        'ئ': 'e',
        'ء': 'a',
        'ب': 'b',
        'ت': 't',
        'ث': 'th',
        'ج': 'j',
        'ح': 'h',
        'خ': 'kh',
        'د': 'd',
        'ذ': 'th',
        'ر': 'r',
        'ز': 'z',
        'س': 's',
        'ش': 'sh',
        'ص': 's',
        'ض': 'dh',
        'ط': 't',
        'ظ': 'z',
        'ع': 'a',
        'غ': 'gh',
        'ف': 'f',
        'ق': 'q',
        'ك': 'k',
        'ل': 'l',
        'م': 'm',
        'ن': 'n',
        'ه': 'h',
        'و': 'w',
        'ي': 'y',
        'ى': 'a',
        'ة': 'h',
        'ﻻ': 'la',
        'ﻷ': 'laa',
        'ﻹ': 'lai',
        'ﻵ': 'laa',

        // Persian additional characters than Arabic
        'گ': 'g',
        'چ': 'ch',
        'پ': 'p',
        'ژ': 'zh',
        'ک': 'k',
        'ی': 'y',

        // Arabic diactrics
        'َ': 'a',
        'ً': 'an',
        'ِ': 'e',
        'ٍ': 'en',
        'ُ': 'u',
        'ٌ': 'on',
        'ْ': '',

        // Arabic numbers
        '٠': '0',
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',

        // Persian numbers
        '۰': '0',
        '۱': '1',
        '۲': '2',
        '۳': '3',
        '۴': '4',
        '۵': '5',
        '۶': '6',
        '۷': '7',
        '۸': '8',
        '۹': '9',

        // Burmese consonants
        'က': 'k',
        'ခ': 'kh',
        'ဂ': 'g',
        'ဃ': 'ga',
        'င': 'ng',
        'စ': 's',
        'ဆ': 'sa',
        'ဇ': 'z',
        'စျ': 'za',
        'ည': 'ny',
        'ဋ': 't',
        'ဌ': 'ta',
        'ဍ': 'd',
        'ဎ': 'da',
        'ဏ': 'na',
        'တ': 't',
        'ထ': 'ta',
        'ဒ': 'd',
        'ဓ': 'da',
        'န': 'n',
        'ပ': 'p',
        'ဖ': 'pa',
        'ဗ': 'b',
        'ဘ': 'ba',
        'မ': 'm',
        'ယ': 'y',
        'ရ': 'ya',
        'လ': 'l',
        'ဝ': 'w',
        'သ': 'th',
        'ဟ': 'h',
        'ဠ': 'la',
        'အ': 'a',
        // consonant character combos
        'ြ': 'y',
        'ျ': 'ya',
        'ွ': 'w',
        'ြွ': 'yw',
        'ျွ': 'ywa',
        'ှ': 'h',
        // independent vowels
        'ဧ': 'e',
        '၏': '-e',
        'ဣ': 'i',
        'ဤ': '-i',
        'ဉ': 'u',
        'ဦ': '-u',
        'ဩ': 'aw',
        'သြော': 'aw',
        'ဪ': 'aw',
        // numbers
        '၀': '0',
        '၁': '1',
        '၂': '2',
        '၃': '3',
        '၄': '4',
        '၅': '5',
        '၆': '6',
        '၇': '7',
        '၈': '8',
        '၉': '9',
        // virama and tone marks which are silent in transliteration
        '္': '',
        '့': '',
        'း': '',

        // Czech
        'č': 'c',
        'ď': 'd',
        'ě': 'e',
        'ň': 'n',
        'ř': 'r',
        'š': 's',
        'ť': 't',
        'ů': 'u',
        'ž': 'z',
        'Č': 'C',
        'Ď': 'D',
        'Ě': 'E',
        'Ň': 'N',
        'Ř': 'R',
        'Š': 'S',
        'Ť': 'T',
        'Ů': 'U',
        'Ž': 'Z',

        // Dhivehi
        'ހ': 'h',
        'ށ': 'sh',
        'ނ': 'n',
        'ރ': 'r',
        'ބ': 'b',
        'ޅ': 'lh',
        'ކ': 'k',
        'އ': 'a',
        'ވ': 'v',
        'މ': 'm',
        'ފ': 'f',
        'ދ': 'dh',
        'ތ': 'th',
        'ލ': 'l',
        'ގ': 'g',
        'ޏ': 'gn',
        'ސ': 's',
        'ޑ': 'd',
        'ޒ': 'z',
        'ޓ': 't',
        'ޔ': 'y',
        'ޕ': 'p',
        'ޖ': 'j',
        'ޗ': 'ch',
        'ޘ': 'tt',
        'ޙ': 'hh',
        'ޚ': 'kh',
        'ޛ': 'th',
        'ޜ': 'z',
        'ޝ': 'sh',
        'ޞ': 's',
        'ޟ': 'd',
        'ޠ': 't',
        'ޡ': 'z',
        'ޢ': 'a',
        'ޣ': 'gh',
        'ޤ': 'q',
        'ޥ': 'w',
        'ަ': 'a',
        'ާ': 'aa',
        'ި': 'i',
        'ީ': 'ee',
        'ު': 'u',
        'ޫ': 'oo',
        'ެ': 'e',
        'ޭ': 'ey',
        'ޮ': 'o',
        'ޯ': 'oa',
        'ް': '',

        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        'ა': 'a',
        'ბ': 'b',
        'გ': 'g',
        'დ': 'd',
        'ე': 'e',
        'ვ': 'v',
        'ზ': 'z',
        'თ': 't',
        'ი': 'i',
        'კ': 'k',
        'ლ': 'l',
        'მ': 'm',
        'ნ': 'n',
        'ო': 'o',
        'პ': 'p',
        'ჟ': 'zh',
        'რ': 'r',
        'ს': 's',
        'ტ': 't',
        'უ': 'u',
        'ფ': 'p',
        'ქ': 'k',
        'ღ': 'gh',
        'ყ': 'q',
        'შ': 'sh',
        'ჩ': 'ch',
        'ც': 'ts',
        'ძ': 'dz',
        'წ': 'ts',
        'ჭ': 'ch',
        'ხ': 'kh',
        'ჯ': 'j',
        'ჰ': 'h',

        // Greek
        'α': 'a',
        'β': 'v',
        'γ': 'g',
        'δ': 'd',
        'ε': 'e',
        'ζ': 'z',
        'η': 'i',
        'θ': 'th',
        'ι': 'i',
        'κ': 'k',
        'λ': 'l',
        'μ': 'm',
        'ν': 'n',
        'ξ': 'ks',
        'ο': 'o',
        'π': 'p',
        'ρ': 'r',
        'σ': 's',
        'τ': 't',
        'υ': 'y',
        'φ': 'f',
        'χ': 'x',
        'ψ': 'ps',
        'ω': 'o',
        'ά': 'a',
        'έ': 'e',
        'ί': 'i',
        'ό': 'o',
        'ύ': 'y',
        'ή': 'i',
        'ώ': 'o',
        'ς': 's',
        'ϊ': 'i',
        'ΰ': 'y',
        'ϋ': 'y',
        'ΐ': 'i',
        'Α': 'A',
        'Β': 'B',
        'Γ': 'G',
        'Δ': 'D',
        'Ε': 'E',
        'Ζ': 'Z',
        'Η': 'I',
        'Θ': 'TH',
        'Ι': 'I',
        'Κ': 'K',
        'Λ': 'L',
        'Μ': 'M',
        'Ν': 'N',
        'Ξ': 'KS',
        'Ο': 'O',
        'Π': 'P',
        'Ρ': 'R',
        'Σ': 'S',
        'Τ': 'T',
        'Υ': 'Y',
        'Φ': 'F',
        'Χ': 'X',
        'Ψ': 'PS',
        'Ω': 'O',
        'Ά': 'A',
        'Έ': 'E',
        'Ί': 'I',
        'Ό': 'O',
        'Ύ': 'Y',
        'Ή': 'I',
        'Ώ': 'O',
        'Ϊ': 'I',
        'Ϋ': 'Y',

        // Latvian
        'ā': 'a',
        // 'č': 'c', // duplicate
        'ē': 'e',
        'ģ': 'g',
        'ī': 'i',
        'ķ': 'k',
        'ļ': 'l',
        'ņ': 'n',
        // 'š': 's', // duplicate
        'ū': 'u',
        // 'ž': 'z', // duplicate
        'Ā': 'A',
        // 'Č': 'C', // duplicate
        'Ē': 'E',
        'Ģ': 'G',
        'Ī': 'I',
        'Ķ': 'k',
        'Ļ': 'L',
        'Ņ': 'N',
        // 'Š': 'S', // duplicate
        'Ū': 'U',
        // 'Ž': 'Z', // duplicate

        // Macedonian
        'Ќ': 'Kj',
        'ќ': 'kj',
        'Љ': 'Lj',
        'љ': 'lj',
        'Њ': 'Nj',
        'њ': 'nj',
        'Тс': 'Ts',
        'тс': 'ts',

        // Polish
        'ą': 'a',
        'ć': 'c',
        'ę': 'e',
        'ł': 'l',
        'ń': 'n',
        // 'ó': 'o', // duplicate
        'ś': 's',
        'ź': 'z',
        'ż': 'z',
        'Ą': 'A',
        'Ć': 'C',
        'Ę': 'E',
        'Ł': 'L',
        'Ń': 'N',
        'Ś': 'S',
        'Ź': 'Z',
        'Ż': 'Z',

        // Ukranian
        'Є': 'Ye',
        'І': 'I',
        'Ї': 'Yi',
        'Ґ': 'G',
        'є': 'ye',
        'і': 'i',
        'ї': 'yi',
        'ґ': 'g',

        // Romanian
        'ă': 'a',
        'Ă': 'A',
        'ș': 's',
        'Ș': 'S',
        // 'ş': 's', // duplicate
        // 'Ş': 'S', // duplicate
        'ț': 't',
        'Ț': 'T',
        'ţ': 't',
        'Ţ': 'T',

        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO

        'а': 'a',
        'б': 'b',
        'в': 'v',
        'г': 'g',
        'д': 'd',
        'е': 'e',
        'ё': 'yo',
        'ж': 'zh',
        'з': 'z',
        'и': 'i',
        'й': 'i',
        'к': 'k',
        'л': 'l',
        'м': 'm',
        'н': 'n',
        'о': 'o',
        'п': 'p',
        'р': 'r',
        'с': 's',
        'т': 't',
        'у': 'u',
        'ф': 'f',
        'х': 'kh',
        'ц': 'c',
        'ч': 'ch',
        'ш': 'sh',
        'щ': 'sh',
        'ъ': '',
        'ы': 'y',
        'ь': '',
        'э': 'e',
        'ю': 'yu',
        'я': 'ya',
        'А': 'A',
        'Б': 'B',
        'В': 'V',
        'Г': 'G',
        'Д': 'D',
        'Е': 'E',
        'Ё': 'Yo',
        'Ж': 'Zh',
        'З': 'Z',
        'И': 'I',
        'Й': 'I',
        'К': 'K',
        'Л': 'L',
        'М': 'M',
        'Н': 'N',
        'О': 'O',
        'П': 'P',
        'Р': 'R',
        'С': 'S',
        'Т': 'T',
        'У': 'U',
        'Ф': 'F',
        'Х': 'Kh',
        'Ц': 'C',
        'Ч': 'Ch',
        'Ш': 'Sh',
        'Щ': 'Sh',
        'Ъ': '',
        'Ы': 'Y',
        'Ь': '',
        'Э': 'E',
        'Ю': 'Yu',
        'Я': 'Ya',

        // Serbian
        'ђ': 'dj',
        'ј': 'j',
        // 'љ': 'lj',  // duplicate
        // 'њ': 'nj', // duplicate
        'ћ': 'c',
        'џ': 'dz',
        'Ђ': 'Dj',
        'Ј': 'j',
        // 'Љ': 'Lj', // duplicate
        // 'Њ': 'Nj', // duplicate
        'Ћ': 'C',
        'Џ': 'Dz',

        // Slovak
        'ľ': 'l',
        'ĺ': 'l',
        'ŕ': 'r',
        'Ľ': 'L',
        'Ĺ': 'L',
        'Ŕ': 'R',

        // Turkish
        'ş': 's',
        'Ş': 'S',
        'ı': 'i',
        'İ': 'I',
        // 'ç': 'c', // duplicate
        // 'Ç': 'C', // duplicate
        // 'ü': 'u', // duplicate, see langCharMap
        // 'Ü': 'U', // duplicate, see langCharMap
        // 'ö': 'o', // duplicate, see langCharMap
        // 'Ö': 'O', // duplicate, see langCharMap
        'ğ': 'g',
        'Ğ': 'G',

        // Vietnamese
        'ả': 'a',
        'Ả': 'A',
        'ẳ': 'a',
        'Ẳ': 'A',
        'ẩ': 'a',
        'Ẩ': 'A',
        'đ': 'd',
        'Đ': 'D',
        'ẹ': 'e',
        'Ẹ': 'E',
        'ẽ': 'e',
        'Ẽ': 'E',
        'ẻ': 'e',
        'Ẻ': 'E',
        'ế': 'e',
        'Ế': 'E',
        'ề': 'e',
        'Ề': 'E',
        'ệ': 'e',
        'Ệ': 'E',
        'ễ': 'e',
        'Ễ': 'E',
        'ể': 'e',
        'Ể': 'E',
        'ỏ': 'o',
        'ọ': 'o',
        'Ọ': 'o',
        'ố': 'o',
        'Ố': 'O',
        'ồ': 'o',
        'Ồ': 'O',
        'ổ': 'o',
        'Ổ': 'O',
        'ộ': 'o',
        'Ộ': 'O',
        'ỗ': 'o',
        'Ỗ': 'O',
        'ơ': 'o',
        'Ơ': 'O',
        'ớ': 'o',
        'Ớ': 'O',
        'ờ': 'o',
        'Ờ': 'O',
        'ợ': 'o',
        'Ợ': 'O',
        'ỡ': 'o',
        'Ỡ': 'O',
        'Ở': 'o',
        'ở': 'o',
        'ị': 'i',
        'Ị': 'I',
        'ĩ': 'i',
        'Ĩ': 'I',
        'ỉ': 'i',
        'Ỉ': 'i',
        'ủ': 'u',
        'Ủ': 'U',
        'ụ': 'u',
        'Ụ': 'U',
        'ũ': 'u',
        'Ũ': 'U',
        'ư': 'u',
        'Ư': 'U',
        'ứ': 'u',
        'Ứ': 'U',
        'ừ': 'u',
        'Ừ': 'U',
        'ự': 'u',
        'Ự': 'U',
        'ữ': 'u',
        'Ữ': 'U',
        'ử': 'u',
        'Ử': 'ư',
        'ỷ': 'y',
        'Ỷ': 'y',
        'ỳ': 'y',
        'Ỳ': 'Y',
        'ỵ': 'y',
        'Ỵ': 'Y',
        'ỹ': 'y',
        'Ỹ': 'Y',
        'ạ': 'a',
        'Ạ': 'A',
        'ấ': 'a',
        'Ấ': 'A',
        'ầ': 'a',
        'Ầ': 'A',
        'ậ': 'a',
        'Ậ': 'A',
        'ẫ': 'a',
        'Ẫ': 'A',
        // 'ă': 'a', // duplicate
        // 'Ă': 'A', // duplicate
        'ắ': 'a',
        'Ắ': 'A',
        'ằ': 'a',
        'Ằ': 'A',
        'ặ': 'a',
        'Ặ': 'A',
        'ẵ': 'a',
        'Ẵ': 'A',
        "⓪": "0",
        "①": "1",
        "②": "2",
        "③": "3",
        "④": "4",
        "⑤": "5",
        "⑥": "6",
        "⑦": "7",
        "⑧": "8",
        "⑨": "9",
        "⑩": "10",
        "⑪": "11",
        "⑫": "12",
        "⑬": "13",
        "⑭": "14",
        "⑮": "15",
        "⑯": "16",
        "⑰": "17",
        "⑱": "18",
        "⑲": "18",
        "⑳": "18",

        "⓵": "1",
        "⓶": "2",
        "⓷": "3",
        "⓸": "4",
        "⓹": "5",
        "⓺": "6",
        "⓻": "7",
        "⓼": "8",
        "⓽": "9",
        "⓾": "10",

        "⓿": "0",
        "⓫": "11",
        "⓬": "12",
        "⓭": "13",
        "⓮": "14",
        "⓯": "15",
        "⓰": "16",
        "⓱": "17",
        "⓲": "18",
        "⓳": "19",
        "⓴": "20",

        "Ⓐ": "A",
        "Ⓑ": "B",
        "Ⓒ": "C",
        "Ⓓ": "D",
        "Ⓔ": "E",
        "Ⓕ": "F",
        "Ⓖ": "G",
        "Ⓗ": "H",
        "Ⓘ": "I",
        "Ⓙ": "J",
        "Ⓚ": "K",
        "Ⓛ": "L",
        "Ⓜ": "M",
        "Ⓝ": "N",
        "Ⓞ": "O",
        "Ⓟ": "P",
        "Ⓠ": "Q",
        "Ⓡ": "R",
        "Ⓢ": "S",
        "Ⓣ": "T",
        "Ⓤ": "U",
        "Ⓥ": "V",
        "Ⓦ": "W",
        "Ⓧ": "X",
        "Ⓨ": "Y",
        "Ⓩ": "Z",

        "ⓐ": "a",
        "ⓑ": "b",
        "ⓒ": "c",
        "ⓓ": "d",
        "ⓔ": "e",
        "ⓕ": "f",
        "ⓖ": "g",
        "ⓗ": "h",
        "ⓘ": "i",
        "ⓙ": "j",
        "ⓚ": "k",
        "ⓛ": "l",
        "ⓜ": "m",
        "ⓝ": "n",
        "ⓞ": "o",
        "ⓟ": "p",
        "ⓠ": "q",
        "ⓡ": "r",
        "ⓢ": "s",
        "ⓣ": "t",
        "ⓤ": "u",
        "ⓦ": "v",
        "ⓥ": "w",
        "ⓧ": "x",
        "ⓨ": "y",
        "ⓩ": "z",

        // symbols
        '“': '"',
        '”': '"',
        '‘': "'",
        '’': "'",
        '∂': 'd',
        'ƒ': 'f',
        '™': '(TM)',
        '©': '(C)',
        'œ': 'oe',
        'Œ': 'OE',
        '®': '(R)',
        '†': '+',
        '℠': '(SM)',
        '…': '...',
        '˚': 'o',
        'º': 'o',
        'ª': 'a',
        '•': '*',
        '၊': ',',
        '။': '.',

        // currency
        '$': 'USD',
        '€': 'EUR',
        '₢': 'BRN',
        '₣': 'FRF',
        '£': 'GBP',
        '₤': 'ITL',
        '₦': 'NGN',
        '₧': 'ESP',
        '₩': 'KRW',
        '₪': 'ILS',
        '₫': 'VND',
        '₭': 'LAK',
        '₮': 'MNT',
        '₯': 'GRD',
        '₱': 'ARS',
        '₲': 'PYG',
        '₳': 'ARA',
        '₴': 'UAH',
        '₵': 'GHS',
        '¢': 'cent',
        '¥': 'CNY',
        '元': 'CNY',
        '円': 'YEN',
        '﷼': 'IRR',
        '₠': 'EWE',
        '฿': 'THB',
        '₨': 'INR',
        '₹': 'INR',
        '₰': 'PF',
        '₺': 'TRY',
        '؋': 'AFN',
        '₼': 'AZN',
        'лв': 'BGN',
        '៛': 'KHR',
        '₡': 'CRC',
        '₸': 'KZT',
        'ден': 'MKD',
        'zł': 'PLN',
        '₽': 'RUB',
        '₾': 'GEL'

    };

    /**
     * special look ahead character array
     * These characters form with consonants to become 'single'/consonant combo
     * @type [Array]
     */
    var lookAheadCharArray = [
        // burmese
        '်',

        // Dhivehi
        'ް'
    ];

    /**
     * diatricMap for languages where transliteration changes entirely as more diatrics are added
     * @type {Object}
     */
    var diatricMap = {
        // Burmese
        // dependent vowels
        'ာ': 'a',
        'ါ': 'a',
        'ေ': 'e',
        'ဲ': 'e',
        'ိ': 'i',
        'ီ': 'i',
        'ို': 'o',
        'ု': 'u',
        'ူ': 'u',
        'ေါင်': 'aung',
        'ော': 'aw',
        'ော်': 'aw',
        'ေါ': 'aw',
        'ေါ်': 'aw',
        '်': '်', // this is special case but the character will be converted to latin in the code
        'က်': 'et',
        'ိုက်': 'aik',
        'ောက်': 'auk',
        'င်': 'in',
        'ိုင်': 'aing',
        'ောင်': 'aung',
        'စ်': 'it',
        'ည်': 'i',
        'တ်': 'at',
        'ိတ်': 'eik',
        'ုတ်': 'ok',
        'ွတ်': 'ut',
        'ေတ်': 'it',
        'ဒ်': 'd',
        'ိုဒ်': 'ok',
        'ုဒ်': 'ait',
        'န်': 'an',
        'ာန်': 'an',
        'ိန်': 'ein',
        'ုန်': 'on',
        'ွန်': 'un',
        'ပ်': 'at',
        'ိပ်': 'eik',
        'ုပ်': 'ok',
        'ွပ်': 'ut',
        'န်ုပ်': 'nub',
        'မ်': 'an',
        'ိမ်': 'ein',
        'ုမ်': 'on',
        'ွမ်': 'un',
        'ယ်': 'e',
        'ိုလ်': 'ol',
        'ဉ်': 'in',
        'ံ': 'an',
        'ိံ': 'ein',
        'ုံ': 'on',

        // Dhivehi
        'ައް': 'ah',
        'ަށް': 'ah'
    };

    /**
     * langCharMap language specific characters translations
     * @type   {Object}
     */
    var langCharMap = {
        'en': {}, // default language

        'az': { // Azerbaijani
            'ç': 'c',
            'ə': 'e',
            'ğ': 'g',
            'ı': 'i',
            'ö': 'o',
            'ş': 's',
            'ü': 'u',
            'Ç': 'C',
            'Ə': 'E',
            'Ğ': 'G',
            'İ': 'I',
            'Ö': 'O',
            'Ş': 'S',
            'Ü': 'U'
        },

        'cs': { // Czech
            'č': 'c',
            'ď': 'd',
            'ě': 'e',
            'ň': 'n',
            'ř': 'r',
            'š': 's',
            'ť': 't',
            'ů': 'u',
            'ž': 'z',
            'Č': 'C',
            'Ď': 'D',
            'Ě': 'E',
            'Ň': 'N',
            'Ř': 'R',
            'Š': 'S',
            'Ť': 'T',
            'Ů': 'U',
            'Ž': 'Z'
        },

        'fi': { // Finnish
            // 'å': 'a', duplicate see charMap/latin
            // 'Å': 'A', duplicate see charMap/latin
            'ä': 'a', // ok
            'Ä': 'A', // ok
            'ö': 'o', // ok
            'Ö': 'O' // ok
        },

        'hu': { // Hungarian
            'ä': 'a', // ok
            'Ä': 'A', // ok
            // 'á': 'a', duplicate see charMap/latin
            // 'Á': 'A', duplicate see charMap/latin
            'ö': 'o', // ok
            'Ö': 'O', // ok
            // 'ő': 'o', duplicate see charMap/latin
            // 'Ő': 'O', duplicate see charMap/latin
            'ü': 'u',
            'Ü': 'U',
            'ű': 'u',
            'Ű': 'U'
        },

        'lt': { // Lithuanian
            'ą': 'a',
            'č': 'c',
            'ę': 'e',
            'ė': 'e',
            'į': 'i',
            'š': 's',
            'ų': 'u',
            'ū': 'u',
            'ž': 'z',
            'Ą': 'A',
            'Č': 'C',
            'Ę': 'E',
            'Ė': 'E',
            'Į': 'I',
            'Š': 'S',
            'Ų': 'U',
            'Ū': 'U'
        },

        'lv': { // Latvian
            'ā': 'a',
            'č': 'c',
            'ē': 'e',
            'ģ': 'g',
            'ī': 'i',
            'ķ': 'k',
            'ļ': 'l',
            'ņ': 'n',
            'š': 's',
            'ū': 'u',
            'ž': 'z',
            'Ā': 'A',
            'Č': 'C',
            'Ē': 'E',
            'Ģ': 'G',
            'Ī': 'i',
            'Ķ': 'k',
            'Ļ': 'L',
            'Ņ': 'N',
            'Š': 'S',
            'Ū': 'u',
            'Ž': 'Z'
        },

        'pl': { // Polish
            'ą': 'a',
            'ć': 'c',
            'ę': 'e',
            'ł': 'l',
            'ń': 'n',
            'ó': 'o',
            'ś': 's',
            'ź': 'z',
            'ż': 'z',
            'Ą': 'A',
            'Ć': 'C',
            'Ę': 'e',
            'Ł': 'L',
            'Ń': 'N',
            'Ó': 'O',
            'Ś': 'S',
            'Ź': 'Z',
            'Ż': 'Z'
        },

        'sv': { // Swedish
            // 'å': 'a', duplicate see charMap/latin
            // 'Å': 'A', duplicate see charMap/latin
            'ä': 'a', // ok
            'Ä': 'A', // ok
            'ö': 'o', // ok
            'Ö': 'O' // ok
        },

        'sk': { // Slovak
            'ä': 'a',
            'Ä': 'A'
        },

        'sr': { // Serbian
            'љ': 'lj',
            'њ': 'nj',
            'Љ': 'Lj',
            'Њ': 'Nj',
            'đ': 'dj',
            'Đ': 'Dj'
        },

        'tr': { // Turkish
            'Ü': 'U',
            'Ö': 'O',
            'ü': 'u',
            'ö': 'o'
        }
    };

    /**
     * symbolMap language specific symbol translations
     * translations must be transliterated already
     * @type   {Object}
     */
    var symbolMap = {
        'ar': {
            '∆': 'delta',
            '∞': 'la-nihaya',
            '♥': 'hob',
            '&': 'wa',
            '|': 'aw',
            '<': 'aqal-men',
            '>': 'akbar-men',
            '∑': 'majmou',
            '¤': 'omla'
        },

        'az': {},

        'ca': {
            '∆': 'delta',
            '∞': 'infinit',
            '♥': 'amor',
            '&': 'i',
            '|': 'o',
            '<': 'menys que',
            '>': 'mes que',
            '∑': 'suma dels',
            '¤': 'moneda'
        },

        'cs': {
            '∆': 'delta',
            '∞': 'nekonecno',
            '♥': 'laska',
            '&': 'a',
            '|': 'nebo',
            '<': 'mensi nez',
            '>': 'vetsi nez',
            '∑': 'soucet',
            '¤': 'mena'
        },

        'de': {
            '∆': 'delta',
            '∞': 'unendlich',
            '♥': 'Liebe',
            '&': 'und',
            '|': 'oder',
            '<': 'kleiner als',
            '>': 'groesser als',
            '∑': 'Summe von',
            '¤': 'Waehrung'
        },

        'dv': {
            '∆': 'delta',
            '∞': 'kolunulaa',
            '♥': 'loabi',
            '&': 'aai',
            '|': 'noonee',
            '<': 'ah vure kuda',
            '>': 'ah vure bodu',
            '∑': 'jumula',
            '¤': 'faisaa'
        },

        'en': {
            '∆': 'delta',
            '∞': 'infinity',
            '♥': 'love',
            '&': 'and',
            '|': 'or',
            '<': 'less than',
            '>': 'greater than',
            '∑': 'sum',
            '¤': 'currency'
        },

        'es': {
            '∆': 'delta',
            '∞': 'infinito',
            '♥': 'amor',
            '&': 'y',
            '|': 'u',
            '<': 'menos que',
            '>': 'mas que',
            '∑': 'suma de los',
            '¤': 'moneda'
        },

        'fa': {
            '∆': 'delta',
            '∞': 'bi-nahayat',
            '♥': 'eshgh',
            '&': 'va',
            '|': 'ya',
            '<': 'kamtar-az',
            '>': 'bishtar-az',
            '∑': 'majmooe',
            '¤': 'vahed'
        },

        'fi': {
            '∆': 'delta',
            '∞': 'aarettomyys',
            '♥': 'rakkaus',
            '&': 'ja',
            '|': 'tai',
            '<': 'pienempi kuin',
            '>': 'suurempi kuin',
            '∑': 'summa',
            '¤': 'valuutta'
        },

        'fr': {
            '∆': 'delta',
            '∞': 'infiniment',
            '♥': 'Amour',
            '&': 'et',
            '|': 'ou',
            '<': 'moins que',
            '>': 'superieure a',
            '∑': 'somme des',
            '¤': 'monnaie'
        },

        'ge': {
            '∆': 'delta',
            '∞': 'usasruloba',
            '♥': 'siqvaruli',
            '&': 'da',
            '|': 'an',
            '<': 'naklebi',
            '>': 'meti',
            '∑': 'jami',
            '¤': 'valuta'
        },

        'gr': {},

        'hu': {
            '∆': 'delta',
            '∞': 'vegtelen',
            '♥': 'szerelem',
            '&': 'es',
            '|': 'vagy',
            '<': 'kisebb mint',
            '>': 'nagyobb mint',
            '∑': 'szumma',
            '¤': 'penznem'
        },

        'it': {
            '∆': 'delta',
            '∞': 'infinito',
            '♥': 'amore',
            '&': 'e',
            '|': 'o',
            '<': 'minore di',
            '>': 'maggiore di',
            '∑': 'somma',
            '¤': 'moneta'
        },

        'lt': {
            '∆': 'delta',
            '∞': 'begalybe',
            '♥': 'meile',
            '&': 'ir',
            '|': 'ar',
            '<': 'maziau nei',
            '>': 'daugiau nei',
            '∑': 'suma',
            '¤': 'valiuta'
        },

        'lv': {
            '∆': 'delta',
            '∞': 'bezgaliba',
            '♥': 'milestiba',
            '&': 'un',
            '|': 'vai',
            '<': 'mazak neka',
            '>': 'lielaks neka',
            '∑': 'summa',
            '¤': 'valuta'
        },

        'my': {
            '∆': 'kwahkhyaet',
            '∞': 'asaonasme',
            '♥': 'akhyait',
            '&': 'nhin',
            '|': 'tho',
            '<': 'ngethaw',
            '>': 'kyithaw',
            '∑': 'paungld',
            '¤': 'ngwekye'
        },

        'mk': {},

        'nl': {
            '∆': 'delta',
            '∞': 'oneindig',
            '♥': 'liefde',
            '&': 'en',
            '|': 'of',
            '<': 'kleiner dan',
            '>': 'groter dan',
            '∑': 'som',
            '¤': 'valuta'
        },

        'pl': {
            '∆': 'delta',
            '∞': 'nieskonczonosc',
            '♥': 'milosc',
            '&': 'i',
            '|': 'lub',
            '<': 'mniejsze niz',
            '>': 'wieksze niz',
            '∑': 'suma',
            '¤': 'waluta'
        },

        'pt': {
            '∆': 'delta',
            '∞': 'infinito',
            '♥': 'amor',
            '&': 'e',
            '|': 'ou',
            '<': 'menor que',
            '>': 'maior que',
            '∑': 'soma',
            '¤': 'moeda'
        },

        'ro': {
            '∆': 'delta',
            '∞': 'infinit',
            '♥': 'dragoste',
            '&': 'si',
            '|': 'sau',
            '<': 'mai mic ca',
            '>': 'mai mare ca',
            '∑': 'suma',
            '¤': 'valuta'
        },

        'ru': {
            '∆': 'delta',
            '∞': 'beskonechno',
            '♥': 'lubov',
            '&': 'i',
            '|': 'ili',
            '<': 'menshe',
            '>': 'bolshe',
            '∑': 'summa',
            '¤': 'valjuta'
        },

        'sk': {
            '∆': 'delta',
            '∞': 'nekonecno',
            '♥': 'laska',
            '&': 'a',
            '|': 'alebo',
            '<': 'menej ako',
            '>': 'viac ako',
            '∑': 'sucet',
            '¤': 'mena'
        },

        'sr': {},

        'tr': {
            '∆': 'delta',
            '∞': 'sonsuzluk',
            '♥': 'ask',
            '&': 've',
            '|': 'veya',
            '<': 'kucuktur',
            '>': 'buyuktur',
            '∑': 'toplam',
            '¤': 'para birimi'
        },

        'uk': {
            '∆': 'delta',
            '∞': 'bezkinechnist',
            '♥': 'lubov',
            '&': 'i',
            '|': 'abo',
            '<': 'menshe',
            '>': 'bilshe',
            '∑': 'suma',
            '¤': 'valjuta'
        },

        'vn': {
            '∆': 'delta',
            '∞': 'vo cuc',
            '♥': 'yeu',
            '&': 'va',
            '|': 'hoac',
            '<': 'nho hon',
            '>': 'lon hon',
            '∑': 'tong',
            '¤': 'tien te'
        }
    };

    var uricChars = [';', '?', ':', '@', '&', '=', '+', '$', ',', '/'].join('');

    var uricNoSlashChars = [';', '?', ':', '@', '&', '=', '+', '$', ','].join('');

    var markChars = ['.', '!', '~', '*', "'", '(', ')'].join('');

    /**
     * getSlug
     * @param  {string} input input string
     * @param  {object|string} opts config object or separator string/char
     * @api    public
     * @return {string}  sluggified string
     */
    var getSlug = function getSlug(input, opts) {
        var separator = '-';
        var result = '';
        var diatricString = '';
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars = '';

        if (typeof input !== 'string') {
            return '';
        }

        if (typeof opts === 'string') {
            separator = opts;
        }

        symbol = symbolMap.en;
        langChar = langCharMap.en;

        if (typeof opts === 'object') {
            maintainCase = opts.maintainCase || false;
            customReplacements = (opts.custom && typeof opts.custom === 'object') ? opts.custom : customReplacements;
            truncate = (+opts.truncate > 1 && opts.truncate) || false;
            uricFlag = opts.uric || false;
            uricNoSlashFlag = opts.uricNoSlash || false;
            markFlag = opts.mark || false;
            convertSymbols = (opts.symbols === false || opts.lang === false) ? false : true;
            separator = opts.separator || separator;

            if (uricFlag) {
                allowedChars += uricChars;
            }

            if (uricNoSlashFlag) {
                allowedChars += uricNoSlashChars;
            }

            if (markFlag) {
                allowedChars += markChars;
            }

            symbol = (opts.lang && symbolMap[opts.lang] && convertSymbols) ?
                symbolMap[opts.lang] : (convertSymbols ? symbolMap.en : {});

            langChar = (opts.lang && langCharMap[opts.lang]) ?
                langCharMap[opts.lang] :
                opts.lang === false || opts.lang === true ? {} : langCharMap.en;

            // if titleCase config is an Array, rewrite to object format
            if (opts.titleCase && typeof opts.titleCase.length === 'number' && Array.prototype.toString.call(opts.titleCase)) {
                opts.titleCase.forEach(function (v) {
                    customReplacements[v + ''] = v + '';
                });

                titleCase = true;
            } else {
                titleCase = !!opts.titleCase;
            }

            // if custom config is an Array, rewrite to object format
            if (opts.custom && typeof opts.custom.length === 'number' && Array.prototype.toString.call(opts.custom)) {
                opts.custom.forEach(function (v) {
                    customReplacements[v + ''] = v + '';
                });
            }

            // custom replacements
            Object.keys(customReplacements).forEach(function (v) {
                var r;

                if (v.length > 1) {
                    r = new RegExp('\\b' + escapeChars(v) + '\\b', 'gi');
                } else {
                    r = new RegExp(escapeChars(v), 'gi');
                }

                input = input.replace(r, customReplacements[v]);
            });

            // add all custom replacement to allowed charlist
            for (ch in customReplacements) {
                allowedChars += ch;
            }
        }

        allowedChars += separator;

        // escape all necessary chars
        allowedChars = escapeChars(allowedChars);

        // trim whitespaces
        input = input.replace(/(^\s+|\s+$)/g, '');

        lastCharWasSymbol = false;
        lastCharWasDiatric = false;

        for (i = 0, l = input.length; i < l; i++) {
            ch = input[i];

            if (isReplacedCustomChar(ch, customReplacements)) {
                // don't convert a already converted char
                lastCharWasSymbol = false;
            } else if (langChar[ch]) {
                // process language specific diactrics chars conversion
                ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? ' ' + langChar[ch] : langChar[ch];

                lastCharWasSymbol = false;
            } else if (ch in charMap) {
                // the transliteration changes entirely when some special characters are added
                if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
                    diatricString += ch;
                    ch = '';
                } else if (lastCharWasDiatric === true) {
                    ch = diatricMap[diatricString] + charMap[ch];
                    diatricString = '';
                } else {
                    // process diactrics chars
                    ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? ' ' + charMap[ch] : charMap[ch];
                }

                lastCharWasSymbol = false;
                lastCharWasDiatric = false;
            } else if (ch in diatricMap) {
                diatricString += ch;
                ch = '';
                // end of string, put the whole meaningful word
                if (i === l - 1) {
                    ch = diatricMap[diatricString];
                }
                lastCharWasDiatric = true;
            } else if (
                // process symbol chars
                symbol[ch] && !(uricFlag && uricChars
                    .indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars
                    // .indexOf(ch) !== -1) && !(markFlag && markChars
                    .indexOf(ch) !== -1)) {
                ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
                ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : '';

                lastCharWasSymbol = true;
            } else {
                if (lastCharWasDiatric === true) {
                    ch = diatricMap[diatricString] + ch;
                    diatricString = '';
                    lastCharWasDiatric = false;
                } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
                    // process latin chars
                    ch = ' ' + ch;
                }
                lastCharWasSymbol = false;
            }

            // add allowed chars
            result += ch.replace(new RegExp('[^\\w\\s' + allowedChars + '_-]', 'g'), separator);
        }

        if (titleCase) {
            result = result.replace(/(\w)(\S*)/g, function (_, i, r) {
                var j = i.toUpperCase() + (r !== null ? r : '');
                return (Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0) ? j : j.toLowerCase();
            });
        }

        // eliminate duplicate separators
        // add separator
        // trim separators from start and end
        result = result.replace(/\s+/g, separator)
            .replace(new RegExp('\\' + separator + '+', 'g'), separator)
            .replace(new RegExp('(^\\' + separator + '+|\\' + separator + '+$)', 'g'), '');

        if (truncate && result.length > truncate) {
            lucky = result.charAt(truncate) === separator;
            result = result.slice(0, truncate);

            if (!lucky) {
                result = result.slice(0, result.lastIndexOf(separator));
            }
        }

        if (!maintainCase && !titleCase) {
            result = result.toLowerCase();
        }

        return result;
    };

    /**
     * createSlug curried(opts)(input)
     * @param   {object|string} opts config object or input string
     * @return  {Function} function getSlugWithConfig()
     **/
    var createSlug = function createSlug(opts) {

        /**
         * getSlugWithConfig
         * @param   {string} input string
         * @return  {string} slug string
         */
        return function getSlugWithConfig(input) {
            return getSlug(input, opts);
        };
    };

    /**
     * escape Chars
     * @param   {string} input string
     */
    var escapeChars = function escapeChars(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, '\\$&');
    };

    /**
     * check if the char is an already converted char from custom list
     * @param   {char} ch character to check
     * @param   {object} customReplacements custom translation map
     */
    var isReplacedCustomChar = function (ch, customReplacements) {
        for (var c in customReplacements) {
            if (customReplacements[c] === ch) {
                return true;
            }
        }
    };

    if (typeof module !== 'undefined' && module.exports) {

        // export functions for use in Node
        module.exports = getSlug;
        module.exports.createSlug = createSlug;
    } else if (typeof define !== 'undefined' && define.amd) {

        // export function for use in AMD
        define([], function () {
            return getSlug;
        });
    } else {

        // don't overwrite global if exists
        try {
            if (root.getSlug || root.createSlug) {
                throw 'speakingurl: globals exists /(getSlug|createSlug)/';
            } else {
                root.getSlug = getSlug;
                root.createSlug = createSlug;
            }
        } catch (e) {}
    }
})(this);
},{}],33:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":34,"punycode":27,"querystring":30}],34:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],35:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],36:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],37:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":36,"_process":26,"inherits":35}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = isByteLength;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString2.default)(str);
  var min = void 0;
  var max = void 0;
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }
  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}
module.exports = exports['default'];
},{"./util/assertString":41}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isEmail;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

var _merge = require('./util/merge');

var _merge2 = _interopRequireDefault(_merge);

var _isByteLength = require('./isByteLength');

var _isByteLength2 = _interopRequireDefault(_isByteLength);

var _isFQDN = require('./isFQDN');

var _isFQDN2 = _interopRequireDefault(_isFQDN);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_email_options = {
  allow_display_name: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true
};

/* eslint-disable max-len */
/* eslint-disable no-control-regex */
var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/* eslint-enable max-len */
/* eslint-enable no-control-regex */

function isEmail(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_email_options);

  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(displayName);
    if (display_email) {
      str = display_email[1];
    } else if (options.require_display_name) {
      return false;
    }
  }

  var parts = str.split('@');
  var domain = parts.pop();
  var user = parts.join('@');

  var lower_domain = domain.toLowerCase();
  if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
    user = user.replace(/\./g, '').toLowerCase();
  }

  if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 254 })) {
    return false;
  }

  if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
    return false;
  }

  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }

  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

  var user_parts = user.split('.');
  for (var i = 0; i < user_parts.length; i++) {
    if (!pattern.test(user_parts[i])) {
      return false;
    }
  }

  return true;
}
module.exports = exports['default'];
},{"./isByteLength":38,"./isFQDN":40,"./util/assertString":41,"./util/merge":42}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isFDQN;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

var _merge = require('./util/merge');

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false
};

function isFDQN(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_fqdn_options);

  /* Remove the optional trailing dot before checking validity */
  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }
  var parts = str.split('.');
  if (options.require_tld) {
    var tld = parts.pop();
    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    }
    // disallow spaces
    if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
      return false;
    }
  }
  for (var part, i = 0; i < parts.length; i++) {
    part = parts[i];
    if (options.allow_underscores) {
      part = part.replace(/_/g, '');
    }
    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    }
    // disallow full-width chars
    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }
    if (part[0] === '-' || part[part.length - 1] === '-') {
      return false;
    }
  }
  return true;
}
module.exports = exports['default'];
},{"./util/assertString":41,"./util/merge":42}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertString;
function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    throw new TypeError('This library (validator.js) validates strings only');
  }
}
module.exports = exports['default'];
},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;
function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments[1];

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }
  return obj;
}
module.exports = exports['default'];
},{}],43:[function(require,module,exports){
'use strict'

var getSlug = require('speakingurl')

// take care of slugging everything BUT the file extension
// keeping this file as minimal as possible -> used in front-end (editor)
var extReg  = /\.[0-9a-z]+$/

function slugFilename(name) {
  var fileName      = name.toLowerCase().trim()
  // It seems that some files came here without extension O_O'
  // https://github.com/goodenough/mosaico/issues/71
  // Haven't been able to reproduce but secure it
  var hasExtension  = extReg.test( fileName )
  if ( !hasExtension ) {
    console.log('[SLUGFILENAME] impossible to slug', name)
    return false
  }
  var ext           = extReg.exec(fileName)[0]
  fileName          = fileName.replace(ext, '')
  fileName          = getSlug( fileName.trim() ) + ext
  return fileName
}

module.exports = slugFilename

},{"speakingurl":31}],44:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
/* global XMLHttpRequest: false */

var url     = require('url');
var console = require("./../../bower_components/console-browserify/index.js");
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

var templateLoader = require('./template-loader.js');

require("./ko-bindings.js");
var performanceAwareCaller = require("./timed-call.js").timedCall;

var addUndoStackExtensionMaker = require("./undomanager/undomain.js");
var colorPlugin = require("./ext/color.js");
var inlinerPlugin = require("./ext/inliner.js");

var localStorageLoader = require("./ext/localstorage.js");

if (typeof ko == 'undefined') throw "Cannot find knockout.js library!";
if (typeof $ == 'undefined') throw "Cannot find jquery library!";

if (false) {

function _canonicalize(url) {
  var div = global.document.createElement('div');
  div.innerHTML = "<a></a>";
  div.firstChild.href = url; // Ensures that the href is properly escaped
  div.innerHTML = div.innerHTML; // Run the current innerHTML back through the parser
  return div.firstChild.href;
}

function _appendUrlParameters(baseUrl, parameters) {
  var paramSeparator = baseUrl.indexOf('?') == -1 ? '?' : '&';
  var res = baseUrl;
  for (var param in parameters) if (parameters.hasOwnProperty(param)) {
    res += paramSeparator + param + "=" + encodeURIComponent(parameters[param]);
    paramSeparator = '&';
  }
  return res;
}

var applyBindingOptions = function(options, ko) {

  ko.bindingHandlers.wysiwygSrc.convertedUrl = function(src, method, width, height) {
    var queryParamSeparator;
    var imgProcessorBackend = options.imgProcessorBackend ? options.imgProcessorBackend : './upload';
    var backEndMatch = imgProcessorBackend.match(/^(https?:\/\/[^\/]*\/).*$/);
    var srcMatch = src.match(/^(https?:\/\/[^\/]*\/).*$/);
    if (backEndMatch === null || (srcMatch !== null && backEndMatch[1] == srcMatch[1])) {
      queryParamSeparator = imgProcessorBackend.indexOf('?') == -1 ? '?' : '&';
      return _appendUrlParameters(imgProcessorBackend, { src: src, method: method, params: width + "," + height });
    } else {
      console.log("Cannot apply backend image resizing to non-local resources ", src, method, width, height, backEndMatch, srcMatch);
      var params = { method: method, width: width };
      if (height !== null) params['height'] = height;
      return _appendUrlParameters(src, params);
    }
  };

  ko.bindingHandlers.wysiwygSrc.placeholderUrl = function(width, height, text) {
    var imgProcessorBackend = options.imgProcessorBackend ? options.imgProcessorBackend : './upload';
    return _appendUrlParameters(imgProcessorBackend, { method: 'placeholder', params: width + "," + height });
  };

  // pushes custom tinymce configurations from options to the binding
  if (options && options.tinymceConfig)
    ko.bindingHandlers.wysiwyg.standardOptions = options.tinymceConfig;
  if (options && options.tinymceConfigFull)
    ko.bindingHandlers.wysiwyg.fullOptions = options.tinymceConfigFull;
};

}

var start = function(options, templateFile, templateMetadata, jsorjson, customExtensions) {

  templateLoader.fixPageEvents();

  var fileUploadMessagesExtension = function(vm) {
    var fileuploadConfig = {
      messages: {
        unknownError: vm.t('Unknown error'),
        uploadedBytes: vm.t('Uploaded bytes exceed file size'),
        maxNumberOfFiles: vm.t('Maximum number of files exceeded'),
        acceptFileTypes: vm.t('File type not allowed'),
        maxFileSize: vm.t('File is too large'),
        minFileSize: vm.t('File is too small'),
        post_max_size: vm.t('The uploaded file exceeds the post_max_size directive in php.ini'),
        max_file_size: vm.t('File is too big'),
        min_file_size: vm.t('File is too small'),
        accept_file_types: vm.t('Filetype not allowed'),
        max_number_of_files: vm.t('Maximum number of files exceeded'),
        max_width: vm.t('Image exceeds maximum width'),
        min_width: vm.t('Image requires a minimum width'),
        max_height: vm.t('Image exceeds maximum height'),
        min_height: vm.t('Image requires a minimum height'),
        abort: vm.t('File upload aborted'),
        image_resize: vm.t('Failed to resize image'),
        generic: vm.t('Unexpected upload error')
      }
    };
    // fileUpload options.
    if (options && options.fileuploadConfig)
      fileuploadConfig = $.extend(true, fileuploadConfig, options.fileuploadConfig);

    ko.bindingHandlers['fileupload'].extendOptions = fileuploadConfig;

  };

  var simpleTranslationPlugin = function(vm) {
    if (options && options.strings) {
      vm.t = function(key, objParam) {
        var res = options.strings[key];
        if (typeof res == 'undefined') {
          console.warn("Missing translation string for",key,": using default string");
          res = key;
        }
        return vm.tt(res, objParam);
      };
    }
  };

  // simpleTranslationPlugin must be before the undoStack to translate undo/redo labels
  var extensions = [simpleTranslationPlugin, addUndoStackExtensionMaker(performanceAwareCaller), colorPlugin, inlinerPlugin];
  if (typeof customExtensions !== 'undefined')
    for (var k = 0; k < customExtensions.length; k++) extensions.push(customExtensions[k]);
  extensions.push(fileUploadMessagesExtension);

  var galleryUrl = options.fileuploadConfig ? options.fileuploadConfig.url : '/upload/';
  applyBindingOptions(options, ko);

  // TODO what about appending to another element?
  $("<!-- ko template: 'main' --><!-- /ko -->").appendTo(global.document.body);

  // templateFile may override the template path in templateMetadata
  if (typeof templateFile == 'undefined' && typeof templateMetadata != 'undefined') {
    templateFile = templateMetadata.template;
  }
  // TODO canonicalize templateFile to absolute or relative depending on "relativeUrlsException" plugin

  templateLoader.load(performanceAwareCaller, templateFile, templateMetadata, jsorjson, extensions, galleryUrl);

};

if (false) {

var initFromLocalStorage = function(options, hash_key, customExtensions) {
  try {
    var lsData = localStorageLoader(hash_key, options.emailProcessorBackend);
    var extensions = typeof customExtensions !== 'undefined' ? customExtensions : [];
    extensions.push(lsData.extension);
    var template = _canonicalize(lsData.metadata.template);
    start(options, template, lsData.metadata, lsData.model, extensions);
  } catch (e) {
    console.error("TODO not found ", hash_key, e);
  }
};

var init = function(options, customExtensions) {

  var hash = global.location.hash ? global.location.href.split("#")[1] : undefined;

  // Loading from configured template or configured metadata
  if (options && (options.template || options.data)) {
    if (options.data) {
      var data = JSON.parse(options.data);
      start(options, undefined, data.metadata, data.content, customExtensions);
    } else {
      start(options, options.template, undefined, undefined, customExtensions);
    }
    // Loading from LocalStorage (if url hash has a 7chars key)
  } else if (hash && hash.length == 7) {
    initFromLocalStorage(options, hash, customExtensions);
    // Loading from template url as hash (if hash is not a valid localstorage key)
  } else if (hash) {
    start(options, _canonicalize(hash), undefined, undefined, customExtensions);
  } else {
    return false;
  }
  return true;
};

}

if (true) {

//////
// CUSTOM MOSAICO SPECIFIC
//////

// don't replace mosaico code for better merging

// Keep an empty function for not breaking start function
// Even if applyBindingOptions can be surcharged,
// it's better to remove this not necessary piece of code
var applyBindingOptions = $.noop

// FLOW:
// => init
// => start
// in ./template-loader.js
// => templateLoader: Ajax datas
// => templateCompiler:
//    -> Initialize viewmodel (./viewmodel.js)
//    -> Add server datas
//    -> apply plugins (server-storage, setEditorIcon + mosaico defined)

var customExt = require('./ext/custom-extensions')

var init = function(opts, customExtensions) {
  console.info('CUSTOM MOSAICO – init')
  console.log(opts)
  var hasDatas = opts && opts.metadata && opts.data
  // editor.jade script need a return value
  if (!hasDatas) return false;

  customExt.extendViewModel(opts, customExtensions)
  customExt.extendKnockout(opts)

  start(opts, void(0), opts.metadata, opts.data, customExtensions)

  return true;
}

}

module.exports = {
  isCompatible: templateLoader.isCompatible,
  init: init,
  start: start
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./ext/color.js":76,"./ext/custom-extensions":78,"./ext/inliner.js":84,"./ext/localstorage.js":85,"./ko-bindings.js":86,"./template-loader.js":87,"./timed-call.js":88,"./undomanager/undomain.js":89,"url":33}],45:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// @see also script-template.js pushTemplate
var addScriptTemplate = function(doc, templateName, templateMarkup) {
  var scriptTag = doc.createElement('script');
  scriptTag.setAttribute('type', 'text/html');
  scriptTag.setAttribute('id', templateName);
  scriptTag.text = templateMarkup;
  doc.body.appendChild(scriptTag);
  return scriptTag;
  // $('<script type="text/html"></sc' + 'ript>').text(templateMarkup).attr('id', templateName).appendTo($('body'));
};

// used for live preview in iframe.
ko.bindingHandlers.bindIframe = {
  // tpl will be overriden with the structure parsed by the input template.
  tpl: "<!DOCTYPE html>\r\n<html>\r\n<head>\r\n</head>\r\n<body><div data-bind=\"block: content\"></div></body>\r\n</html>\r\n",
  init: function(element, valueAccessor) {
    function bindIframe(local) {
      try {
        var iframe = element.contentDocument;
        iframe.open();
        iframe.write(ko.bindingHandlers.bindIframe.tpl);
        iframe.close();

        try {
          var iframedoc = iframe.body;
          if (iframedoc) {
            // scripts have to be duplicated (maybe this is not needed anymore since using string-templates)
            var templates = element.contentWindow.parent.document.getElementsByTagName('script');
            for (var i = 0; i < templates.length; i++) {
              if (templates[i].getAttribute('type') == 'text/html' && templates[i].getAttribute('id')) {
                addScriptTemplate(iframe, templates[i].getAttribute('id'), templates[i].innerHTML);
              }
            }

            var html = iframe.getElementsByTagName("HTML");

            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
              ko.cleanNode(html[0] || iframedoc);
            });

            ko.applyBindings(valueAccessor(), html[0] || iframedoc);
          } else {
            console.log("no iframedoc", local);
          }
        } catch (e) {
          console.log("error reading iframe.body", e, local);
          throw e;
        }
      } catch (e) {
        console.log("error reading iframe contentDocument", e, local);
        throw e;
        // ignored
      }
    }
    bindIframe("first call");
    // older browsers needed this
    // ko.utils.registerEventHandler(element, 'load', bindIframe);
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],46:[function(require,module,exports){
(function (global){
"use strict";
/* globals global:false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");


ko.bindingHandlers['withProperties'] = {
  init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // Make a modified binding context, with a extra properties, and apply it to descendant elements
    var childBindingContext = bindingContext.createChildContext(
      bindingContext.$rawData,
      null, // Optionally, pass a string here as an alias for the data item in descendant contexts
      function(context) {
        ko.utils.extend(context, valueAccessor());
      }
    );
    ko.applyBindingsToDescendants(childBindingContext, element);

    // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice
    return {
      controlsDescendantBindings: true
    };
  }
};
ko.virtualElements.allowedBindings['withProperties'] = true;

ko.bindingHandlers['log'] = {
  init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    console.log("log", valueAccessor());
  }
};


ko.bindingHandlers['block'] = {

  templateExists: function(id) {
    var el = global.document.getElementById(id);
    if (el) return true;
    else return false;
  },

  _chooseTemplate: function(isArray, prefix, action, fallback) {
    var id = prefix + '-' + action;
    if (ko.bindingHandlers['block'].templateExists(id)) return id;
    if (typeof fallback != 'undefined' && fallback !== null) return ko.bindingHandlers['block']._chooseTemplate(isArray, prefix, fallback);
    else {
      var fallBackId = isArray ? 'array' : 'object-' + action;
      if (ko.bindingHandlers['block'].templateExists(fallBackId)) return fallBackId;
      else throw "cannot find template for " + id + "/" + fallBackId;
    }
  },

  // compute displayMode depending on templateMode set using "withProperties" binding.
  _displayMode: function(unwrapped, bindingContext) {
    var prefix = typeof unwrapped.type != 'undefined' ? ko.utils.unwrapObservable(unwrapped.type) : 'notablock-' + typeof(unwrapped);
    var isArray = typeof unwrapped.splice !== 'undefined';
    var templateMode = bindingContext.templateMode ? bindingContext.templateMode : 'show';
    return ko.bindingHandlers['block']._chooseTemplate(isArray, prefix, templateMode, bindingContext.templateModeFallback);
  },

  _makeTemplateValueAccessor: function(valueAccessor, bindingContext) {
    return function() {
      var value = valueAccessor(),
        unwrappedValue = ko.utils.peekObservable(value); // Unwrap without setting a dependency here

      // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
      var modelValue;
      var template;

      if ((!unwrappedValue) || (typeof unwrappedValue.data != 'object' && typeof unwrappedValue.data != 'function')) {
        modelValue = value;
      } else {
        modelValue = unwrappedValue.data;
        if (typeof unwrappedValue.template != 'undefined') {
          var templateParam = ko.utils.unwrapObservable(unwrappedValue.template);
          var templateMode = bindingContext.templateMode ? bindingContext.templateMode : 'show';
          template = ko.bindingHandlers['block']._chooseTemplate(false, templateParam, templateMode, bindingContext.templateModeFallback);
        }
      }

      var unwrappedModelValue = ko.utils.unwrapObservable(modelValue);
      if (ko.isObservable(unwrappedModelValue)) console.log("doubleObservable", unwrappedModelValue);

      if (typeof template == 'undefined') {
        // NOTE IE8 used to break here, but we don't support it anymore, so maybe this is not needed.
        if (modelValue === undefined) {
          template = 'empty';
        } else {
          try {
            template = ko.bindingHandlers['block']._displayMode(unwrappedModelValue, bindingContext);
          } catch (e) {
            console.log(e, unwrappedModelValue, bindingContext['$data'], bindingContext.templateMode);
            throw e;
          }
        }
      }

      return {
        'name': template,
        'data': modelValue,
        'templateEngine': ko.nativeTemplateEngine.instance
      };
    };
  },

  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    if (typeof valueAccessor() === 'undefined') console.log("found a null block: check ending commas in arrays defs in IE");
    var newValueAccessor = ko.bindingHandlers['block']._makeTemplateValueAccessor(valueAccessor, bindingContext);
    return ko.bindingHandlers['template']['init'](element, newValueAccessor);
  },
  'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var newValueAccessor = ko.bindingHandlers['block']._makeTemplateValueAccessor(valueAccessor, bindingContext);
    return ko.bindingHandlers['template']['update'](element, newValueAccessor, allBindings, viewModel, bindingContext);
  }
};
ko.expressionRewriting.bindingRewriteValidators['block'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['block'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],47:[function(require,module,exports){
"use strict";

// script template is the one provided by KO and deals with tempaltes defined as <script type=text/html.
// string template defines them in memory and avoids polluting the HTML: seems to work better in Mosaico.

module.exports = require('./string-template.js');
// module.exports = require('./script-template.js');
},{"./string-template.js":61}],48:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

require("./../../../bower_components/evol-colorpicker/js/evol.colorpicker.min.js");

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null);


var ColorPicker = function() {
  kojqui.BindingHandler.call(this, 'colorpicker');
};
ColorPicker.prototype = kojqui.utils.createObject(kojqui.BindingHandler.prototype);
ColorPicker.prototype.constructor = ColorPicker;

ColorPicker.prototype.init = function(element, valueAccessor, allBindings) {
  var va = valueAccessor();
  var value = va.color;

  // In order to have a correct dependency tracking in "ifSubs" we have to ensure we use a single computer for each editable
  // property. Given this binding needs 2 of them, we create a computed so to "proxy" the dependencies.
  var newDO = ko.computed({
    read: value,
    write: value,
    disposeWhenNodeIsRemoved: element
  });
  var newVA = function() {
    return newDO;
  };

  ko.bindingHandlers.value.init(element, newVA, allBindings);

  var changePropagator = function(event, color) {
    if (typeof color !== 'undefined') newDO(color);
  };
  $(element).on('change.color', changePropagator);

  ko.computed({
    read: function() {
      var opt = {
        color: ko.utils.unwrapObservable(newDO),
        showOn: 'button'
      };
      for (var prop in va)
        if (prop !== 'color' && va.hasOwnProperty(prop)) opt[prop] = ko.utils.unwrapObservable(va[prop]);
      $(element).colorpicker(opt);
    },
    disposeWhenNodeIsRemoved: element
  });

  ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
    $(element).off('change.color', changePropagator);
    $(element).colorpicker('destroy');
  });

};
kojqui.utils.register(ColorPicker);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/evol-colorpicker/js/evol.colorpicker.min.js":2}],49:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

/* https://github.com/knockout/knockout/issues/1171 */
ko.bindingHandlers.cssText = {
  'update': function(node, valueAccessor, allBindings) {
    var text = ko.utils.unwrapObservable(valueAccessor());
    try {
      node.innerText = text;
    } catch (e) {
      if (!node.styleSheet) node.innerHTML = "a{}";
      node.styleSheet.cssText = text;
    }
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],50:[function(require,module,exports){
(function (global){
"use strict";

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

/* knockout droppable, with simplified UMD */
;(function(factory) {
  factory(ko, $);
})(function(ko, $) {
  var ITEMKEY = "ko_sortItem",
    INDEXKEY = "ko_sourceIndex",
    LISTKEY = "ko_sortList",
    PARENTKEY = "ko_parentList",
    DRAGKEY = "ko_dragItem",
    unwrap = ko.utils.unwrapObservable,
    dataGet = ko.utils.domData.get,
    dataSet = ko.utils.domData.set;

  ko.bindingHandlers.droppable = {
    init: function(element, valueAccessor, allBindingsAccessor, data, context) {
      var $element = $(element),
        value = ko.utils.unwrapObservable(valueAccessor()) || {},
        droppable = {},
        dropActual;

      $.extend(true, droppable, ko.bindingHandlers.droppable);
      if (value.data) {
        if (value.options && droppable.options) {
          ko.utils.extend(droppable.options, value.options);
          delete value.options;
        }
        ko.utils.extend(droppable, value);
      } else {
        droppable.data = value;
      }

      dropActual = droppable.options.drop;

      $element.droppable(ko.utils.extend(droppable.options, {
        drop: function(event, ui) {

          var el = ui.draggable[0],
            item = dataGet(el, ITEMKEY) || dataGet(el, DRAGKEY);

          if (item) {

            if (item.clone) {
              item = item.clone();
            }

            if (droppable.dragged) {
              item = droppable.dragged.call(this, item, event, ui) || item;
            }

            if (droppable.data) {
              droppable.data(item);
            }

          }

          if (dropActual) {
            dropActual.apply(this, arguments);
          }

        }
      }));

      //handle enabling/disabling
      if (droppable.isEnabled !== undefined) {
        ko.computed({
          read: function() {
            $element.droppable(ko.utils.unwrapObservable(droppable.isEnabled) ? "enable" : "disable");
          },
          disposeWhenNodeIsRemoved: element
        });
      }

    },
    update: function(element, valueAccessor, allBindingsAccessor, data, context) {

    },
    targetIndex: null,
    afterMove: null,
    beforeMove: null,
    options: {}
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],51:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

/* utility for togetherjs */
ko.bindingHandlers.focusable = {
  'focus': function() {},
  'blur': function() {},
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("focusin", ko.bindingHandlers.focusable.focus);
      $(element).off("focusout", ko.bindingHandlers.focusable.blur);
    });

    $(element).on("focusin", ko.bindingHandlers.focusable.focus);
    $(element).on("focusout", ko.bindingHandlers.focusable.blur);

  }
};

ko.bindingHandlers.scrollable = {
  'scroll': function() {},
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("scroll", ko.bindingHandlers.scrollable.scroll);
    });

    $(element).on("scroll", ko.bindingHandlers.scrollable.scroll);

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],52:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

ko.extenders.paging = function(target, pageSize) {
  var _pageSize = ko.observable(pageSize || 10),
    // default pageSize to 10
    _currentPage = ko.observable(1); // default current page to 1
  target.pageSize = ko.computed({
    read: _pageSize,
    write: function(newValue) {
      if (newValue > 0) {
        _pageSize(newValue);
      } else {
        _pageSize(10);
      }
    }
  });

  target.currentPage = ko.computed({
    read: _currentPage,
    write: function(newValue) {
      if (newValue > target.pageCount()) {
        _currentPage(target.pageCount());
      } else if (newValue <= 0) {
        _currentPage(1);
      } else {
        _currentPage(newValue);
      }
    }
  });

  target.pageCount = ko.computed(function() {
    return Math.ceil(target().length / target.pageSize()) || 1;
  });

  target.currentPageData = ko.computed(function() {
    var pageSize = _pageSize(),
      pageIndex = _currentPage(),
      startIndex = pageSize * (pageIndex - 1),
      endIndex = pageSize * pageIndex;

    return target().slice(startIndex, endIndex);
  });

  target.moveFirst = function() {
    target.currentPage(1);
  };
  target.movePrevious = function() {
    target.currentPage(target.currentPage() - 1);
  };
  target.moveNext = function() {
    target.currentPage(target.currentPage() + 1);
  };
  target.moveLast = function() {
    target.currentPage(target.pageCount());
  };

  return target;
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],53:[function(require,module,exports){
(function (global){
"use strict";
/* globals global: true */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var sortable = (typeof window !== "undefined" ? window['jQuery']['ui']['sortable'] : typeof global !== "undefined" ? global['jQuery']['ui']['sortable'] : null);
var draggable = (typeof window !== "undefined" ? window['jQuery']['ui']['draggable'] : typeof global !== "undefined" ? global['jQuery']['ui']['draggable'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
require("./../../../bower_components/knockout-sortable/build/knockout-sortable.min.js");

if (typeof sortable == 'undefined') throw "Cannot find jquery-ui sortable widget dependency!";
if (typeof draggable == 'undefined') throw "Cannot find jquery-ui sortable widget dependency!";

var isDraggingHelper = function(writable, e) {
  if (writable()) {
    if (e.type == writable() + 'stop') writable(false);
  } else {
    if (e.type == 'dragstart' || e.type == 'sortstart') writable(e.type.substring(0, 4));
  }
};

var makeExtendedValueAccessor = function(valueAccessor) {
  return function() {
    var modelValue = valueAccessor(),
      unwrappedValue = ko.utils.peekObservable(modelValue); // Unwrap without setting a dependency here

    ko.utils.unwrapObservable(modelValue);

    if (modelValue.options == 'undefined') {
      modelValue.options = {};
    }

    var origStart = modelValue.options.start;
    modelValue.options.start = function(e, ui) {
      if (typeof modelValue.dragging != 'undefined' && ko.isWritableObservable(modelValue.dragging)) isDraggingHelper(modelValue.dragging, e);
      if (typeof modelValue.dropContainer != 'undefined') {
        modelValue.scrollInterval = global.setInterval(function() {
          var foo = $(modelValue.dropContainer).scrollTop();
          $(modelValue.dropContainer).scrollTop(foo + modelValue.adding);
        }, 20);
      }
      if (typeof origStart != 'undefined') return origStart(e, ui);
    };
    var origStop = modelValue.options.stop;
    modelValue.options.stop = function(e, ui) {
      if (typeof modelValue.dragging != 'undefined' && ko.isWritableObservable(modelValue.dragging)) isDraggingHelper(modelValue.dragging, e);
      if (typeof modelValue.dropContainer != 'undefined') {
        global.clearInterval(modelValue.scrollInterval);
      }
      if (typeof origStop != 'undefined') return origStop(e, ui);
    };
    var origDrag = modelValue.options.drag;
    modelValue.options.drag = function(e, ui) {
      if (typeof modelValue.dropContainer != 'undefined') {
        var top = e.pageY - $(modelValue.dropContainer).offset().top;
        var bottom = top - $(modelValue.dropContainer).height();
        // Handle scrolling speed depending on distance from border.
        if (top < -20) {
          modelValue.adding = -20;
          // console.log("<<<");
        } else if (top < 0) {
          modelValue.adding = -10;
          // console.log("<<");
        } else if (top < 10) {
          modelValue.adding = -5;
          // console.log("<");
        } else if (bottom > 20) {
          modelValue.adding = 20;
          // console.log(">>>");
        } else if (bottom > 0) {
          modelValue.adding = 10;
          // console.log(">>");
        } else if (bottom > -10) {
          modelValue.adding = 5;
          // console.log(">");
        } else {
          modelValue.adding = 0;
        }
      }
      if (typeof origDrag != 'undefined') return origDrag(e, ui);
    };

    return modelValue;
  };
};

ko.bindingHandlers.extsortable = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.sortable.init(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.sortable.update(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  }
};

ko.bindingHandlers.extdraggable = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.draggable.init(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.draggable.update(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/knockout-sortable/build/knockout-sortable.min.js":8}],54:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false, Image: false */

// This module depends on those files, but it doesn't have a direct dependency, so we don't require them here.

//require("blueimp-canvas-to-blob");
//require("jquery-file-upload/js/jquery.iframe-transport.js");
//require("jquery-file-upload/js/jquery.fileupload.js");
//require("jquery-file-upload/js/jquery.fileupload-process.js");
//require("jquery-file-upload/js/jquery.fileupload-image.js");
//require("jquery-file-upload/js/jquery.fileupload-validate.js");

var $       = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko      = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// experimental image preloading.
ko.bindingHandlers['preloader'] = {
  init: function(element, valueAccessor) {
    var value = valueAccessor();
    if (typeof value.preloaded == 'undefined') {
      value.preloaded = ko.observable("");

      var preloader = function(newValue) {
        if (newValue != value.preloaded()) {
          if (newValue !== '') {
            var img = new Image();
            img.onload = function() {
              value.preloaded(newValue);
            };
            img.onerror = function() {
              value.preloaded(newValue);
            };
            img.src = newValue;
          } else {
            value.preloaded(newValue);
          }
        }
      };

      value.subscribe(preloader);
      preloader(value());
    }
  }
};

if (false) {

// TODO we don't use advattr and advstyle, maybe we should simply remove this code.
ko.bindingHandlers['advattr'] = {
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(attrName, attrValueAccessor) {
      var attrValue = element.getAttribute(attrName);

      if (ko.isWriteableObservable(attrValueAccessor)) {
        var oldValue = attrValueAccessor();
        if (oldValue != attrValue) {
          attrValueAccessor(attrValue);
          if (oldValue !== null) {
            console.log("AdvAttr found a value different from the default", attrName, oldValue, attrValue);
          }
        }
      }
    });
  },
  'update': function(element, valueAccessor, allBindings) {
    var value = ko.utils.unwrapObservable(valueAccessor()) || {};
    ko.utils.objectForEach(value, function(attrName, attrValue) {
      attrValue = ko.utils.unwrapObservable(attrValue);
      // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
      // when someProp is a "no value"-like value (strictly null, false, or undefined)
      // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
      var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
      if (toRemove) element.removeAttribute(attrName);
      else element.setAttribute(attrName, attrValue.toString());
    });
  }
};
ko.bindingHandlers['advstyle'] = {
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(styleName, styleValueAccessor) {
      var styleValue;
      if (styleName.match(/Px$/)) {
        styleName = styleName.substr(0, styleName.length - 2);
        styleValue = element.style[styleName];
        if (styleValue.match(/px$/)) {
          styleValue = styleValue.replace(/px$/, '');
        } else {
          console.log("AdvStyle binding found an unexpected default value", styleName, styleValue, element);
        }
      } else {
        styleValue = element.style[styleName];
      }

      if (ko.isWriteableObservable(styleValueAccessor)) {
        var oldValue = styleValueAccessor();
        if (oldValue != styleValue) {
          styleValueAccessor(styleValue);
          if (oldValue !== null) {
            console.log("AdvStyle found a value different from the default", styleName, oldValue, styleValue);
          }
        }
      }
    });
  },
  'update': function(element, valueAccessor) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(styleName, styleValue) {
      styleValue = ko.utils.unwrapObservable(styleValue);

      if (styleValue === null || typeof styleValue === 'undefined' || styleValue === false) {
        styleValue = "";
      }

      if (styleName.match(/Px$/)) {
        styleName = styleName.substr(0, styleName.length - 2);
        styleValue = styleValue + "px";
      }

      element.style[styleName] = styleValue;
    });
  }
};

}

// Utility to log inizialization and disposal of DOM elements.
ko.bindingHandlers['domlog'] = {
  init: function(element, valueAccessor) {
    console.log("initialized", element);
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      console.log("disposed", element);
    });
  }
};

ko.bindingHandlers['fudroppable'] = {
  init: function(element, valueAccessor) {
    var opt = valueAccessor() || {};
    var timeoutsObj = {};

    var over = function(timeouts, dropZoneTimeout, element, className, observable, event) {

      if (!timeouts[dropZoneTimeout]) {
        if (typeof className !== 'undefined') {
          element.classList.add(className);
        }
        if (ko.isWriteableObservable(observable) && !observable()) {
          observable(true);
        }
      } else {
        global.clearTimeout(timeouts[dropZoneTimeout]);
      }

      var stop = function() {
        timeouts[dropZoneTimeout] = null;
        if (typeof className !== 'undefined') {
          element.classList.remove(className);
        }
        if (ko.isWriteableObservable(observable) && observable()) {
          observable(false);
        }
      };

      if (event.type == 'dragleave') stop();
      else {
        // Using 100 it doens't work fine on Linux (chome/firefox), using 200 still shows issues on slow Linux boxes
        timeouts[dropZoneTimeout] = global.setTimeout(stop, 500);
      }

    };

    if (opt.active || opt.activeClass) {
      ko.utils.registerEventHandler(global, 'dragover', over.bind(undefined, timeoutsObj, 'activeTimeout', element, opt.activeClass, opt.active));
    }
    if (opt.hoverClass) {
      // dragenter and dragleave are not required but they speedup feedback when used.
      ko.utils.registerEventHandler(element, 'dragover dragenter dragleave', over.bind(undefined, timeoutsObj, 'hoverTimeout', element, opt.hoverClass, undefined));
    }
  }
};

ko.bindingHandlers['fileupload'] = {
  extendOptions: {},
  // remoteFilePreprocessor method has been set in app.js
  init: function(element, valueAccessor) {
    // TODO domnodedisposal doesn't work when the upload is done by "clicking"
    // Probably jquery-fileupload moves the DOM somewhere else so that KO doesn't
    // detect the removal anymore.
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).fileupload('destroy');
    });

    // if we leave the title the native control will show us a tooltip we don't want.
    // In WebKit the right way to remove it is leaving a "whitespace".
    // In Gecko we have to set it empty.
    if (global.webkitURL)
      $(element).attr('title', ' ');
    else
      $(element).attr('title', '');
  },

  update: function(element, valueAccessor) {
    var options = valueAccessor() || {};

    var $fu = $(element);
    var $parent = $fu.parents('.uploadzone');

    var dataValue = options.data;
    options.data = undefined;

    var canvasPreview = options.canvasPreview;

    // TODO remove hardcoded url
    ko.utils.extend(options, {
      url: '/upload/',
      dataType: 'json',
      dropZone: $parent.find('.mo-uploadzone')[0],
      autoUpload: true,
      acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
      maxFileSize: 1024 * 1024,
      // Enable image resizing, except for Android and Opera,
      // which actually support image resizing, but fail to
      // send Blob objects via XHR requests:
      disableImageResize: /Android(?!.*Chrome)|Opera/.test(global.navigator.userAgent),
      previewMaxWidth: 200,
      previewMaxHeight: 200,
      previewCrop: false,
      replaceFileInput: false, // replaceFileInput true breaks after uploading using "input" (using mouse clic instead of dropping)

      messages: {
        // client side
        unknownError: 'Unknown error',
        uploadedBytes: 'Uploaded bytes exceed file size',
        maxNumberOfFiles: 'Maximum number of files exceeded',
        acceptFileTypes: 'File type not allowed',
        maxFileSize: 'File is too large',
        minFileSize: 'File is too small',
        // server side
        post_max_size: 'The uploaded file exceeds the post_max_size directive in php.ini',
        max_file_size: 'File is too big',
        min_file_size: 'File is too small',
        accept_file_types: 'Filetype not allowed',
        max_number_of_files: 'Maximum number of files exceeded',
        max_width: 'Image exceeds maximum width',
        min_width: 'Image requires a minimum width',
        max_height: 'Image exceeds maximum height',
        min_height: 'Image requires a minimum height',
        abort: 'File upload aborted',
        image_resize: 'Failed to resize image',
        generic: 'Unexpected upload error'
      }
    });

    // extendOptions is setted in app.js#start
    ko.utils.extend(options, ko.bindingHandlers['fileupload'].extendOptions);

    var working = 0;
    var firstWorked = '';

    var cleanup = function() {
      if (--working === 0) {
        if (dataValue) {
          dataValue(firstWorked);
        }
        firstWorked = '';
        if (canvasPreview) {
          $parent.find('img').show();
          $parent.find('canvas').remove();
        }
        $parent.removeClass("uploading");
        $parent.find('.progress-bar').css('width', 0);
      }
    };

    var translatedMessage = function(text) {
      if (typeof options.messages == 'object' && options.messages !== null) {
        var match = text.match(/^([^ ]+)(.*)$/);
        if (match) {
          if (typeof options.messages[match[1]] !== 'undefined') {
            return options.messages[match[1]] + match[2];
          }
        }
      }
      return text;
    };

    // 
    if (options.uploadToTemplate) {
      options.url = ko.bindingHandlers['fileupload'].extendOptions.url.template;
    } else {
      options.url = ko.bindingHandlers['fileupload'].extendOptions.url.mailing;
    }

    $fu.fileupload(options);

    var events = ['fileuploadadd', 'fileuploadprocessalways', 'fileuploadprogressall', 'fileuploaddone', 'fileuploadfail'];
    var eventHandler = function(e, data) {
      if (e.type == 'fileuploadadd') {
        working++;
      }
      if (e.type == 'fileuploadfail') {
        console.log("fileuploadfail", e, data);
        if (options.onerror) {
          if (data.errorThrown === '' && data.textStatus == 'error') {
            options.onerror(translatedMessage('generic'));
          } else {
            options.onerror(translatedMessage('generic (' + data.errorThrown + ')'));
          }
        }
        cleanup();
      }
      if (e.type == 'fileuploaddone') {
        if (typeof data.result.files[0].url !== 'undefined') {
          if (options.onfile) {
            for (var i = 0; i < data.result.files.length; i++) {
              data.result.files[i] = ko.bindingHandlers['fileupload'].remoteFilePreprocessor(data.result.files[i]);
              options.onfile(data.result.files[i]);
            }
          }

          if (firstWorked === '') firstWorked = data.result.files[0].url;

          if (canvasPreview) {
            var img = new Image();
            img.onload = cleanup;
            img.onerror = cleanup;
            img.src = data.result.files[0].url;
          } else {
            cleanup();
          }
        } else if (typeof data.result.files[0].error !== 'undefined') {
          console.log("remote error", e, data);
          if (options.onerror) {
            options.onerror(translatedMessage(data.result.files[0].error));
          }
          cleanup();
        } else {
          console.log("unexpected error", e, data);
          if (options.onerror) {
            options.onerror(translatedMessage('generic (Unexpected Error retrieving uploaded file)'));
          }
          cleanup();
        }
      }
      if (e.type == 'fileuploadprocessalways') {
        var index = data.index,
          file = data.files[index];
        if (file.preview && index === 0) {
          // if we have a canvas we had multiple uploaded files
          if ($parent.find('canvas').length === 0) {
            if (canvasPreview) {
              var el = $(file.preview).css('width', '100%'); // .css('position', 'absolute').css('left', '0');
              $parent.find('img').hide();
              $parent.prepend(el);
            }
            $parent.addClass("uploading");
            $parent.find('.progress-bar').css('width', 0);
          }
        }
        if (file.error) {
          // File type not allowed
          // File is too large
          if (options.onerror) {
            options.onerror(translatedMessage(file.error));
          }
          cleanup();
        }
      }
      if (e.type == 'fileuploadprogressall') {
        var progress = parseInt(data.loaded / data.total * 100, 10);
        $parent.find('.progress-bar').css('width', progress + '%');
      }
    };
    for (var i = events.length - 1; i >= 0; i--) {
      var eventName = events[i];
      $fu.on(eventName, eventHandler);
    }
    if (!$.support.fileInput) {
      $fu.prop('disabled', true).parent().addClass('disabled');
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],55:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

ko.bindingHandlers['ifSubs'] = {
  // cloneNodes from ko.utils.cloneNodes (missing in minimized KO)
  cloneNodes: function(nodesArray, shouldCleanNodes) {
    for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
      var clonedNode = nodesArray[i].cloneNode(true);
      newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
    }
    return newNodesArray;
  },
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var didDisplayOnLastUpdate,
      savedNodes,
      valueAcc = valueAccessor();
    if (typeof valueAcc.data.subsCount === 'undefined') {
      ko.extenders['subscriptionsCount'](valueAcc.data);
      // NOTE I can't simply listen on "thresholds" because multiple bindings to the same observable could use different thresholds.
    }
    ko.computed(function() {
      var dataValue = ko.utils.unwrapObservable(valueAccessor().data.subsCount),
        isFirstRender = !savedNodes,
        shouldDisplay, needsRefresh, gutter;

      gutter = -(typeof valueAccessor().gutter !== 'undefined' ? valueAccessor().gutter : 1);
      shouldDisplay = dataValue + (didDisplayOnLastUpdate ? gutter : 0) >= ko.utils.unwrapObservable(valueAcc.threshold);
      if (typeof valueAccessor().not !== 'undefined' && valueAccessor().not) {
        shouldDisplay = !shouldDisplay;
      }
      needsRefresh = isFirstRender || (shouldDisplay !== didDisplayOnLastUpdate);

      if (needsRefresh) {
        // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
        if (isFirstRender && ko.computedContext.getDependenciesCount()) {
          savedNodes = ko.bindingHandlers['ifSubs'].cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */ );
        }

        if (shouldDisplay) {
          if (!isFirstRender) {
            ko.virtualElements.setDomNodeChildren(element, ko.bindingHandlers['ifSubs'].cloneNodes(savedNodes));
          }
          ko.applyBindingsToDescendants(bindingContext, element);
        } else {
          ko.virtualElements.emptyNode(element);
        }

        didDisplayOnLastUpdate = shouldDisplay;
      }
    }, null, {
      disposeWhenNodeIsRemoved: element
    });
    return {
      'controlsDescendantBindings': true
    };
  }
};
ko.virtualElements.allowedBindings['ifSubs'] = true;

// ko.isWritableObservable (without "e") has been introduced in 3.2.0, that is also our min requirement.
// minimized knockout "obfuscate" the beforeSubscriptionAdd and afterSubscriptionRemove methods that we hack here.
// so we have to explicitly know that.
// Note: we used to use ko.DEBUG to detect the debug version of KO, but this was removed in KO 3.4.0+, 
//       so we switched to ko.subscription function that only exists in DEBUG versions.
var beforeSubscriptionProp;
var afterSubscriptionProp;
if (typeof ko.subscription == 'function' && typeof ko.isWritableObservable !== 'undefined') {
  beforeSubscriptionProp = 'beforeSubscriptionAdd';
  afterSubscriptionProp = 'afterSubscriptionRemove';
} else if (ko.version == "3.2.0") {
  beforeSubscriptionProp = 'va';
  afterSubscriptionProp = 'nb';
} else if (ko.version == "3.3.0") {
  beforeSubscriptionProp = 'ja';
  afterSubscriptionProp = 'ua';
} else if (ko.version == "3.4.0") {
  beforeSubscriptionProp = 'sa';
  afterSubscriptionProp = 'Ia';
} else if (ko.version == "3.4.1") {
  beforeSubscriptionProp = 'sa';
  afterSubscriptionProp = 'Ia';
}
else throw "Unsupported minimized Knockout version " + ko.version + " (supported DEBUG or minimized 3.2.0 ... 3.4.1)";

// internally used by ifsubs binding.
// WARNING this break when used with pureComputed or deferredEvaluated
ko.extenders['subscriptionsCount'] = function(target, l1, l2) {
  if (typeof target.subsCount === 'undefined') {
    target.subsCount = ko.observable(target.getSubscriptionsCount()).extend({
      notify: 'always'
    });
    var underlyingBeforeSubscriptionAddFunction = target[beforeSubscriptionProp];
    var underlyingAfterSubscriptionRemoveFunction = target[afterSubscriptionProp];
    target[beforeSubscriptionProp] = function(event) {
      if (underlyingBeforeSubscriptionAddFunction) underlyingBeforeSubscriptionAddFunction.call(target, event);
      var c = target.getSubscriptionsCount() + 1;
      if (typeof l1 === 'undefined' || c == l1 || typeof l2 === 'undefined' || c == l2) target.subsCount(c);
    };
    target[afterSubscriptionProp] = function(event) {
      if (underlyingAfterSubscriptionRemoveFunction) underlyingAfterSubscriptionRemoveFunction.call(target, event);
      var c = target.getSubscriptionsCount();
      if (typeof l1 === 'undefined' || c == l1 || typeof l2 === 'undefined' || c == l2) target.subsCount(c);
    };
  } else {
    console.log("already applied subscriptionCount to observable");
  }
  return null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],56:[function(require,module,exports){
(function (global){
"use strict";

// Overrides native jQuery spinner to avoid validation of the "step".
// We wants to use the step but also wants to leave the user the ability to select specific values.

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var spinner = (typeof window !== "undefined" ? window['jQuery']['ui']['spinner'] : typeof global !== "undefined" ? global['jQuery']['ui']['spinner'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

if (typeof spinner == 'undefined') throw "Cannot find jquery-ui spinner widget dependency!";

$.widget("ui.spinner", spinner, {
  _adjustValue: function(value) {
    var adj = this._super(value);

    var options = this.options;

    // fix precision from bad JS floating point math
    value = parseFloat(value.toFixed(this._precision()));

    // clamp the value
    if (options.max !== null && value > options.max) {
      return options.max;
    }
    if (options.min !== null && value < options.min) {
      return options.min;
    }

    return value;
  }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],57:[function(require,module,exports){
(function (global){
"use strict";

// Overrides native jQuery tabs to make tabs working also when using a base tag
// in order to avoid conflicts you have to add a data-local="true" attribute to your tab links.

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var tabs = (typeof window !== "undefined" ? window['jQuery']['ui']['tabs'] : typeof global !== "undefined" ? global['jQuery']['ui']['tabs'] : null);

if (typeof tabs == 'undefined') throw "Cannot find jquery-ui tabs widget dependency!";

$.widget("ui.tabs", tabs, {
  _isLocal: function( anchor ) {
    if (anchor.getAttribute('data-local') == "true") return true;
    else return this._superApply( arguments );
  }
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],58:[function(require,module,exports){
(function (global){
"use strict";
/* globals global: false */

function pushTemplate(templateName, templateText) {
  var scriptTag = global.document.createElement('script');
  scriptTag.setAttribute('type', 'text/html');
  scriptTag.setAttribute('id', templateName);
  scriptTag.text = templateText;
  global.document.body.appendChild(scriptTag);
}

function removeTemplate(templateName) {
  var el = global.document.getElementById(templateName);
  if (el) el.parentNode.removeChild(el);
}

function init() {}

function getTemplateContent(id) {
  var el = global.document.getElementById(id);
  if (el) return el.innerHTML;
  else return undefined;
}

module.exports = {
  init: init,
  addTemplate: pushTemplate,
  removeTemplate: removeTemplate,
  getTemplateContent: getTemplateContent
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var tinymce = (typeof window !== "undefined" ? window['tinymce'] : typeof global !== "undefined" ? global['tinymce'] : null);

var timeout;

var render = function() {

  timeout = undefined;

  if (typeof tinymce.activeEditor !== 'undefined' && tinymce.activeEditor !== null &&
      typeof tinymce.activeEditor.theme !== 'undefined' && tinymce.activeEditor.theme !== null &&
      typeof tinymce.activeEditor.theme.panel !== 'undefined' && tinymce.activeEditor.theme.panel !== null &&
      typeof tinymce.activeEditor.theme.panel.visible !== 'undefined') {
    // @see FloatPanel.js function repositionPanel(panel)
    // First condition group is for Tinymce 4.0/4.1
    // Second condition group is for Tinymce 4.2/4.3 where "._property" are now available as ".state.get('property')".
    if ((typeof tinymce.activeEditor.theme.panel._visible !== 'undefined' && tinymce.activeEditor.theme.panel._visible && tinymce.activeEditor.theme.panel._fixed) ||
        (typeof tinymce.activeEditor.theme.panel.state !== 'undefined' && tinymce.activeEditor.theme.panel.state.get('visible') && tinymce.activeEditor.theme.panel.state.get('fixed'))) {
      tinymce.activeEditor.theme.panel.fixed(false);
    }

    tinymce.activeEditor.nodeChanged();
    // Don't force tinymce to be visible on scrolls
    // If setted, This will show the tinymce controls event when none are selected
    // tinymce.activeEditor.theme.panel.visible(true);
    if (tinymce.activeEditor.theme.panel.layoutRect().y <= 40)
      tinymce.activeEditor.theme.panel.moveBy(0, 40 - tinymce.activeEditor.theme.panel.layoutRect().y);

  }
};

ko.bindingHandlers.wysiwygScrollfix = {
  'scroll': function(event) {
    if (timeout) global.clearTimeout(timeout);
    timeout = global.setTimeout(render, 50);
  },
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("scroll", ko.bindingHandlers.wysiwygScrollfix.scroll);
    });

    $(element).on("scroll", ko.bindingHandlers.wysiwygScrollfix.scroll);

  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],60:[function(require,module,exports){
(function (global){
"use strict";

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

var _scrollIntoView = function($element, alignTop, scrollParent, moveBy) {
  var currentScrollTop = scrollParent.scrollTop();
  var newScrollTop = currentScrollTop - moveBy - (alignTop ? 20 : -20);
  // iframe scrolls the window and animation is not supported
  var animate = typeof scrollParent[0].nodeType !== 'undefined';
  if (animate) {
    var action = {
      'scrollTop': "" + Math.round(newScrollTop) + "px"
    };
    var time = Math.round(Math.abs(newScrollTop - currentScrollTop));
    scrollParent.stop().animate(action, time);
  } else {
    scrollParent.scrollTop(newScrollTop);
  }
  // native scrollIntoView is not well supported and doesn't work fine.
  // element.scrollIntoView(alignTop);
};

ko.bindingHandlers.scrollIntoView = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var selected = ko.utils.unwrapObservable(valueAccessor());
    if (!selected) return;
    try {

      while (element.nodeType === 8) {
        // element is a comment, move to the next sibling...
        element = element.nextSibling;
      }
      if (element.nodeType !== 8) {
        var scrollParent = $(element).scrollParent();

        var parentTop;
        var relativeOffset = false;
        if (scrollParent[0].nodeType == 9) {
          // scrollparent is document, replacing with body...
          scrollParent = $(scrollParent[0].defaultView);
          parentTop = 0;
          relativeOffset = true;
        } else {
          parentTop = scrollParent.offset().top;
        }

        var parentHeight = scrollParent.height();
        var parentScroll = scrollParent.scrollTop();
        var parentBottom = parentTop + parentHeight;

        // scrollParent is the document.
        var $element = $(element);
        var elTop = $element.offset().top;
        // when we are in "iframe" with scrollbar everythijng changes.
        if (relativeOffset) elTop = elTop - parentScroll;
        var elHeight = $element.height();
        var elBottom = elTop + elHeight;
        if (elTop > parentTop && elTop + elHeight < parentBottom) {
          // both borders are visible => don't do anything.
        } else if (elHeight < parentHeight) {
          // if the block is smaller than the viewPort
          if (elTop < parentTop) _scrollIntoView(element, true, scrollParent, parentTop - elTop);
          // -> if the upper border is higher than the top, then I move it to the top.
          if (elBottom > parentBottom) _scrollIntoView(element, false, scrollParent, parentBottom - elBottom);
          // -> if the bottom border is lower than the bottom then I move it to the bottom.
        } else {
          // if the block is larger than the viewPort we do the opposite!
          // -> if the upper border is higher than the top and the lower is higher than the bottom I move the lower it to the bottom.
          if (elTop < parentTop && elBottom < parentBottom) _scrollIntoView(element, false, scrollParent, parentBottom - elBottom);
          // -> if the bottom border il lower than bottom and the upper is lower than the top I move the upper border to the viewport top
          if (elTop > parentTop && elBottom > parentBottom) _scrollIntoView(element, true, scrollParent, parentTop - elTop);
        }

        // element.scrollIntoView(true);
      }
    } catch (e) {
      console.log("TODO exception scrolling into view", e);
    }
  }
};
ko.virtualElements.allowedBindings['scrollIntoView'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],61:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var origTemplateSystem = require("./script-template.js");

var templates = {};

//define a template source that simply treats the template name as its content
ko.templateSources.stringTemplate = function(templateName, template) {
  this.templateName = templateName;
  this.template = template;
  this._data = {};
};

ko.utils.extend(ko.templateSources.stringTemplate.prototype, {
  data: function(key, value) {
    // console.log("data", key, value, this.templateName);
    if (arguments.length === 1) {
      return this._data[key];
    }

    this._data[key] = value;
  },
  text: function(value) {
    // console.log("text", value, this.templateName)
    if (arguments.length === 0) {
      return this.template;
    }
    this.template = value;
  }
});


//modify an existing templateEngine to work with string templates
function createStringTemplateEngine(templateEngine) {
  var orig = templateEngine.makeTemplateSource;
  templateEngine.makeTemplateSource = function(templateName) {
    if (typeof templates[templateName] !== 'undefined') {
      return new ko.templateSources.stringTemplate(templateName, templates[templateName]);
    } else {
      return orig(templateName);
    }
  };
  return templateEngine;
}

function pushTemplate(templateName, templateText) {
  templates[templateName] = templateText;
}

function removeTemplate(templateName) {
  if (typeof templates[templateName] !== 'undefined') {
    templates[templateName] = undefined;
  } else {
    origTemplateSystem.removeTemplate(templateName);
  }
}

function init() {
  ko.setTemplateEngine(createStringTemplateEngine(new ko.nativeTemplateEngine()));
}

function getTemplateContent(id) {
  if (typeof templates[id] !== 'undefined') {
    return templates[id];
  } else {
    return origTemplateSystem.getTemplateContent(id);
  }
}

module.exports = {
  init: init,
  addTemplate: pushTemplate,
  removeTemplate: removeTemplate,
  getTemplateContent: getTemplateContent
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./script-template.js":58}],62:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

var extendValueAccessor = function(valueAccessor, obj) {
  return function() {
    ko.utils.extend(obj, valueAccessor());
    return obj;
  };
};

var options = {
  show: {
    delay: 500
  },
  track: true,
  items: '[title][title!=""][title!=" "]'
};

ko.bindingHandlers.tooltips = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    if (typeof $.fn.tooltip !== 'undefined' && typeof ko.bindingHandlers.tooltip !== 'undefined') {
      // position: { my: "left+15 top+15", at: "center+30 center+30" }
      // NOTE title with "" and " " is needed to avoid default tooltips in native file upload controls
      return ko.bindingHandlers.tooltip.init(element, extendValueAccessor(valueAccessor, options), allBindingsAccessor, data, context);
    }
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    if (typeof $.fn.tooltip !== 'undefined' && typeof ko.bindingHandlers.tooltip !== 'undefined') {
      return ko.bindingHandlers.tooltip.update(element, extendValueAccessor(valueAccessor, options), allBindingsAccessor, data, context);
    }
  },
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],63:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// equals to "value" binding but apply "invalid" class if "pattern" attribute is defined and value matches the rule
ko.bindingHandlers['validatedValue'] = {
	init: function(element, valueAccessor, allBindings) {
		var newValueAccessor = valueAccessor;
		if (typeof element.pattern !== 'undefined') {
			var re = new RegExp('^(?:' + element.pattern + ')$');
			var computed = ko.computed({
				read: function() {
					var res = ko.utils.unwrapObservable(valueAccessor());
					// TODO support for element.required ?
					var valid = res === null || res === '' || re.test(res);
					// IE11 doesn't support classList.toggle('invalid', state)
					if (valid) {
						element.classList.remove('invalid');
					} else {
						element.classList.add('invalid');
					}
					return res;
				},
				write: ko.isWriteableObservable(valueAccessor()) && function(value) {
					// @see https://github.com/voidlabs/mosaico/issues/103
					ko.selectExtensions.writeValue(element, value);
					var updValue = ko.selectExtensions.readValue(element);
					valueAccessor()(updValue);
				},
				disposeWhenNodeIsRemoved: element
			});
			newValueAccessor = function() {
				return computed;
			};
		}
		ko.bindingHandlers['value'].init(element, newValueAccessor, allBindings);
	}
};
ko.expressionRewriting._twoWayBindings['validatedValue'] = true;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],64:[function(require,module,exports){
(function (global){
"use strict";
/* globals global:false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

ko.bindingHandlers['uniqueId'] = {
  currentIndex: 0,
  'init': function(element, valueAccessor) {
    var data = ko.utils.unwrapObservable(valueAccessor()) || {};
    if (data.id() === '') {
      var id, el, prefix;
      // TODO we need a better prefix
      prefix = 'ko_' + (typeof data.type !== 'undefined' ? ko.utils.unwrapObservable(data.type) : 'block');
      // when loading an exising model, IDs could be already assigned.
      do {
        id = prefix + '_' + (++ko.bindingHandlers['uniqueId'].currentIndex);
        el = global.document.getElementById(id);
        if (el) {
          // when loading an existing model my "currentIndex" is empty.
          // but we have existing blocks, so I must be sure I don't reuse their IDs.
          // We use different prefixes (per block type) so that a hidden block 
          // (for which we have no id in the page, e.g: preheader in versafix-1)
          // will break everthing once we reuse its name.
        }
      } while (el);
      data.id(id);
    }
  }
};
ko.virtualElements.allowedBindings['uniqueId'] = true;

ko.bindingHandlers['virtualAttr'] = {
  update: function(element, valueAccessor) {
    if (element.nodeType !== 8) {
      ko.bindingHandlers['attr'].update(element, valueAccessor);
    }
  }
};
ko.virtualElements.allowedBindings['virtualAttr'] = true;

ko.bindingHandlers['virtualAttrStyle'] = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      // In "preview" we also set "replacedstyle" so to have an attribute to be used by IE (IE breaks the STYLE) to do the export.
      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      var attrs = ["style"];
      if (isNotWysiwygMode) attrs.push("replacedstyle");
      var attrValue = ko.utils.unwrapObservable(valueAccessor());
      for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i];
        var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
        if (toRemove)
          element.removeAttribute(attrName);
        else
          element.setAttribute(attrName, attrValue.toString());
      }
    }
  }
};
ko.virtualElements.allowedBindings['virtualAttrStyle'] = true;

ko.bindingHandlers['virtualStyle'] = {
  update: function(element, valueAccessor) {
    if (element.nodeType !== 8) {
      ko.bindingHandlers['style'].update(element, valueAccessor);
    }
  }
};
ko.virtualElements.allowedBindings['virtualStyle'] = true;


ko.bindingHandlers['virtualHtml'] = {
  init: ko.bindingHandlers['html'].init,
  update: function(element, valueAccessor) {
    if (element.nodeType === 8) {
      var html = ko.utils.unwrapObservable(valueAccessor());

      ko.virtualElements.emptyNode(element);
      if ((html !== null) && (html !== undefined)) {
        if (typeof html !== 'string') {
          html = html.toString();
        }

        var parsedNodes = ko.utils.parseHtmlFragment(html);
        if (parsedNodes) {
          var endCommentNode = element.nextSibling;
          for (var i = 0, j = parsedNodes.length; i < j; i++)
            endCommentNode.parentNode.insertBefore(parsedNodes[i], endCommentNode);
        }
      }
    } else { // plain node
      ko.bindingHandlers['html'].update(element, valueAccessor);
    }

    // Content for virtualHTML must not be parsed by KO, it is simple content.
    return {
      controlsDescendantBindings: true
    };
  }
};
ko.virtualElements.allowedBindings['virtualHtml'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],65:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var tinymce = (typeof window !== "undefined" ? window['tinymce'] : typeof global !== "undefined" ? global['tinymce'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
require("./eventable.js");

ko.bindingHandlers.wysiwygOrHtml = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');

    if (isNotWysiwygMode)
      return ko.bindingHandlers['virtualHtml'].init();
    else
      return ko.bindingHandlers.wysiwyg.init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (isNotWysiwygMode)
      return ko.bindingHandlers['virtualHtml'].update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
    //else 
    //  return ko.bindingHandlers.wysiwyg.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygOrHtml'] = true;

ko.bindingHandlers.wysiwygHref = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      var v = valueAccessor();

      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      // console.log("XXX", bindingContext.templateMode, isNotWysiwygMode, element.getAttribute("href"));
      if (isNotWysiwygMode) {
        element.setAttribute('target', '_new');
      } else {
        /*jshint scripturl:true*/
        // 20150226: removed href to work around FF issues with <a href=""><div contenteditable="true">..</div></a>
        // element.setAttribute('href', 'javascript:void(0)');
        // 20150309: on IE, an editable <a href="" data-editable=""> prevent tinymce toolbar to be shown.
        //           so I change behaviour based on the use of "wysiwygOrHtml"
        // @see: http://www.tinymce.com/develop/bugtracker_view.php?id=7432
        var allbindings = allBindingsAccessor();
        if (typeof allbindings.wysiwygOrHtml !== 'undefined') {
          element.setAttribute('href', 'javascript:void(0)');
        } else {
          element.removeAttribute('href');
          element.setAttribute('disabledhref', '#');
        }
      }
    }
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      // NOTE this unwrap is needed also in "wysiwyg" mode, otherwise dependency tracking dies.
      var attrValue = ko.utils.unwrapObservable(valueAccessor());
      if (isNotWysiwygMode) {
        if ((attrValue === false) || (attrValue === null) || (attrValue === undefined))
          element.removeAttribute('href');
        else
          element.setAttribute('href', attrValue.toString());
      }
    }
  }
};
ko.virtualElements.allowedBindings['wysiwygHref'] = true;

ko.bindingHandlers.wysiwygSrc = {
  convertedUrl: function(src, method, width, height) {
    var queryParamSeparator = src.indexOf('?') == -1 ? '?' : '&';
    var res = src + queryParamSeparator + "method=" + method + "&width=" + width + (height !== null ? "&height=" + height : '');
    return res;
  },
  placeholderUrl: function(plwidth, plheight, pltext) {
    var placeholdersrc = "'http://lorempixel.com/g/'+" + plwidth + "+'/'+" + plheight + "+'/abstract/'+encodeURIComponent(" + pltext + ")";
    // http://placehold.it/200x150.png/cccccc/333333&text=placehold.it#sthash.nA3r26vR.dpuf
    // placeholdersrc = "'http://placehold.it/'+"+width+"+'x'+"+height+"+'.png/cccccc/333333&text='+"+size;
    // placeholdersrc = "'"+converterUtils.addSlashes(defaultValue)+"'";
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor());
    var attrValue = ko.utils.unwrapObservable(value.src);
    var placeholderValue = ko.utils.unwrapObservable(value.placeholder);
    var width = ko.utils.unwrapObservable(value.width);
    var height = ko.utils.unwrapObservable(value.height);
    if ((attrValue === false) || (attrValue === null) || (attrValue === undefined) || (attrValue === '')) {
      if (typeof placeholderValue == 'object' && placeholderValue !== null) element.setAttribute('src', ko.bindingHandlers.wysiwygSrc.placeholderUrl(placeholderValue.width, placeholderValue.height, placeholderValue.text));
      else element.removeAttribute('src');
    } else {
      var method = ko.utils.unwrapObservable(value.method);
      if (!method) method = width > 0 && height > 0 ? 'cover' : 'resize';
      var src = ko.bindingHandlers.wysiwygSrc.convertedUrl(attrValue.toString(), method, width, height);
      element.setAttribute('src', src);
    }
    if (typeof width !== 'undefined' && width !== null) element.setAttribute("width", width);
    else element.removeAttribute("width");
    if (typeof height !== 'undefined' && height !== null) element.setAttribute("height", height);
    else element.removeAttribute("height");
  }
};

ko.bindingHandlers.wysiwygId = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      element.setAttribute('id', ko.utils.unwrapObservable(valueAccessor()));
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      element.setAttribute('id', ko.utils.unwrapObservable(valueAccessor()));
  }
};
ko.virtualElements.allowedBindings['wysiwygId'] = true;

// used on editable "item" so to bind clicks only in wysiwyg mode.
ko.bindingHandlers.wysiwygClick = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      ko.bindingHandlers.click.init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygClick'] = true;

// used on editable "item" so to bind css only in wysiwyg mode.
ko.bindingHandlers.wysiwygCss = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      ko.bindingHandlers.css.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygCss'] = true;

ko.bindingHandlers.wysiwygImg = {
  makeTemplateValueAccessor: function(valueAccessor, bindingContext) {
    return function() {
      var isWysiwygMode = (typeof bindingContext.templateMode != 'undefined' && bindingContext.templateMode == 'wysiwyg');

      var modelValue = valueAccessor(),
        unwrappedValue = ko.utils.peekObservable(modelValue); // Unwrap without setting a dependency here

      // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
      ko.utils.unwrapObservable(modelValue);

      return {
        'name': isWysiwygMode ? unwrappedValue['_editTemplate'] : unwrappedValue['_template'],
        'templateEngine': ko.nativeTemplateEngine.instance
      };
    };
  },
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['wysiwygImg'].makeTemplateValueAccessor(valueAccessor, bindingContext));
  },
  'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    bindingContext = bindingContext['extend'](valueAccessor());
    return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['wysiwygImg'].makeTemplateValueAccessor(valueAccessor, bindingContext), allBindings, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygImg'] = true;

// NOTE: there are issues with the "raw" format and trash left around by tinymce workarounds for contenteditable issues.
// setting "forced_root_block: false" disable the default behaviour of adding a wrapper <p> when needed and this seems to fix many issues in IE.
// also, maybe we should use the "raw" only for the "before SetContent" and instead read the "non-raw" content (the raw content sometimes have data- attributes and too many ending <br> in the code)
ko.bindingHandlers.wysiwyg = {
  currentIndex: 0,
  standardOptions: {},
  fullOptions: {
    toolbar1: 'bold italic forecolor backcolor hr styleselect removeformat | link unlink | pastetext code',
    //toolbar1: "bold italic | forecolor backcolor | link unlink | hr | pastetext code", // | newsletter_profile newsletter_optlink newsletter_unsubscribe newsletter_showlink";
    //toolbar2: "formatselect fontselect fontsizeselect | alignleft aligncenter alignright alignjustify | bullist numlist",
    plugins: ["link hr paste lists textcolor code"],
    // valid_elements: 'strong/b,em/i,*[*]',
    // extended_valid_elements: 'strong/b,em/i,*[*]',
    // Removed: image fullscreen contextmenu 
    // download custom:
    // jquery version con legacyoutput, anchor, code, importcss, link, paste, textcolor, hr, lists
  },
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    // TODO ugly, but works...
    ko.bindingHandlers.focusable.init(element);

    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      tinymce.remove('#' + element.getAttribute('id'));
    });

    var value = valueAccessor();

    if (!ko.isObservable(value)) throw "Wysiwyg binding called with non observable";
    if (element.nodeType === 8) throw "Wysiwyg binding called on virtual node, ignoring...." + element.innerHTML;

    var selectorId = element.getAttribute('id');
    if (!selectorId) {
      selectorId = 'wysiwyg_' + (++ko.bindingHandlers['wysiwyg'].currentIndex);
      element.setAttribute('id', selectorId);
    }

    var fullEditor = element.tagName == 'DIV' || element.tagName == 'TD';
    var isSubscriberChange = false;
    var thisEditor;
    var isEditorChange = false;

    var options = {
      selector: '#' + selectorId,
      inline: true,
      // maybe not needed, but won't hurt.
      hidden_input: false,
      plugins: ["paste"],
      toolbar1: "bold italic",
      toolbar2: "",
      // we have to disable preview_styles otherwise tinymce push inline every style he things will be applied and this makes the style menu to inherit color/font-family and more.
      preview_styles: false,
      paste_as_text: true,
      language: 'en',
      schema: "html5",
      extended_valid_elements: 'strong/b,em/i,*[*]',
      menubar: false,
      skin: 'gray-flat',
      setup: function(editor) {
        // TODO change sometimes doesn't trigger (we have to document when)
        // listening on keyup would increase correctness but we would need a rateLimit to avoid flooding.
        editor.on('change redo undo', function() {
          if (!isSubscriberChange) {
            isEditorChange = true;
            // we failed with other ways to do this:
            // value($(element).html());
            // value(element.innerHTML);
            value(editor.getContent({
              format: 'raw'
            }));
            isEditorChange = false;
          }
        });
        // Clicking on the element on focus change allow the "clic" code to be triggered and propagate the selection.
        // Not elegant, maybe we have better options.
        editor.on('focus', function() {
          // Used by scrollfix.js (maybe this is not needed by new scrollfix.js)
          editor.nodeChanged();
          editor.getElement().click();
        });

        // NOTE: this fixes issue with "leading spaces" in default content that were lost during initialization.
        editor.on('BeforeSetContent', function(args) {
          if (args.initial) args.format = 'raw';
        });

        /* NOTE: disabling "ENTER" in tiny editor, not a good thing but may be needed to work around contenteditable issues
        if (!fullEditor) {
          // se non abbiamo il "full Editor", disabilitiamo l'invio. (vari bug)
          editor.on('keydown', function(e) {
            if (e.keyCode == 13) { e.preventDefault(); }
          });
        }
        */

        thisEditor = editor;

      }
    };

    ko.utils.extend(options, ko.bindingHandlers.wysiwyg.standardOptions);
    if (fullEditor) ko.utils.extend(options, ko.bindingHandlers.wysiwyg.fullOptions);

    // we have to put initialization in a settimeout, otherwise switching from "1" to "2" columns blocks
    // will start the new editors before disposing the old ones and IDs get temporarily duplicated.
    // using setTimeout the dispose/create order is correct on every browser tested.
    global.setTimeout(function() {
      tinymce.init(options);
    });

    ko.computed(function() {
      var content = ko.utils.unwrapObservable(valueAccessor());
      if (!isEditorChange) {
        try {
          isSubscriberChange = true;
          // we failed setting contents in other ways...
          // $(element).html(content);
          if (typeof thisEditor !== 'undefined') {
            thisEditor.setContent(content, {
              format: 'raw'
            });
          } else {
            ko.utils.setHtml(element, content);
          }
        } catch (e) {
          console.log("TODO exception setting content to editable element", typeof thisEditor, e);
        }
        isSubscriberChange = false;
      }
    }, null, {
      disposeWhenNodeIsRemoved: element
    });

    // do not parse html content for KO bindings!!
    return {
      controlsDescendantBindings: true
    };

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./eventable.js":51}],66:[function(require,module,exports){
"use strict";
var console = require("./../../../bower_components/console-browserify/index.js");

// returns 0 if equal (0.0.x release), 1 with backward compatible additions (0.x.0 release), 2 on lost data or incompatible data (x.0.0 release)
var checkModel = function(reference, blockDefs, model, origPrefix, reverse) {
  var blockDefsObj, i, prefix;
  var valid = 0;
  if (typeof reverse == 'undefined') reverse = false;
  if (typeof blockDefs !== 'undefined' && typeof blockDefs.splice == 'function') {
    blockDefsObj = {};
    for (i = 0; i < blockDefs.length; i++) blockDefsObj[blockDefs[i].type] = blockDefs[i];
  } else {
    blockDefsObj = blockDefs;
  }
  for (var prop in reference)
    if (reference.hasOwnProperty(prop)) {
      prefix = typeof origPrefix !== 'undefined' ? origPrefix + "." + prop : prop;
      if (!model.hasOwnProperty(prop)) {
        if (reverse) {
          console.warn("WARN Property ", prefix, "found in model is not defined by template: removing it!");
          valid = Math.max(valid, 2);
          delete reference[prop];
        } else {
          console.log("INFO Property ", prefix, "missing in model, cloning from reference!");
          valid = Math.max(valid, 1);
          model[prop] = reference[prop];
        }
      } else if (typeof model[prop] != typeof reference[prop]) {
        // se sono di tipo diverso allora provo a vedere se l'altro, convertito di tipo mantiene un valore equivalente.
        if (model[prop] !== null && reference[prop] !== null) {
          if (typeof model[prop] == 'string') {
            if (String(reference[prop]) != reference[prop]) {
              console.log("TODO Different type 1 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
              valid = Math.max(valid, 2);
            }
          } else if (typeof model[prop] == 'number') {
            if (Number(reference[prop]) != reference[prop]) {
              console.log("TODO Different type 2 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
              valid = Math.max(valid, 2);
            }
          } else {
            console.log("TODO Different type 3 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
            valid = Math.max(valid, 2);
          }
        }
      } else if (typeof reference[prop] == 'object') {
        if (reference[prop] !== null) {
          if (typeof reference[prop].splice !== 'undefined') {
            if (reference[prop].length > 0) {
              if (model[prop].length > 0) {
                // TODO needs sorting?
                var j = 0;
                for (i = 0; i < model[prop].length; i++) {
                  if (typeof model[prop][i].type == 'string') {
                    while (j < reference[prop].length && reference[prop][j].type !== model[prop][i].type) {
                      console.log("ignoring ", prefix, reference[prop][j].type, " block type in reference not found in model");
                      j++;
                    }
                    if (j >= reference[prop].length) {
                      console.log("WARN cannot find ", prefix, model[prop][i].type, " block in reference");
                      valid = Math.max(valid, 2);
                      break;
                    }
                    // reverse condition so to skip "deep traversing" on error
                    valid = Math.max(valid, checkModel(reference[prop][j], undefined, model[prop][i], prefix + "[" + i + "." + model[prop][i].type + "]"));
                  }
                }
              } else {
                // in the case of different array we check blockDefs
                for (i = 0; i < reference[prop].length; i++) {
                  if (typeof reference[prop][i].type !== 'string') {
                    console.log("TODO found an object with no type", prefix, reference[prop][i]);
                    valid = Math.max(valid, 2);
                  } else if (!blockDefsObj.hasOwnProperty(reference[prop][i].type)) {
                    console.warn("TODO the model uses a block type not defined by the template. REMOVING IT!!", prefix, reference[prop][i]);
                    reference[prop].splice(i, 1);
                    i--;
                    valid = Math.max(valid, 2);
                  } else {
                    valid = Math.max(valid, checkModel(blockDefsObj[reference[prop][i].type], blockDefsObj, reference[prop][i], prefix + "[" + i + "." + reference[prop][i].type + "]"));
                  }
                }
              }
            }
          } else {
            if (model[prop] === null) {
              if (reverse) {
                console.log("WARN Null object in model ", prefix, "instead of", reference[prop], "deleting it");
                valid = Math.max(valid, 2);
                delete reference[prop];
              } else {
                console.log("INFO Null object in model ", prefix, "instead of", reference[prop], "cloning it from the reference");
                valid = Math.max(valid, 1);
                model[prop] = reference[prop];
              }
            } else {
              valid = Math.max(valid, checkModel(reference[prop], blockDefsObj, model[prop], prefix, reverse));
            }
          }
        } else if (model[prop] !== null) {
          console.log("TODO Null in reference but not null in model", prefix, model[prop]);
          valid = Math.max(valid, 2);
        }
      } else if (typeof reference[prop] !== 'string' && typeof reference[prop] !== 'boolean' && typeof reference[prop] !== 'number') {
        console.log("TODO unsupported type", prefix, typeof reference[prop]);
        valid = Math.max(valid, 2);
      }

    }
  if (!reverse) valid = Math.max(valid, checkModel(model, blockDefs, reference, typeof origPrefix !== 'undefined' ? origPrefix + "!R" : "!R", true));
  return valid;
};

module.exports = checkModel;
},{"./../../../bower_components/console-browserify/index.js":1}],67:[function(require,module,exports){
"use strict";

// Parses CSS declarations and supports the property language (-ko-*) found between them.
// Create KO bindings but doesn't depend on KO.
// Needs a bindingProvider.

var converterUtils = require("./utils.js");
var cssParse = require("./../../../bower_components/mensch/lib/parser.js");
var console = require("./../../../bower_components/console-browserify/index.js");
var domutils = require("./domutils.js");

var _declarationValueLookup = function(declarations, propertyname, templateUrlConverter) {
  for (var i = declarations.length - 1; i >= 0; i--) {
    if (declarations[i].type == 'property' && declarations[i].name == propertyname) {
      return _declarationValueUrlPrefixer(declarations[i].value, templateUrlConverter);
    }
  }
  return null;
};

var _propToCamelCase = function(propName) {
  return propName.replace(/-([a-z])/g, function(match, contents, offset, s) {
    return contents.toUpperCase();
  });
};

var _declarationValueUrlPrefixer = function(value, templateUrlConverter) {
  if (value.match(/url\(.*\)/)) {
    var replaced = value.replace(/(url\()([^\)]*)(\))/g, function(matched, prefix, url, postfix) {
      var trimmed = url.trim();
      var apice = url.trim().charAt(0);
      if (apice == '\'' || apice == '"') {
        trimmed = trimmed.substr(1, trimmed.length - 2);
      } else {
        apice = '';
      }
      var newUrl = templateUrlConverter(trimmed);
      if (newUrl !== null) {
        return prefix + apice + newUrl + apice + postfix;
      } else {
        return matched;
      }
    });
    return replaced;
  } else {
    return value;
  }
};

var elaborateDeclarations = function(style, declarations, templateUrlConverter, bindingProvider, element, basicBindings, removeDisplayNone) {
  var newBindings = typeof basicBindings == 'object' && basicBindings !== null ? basicBindings : {};
  var newStyle = null;
  var skipLines = 0;
  if (typeof declarations == 'undefined') {
    var styleSheet = cssParse("#{\n" + style + "}", {
      comments: true,
      position: true
    });
    declarations = styleSheet.stylesheet.rules[0].declarations;
    skipLines = 1;
  }
  for (var i = declarations.length - 1; i >= 0; i--)
    if (declarations[i].type == 'property') {
      if (removeDisplayNone === true && declarations[i].name == 'display' && declarations[i].value == 'none') {
        if (newStyle === null) newStyle = style;
        newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, '');
      } else {
        var decl = declarations[i].name.match(/^-ko-(bind-|attr-)?([a-z0-9-]*?)(-if|-ifnot)?$/);
        if (decl !== null) {
          // rimozione dello stile -ko- dall'attributo style.
          if (newStyle === null && typeof style != 'undefined') newStyle = style;

          var isAttr = decl[1] == 'attr-';
          var isBind = decl[1] == 'bind-';
          var propName = decl[2];

          var isIf = decl[3] == '-if' || decl[3] == '-ifnot';
          var condDecl;
          var bindValue;
          var propDefaultValue;

          if (isIf) {
            condDecl = declarations[i].name.substr(0, declarations[i].name.length - decl[3].length);
            var conditionedDeclaration = _declarationValueLookup(declarations, condDecl, templateUrlConverter);
            if (conditionedDeclaration === null) throw "Unable to find declaration " + condDecl + " for " + declarations[i].name;
          } else {

            if ((isAttr || isBind) && (typeof element == 'undefined' && typeof style != 'undefined')) throw "Attributes and bind declarations are only allowed in inline styles!";

            var needDefaultValue = true;
            var bindType;
            if (isAttr) {
              propDefaultValue = domutils.getAttribute(element, propName);
              needDefaultValue = false;
              bindType = 'virtualAttr';
            } else if (!isBind) {
              needDefaultValue = typeof style !== 'undefined';
              if (needDefaultValue) propDefaultValue = _declarationValueLookup(declarations, propName, templateUrlConverter);
              bindType = 'virtualStyle';
            } else {
              bindType = null;
              if (propName == 'text') {
                if (typeof element !== 'undefined') {
                  propDefaultValue = domutils.getInnerText(element);
                } else {
                  needDefaultValue = false;
                }
              } else if (propName == 'html') {
                if (typeof element !== 'undefined') {
                  propDefaultValue = domutils.getInnerHtml(element);
                } else {
                  needDefaultValue = false;
                }
              } else {
                needDefaultValue = false;
              }
            }

            if (needDefaultValue && propDefaultValue === null) {
              console.error("Cannot find default value for", declarations[i].name, declarations);
              throw "Cannot find default value for " + declarations[i].name + ": " + declarations[i].value + " in " + element + " (" + typeof style + "/" + propName + ")";
            }
            var bindDefaultValue = propDefaultValue;

            var bindName = !isBind && !isAttr ? _propToCamelCase(propName) : (propName.indexOf('-') != -1 ? '\''+propName+'\'' : propName);

            try {
              bindValue = converterUtils.expressionBinding(declarations[i].value, bindingProvider, bindDefaultValue);
            } catch (e) {
              console.error("Model ensure path failed", e.stack, "name", declarations[i].name, "value", declarations[i].value, "default", propDefaultValue, "element", element);
              throw e;
            }

            if (bindType !== null && typeof newBindings[bindType] == 'undefined') newBindings[bindType] = {};


            // Special handling for HREFs
            if (bindType == 'virtualAttr' && bindName == 'href') {
              bindType = null;
              bindName = 'wysiwygHref';
              // We have to remove it, otherwise we ends up with 2 rules writing it.
              if (typeof element != 'undefined' && element !== null) {
                domutils.removeAttribute(element, "href");
              }
            }

            // TODO evaluate the use of "-then" (and -else) postfixes to complete the -if instead of relaying
            // on the same basic sintax (or maybe it is better to support ternary operator COND ? THEN : ELSE).
            var declarationCondition = _declarationValueLookup(declarations, declarations[i].name + '-if', templateUrlConverter);
            var not = false;
            if (declarationCondition === null) {
              declarationCondition = _declarationValueLookup(declarations, declarations[i].name + '-ifnot', templateUrlConverter);
              not = true;
            } else {
              if (_declarationValueLookup(declarations, declarations[i].name + '-ifnot', templateUrlConverter) !== null) {
                throw "Unexpected error: cannot use both -if and -ifnot property conditions";
              }
            }
            if (declarationCondition !== null) {
              try {
                var bindingCond = converterUtils.conditionBinding(declarationCondition, bindingProvider);
                bindValue = (not ? '!' : '') + "(" + bindingCond + ") ? " + bindValue + " : null";
              } catch (e) {
                console.error("Unable to deal with -ko style binding condition", declarationCondition, declarations[i].name);
                throw e;
              }
            }

            if (bindType !== null) newBindings[bindType][bindName] = bindValue;
            else newBindings[bindName] = bindValue;
          }

          // parsing @supports :preview
          if (newStyle !== null) {

            try {
              // if "element" is defined then we are parsing an "inline" style and we want to remove it.
              if (typeof element != 'undefined' && element !== null) {
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, '');
              } else {
                // otherwise we are parsing a full stylesheet.. let's rewrite the full "prop: value" without caring about the original syntax.
                var replacedWith = '';
                // if it is an "if" we simply have to remove it, otherwise we replace the input code with "prop: value" generating expression.
                if (!isIf) replacedWith = propName + ': <!-- ko text: ' + bindValue + ' -->' + propDefaultValue + '<!-- /ko -->';
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, replacedWith);
              }
            } catch (e) {
              console.warn("Remove style failed", e, "name", declarations[i]);
              throw e;
            }

          }

        } else {
          // prefixing urls
          var replacedValue = _declarationValueUrlPrefixer(declarations[i].value, templateUrlConverter);
          if (replacedValue != declarations[i].value) {
            if (newStyle === null && typeof style !== 'undefined') newStyle = style;
            if (newStyle !== null) {
              try {
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, declarations[i].name + ": " + replacedValue);
              } catch (e) {
                console.log("Remove style failed replacing url", e, "name", declarations[i]);
                throw e;
              }
            }
          }

          // Style handling by concatenated "style attribute" (worse performance but more stable than direct style handling)
          var bindName2 = _propToCamelCase(declarations[i].name);
          var bind = 'virtualAttrStyle';
          var bindVal2 = typeof newBindings['virtualStyle'] !== 'undefined' ? newBindings['virtualStyle'][bindName2] : undefined;

          var dist = ' ';
          if (typeof newBindings[bind] == 'undefined') {
            newBindings[bind] = "''";
            dist = '';
          }

          if (typeof bindVal2 !== 'undefined') {
            newBindings[bind] = "'" + declarations[i].name + ": '+(" + bindVal2 + ")+';" + dist + "'+" + newBindings[bind];
            delete newBindings['virtualStyle'][bindName2];
          } else {
            newBindings[bind] = "'" + declarations[i].name + ": " + converterUtils.addSlashes(replacedValue) + ";" + dist + "'+" + newBindings[bind];
          }

        }
      }
    }

  if (typeof element != 'undefined' && element !== null) {
    for (var prop in newBindings['virtualStyle'])
      if (newBindings['virtualStyle'].hasOwnProperty(prop)) {
        console.log("Unexpected virtualStyle binding after conversion to virtualAttr.style", prop, newBindings['virtualStyle'][prop], style);
        throw "Unexpected virtualStyle binding after conversion to virtualAttr.style for " + prop;
      }
    delete newBindings['virtualStyle'];

    var currentBindings = domutils.getAttribute(element, 'data-bind');
    var dataBind = (currentBindings !== null ? currentBindings + ", " : "") + _bindingSerializer(newBindings);
    domutils.setAttribute(element, 'data-bind', dataBind);
  }

  // TODO a function whose return type depends on the input parameters is very ugly.. please FIX ME.
  if (typeof style == 'undefined') {
    // clean virtualStyle if empty
    var hasVirtualStyle = false;
    for (var prop1 in newBindings['virtualStyle'])
      if (newBindings['virtualStyle'].hasOwnProperty(prop1)) {
        hasVirtualStyle = true;
        break;
      }
    if (!hasVirtualStyle) delete newBindings['virtualStyle'];
    else {
      // remove and add back virtualAttrStyle so it gets appended BEFORE virtualAttrStyle (_bindingSerializer reverse them...)
      if (typeof newBindings['virtualAttrStyle'] !== 'undefined') {
        var vs = newBindings['virtualAttrStyle'];
        delete newBindings['virtualAttrStyle'];
        newBindings['virtualAttrStyle'] = vs;
      }
    }
    // returns new serialized bindings
    return _bindingSerializer(newBindings);
  }

  return newStyle;
};

var _bindingSerializer = function(val) {
  var res = [];
  for (var prop in val)
    if (val.hasOwnProperty(prop)) {
      if (typeof val[prop] == 'object') res.push(prop + ": " + "{ " + _bindingSerializer(val[prop]) + " }");
      else res.push(prop + ": " + val[prop]);
    }
  return res.reverse().join(', ');
};

module.exports = elaborateDeclarations;
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/mensch/lib/parser.js":15,"./domutils.js":68,"./utils.js":74}],68:[function(require,module,exports){
(function (global){
"use strict";

// This deals with Cheerio/jQuery issues.
// Most of this could be done without jQuery, too, but jQuery is easier to be mocked with Cheerio
// Otherwise we would need jsDom to run the compiler in the server (without a real browser)

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

function _extend(target, source) {
  if (source) {
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}

var objExtend = function(obj, extender) {
  if (typeof $.extend == 'function') {
    return $.extend(true, obj, extender);
  } else {
    return _extend(obj, JSON.parse(JSON.stringify(extender)));
  }
};

var getAttribute = function(element, attribute) {
  var res = $(element).attr(attribute);
  if (typeof res == 'undefined') res = null;
  return res;
  // return element.getAttribute(attribute);
};

var setAttribute = function(element, attribute, value) {
  $(element).attr(attribute, value);
  // element.setAttribute(attribute, value);
};

var removeAttribute = function(element, attribute) {
  $(element).removeAttr(attribute);
  // element.removeAttribute(attribute);
};

var getInnerText = function(element) {
  return $(element).text();
  // if (typeof element.innerText != 'undefined') return element.innerText;
  // else return element.textContent;
};

var getInnerHtml = function(element) {
  return $(element).html();
  // return element.innerHTML;
};

var getLowerTagName = function(element) {
  // sometimes cheerio doesn't have tagName but "name".
  // Browsers have "name" with empty string
  // Sometimes cheerio has tagName but no prop function.
  if (element.tagName === '' && typeof element.name == 'string') return element.name.toLowerCase();
  if (element.tagName !== '') return element.tagName.toLowerCase();
  return $(element).prop("tagName").toLowerCase();
  // return element.tagName.toLowerCase();
};

var setContent = function(element, content) {
  $(element).html(content);
  // element.innerHTML = content;
};

var replaceHtml = function(element, html) {
  $(element).replaceWith(html);
  // element.outerHTML = html;
};

var removeElements = function($elements, tryDetach) {
  if (tryDetach && typeof $elements.detach !== 'undefined') $elements.detach();
  // NOTE: we don't need an else, as detach is simply an optimization
  $elements.remove();
};

module.exports = {
  getAttribute: getAttribute,
  setAttribute: setAttribute,
  removeAttribute: removeAttribute,
  getInnerText: getInnerText,
  getInnerHtml: getInnerHtml,
  getLowerTagName: getLowerTagName,
  setContent: setContent,
  replaceHtml: replaceHtml,
  removeElements: removeElements,
  objExtend: objExtend
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],69:[function(require,module,exports){
"use strict";

var console = require("./../../../bower_components/console-browserify/index.js");
var elaborateDeclarations = require("./declarations.js");
var utils = require('./utils.js');
var modelDef = require('./model.js');

var _getOptionsObject = function(options) {
  var optionsCouples = options.split('|');
  var opts = {};
  for (var i = 0; i < optionsCouples.length; i++) {
    var opt = optionsCouples[i].split('=');
    opts[opt[0]] = opt.length > 1 ? opt[1] : opt[0];
  }
  return opts;
};

// TODO this should not have hardcoded rules (we now have a way to declare them in the template definition)
// Category "style" is used by editType "styler"
// Cateogry "content" is used by editType "edit"
// TODO maybe we should use a common string here, and rely only on the original category.
var _filterProps = function(model, editType, level) {
  var res = [];
  for (var prop in model)
    if (!prop.match(/^customStyle$/) && !prop.match(/^_/) && model.hasOwnProperty(prop)) {
      var isStyleProp = model[prop] !== null && typeof model[prop]._category != 'undefined' && model[prop]._category == 'style';
      if (prop == 'id' || prop == 'type' || prop.match(/Blocks$/)) {} else if (editType == 'styler') {
        if (isStyleProp || level > 0) res.push(prop);
      } else if (editType == 'edit') {
        // Editing for properties in the "content" category but not defined in the context of a block
        var isContentProp = model[prop] !== null && typeof model[prop]._category != 'undefined' && model[prop]._category == 'content' &&
          (typeof model[prop]._context == 'undefined' || model[prop]._context != 'block');
        if (isContentProp) res.push(prop);
      } else if (typeof editType == 'undefined') {
        res.push(prop);
      }
    }
  return res;
};

var _propInput = function(model, prop, propAccessor, editType, widgets) {
  var html = "";
  var widget;
  if (model !== null && typeof model._widget != 'undefined') widget = model._widget;

  if (typeof widget == 'undefined') {
    throw "Unknown data type for " + prop;
  }

  // For content editors we deal with focusing (clicking is handled by the container DIV).
  var onfocusbinding = 'focusable: true';
  if (editType == 'edit') {
    onfocusbinding += ', event: { focus: function(ui, event) { $($element).click(); } } ';
  }

  html += '<label class="data-' + widget + '"' + (widget == 'boolean' ? ' data-bind="event: { mousedown: function(ui, evt) { if (evt.button == 0) { var input = $($element).find(\'input\'); var ch = input.prop(\'checked\'); setTimeout(function() { input.click(); input.prop(\'checked\', !ch); input.trigger(\'change\'); }, 0); } } }, click: function(ui, evt) { evt.preventDefault(); }, clickBubble: false"' : '') + '>';

  if (typeof widgets !== 'undefined' && typeof widgets[widget] !== 'undefined') {
    var w = widgets[widget];
    var parameters = {};
    if (typeof w.parameters !== 'undefined')
      for (var p in w.parameters)
        if (w.parameters.hasOwnProperty(p) && typeof model['_'+p] !== 'undefined')
          parameters[p] = model['_'+p];
    html += w.html(propAccessor, onfocusbinding, parameters);
  } else if (widget == 'boolean') {
    html += '<input type="checkbox" value="nothing" data-bind="checked: ' + propAccessor + ', ' + onfocusbinding + '" />';
    html += '<span class="checkbox-replacer" ></span>'; /* data-bind="css: { checked: '+propAccessor+' }" */
  } else if (widget == 'color') {
    html += '<input size="7" type="text" data-bind="colorpicker: { color: ' + propAccessor + ', strings: $root.t(\'Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.\') }, ' + ', ' + onfocusbinding + '" />';
  } else if (widget == 'select') {
    if (typeof model._options != 'undefined') {
      var opts = _getOptionsObject(model._options);
      // var opts = model._options;
      html += '<select data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '">';
      for (var opt in opts)
        if (opts.hasOwnProperty(opt)) {
          html += '<option value="' + opt + '" data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(opts[opt]) + '\')">' + opts[opt] + '</option>';
        }
      html += '</select>';
    }
  } else if (widget == 'font') {
    html += '<select type="text" data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '">';
    html += '<optgroup label="Sans-Serif Fonts">';
    html += '<option value="Arial,Helvetica,sans-serif">Arial</option>';
    html += '<option value="\'Comic Sans MS\',cursive,sans-serif">Comic Sans MS</option>';
    html += '<option value="Impact,Charcoal,sans-serif">Impact</option>';
    html += '<option value="\'Trebuchet MS\',Helvetica,sans-serif">Trebuchet MS</option>';
    html += '<option value="Verdana,Geneva,sans-serif">Verdana</option>';
    html += '</optgroup>';
    html += '<optgroup label="Serif Fonts">';
    html += '<option value="Georgia,serif">Georgia</option>';
    html += '<option value="\'Times New Roman\',Times,serif">Times New Roman</option>';
    html += '</optgroup>';
    html += '<optgroup label="Monospace Fonts">';
    html += '<option value="\'Courier New\',Courier,monospace">Courier New</option>';
    html += '</optgroup>';
    html += '</select>';
  } else if (widget == 'url') {
    html += '<div class="ui-textbutton">';
    // <a class="ui-spinner-button ui-spinner-down ui-corner-br ui-button ui-widget ui-state-default ui-button-text-only" tabindex="-1" role="button"><span class="ui-button-text"><span class="ui-icon fa fa-fw caret-down">▼</span></span></a>
    html += '<input class="ui-textbutton-input" size="7" type="url" pattern="(mailto:.+@.+|https?://.+\\..+|\\[.*\\].*)" value="nothing" data-bind="css: { withButton: typeof $root.linkDialog !== \'undefined\' }, validatedValue: ' + propAccessor + ', ' + onfocusbinding + '" />';
    html += '<a class="ui-textbutton-button" data-bind="visible: typeof $root.linkDialog !== \'undefined\', click: typeof $root.linkDialog !== \'undefined\' ? $root.linkDialog.bind($element.previousSibling) : false, button: { icons: { primary: \'fa fa-fw fa-ellipsis-h\' }, label: \'Opzioni\', text: false }">Opzioni</a>';
    html += '</div>';
  } else if (widget == 'integer') {
    // at this time the "step" depends on max being greater than 100.
    // maybe we should expose "step" as a configuration, too
    var min = 0;
    var max = 1000;
    if (model !== null && typeof model._max !== 'undefined') max = model._max;
    if (model !== null && typeof model._min !== 'undefined') min = model._min;
    var step = (max - min) >= 100 ? 10 : 1;
    var page = step * 5;
    html += '<input class="number-spinner" size="7" step="' + step + '" type="number" value="-1" data-bind="spinner: { min: ' + min + ', max: ' + max + ', page: ' + page + ', value: ' + propAccessor + ' }, valueUpdate: [\'change\', \'spin\']' + ', ' + onfocusbinding + '" />';
  } else {
    html += '<input size="7" type="text" value="nothing" data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '" />';
  }

  html += '</label>';

  return html;
};

var _getGlobalStyleProp = function(globalStyles, model, prop, path) {
  var globalStyleProp;
  if (typeof model !== 'object' || model === null || typeof model._widget !== 'undefined') {
    if (typeof prop !== 'undefined' && typeof path !== 'undefined' && path.length > 0 && typeof globalStyles == 'object' && typeof globalStyles[path] != 'undefined') {
      globalStyleProp = globalStyles[path];
    }
  }
  return globalStyleProp;
};

var _propEditor = function(withBindingProvider, widgets, templateUrlConverter, model, themeModel, path, prop, editType, level, baseThreshold, globalStyles, globalStyleProp, trackUsage, rootPreviewBinding, previewBackground) {
  if (typeof level == 'undefined') level = 0;

  if (typeof prop !== 'undefined' && typeof model == 'object' && model !== null && typeof model._usecount === 'undefined') {
    console.log("TODO EDITOR ignoring", path, "property because it is not used by the template", "prop:", prop, "type:", editType, "level:", level, withBindingProvider._templateName);
    return "";
  }

  var propAccessor = typeof globalStyleProp != 'undefined' ? prop + '._defaultComputed' : prop;

  var html = "";
  var title;
  var ifSubsProp = propAccessor;
  var ifSubsGutter = 1;
  // typeof globalStyleProp != 'undefined' ? 1 : 2;
  var ifSubsThreshold = 1;

  // The visibility handling is a PITA
  // 
  // Here are some "edge cases" to test whenever we change something here:
  // LM social footer: removing shareVisibile must be reflected in the booleans sub-checks
  // FLUID social block: multiple clicks on the "wand" should not make the editor invisible
  // BIS heroMenu - By changing the menu visibility it should be reflected in style editors for the menu links
  // FLUID almost every block with a color variant sometimes keeps showing style editor for the hidden variant.
  if (typeof model == 'object' && model !== null && typeof model._widget == 'undefined') {
    // Do nothing here
  } else {
    if (typeof globalStyleProp == 'undefined') {
      ifSubsGutter += 1;
    }
  }

  // NOTE baseThreshold is added only when globalStyle is not defined because when we have globalStyle
  // we're going to bind the computed values and not the original and this way we don't add ourserf to the dependency 
  // tracking (subscriptionCount)
  // NOTE baseThreshold is an "expression" and not a fixed number, so this is a concatenation
  if (typeof globalStyleProp == 'undefined' && typeof baseThreshold !== 'undefined') ifSubsThreshold += baseThreshold;

  if (typeof prop != 'undefined' && !!trackUsage) {
    html += '<!-- ko ifSubs: { data: ' + ifSubsProp + ', threshold: ' + ifSubsThreshold + ', gutter: ' + ifSubsGutter + ' } -->';
  }

  if (typeof prop != 'undefined' && (model === null || typeof model._name == 'undefined')) {
    // TODO throw exception?
    console.log("TODO WARN Missing label for property ", prop);
  }
  if (typeof prop == 'undefined' && model !== null && typeof model._name == 'undefined') {
    console.log("TODO WARN Missing label for object ", model.type /*, model */ );
  }

  if (typeof model == 'object' && model !== null && typeof model._widget == 'undefined') {
    var props = _filterProps(model, editType, level);

    var hasCustomStyle = editType == 'styler' && model !== null && typeof model.customStyle !== 'undefined' && typeof globalStyleProp !== 'undefined';
    var selectedItemBinding = '';
    var additionalClasses = '';
    if (typeof prop !== 'undefined' && editType == 'edit') {
      selectedItemBinding = ', click: function(obj, evt) { $root.selectItem(' + prop + ', $data); return false }, clickBubble: false, css: { selecteditem: $root.isSelectedItem(' + prop + ') }, scrollIntoView: $root.isSelectedItem(' + prop + '), ';
      additionalClasses += ' selectable';
    }
    if (hasCustomStyle) {
      additionalClasses += ' supportsCustomStyles';
    }
    html += '<div class="objEdit level' + level + additionalClasses + '" data-bind="tooltips: {}' + selectedItemBinding + '">';
    var modelName = (model !== null && typeof model._name != 'undefined' ? model._name : (typeof prop !== 'undefined' ? '[' + prop + ']' : ''));
    if (hasCustomStyle) {
      var themeSectionName = 'Stile';
      if (typeof themeModel !== 'undefined' && themeModel !== null && typeof themeModel._name !== 'undefined') {
        themeSectionName = themeModel._name;
      } else {
        console.log("TODO missing label for theme section ", prop, model !== null ? model.type : '-');
      }

      modelName = '<span class="blockSelectionMethod" data-bind="text: customStyle() ? $root.ut(\'template\', \'' + utils.addSlashes(modelName) + '\') : $root.ut(\'template\', \'' + utils.addSlashes(themeSectionName) + '\')">Block</span>';
    } else {
      modelName = '<span data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(modelName) + '\')">' + modelName + '</span>';
    }
    title = model !== null && typeof model._help !== 'undefined' ? ' title="' + utils.addSlashes(model._help) + '" data-bind="attr: { title: $root.ut(\'template\', \'' + utils.addSlashes(model._help) + '\') }"' : '';
    html += '<span' + title + ' class="objLabel level' + level + '">' + modelName + '</span>';

    if (editType == 'edit' && typeof model._blockDescription !== 'undefined') {
      html += '<div class="blockDescription" data-bind="html: $root.ut(\'template\', \'' + utils.addSlashes(model._blockDescription) + '\')">' + model._blockDescription + '</div>';
    }

    /* CUSTOM STYLE */
    if (hasCustomStyle) {
      html += '<label class="data-boolean blockCheck" data-bind="tooltips: { }">';
      html += '<input type="checkbox" value="nothing" data-bind="focusable: true, checked: customStyle" />';
      html += '<span title="Switch between global and block level styles editing" data-bind="attr: { title: $root.t(\'Switch between global and block level styles editing\') }" class="checkbox-replacer checkbox-replacer-onoff"></span>'; //  data-bind="tooltip: { content: \'personalizza tutti\' }"
      html += '</label>';
      html += '<!-- ko template: { name: \'customstyle\', if: customStyle } --><!-- /ko -->';
    }

    if (typeof prop != 'undefined') {
      html += '<!-- ko with: ' + prop + ' -->';

      /* PREVIEW */
      if (level == 1 && typeof prop != 'undefined') {
        if (typeof model._previewBindings != 'undefined' && typeof withBindingProvider != 'undefined') {
          if (typeof rootPreviewBinding != 'undefined') html += '<!-- ko with: $root.content() --><div class="objPreview" data-bind="' + rootPreviewBinding + '"></div><!-- /ko -->';
          if (typeof previewBackground != 'undefined') html += '<!-- ko with: $parent --><div class="objPreview" data-bind="' + previewBackground + '"></div><!-- /ko -->';
          var previewBindings = elaborateDeclarations(undefined, model._previewBindings, templateUrlConverter, withBindingProvider.bind(this, path + '.'));
          html += '<div class="objPreview"><div class="objPreviewInner" data-bind="' + previewBindings + '"></div></div>';
        }
      }
    }

    /* PREVIEW */
    var previewBG;
    if (level === 0) {
      if (typeof model._previewBindings != 'undefined') {
        previewBG = elaborateDeclarations(undefined, model._previewBindings, templateUrlConverter, withBindingProvider.bind(this, path.length > 0 ? path + '.' : ''));
      }
    }

    var i, newPath;

    var before = html.length;

    var newThemeModel;
    var newGlobalStyleProp;

    for (i = 0; i < props.length; i++) {
      newPath = path.length > 0 ? path + "." + props[i] : props[i];
      if (typeof model[props[i]] != 'object' || model[props[i]] === null || typeof model[props[i]]._widget != 'undefined') {
        newGlobalStyleProp = undefined;
        if (level === 0 && props[i] == 'theme')
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, 0, baseThreshold, undefined, undefined, trackUsage, rootPreviewBinding);
        else {
          newGlobalStyleProp = _getGlobalStyleProp(globalStyles, model[props[i]], props[i], newPath);
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, level + 1, baseThreshold, globalStyles, newGlobalStyleProp, trackUsage, rootPreviewBinding, previewBG);
        }
      }
    }
    for (i = 0; i < props.length; i++) {
      newPath = path.length > 0 ? path + "." + props[i] : props[i];
      if (!(typeof model[props[i]] != 'object' || model[props[i]] === null || typeof model[props[i]]._widget != 'undefined')) {
        newGlobalStyleProp = undefined;
        if (level === 0 && props[i] == 'theme')
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, 0, baseThreshold, undefined, undefined, trackUsage, rootPreviewBinding);
        else {
          newGlobalStyleProp = _getGlobalStyleProp(globalStyles, model[props[i]], props[i], newPath);
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, level + 1, baseThreshold, globalStyles, newGlobalStyleProp, trackUsage, rootPreviewBinding, previewBG);
        }
      }
    }

    var added = html.length - before;
    if (added === 0) {
      // No editable content: if this is in context "template" we leave it empty, otherwise we show an help.
      if (typeof model == 'object' && model !== null && model._context == 'template') {
        return '';
      } else {
        // TODO move me to a tmpl?
        html += '<div class="objEmpty" data-bind="html: $root.t(\'Selected element has no editable properties\')">Selected element has no editable properties</div>';
      }
    }

    if (typeof prop != 'undefined') {
      html += '<!-- /ko -->';
    }
    html += '</div>';

  } else {
    var checkboxes = true;

    if (typeof globalStyles == 'undefined') checkboxes = false;

    if (model === null || typeof model != 'object' || typeof model._widget != 'undefined') {
      var bindings = [];

      if (typeof globalStyleProp != 'undefined') bindings.push('css: { notnull: ' + prop + '() !== null }');
      title = model !== null && typeof model._help !== 'undefined' ? ' title="' + utils.addSlashes(model._help) + '" data-bind="attr: { title: $root.ut(\'template\', \'' + utils.addSlashes(model._help) + '\') }"' : '';
      if (title.length > 0) bindings.push('tooltips: {}');
      var bind = bindings.length > 0 ? 'data-bind="' + utils.addSlashes(bindings.join()) + '"' : '';
      html += '<div class="propEditor ' + (checkboxes ? 'checkboxes' : '') + '"' + bind + '>';

      var modelName2 = (model !== null && typeof model._name != 'undefined' ? model._name : (typeof prop !== 'undefined' ? '[' + prop + ']' : ''));
      modelName2 = '<span data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(modelName2) + '\')">' + modelName2 + '</span>';
      html += '<span' + title + ' class="propLabel">' + modelName2 + '</span>';
      html += '<div class="propInput ' + (typeof globalStyles != 'undefined' ? 'local' : '') + '" data-bind="css: { default: ' + prop + '() === null }">';
      html += _propInput(model, prop, propAccessor, editType, widgets);
      html += '</div>';
      if (typeof globalStyleProp != 'undefined') {
        html += '<div class="propInput global" data-bind="css: { overridden: ' + prop + '() !== null }">';
        html += _propInput(model, prop, globalStyleProp, editType, widgets);
        html += '</div>';

        if (checkboxes) {
          html += '<div class="propCheck"><label data-bind="tooltips: {}"><input type="checkbox" data-bind="focusable: true, click: function(evt, obj) { $root.localGlobalSwitch(' + prop + ', ' + globalStyleProp + '); return true; }, checked: ' + prop + '() !== null">';
          html += '<span class="checkbox-replacer" data-bind="css: { checked: ' + prop + '() !== null }, attr: { title: $root.t(\'This style is specific for this block: click here to remove the custom style and revert to the theme value\') }"></span>';
          html += '</label></div>';
        }
      }
      html += '</div>';
    } else if (model === null || typeof model != 'object') {
      // TODO remove debug output
      html += '<div class="propEditor unknown">[A|' + prop + "|" + typeof model + ']</div>';
    } else {
      // TODO remove debug output
      html += '<div class="propEditor unknown">[B|' + prop + "|" + typeof model + ']</div>';
    }


  }

  if (typeof prop != 'undefined' && !!trackUsage) {
    html += '<!-- /ko -->';
    html += '<!-- ko ifSubs: { not: true, data: ' + ifSubsProp + ', threshold: ' + ifSubsThreshold + ', gutter: 0 } -->';
    html += '<span class="label notused">(' + prop + ')</span>';
    html += '<!-- /ko -->';
  }

  return html;
};


var createBlockEditor = function(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, editType, templateCreator, baseThreshold, trackGlobalStyles, trackUsage, fromLevel) {
  if (typeof trackUsage == 'undefined') trackUsage = true;
  var model = modelDef.getDef(defs, templateName);

  var rootModel = modelDef.getDef(defs, rootModelName);
  var rootPreviewBindings;
  if (typeof rootModel._previewBindings != 'undefined' && templateName != 'thaeme' && editType == 'styler') {
    rootPreviewBindings = elaborateDeclarations(undefined, rootModel._previewBindings, templateUrlConverter, modelDef.getBindValue.bind(undefined, defs, themeUpdater, rootModelName, rootModelName, ''));
  }

  var globalStyles = typeof trackGlobalStyles != 'undefined' && trackGlobalStyles ? defs[templateName]._globalStyles : undefined;
  var globalStyleProp = typeof trackGlobalStyles != 'undefined' && trackGlobalStyles ? defs[templateName]._globalStyle : undefined;


  var themeModel;
  if (typeof globalStyleProp !== 'undefined') {
    var mm = modelDef.getDef(defs, 'theme');
    // TODO remove deprecated $theme
    themeModel = mm[globalStyleProp.replace(/^(\$theme|_theme_)\./, '')];
  }


  var withBindingProvider = modelDef.getBindValue.bind(undefined, defs, themeUpdater, rootModelName, templateName);
  withBindingProvider._templateName = templateName;

  var html = '<div class="editor">';
  html += "<div class=\"blockType" + (typeof globalStyles != 'undefined' ? " withdefaults" : "") + "\">" + model.type + "</div>";

  var editorContent = _propEditor(withBindingProvider, widgets, templateUrlConverter, model, themeModel, "", undefined, editType, fromLevel, baseThreshold, globalStyles, globalStyleProp, trackUsage, rootPreviewBindings);
  if (editorContent.length > 0) {
    html += editorContent;
  }

  html += '</div>';

  templateCreator(html, templateName, editType);
};

var createBlockEditors = function(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, templateCreator, baseThreshold) {
  createBlockEditor(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, 'edit', templateCreator, baseThreshold);
  createBlockEditor(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, 'styler', templateCreator, baseThreshold, true);
};

var generateEditors = function(templateDef, widgets, templateUrlConverter, templateCreator, baseThreshold) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;
  var blocks = templateDef._blocks;
  var idx;
  var blockDefs = [];
  for (idx = 0; idx < blocks.length; idx++) {
    if (typeof blocks[idx].container !== 'undefined') {
      blockDefs.push(modelDef.generateModel(defs, blocks[idx].block));
    }
    createBlockEditors(defs, widgets, undefined, templateUrlConverter, blocks[idx].root, blocks[idx].block, templateCreator, baseThreshold);
  }

  if (typeof defs['theme'] != 'undefined') createBlockEditor(defs, widgets, undefined, templateUrlConverter, templateName, 'theme', 'styler', templateCreator, undefined, false, false, -1);
  return blockDefs;
};

module.exports = generateEditors;

},{"./../../../bower_components/console-browserify/index.js":1,"./declarations.js":67,"./model.js":71,"./utils.js":74}],70:[function(require,module,exports){
"use strict";
/* global global: false */

var modelDef = require("./model.js");

var wrappedResultModel = function(templateDef) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;
  var finalModelContentDef = modelDef.getDef(defs, templateName);

  var finalModelContent = modelDef.generateResultModel(templateDef);

  var wrapper = require("./wrapper.js");
  var res = wrapper(finalModelContent, finalModelContentDef, defs);

  return res;
};

// requires only when imported
var translateTemplate = function() {
  var tt = require('./parser.js');
  return tt.apply(tt, arguments);
};

// requires only when imported
var generateEditors = function() {
  var ge = require('./editor.js');
  return ge.apply(ge, arguments);
};

var checkModel = function() {
  var cm = require('./checkmodel.js');
  return cm.apply(cm, arguments);
};

module.exports = {
  translateTemplate: translateTemplate,
  wrappedResultModel: wrappedResultModel,
  generateResultModel: modelDef.generateResultModel,
  generateEditors: generateEditors,
  checkModel: checkModel
};
},{"./checkmodel.js":66,"./editor.js":69,"./model.js":71,"./parser.js":72,"./wrapper.js":75}],71:[function(require,module,exports){
"use strict";

var objExtend = require("./domutils.js").objExtend;
var console = require("./../../../bower_components/console-browserify/index.js");

var _valueSet = function(defs, model, prop, value) {
  var dotPos = prop.indexOf('.');
  if (dotPos == -1) {
    if (typeof model[prop] == 'undefined') {
      console.log("Undefined prop " + prop + " while setting value " + value + " in model._valueSet");
    } else if (model[prop] === null) {
      if (typeof value == 'object' && value !== null && typeof value.push == 'undefined') console.log("nullpropobjectvalue", prop, value);
      model[prop] = value;
    } else if (typeof model[prop] == 'object' && typeof model[prop].push == 'function') {
      var values;
      if (typeof value === 'string') {
        var valuesString = value.match(/^\[(.*)\]$/);
        if (valuesString !== null) {
          values = valuesString[1].split(',');
        } else {
          throw "Unexpected default value for array property " + prop + ": " + value;
        }
      } else if (typeof value === 'object' && typeof value.push !== 'undefined') {
        values = value;
      } else {
        throw "Unexpected default value for array property " + prop + ": " + value + " typeof " + (typeof value);
      }
      var res = [];
      for (var i = 0; i < values.length; i++) {
        if (values[i].substr(0, 1) == '@') {
          // TODO remove this legacy support (@), so we can remove "defs" from this function, too.
          res.push(_generateModel(defs, values[i].substr(1)));
        } else if (values[i].length > 0) {
          res.push(values[i]);
        }
      }
      model[prop] = res;
    } else if (typeof model[prop] == 'string' || typeof model[prop] == 'boolean') {
      // TODO does this still happen? Debug/test me.
      model[prop] = value;
    } else if (typeof model[prop] == 'object' && model[prop] !== null && typeof model[prop]._widget != 'undefined') {
      if (typeof value == 'object' && value !== null) console.log("objectvalue", prop, model[prop]._widget, value);
      // _data is defined for primitive types
      model[prop] = value;
    } else {
      console.log("setting", typeof model[prop], model[prop], prop, value);
    }
  } else {
    var propName = prop.substr(0, dotPos);
    _valueSet(defs, model[propName], prop.substr(dotPos + 1), value);
  }
};

var _modelCreateOrUpdateBlockDef = function(defs, templateName, properties, namedProperties) {
  if (typeof defs[templateName] !== 'undefined' && defs[templateName]._initialized && !defs[templateName]._writeable) {
    console.log("_modelCreateOrUpdateBlockDef", defs, templateName, properties, namedProperties);
    throw "Trying to alter non writeable model: " + templateName + " / " + properties;
  }

  if (typeof defs[templateName] == 'undefined') {
    defs[templateName] = {
      _writeable: true
    };
    // Fallback computation of "category" depending on the property name
    // TODO remove me: this should be always defined in the template definition, no need to hardcode this stuff.
    if (typeof namedProperties == 'undefined') namedProperties = {};
    if (typeof namedProperties.category == 'undefined' && typeof defs[templateName]._category == 'undefined') {
      if (templateName.match(/(^t|.T)heme$/) || templateName.match(/(^s|.S)tyle$/) || templateName.match(/(^c|.C)olor$/) || templateName.match(/(^r|.R)adius$/)) {
        namedProperties.category = 'style';
      } else {
        namedProperties.category = 'content';
      }
    }
  }


  if (typeof namedProperties !== 'undefined') {
    // TODO check if this is needed before the ending namedProperty "loop" or not.
    if (typeof namedProperties.name != 'undefined') defs[templateName]._name = namedProperties.name;

    if (typeof namedProperties.themeOverride != 'undefined') {
      defs[templateName]._themeOverride = namedProperties.themeOverride;
    }
    if (typeof namedProperties.globalStyle != 'undefined') {
      defs[templateName]._globalStyle = namedProperties.globalStyle;
      // TODO remove deprecated $theme
      var globalStyleSub = namedProperties.globalStyle.replace(/^(\$theme|_theme_)\./, '');
      var p = globalStyleSub.indexOf('.');
      var gs = p != -1 ? globalStyleSub.substr(0, p) : globalStyleSub;
      _modelCreateOrUpdateBlockDef(defs, 'theme', gs);

      if (typeof defs[templateName]._themeOverride === 'undefined' || !!defs[templateName]._themeOverride) {
        _modelCreateOrUpdateBlockDef(defs, templateName, "customStyle=false");
      }
    }
    if (typeof namedProperties.contextName !== 'undefined') {
      defs[templateName]._context = namedProperties.contextName;
      // TODO is it correct to fallback to "bodyTheme" for blocks not declaring a default theme?
      // Maybe it would be better to simply declare it as mandatory but leave the default configutation
      // to the template definition.
      if (namedProperties.contextName == 'block' && typeof defs[templateName]._globalStyle == 'undefined') {
        defs[templateName]._globalStyle = '_theme_.bodyTheme';
        _modelCreateOrUpdateBlockDef(defs, 'theme', 'bodyTheme');

        if (typeof defs[templateName]._themeOverride == 'undefined' || defs[templateName]._themeOverride) {
          _modelCreateOrUpdateBlockDef(defs, templateName, "customStyle=false");
        }
      }
    }
    if (typeof namedProperties.extend != 'undefined') defs[templateName].type = namedProperties.extend;
  }

  for (var np in namedProperties) if (namedProperties.hasOwnProperty(np) && typeof namedProperties[np] !== 'undefined' && ['name', 'extend', 'contextName', 'globalStyle','themeOverride'].indexOf(np) == -1) {
    defs[templateName]['_'+np] = namedProperties[np];
  }

  if (typeof properties != 'undefined' && properties.length > 0) {
    defs[templateName]._props = typeof defs[templateName]._props != 'undefined' && defs[templateName]._props.length > 0 ? defs[templateName]._props + " " + properties : properties;
  }
};

// remove the first "sequence" in a camelcased word (e.g: myCamelCase => camelCase).
var _removePrefix = function(str) {
  var res = str.match(/^[^A-Z]+([A-Z])(.*)$/);
  return res !== null ? res[1].toLowerCase() + res[2] : null;
};

// TODO defs is needed only because _valueSet needs it.. we should remove it downstream.
var _generateModelFromDef = function(modelDef, defs) {
  var res = {};

  for (var prop in modelDef)
    if (!prop.match(/^_.*/) && modelDef.hasOwnProperty(prop)) {
      var value = modelDef[prop];
      if (typeof value == 'object' && value !== null && typeof value._complex != 'undefined' && value._complex) {
        res[prop] = _generateModelFromDef(value, defs);
      } else if (prop == 'type') {
        res[prop] = value;
      } else if (typeof value == 'object') {
        // most times this will be overwritten by _valueSet
        res[prop] = null;
        // for customStyle this is set to null.
      } else {
        console.error("Unexpected model def", prop, value, modelDef);
        throw "Unexpected model def [" + prop + "]=" + value;
      }
    }

  if (typeof modelDef._defaultValues != 'undefined') {
    var defaults = modelDef._defaultValues;
    for (var prop2 in defaults)
      if (defaults.hasOwnProperty(prop2)) {
        _valueSet(defs, res, prop2, defaults[prop2]);
      }
  }

  return res;
};

var _generateModel = function(defs, name) {
  var modelDef = _getModelDef(defs, name, false, true);
  return _generateModelFromDef(modelDef, defs);
};

var _getDef = function(defs, name) {
  return _getModelDef(defs, name, false, true);
};

var _getModelDef = function(defs, name, returnClone, readonly) {
  // lookup "name" in the template definition
  if (typeof defs[name] == 'undefined') {
    // if the name has a space then returns.
    if (name.indexOf(' ') != -1) return null;
    // otherwise try looking up using a deprefixed name.
    var res = _removePrefix(name);
    if (res !== null) {
      // TODO the deprefixing is powerful, but maybe not really needed.
      return _getModelDef(defs, res, returnClone, readonly);
    }
    // not a prefixed name
    // TODO should we raise an error?
    return null;
  } else {
    // when the name is already defined...
    var defObj = defs[name];
    if (typeof defObj != 'object') throw "Block definition must be an object: found " + defObj + " for " + name;

    if (typeof defObj._initialized == 'undefined') {
      // Populate "type" depending on name
      if (typeof defObj.type == 'undefined') {
        if (name.indexOf(' ') == -1) {
          defObj.type = name;
        } else {
          defObj.type = name.substr(name.indexOf(' ') + 1);
        }
      }

      // If it is not a "data" type then let's deal with inheritance
      if (defObj.type != name && typeof defObj._widget == 'undefined') {
        var typeDef = _getModelDef(defs, defObj.type, true);
        var extended = objExtend(typeDef, defObj);
        defObj = extended;
        defs[name] = defObj;
      } else if (typeof defObj._widget == 'undefined' && typeof defObj._props == 'undefined' && typeof defObj._complex == 'undefined') {
        // TODO here I tried to deal with inheritance for every object without a "type" by using a simple deprefix.
        // but this break on theme containing "pageTheme" that would inherit from is parent. (creating a loop)
        /*
        var superType = _removePrefix(defObj.type);
        if (superType !== null) {
          console.log("Extending", typeDef, name, superType, defObj.type);
          var typeDef = _getModelDef(defs, superType, true);
          
          var extended = jQuery.extend(true, typeDef, defObj);
          defObj = extended;
          defs[name] = defObj;
        }
        */
      }
      defObj._writeable = true;
      defObj._initialized = true;
    }

    if (typeof defObj._props != 'undefined') {
      var def = defObj._props;
      def = def.split(" ");

      if (def.length > 0 && typeof defObj._writeable == 'undefined') {
        console.error("Altering a non writable object ", name, def, defObj);
        throw "Altering a non writable object: " + name + " def: " + def;
      }

      if (typeof defObj._processedDefs == 'undefined') {
        defObj._processedDefs = {};
      }

      if (typeof defObj._globalStyles == 'undefined') {
        defObj._globalStyles = {};
      }

      if (typeof defObj._defaultValues == 'undefined') {
        defObj._defaultValues = {};
      }

      for (var i = 0; i < def.length; i++) {
        var prop = def[i];
        if (prop.length === 0) continue;
        var origProp = prop;
        var defValue = null;
        // parses  "prop" "prop=value" and "prop[]" declarations
        var propDef = prop.match(/^([^=\[\]]+)(\[\])?(=?)(.*)$/);
        if (propDef !== null) {
          prop = propDef[1];
          // TODO array definition should be done differently
          if (propDef[2] == '[]') {
            // TODO type should not be defined in this function
            if (typeof defObj[prop] == 'undefined') defObj[prop] = [];
            defValue = [];
          }
          if (propDef[3] == '=') {
            // TODO remove hardcoded "visible" matching (this should be defined in the template definition)
            if (prop.match(/(^v|V)isible$/)) defValue = String(propDef[4]).toLowerCase() == 'true';
            else if (prop.match(/^customStyle$/)) {
              defValue = String(propDef[4]).toLowerCase() == 'true';
            } else defValue = propDef[4];
          }
        }
        // default values found in "properties" are not being processed by "modelEnsureValue" and by consequence do not call "themeUpdater".
        // TODO document why this is needed, or remove.
        if (defValue !== null) {
          if (typeof defObj._defaultValues[prop] == 'undefined') {
            // if (prop.match(/^_/)) console.log("defValue for", prop, "in", name);
            defObj._defaultValues[prop] = defValue;
          }
        }

        if (typeof defObj[prop] == 'undefined') {
          var val = _getModelDef(defs, name + ' ' + prop, true);
          if (val === null) {
            val = _getModelDef(defs, prop, true);
          }
          defObj[prop] = val;
        }

        defObj._processedDefs[prop] = origProp;
        defObj._complex = true;
      }

      delete defObj._props;
    }

    if (returnClone) {
      defObj._writeable = false;
      var cloned = objExtend({}, defObj);
      return cloned;
    } else if (readonly) {
      defObj._writeable = false;
      return defObj;
    } else {
      if (typeof defObj._writeable == 'undefined' || defObj._writeable === false) throw "Retrieving non writeable object definition: " + name;
      return defObj;
    }
  }
};

var _increaseUseCount = function(readonly, model) {
  if (!readonly) {
    if (typeof model._usecount == 'undefined') model._usecount = 0;
    model._usecount++;
  } else if (typeof model._usecount == 'undefined') {
    console.error("ERROR trying to bind an unused property while readonly", model);
    throw "ERROR trying to bind an unused property";
  }
};

var ensureGlobalStyle = function(defs, readonly, gsBindingProvider, modelName, path, gsFullPath, defaultValue, overrideDefault) {

  var globalStyleBindingBindValue = gsBindingProvider(gsFullPath, defaultValue, overrideDefault);

  if (typeof defs[modelName]._globalStyles[path] == 'undefined') {
    if (readonly) throw "Cannot find _globalStyle for " + path + " in " + modelName + "!";
    if (path.indexOf('.') != -1 || (typeof defs[modelName][path] == 'object' && typeof defs[modelName][path]._widget !== 'undefined')) {
      defs[modelName]._globalStyles[path] = globalStyleBindingBindValue;
    }
  } else if (defs[modelName]._globalStyles[path] != globalStyleBindingBindValue) throw "Unexpected conflicting globalStyle [2] for " + modelName + "/" + path + ": old=" + defs[modelName]._globalStyles[path] + " new=" + globalStyleBindingBindValue;
};

// themeUpdater, defaultValue, overrideDefault, setcategory are only used in !readonly mode
var modelEnsurePathAndGetBindValue = function(readonly, defs, themeUpdater, rootModelName, templateName, within, fullPath, defaultValue, overrideDefault, setcategory) {
  var modelName;
  var res;
  var path;
  // TODO remove '$' and '#' handing
  if (fullPath.substr(0, 1) == '$') {
    console.warn("DEPRECATED $ in bindingProvider: ", fullPath, templateName);
    var p = fullPath.indexOf('.');
    if (p == -1) {
      throw "Unexpected fullPath: " + fullPath + "/" + within + "/" + templateName + "/" + defaultValue + "/" + overrideDefault;
    } else {
      modelName = fullPath.substr(1, p - 1);
      path = fullPath.substr(p + 1);
      // TODO refactor me please
      if (modelName == 'theme') {
        var p2 = path.indexOf('.');
        modelName = path.substr(0, p2);
        path = path.substr(p2 + 1);
      } else {
        throw "Unexpected $ sequence: " + modelName + " in " + fullPath;
      }
      res = "$root.content().theme()." + modelName + "()." + path.replace(new RegExp('\\.', 'g'), '().');
    }
  } else if (fullPath.substr(0, 1) == '#') {
    console.warn("DEPRECATED # in bindingProvider: ", fullPath, templateName);
    modelName = rootModelName;
    path = fullPath.substr(1);
    res = "$root.content()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else if (fullPath.substr(0, 8) == '_theme_.') {
    var p3 = fullPath.indexOf('.', 8);
    modelName = fullPath.substr(8, p3 - 8);
    path = fullPath.substr(p3 + 1);
    res = "$root.content().theme()." + modelName + "()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else if (fullPath.substr(0, 7) == '_root_.') {
    modelName = rootModelName;
    path = fullPath.substr(7);
    res = "$root.content()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else {
    modelName = templateName;
    path = within + fullPath;
    res = fullPath.replace(new RegExp('\\.', 'g'), '().');
  }

  if (typeof defs[modelName] === 'undefined') throw "Cannot find model def for [" + modelName + "]";

  var propPos = path.indexOf('.');
  var propName = propPos == -1 ? path : path.substr(0, propPos);

  if (modelName.indexOf('-') != -1) {
    console.error("ERROR cannot use - for block names", modelName);
    throw "ERROR unexpected char in block name: " + modelName;
  }
  if (propName.indexOf('-') != -1) {
    console.error("ERROR cannot use - for property names", propName);
    throw "ERROR unexpected char in property name: " + modelName;
  }

  // Fastpath
  if (readonly) {
    if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] !== 'undefined' && defs[modelName][propName]._category == 'style') {
      res += '._defaultComputed';
    }
    return res;
  }

  // gets the writable model when "!readonly" or the readonly model otherwise
  var model;
  if (readonly) {
    if (typeof defaultValue !== 'undefined') throw "Cannot use defaultValue in readonly mode!";
    if (overrideDefault) throw "Cannot use overrideDefault in readonly mode for " + modelName + "/" + path + "/" + overrideDefault + "!";
    if (typeof setcategory !== 'undefined') throw "Cannot set category for " + modelName + "/" + path + "/" + setcategory + " in readonly mode!";
    model = _getModelDef(defs, modelName, false, true);
  } else {
    if (defs[modelName]._writeable === false) console.log("TODO debug use cases for this condition", modelName, path);
    model = _getModelDef(defs, modelName, defs[modelName]._writeable === false);
  }

  if (model === null) throw "Unexpected model for [" + modelName + "]";

  // if the property does not exists we have to create it.
  if (typeof model[propName] == 'undefined') {
    // when in readonly mode this cannot be done!
    if (readonly) throw "Cannot find path " + propName + " for " + modelName + "!";
    _modelCreateOrUpdateBlockDef(defs, modelName, propName);
    model = _getModelDef(defs, modelName, false);
  }

  // Needs to do this again, because "_modelCreateOrUpdateBlockDef" could have been just created the property (e.g: backgroundColor buttonBlock not getting defaultComputed in template-lm)
  if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] !== 'undefined' && defs[modelName][propName] !== null && defs[modelName][propName]._category == 'style') {
    res += '._defaultComputed';
  }

  var childModel = model;
  try {
    _increaseUseCount(readonly, childModel);
    if (propPos != -1) {
      var mypath = path;
      do {
        var prop = mypath.substr(0, propPos);
        if (typeof childModel[prop] == 'undefined') {
          throw "Found an unexpected prop " + prop + " for model " + modelName + " for " + path;
        }

        childModel = childModel[prop];
        _increaseUseCount(readonly, childModel);
        mypath = mypath.substr(propPos + 1);
        propPos = mypath.indexOf('.');
      } while (propPos != -1);

      if (typeof childModel[mypath] == 'undefined' || childModel[mypath] === null) {
        throw "Found an unexpected path termination " + mypath + " for model " + modelName + " for " + path;
      }
      childModel = childModel[mypath];
    } else {
      childModel = childModel[path];
    }

    if (typeof childModel === 'undefined' || childModel === null) throw "Unexpected null model for " + modelName + "/" + within + "/" + fullPath;

    if (typeof setcategory !== 'undefined') {
      childModel._category = setcategory;
    }

    _increaseUseCount(readonly, childModel);
  } catch (e) {
    console.error("TODO ERROR Property lookup exception", e, modelName, path, templateName, fullPath, defs);
    throw e;
  }

  if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] == 'object' && defs[modelName][propName] !== null && typeof defs[modelName][propName]._category != 'undefined' && defs[modelName][propName]._category == 'style') {
    // TODO can I restrict this code to !readonly mode?
    var gsBindingProvider = modelEnsurePathAndGetBindValue.bind(undefined, readonly, defs, themeUpdater, rootModelName, templateName, '');

    var subPath = path.indexOf('.') != -1 ? path.substr(path.indexOf('.')) : '';

    // The next code supports only properties with one dot (object.property).
    if (subPath.indexOf('.', 1) != -1) throw "TODO unsupported object nesting! " + path;

    var gsPath = defs[modelName]._globalStyle + '.' + propName;
    if (typeof defs[modelName][propName] == 'object' && defs[modelName][propName] !== null && typeof defs[modelName][propName]._globalStyle != 'undefined') {
      gsPath = defs[modelName][propName]._globalStyle;
    }

    ensureGlobalStyle(defs, readonly, gsBindingProvider, modelName, propName, gsPath, undefined, false);

    var gsFullPath = gsPath + subPath;

    if (typeof defaultValue == 'undefined' && defs[modelName]._defaultValues[path] !== null) defaultValue = defs[modelName]._defaultValues[path];

    ensureGlobalStyle(defs, readonly, gsBindingProvider, modelName, path, gsFullPath, defaultValue, overrideDefault);

    if (typeof defaultValue !== 'undefined') {
      if (readonly) {
        console.error("Cannot set a new theme default value", gsFullPath.substr(7), defaultValue, "while in readonly mode");
        throw "Cannot set a new theme default value (" + defaultValue + ") for " + gsFullPath.substr(7) + " while in readonly mode!";
      }
      themeUpdater('default', gsFullPath.substr(7), defaultValue);
    }

    // TODO complex stuff. If the theme uses inheritance we enforce it using with the same value, but this is a limit.
    defaultValue = null;

  }

  if (typeof defaultValue != 'undefined') {
    if (typeof defs[modelName]._defaultValues[path] == 'undefined' || (typeof overrideDefault != 'undefined' && overrideDefault)) {
      if (readonly) throw "Cannot set new _defaultValues [1] for " + path + " in " + modelName + "!";
      defs[modelName]._defaultValues[path] = defaultValue;
    } else {
      if (defaultValue === null) {
        if (readonly && defs[modelName]._defaultValues[path] !== null) {
          throw "Cannot set new _defaultValues [2] for " + path + " in " + modelName + "!";
        }
        // This remove default value. Ugly. (Needs this for defaults in template-lm socialLinksIcon)
        defs[modelName]._defaultValues[path] = null;
      } else if (defs[modelName]._defaultValues[path] != defaultValue) {
        console.error("TODO error!!! Trying to set a new default value for " + modelName + " " + path + " while it already exists (current: " + defs[modelName]._defaultValues[path] + ", new: " + defaultValue + ")");
        throw "Trying to set a new default value for " + modelName + " " + path + " while it already exists (current: " + defs[modelName].defaultValues[path] + ", new: " + defaultValue + ")";
      }
    }
  }

  return res;
};

var generateResultModel = function(templateDef) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;

  var finalModelContent = _generateModel(defs, templateName);

  // TODO ugly to add this manually
  if (typeof defs['theme'] !== 'undefined') {
    finalModelContent.theme = _generateModel(defs, 'theme');
  }

  return finalModelContent;
};

module.exports = {
  // used to compile the template
  ensurePathAndGetBindValue: modelEnsurePathAndGetBindValue.bind(undefined, false),
  // used in runtime the template
  getBindValue: modelEnsurePathAndGetBindValue.bind(undefined, true),
  generateModel: _generateModel,
  generateResultModel: generateResultModel,
  getDef: _getDef,
  createOrUpdateBlockDef: _modelCreateOrUpdateBlockDef
};
},{"./../../../bower_components/console-browserify/index.js":1,"./domutils.js":68}],72:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var converterUtils = require("./utils.js");
var elaborateDeclarations = require("./declarations.js");
var processStylesheetRules = require("./stylesheet.js");
var modelDef = require("./model.js");
var domutils = require("./domutils.js");

var wrapElementWithCondition = function(attribute, element, bindingProvider) {
  var cond = domutils.getAttribute(element, attribute);

  try {
    var binding = converterUtils.conditionBinding(cond, bindingProvider);
    $(element).before('<!-- ko if: ' + binding + ' -->');
    $(element).after('<!-- /ko -->');
    domutils.removeAttribute(element, attribute);
  } catch (e) {
    console.warn("Model ensure path failed in if/variant", element, cond, attribute);
    throw e;
  }

};

var replacedAttributes = function(element, attributeName) {
  domutils.setAttribute(element, attributeName, domutils.getAttribute(element, "replaced" + attributeName));
};

var processStyle = function(element, templateUrlConverter, bindingProvider, addUniqueId) {
  var style = domutils.getAttribute(element, 'replacedstyle');
  var newStyle = null;
  var newBindings;
  if (addUniqueId) newBindings = {
    uniqueId: '$data',
    attr: {
      id: 'id'
    }
  };

  var removeDisplayNone = domutils.getAttribute(element, 'data-ko-display') !== null;

  newStyle = elaborateDeclarations(style, undefined, templateUrlConverter, bindingProvider, element, newBindings, removeDisplayNone);

  // only when using "replaced"
  if (newStyle === null) {
    newStyle = style;
  } else {
    // in case there are no bindings we keep replacedstyle to be used by IE during output
    // otherwise I remove it because it will be overwritten by virtualAttrStyle binding.
    // TODO maybe we better use different names for "replaced" used during template conversion
    // and the ones used to create the output.
    domutils.removeAttribute(element, 'replacedstyle');
  }

  if (newStyle !== null) {
    if (newStyle.trim().length > 0) {
      domutils.setAttribute(element, 'style', newStyle);
    } else domutils.removeAttribute(element, 'style');
  }
};


// TODO fixing URLs is also needed where styles uses path (e.g: background-image, @import)
var _fixRelativePath = function(attribute, templateUrlConverter, index, element) {
  var url = domutils.getAttribute(element, attribute);
  var newUrl = templateUrlConverter(url);
  if (newUrl !== null) {
    domutils.setAttribute(element, attribute, newUrl);
  }
};


var processBlock = function(element, defs, themeUpdater, blockPusher, templateUrlConverter, contextName, rootModelName, containerName, generateUniqueId, templateCreator) {

  try {

  var templateName;
  var variantName = '',
    variantDef = '';
  if (contextName == 'block') {
    templateName = domutils.getAttribute(element, 'data-ko-block');
    domutils.removeAttribute(element, 'data-ko-block');
  } else if (contextName == 'template') {
    templateName = rootModelName;
  } else {
    throw "Unexpected context name while processing block: " + contextName;
  }

  // console.log("processBlock", contextName, rootModelName, containerName, templateName);

  // Remove element
  $('[data-ko-remove]', element).remove();

  var fixedBlocks = $('[data-ko-block]', element).replaceWith('<replacedblock>');

  // Urls in these attributes needs "relativization"
  var urlattrs = ['href', 'src', 'data-ko-placeholder-src', 'background'];
  for (var i = 0; i < urlattrs.length; i++) {
    // faccio il bind per non definire funzioni in un loop (jshint)
    var func = _fixRelativePath.bind(undefined, urlattrs[i], templateUrlConverter);
    $('[' + urlattrs[i] + ']', element).each(func);
  }

  var dataDefs = domutils.getAttribute(element, 'data-ko-properties');
  if (dataDefs === null) dataDefs = "";
  $("[data-ko-properties]", element).each(function(index, element) {
    if (dataDefs.length > 0) dataDefs = dataDefs + " ";
    dataDefs = dataDefs + domutils.getAttribute(element, 'data-ko-properties');
    domutils.removeAttribute(element, 'data-ko-properties');
  });

  modelDef.createOrUpdateBlockDef(defs, templateName, dataDefs, { contextName: contextName });

  var bindingProvider = modelDef.ensurePathAndGetBindValue.bind(undefined, defs, themeUpdater, rootModelName, templateName, '');
  if (contextName == 'block') bindingProvider('id', '');

  $('style', element).each(function(index, element) {
    var style = domutils.getInnerHtml(element);

    var blockDefsUpdater = modelDef.createOrUpdateBlockDef.bind(undefined, defs);
    var localWithBindingProvider = modelDef.ensurePathAndGetBindValue.bind(undefined, defs, themeUpdater, rootModelName);
    var newStyle = processStylesheetRules(style, undefined, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName);

    if (newStyle != style) {
      if (newStyle.trim() !== '') {
        var tmpName = templateCreator(newStyle);
        domutils.setAttribute(element, 'data-bind', 'template: { name: \'' + tmpName + '\' }');
        // ho creato il template quindi posso svuotare il sorgente.
        domutils.setContent(element, '');
      } else {
        // remove empty styles blocks
        domutils.removeElements($(element));
      }
    }
  });

  processStyle(element, templateUrlConverter, bindingProvider, generateUniqueId);

  // TODO href should be supported. data-ko-display and data-ko-wrap should never happen in here.
  var notsupported = ['data-ko-display', 'data-ko-editable', 'data-ko-wrap', 'href'];
  for (var j = 0; j < notsupported.length; j++) {
    var attr = domutils.getAttribute(element, notsupported[j]);
    if (attr) {
      console.warn("ERROR: Unsupported " + notsupported[j] + " used together with data-ko-block", element);
      throw "ERROR: Unsupported " + notsupported[j] + " used together with data-ko-block";
    }
  }

  // simply preprocessed as data-ko-wrap + -ko-attr-href
  $("[data-ko-link]", element).each(function(index, element) {
    var urlVar = domutils.getAttribute(element, 'data-ko-link');
    var repStyle = domutils.getAttribute(element, 'replacedstyle');
    if (typeof repStyle == 'undefined' || repStyle === null) repStyle = '';
    if (repStyle !== '') repStyle = '-ko-attr-href: @' + urlVar + "; " + repStyle;
    else repStyle = '-ko-attr-href: @' + urlVar;
    domutils.setAttribute(element, 'replacedstyle', repStyle);
    domutils.setAttribute(element, 'data-ko-wrap', urlVar);
    domutils.removeAttribute(element, 'data-ko-link');
  });

  $("[replacedstyle]", element).each(function(index, element) {
    processStyle(element, templateUrlConverter, bindingProvider, false);
  });

  $("[replacedhttp-equiv]", element).each(function(index, element) {
    replacedAttributes(element, "http-equiv");
  });

  $("[data-ko-display]", element).each(function(index, element) {
    wrapElementWithCondition('data-ko-display', element, bindingProvider);
  });

  $("[data-ko-editable]", element).each(function(index, element) {
    var newBinding, defaultValue, model, currentBindings, dataBind;


    var dataEditable = domutils.getAttribute(element, "data-ko-editable");

    // TODO add validation of the editable

    var itemBindValue;
    var selectBinding;
    if (dataEditable.lastIndexOf('.') > 0) {
      var subs = dataEditable.substr(0, dataEditable.lastIndexOf('.'));
      itemBindValue = bindingProvider(subs);
    } else {
      itemBindValue = bindingProvider(dataEditable);
    }
    selectBinding = "wysiwygClick: function(obj, evt) { $root.selectItem(" + itemBindValue + ", $data); return false }, clickBubble: false, wysiwygCss: { selecteditem: $root.isSelectedItem(" + itemBindValue + ") }, scrollIntoView: $root.isSelectedItem(" + itemBindValue + ")";

    if (domutils.getLowerTagName(element) != 'img') {


      defaultValue = domutils.getInnerHtml(element);
      var modelBindValue = bindingProvider(dataEditable, defaultValue, true, 'wysiwyg');
      newBinding = "";

      if (!domutils.getAttribute(element, "id")) {
        newBinding += "wysiwygId: id()+'_" + dataEditable.replace('.', '_') + "', ";
      }

      if (typeof selectBinding !== 'undefined') {
        newBinding += selectBinding + ", ";
      }

      newBinding += "wysiwygOrHtml: " + modelBindValue;

      if (domutils.getLowerTagName(element) == 'td') {
        var wrappingDiv = $('<div data-ko-wrap="false" style="width: 100%; height: 100%"></div>')[0];
        domutils.setAttribute(wrappingDiv, 'data-bind', newBinding);
        var newContent = domutils.getInnerHtml($('<div></div>').append(wrappingDiv));
        domutils.setContent(element, newContent);
      } else {
        currentBindings = domutils.getAttribute(element, 'data-bind');
        dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
        domutils.setAttribute(element, 'data-bind', dataBind);
        domutils.setContent(element, '');
      }
      domutils.removeAttribute(element, 'data-ko-editable');
    } else {
      var width = domutils.getAttribute(element, 'width');
      if (width === '') width = null;
      if (width === null) {
        console.error("ERROR: data-ko-editable images must declare a WIDTH attribute!", element);
        throw "ERROR: data-ko-editable images must declare a WIDTH attribute!";
      }
      var height = domutils.getAttribute(element, 'height');
      if (height === '') height = null;

      var align = domutils.getAttribute(element, 'align');

      currentBindings = domutils.getAttribute(element, 'data-bind');

      // TODO this is ugly... maybe a better strategy is to pass this around using "data-" attributes
      var dynHeight = currentBindings && currentBindings.match(/virtualAttr: {[^}]* height: ([^,}]*)[,}]/);
      if (dynHeight) height = dynHeight[1];
      var dynWidth = currentBindings && currentBindings.match(/virtualAttr: {[^}]* width: ([^,}]*)[,}]/);
      if (dynWidth) width = dynWidth[1];

      var method;

      defaultValue = domutils.getAttribute(element, 'data-ko-placeholder-src');
      // TODO make sure this default value is the same as the one checked by img-wysiwyg template.
      var value = '';
      if (defaultValue) {
        value = domutils.getAttribute(element, 'src');
      } else {
        defaultValue = domutils.getAttribute(element, 'src');
      }

      var size;
      if (width && height) {
        size = width + "+'x'+" + height;
      } else if (!height) {
        size = "'w'+" + width + "+''";
      } else if (!width) {
        size = "'h'+" + height + "+''";
      }
      var placeholdersrc;
      var plheight = height || domutils.getAttribute(element, 'data-ko-placeholder-height');
      var plwidth = width || domutils.getAttribute(element, 'data-ko-placeholder-width');

      domutils.removeAttribute(element, 'src');
      domutils.removeAttribute(element, 'data-ko-editable');
      domutils.removeAttribute(element, 'data-ko-placeholder-height');
      domutils.removeAttribute(element, 'data-ko-placeholder-width');
      domutils.removeAttribute(element, 'data-ko-placeholder-src');

      if (defaultValue) {
        placeholdersrc = "{ width: " + plwidth + ", height: " + plheight + ", text: " + size + "}";
      }

      if (!plwidth || !plheight) {
        // TODO raise an exception?
        console.error("IMG data-ko-editable must declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height", element);
        throw "ERROR: IMG data-ko-editable MUST declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height";
      }

      var bindingValue = bindingProvider(dataEditable, value, false, 'wysiwyg');
      newBinding = "wysiwygSrc: { width: " + width + ", height: " + height + ", src: " + bindingValue + ", placeholder: " + placeholdersrc + " }";
      dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
      domutils.setAttribute(element, 'data-bind', dataBind);

      var tmplName = templateCreator(element);

      var containerBind = '{ width: ' + width;
      if (align == 'left') containerBind += ', float: \'left\'';
      else if (align == 'right') containerBind += ', float: \'right\'';
      else if (align == 'center') console.log('non so cosa fa align=center su una img e quindi non so come simularne l\'editing');
      else if (align == 'top') containerBind += ', verticalAlign: \'top\'';
      else if (align == 'middle') containerBind += ', verticalAlign: \'middle\'';
      else if (align == 'bottom') containerBind += ', verticalAlign: \'bottom\'';
      containerBind += '}';

      $(element).before('<!-- ko wysiwygImg: { _data: $data, _item: ' + itemBindValue + ', _template: \'' + tmplName + '\', _editTemplate: \'img-wysiwyg\', _src: ' + bindingValue + ', _width: ' + width + ', _height: ' + height + ', _align: ' + (align === null ? undefined : '\'' + align + '\'') + ', _size: ' + size + ', _method: ' + method + ', _placeholdersrc: ' + placeholdersrc + ', _stylebind: ' + containerBind + ' } -->');
      $(element).after('<!-- /ko -->');
    }

  });

  // Applied after the data-editable so to avoid processing hrefs for editable content
  $("[href]", element).each(function(index, element) {
    var attrValue = domutils.getAttribute(element, 'href');
    var newBinding = 'wysiwygHref: \'' + converterUtils.addSlashes(attrValue) + '\'';
    var currentBindings = domutils.getAttribute(element, 'data-bind');
    var dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
    domutils.setAttribute(element, 'data-bind', dataBind);
  });

  $("replacedblock", element).each(function(index, element) {
    var blockElement = fixedBlocks[index];

    var blockName = processBlock(blockElement, defs, themeUpdater, blockPusher, templateUrlConverter, 'block', templateName, containerName, true, templateCreator);
    // replaced blocks are defined in the model root
    var modelBindValue = modelDef.ensurePathAndGetBindValue(defs, themeUpdater, rootModelName, templateName, '', blockName);

    // this way we call block-wysiwyg or block-show and not directly the right block
    $(element).before('<!-- ko block: { data: ' + converterUtils.addSlashes(modelBindValue) + ', template: \'block\' } -->');
    $(element).after('<!-- /ko -->');
    $(element).remove();
  });

  // TODO do we really need to loop in reverse order?
  // data-ko-wrap have to be processed at the end, expecially after "replaceblocks"
  // otherwise a data-ko-wrap wrapping a data-ko-block would break everything.
  $($("[data-ko-wrap]", element).get().reverse(), element).each(function(index, element) {
    var cond = domutils.getAttribute(element, 'data-ko-wrap');
    if (typeof cond === 'undefined' || cond === '' || cond === 'true') {
      throw "Unsupported empty value for data-ko-wrap: use false value if you want to always remove the tag";
    }

    var condBinding = converterUtils.conditionBinding(cond, bindingProvider);

    /*
          var condBinding = false;
          if (typeof cond === 'undefined' || cond === '') {
            throw "Unsupported empty value for data-ko-wrap: use false value if you want to always remove the tag";
          } else if (cond === 'false') {
            condBinding = false;
          } else if (cond === 'true') {
            throw "Unsupported true value for data-ko-wrap. This makes no sense: use false or a variable";
          } else {
            condBinding = bindingProvider(cond)+'()';
          }
    */

    var dataBind = domutils.getAttribute(element, 'data-bind');

    var innerTmplName, outerTmplName;
    // TODO ugly hardcoded handling: at the very least this should be invoked by the data-container caller.
    if (dataBind !== '' && dataBind !== null && dataBind.match(/(block|wysiwygOrHtml):/)) {
      // we can't put the content in a template because it will be overwritten by the binding
      var innerTmplContent = '<!-- ko ' + dataBind + ' -->' + domutils.getInnerHtml(element) + '<!-- /ko -->';
      innerTmplName = templateCreator(innerTmplContent);
      domutils.removeAttribute(element, 'data-ko-wrap');
      outerTmplName = templateCreator(element);
      domutils.replaceHtml(element, '<!-- ko template: /* special */ (typeof templateMode != \'undefined\' && templateMode == \'wysiwyg\') || ' + condBinding + ' ? \'' + outerTmplName + '\' : \'' + innerTmplName + '\' --><!-- /ko -->');
    } else {
      // we put the content in a template and the frame in another template including this one.
      innerTmplName = templateCreator(domutils.getInnerHtml(element));
      domutils.removeAttribute(element, 'data-ko-wrap');
      domutils.setContent(element, '<!-- ko template: \'' + innerTmplName + '\' --><!-- /ko -->');
      outerTmplName = templateCreator(element);
      domutils.replaceHtml(element, '<!-- ko template: (typeof templateMode != \'undefined\' && templateMode == \'wysiwyg\') || ' + condBinding + ' ? \'' + outerTmplName + '\' : \'' + innerTmplName + '\' --><!-- /ko -->');
    }

  });

  templateCreator(element, templateName, 'show');

  blockPusher(rootModelName, templateName, contextName, containerName);

  return templateName;

  } catch (e) {
    console.error("Exception while parsing the template", e, element);
    throw e;
  }

};

function conditional_replace(html) {
  return html.replace(/<!--\[if ([^\]]*)\]>((?:(?!--)[\s\S])*?)<!\[endif\]-->/g, function(match, condition, body) {
    var dd = '<!-- cc:start -->';
    dd += body.replace(/<([A-Za-z:]+)/g, '<!-- cc:bo:$1 --><cc') // before open tag
           .replace(/<\/([A-Za-z:]+)>/g,'<!-- cc:bc:$1 --></cc><!-- cc:ac:$1 -->') // before/after close tag
           .replace(/\/>/g,'/><!-- cc:sc -->'); // self-close tag
    dd += '<!-- cc:end -->';
    var output = '<replacedcc condition="'+condition+'" style="display: none">';
    output += $('<div>').append($(dd)).html()
      .replace(/^<!-- cc:start -->/, '')
      .replace(/<!-- cc:end -->$/, '');
    output += '</replacedcc>';
    return output;
  });
}


var translateTemplate = function(templateName, html, templateUrlConverter, templateCreator) {
  var defs = {};
  var replacedHtml = conditional_replace(html.replace(/(<[^>]+\s)(style|http-equiv)(="[^"]*"[^>]*>)/gi, function(match, p1, p2, p3) {
    return p1 + 'replaced' + p2 + p3;
  }));
  var content = $(replacedHtml);
  var element = content[0];

  var blocks = []; // {rootName, blockName, containerName}
  var _blockPusher = function(rootName, blockName, contextName, containerName) {
    blocks.push({
      root: rootName,
      block: blockName,
      context: contextName,
      container: containerName
    });
  };

  // TODO have to accept nulls as undefineds (because of model.js behaviour)
  var themeUpdater = function(name, key, val) {
    if (typeof defs['themes'] === 'undefined') defs['themes'] = {};
    if (typeof defs['themes'][name] === 'undefined') defs['themes'][name] = {};
    if (typeof defs['themes'][name][key] === 'undefined' || defs['themes'][name][key] === null) defs['themes'][name][key] = val;
    else if (typeof val !== 'undefined' && val !== null) {
      var precVal = defs['themes'][name][key];
      if (precVal != val) console.log("Error setting a new default for property " + key + " in theme " + name + ". old:" + precVal + " new:" + val + "!");
    }
  };

  var containers = $("[data-ko-container]", content);
  var containersDom = {};
  containers.each(function(index, element) {
    var containerName = domutils.getAttribute(element, 'data-ko-container') + "Blocks";

    domutils.removeAttribute(element, 'data-ko-container');
    domutils.setAttribute(element, 'data-bind', 'block: ' + containerName);

    var containerBlocks = $("> [data-ko-block]", element);
    domutils.removeElements(containerBlocks, true);

    containersDom[containerName] = containerBlocks;
  });

  // TODO remove hardcoded properties: we need them because without these loading a basic template fails.
  // Needed in order to use data-ko-block
  modelDef.createOrUpdateBlockDef(defs, 'id');
  // Needed always as it is the default theme section.
  modelDef.createOrUpdateBlockDef(defs, 'bodyTheme');
  // Needed for data-ko-container
  modelDef.createOrUpdateBlockDef(defs, 'blocks', 'blocks[]');

  // Needed if you want to use a text variable? TODO this should not be needed!
  modelDef.createOrUpdateBlockDef(defs, 'text');

  processBlock(element, defs, themeUpdater, _blockPusher, templateUrlConverter, 'template', templateName, undefined, false, templateCreator);

  var blockProcess = function(containerName, index, element) {
    processBlock(element, defs, themeUpdater, _blockPusher, templateUrlConverter, 'block', templateName, containerName, true, templateCreator);
  };

  for (var prop in containersDom)
    if (containersDom.hasOwnProperty(prop)) {
      var containerBlocks = containersDom[prop];
      var containerName = prop;

      modelDef.ensurePathAndGetBindValue(defs, themeUpdater, templateName, templateName, '', containerName + ".blocks", "[]");

      containerBlocks.each(blockProcess.bind(undefined, containerName));
    }

  var templateDef = {
    _defs: defs,
    templateName: templateName,
    _blocks: blocks
  };

  if (typeof defs[templateName]._version !== 'undefined') {
    templateDef.version = defs[templateName]._version;
  }

  return templateDef;
};


module.exports = translateTemplate;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./declarations.js":67,"./domutils.js":68,"./model.js":71,"./stylesheet.js":73,"./utils.js":74}],73:[function(require,module,exports){
"use strict";

// Parses CSS/stylesheets declarations -ko-blockdefs/-ko-themes
// It returns KO bindings but doesn't depend on KO
// Needs a bindingProvider
// Also uses a blockDefsUpdater to update definitions while parsing the stylesheet.

var cssParse = require("./../../../bower_components/mensch/lib/parser.js");
var console = require("./../../../bower_components/console-browserify/index.js");
var converterUtils = require("./utils.js");
var elaborateDeclarations = require("./declarations.js");

/* Temporary experimental code not used
var _processStyleSheetRules_processThemes = function (bindingProvider, themeUpdater, rules) {
  var sels, decls, i, j, k;
  for( i = 0; i < rules.length; i++) {
    if (rules[i].type == 'rule') {
      sels = rules[i].selectors;
      decls = rules[i].declarations;
      for (j = 0; j < sels.length; j++) {
        for (k = 0; k < decls.length; k++) if (decls[k].type == 'property') {
          try {
            var bindVal = bindingProvider('$'+decls[k].name);
            themeUpdater(sels[j], decls[k].name, decls[k].value, bindVal);
          } catch (e) {
            console.log("Exception setting theme for", decls[k].name, decls[k].value, e);
          }
        }
      }
    }
  }
};
*/

var _processStyleSheetRules_processBlockDef = function(blockDefsUpdater, rules) {
  var properties, namedProps, decls;
  // name, contextName, globalStyle, themeOverride, extend, min, max, widget, options, category, variant, help, blockDescription, version, 
  for (var i = 0; i < rules.length; i++) {
    if (rules[i].type == 'rule') {
      var sels = rules[i].selectors;
      var hasDeclarations = false;
      var hasPreviews = false;
      for (var j = 0; j < sels.length; j++) {
        if (sels[j].match(/:preview$/)) {
          hasPreviews = true;
        } else {
          hasDeclarations = true;
        }
      }
      if (hasPreviews && hasDeclarations) {
        console.log("cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs ", sels);
        throw "Cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs";
      }
      if (!hasPreviews && !hasDeclarations) {
        console.log("cannot find known selectors in @supports -ko-blockdefs ", sels);
        throw "Cannot find known selectors in @supports -ko-blockdefs";
      }
      if (hasDeclarations) {
        properties = '';
        namedProps = {};

/*
        name = undefined;
        contextName = undefined;
        globalStyle = undefined;
        themeOverride = undefined;
        extend = undefined;
        max = undefined;
        min = undefined;
        widget = undefined;
        options = undefined;
        category = undefined;
        variant = undefined;
        help = undefined;
        blockDescription = undefined;
        version = undefined;
        */
        decls = rules[i].declarations;
        for (var k = 0; k < decls.length; k++) if (decls[k].type == 'property') {
          if (decls[k].name == 'label') namedProps.name = decls[k].value;
          else if (decls[k].name == 'context') namedProps.contextName = decls[k].value;
          else if (decls[k].name == 'properties') properties = decls[k].value;
          else if (decls[k].name == 'theme') namedProps.globalStyle = '_theme_.' + decls[k].value;
          else if (decls[k].name == 'themeOverride') namedProps.themeOverride = String(decls[k].value).toLowerCase() == 'true';
          // else if (decls[k].name == 'extend') extend = decls[k].value;

          // else if (decls[k].name == 'max') max = decls[k].value;
          // else if (decls[k].name == 'min') min = decls[k].value;
          // else if (decls[k].name == 'options') options = decls[k].value;

          // else if (decls[k].name == 'widget') widget = decls[k].value;
          // else if (decls[k].name == 'category') category = decls[k].value;
          // else if (decls[k].name == 'variant') variant = decls[k].value;
          // else if (decls[k].name == 'help') help = decls[k].value;
          // else if (decls[k].name == 'blockDescription') blockDescription = decls[k].value;
          // else if (decls[k].name == 'version') version = decls[k].value;
          else {
            namedProps[decls[k].name] = decls[k].value;
            // TODO in past we detected unsupported properties, while now we simple push every declaration in a namedProperty.
            // This make it harder to spot errors in declarations.
            // console.warn("Unknown property processing @supports -ko-blockdefs ", decls[k], sels);
          }
        }
        for (var l = 0; l < sels.length; l++) {
          blockDefsUpdater(sels[l], properties, namedProps);
        }
      }
      if (hasPreviews) {
        for (var m = 0; m < sels.length; m++) {
          var localBlockName = sels[m].substr(0, sels[m].indexOf(':'));
          var previewBindings = rules[i].declarations;
          blockDefsUpdater(localBlockName, undefined, { previewBindings: previewBindings });
        }
      }

    } else {
      // Ignoring comments or other content
    }
  }
};

var processStylesheetRules = function(style, rules, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName) {
  var newStyle = style;
  var lastStart = null;

  if (typeof rules == 'undefined') {
    var styleSheet = cssParse(style, {
      comments: true,
      position: true
    });
    if (styleSheet.type != 'stylesheet' || typeof styleSheet.stylesheet == 'undefined') {
      console.log("unable to process styleSheet", styleSheet);
      throw "Unable to parse stylesheet";
    }
    rules = styleSheet.stylesheet.rules;
  }

  // WARN currenlty this parses rules in reverse order so that string replacements works using input "positions"
  // otherwise it should compute new offsets on every replacement.
  // But this create issues because of definitions being parsed in reverse order, so this is not a good idea.
  // Sometimes, to work around this issues, you need to create 2 different <style> blocks.
  var bindingProvider;

  for (var i = rules.length - 1; i >= 0; i--) {
    if (rules[i].type == 'supports' && rules[i].name == '-ko-blockdefs') {
      _processStyleSheetRules_processBlockDef(blockDefsUpdater, rules[i].rules);
      newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, lastStart, 0, 0, 0, '');
      /* temporary experimental code not used
      } else if (rules[i].type == 'supports' && rules[i].name == '-ko-themes') {
        bindingProvider = localWithBindingProvider.bind(this, 'theme', '');
        _processStyleSheetRules_processThemes(bindingProvider, themeUpdater, rules[i].rules);
        newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, lastStart, 0, 0, 0, '');
      */
    } else if (rules[i].type == 'media' || rules[i].type == 'supports') {
      newStyle = processStylesheetRules(newStyle, rules[i].rules, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName);
    } else if (rules[i].type == 'comment') {
      // ignore comments
    } else if (rules[i].type == 'rule') {
      var sels = rules[i].selectors;
      var newSel = "";
      var foundBlockMatch = null;
      for (var j = 0; j < sels.length; j++) {
        if (newSel.length > 0) newSel += ", ";
        var match = sels[j].match(/\[data-ko-block=([^ ]*)\]/);
        if (match !== null) {
          if (foundBlockMatch !== null && foundBlockMatch != match[1]) throw "Found multiple block-match attribute selectors: cannot translate it (" + foundBlockMatch + " vs " + match[1] + ")";
          foundBlockMatch = match[1];
        }
        newSel += '<!-- ko text: templateMode ==\'wysiwyg\' ? \'#main-wysiwyg-area \' : \'\' --><!-- /ko -->' + sels[j];
      }
      if (foundBlockMatch) {
        var loopPrefix = '<!-- ko foreach: $root.findObjectsOfType($data, \'' + foundBlockMatch + '\') -->';
        var loopPostfix = '<!-- /ko -->';
        var end = lastStart;
        var spacing = " ";
        if (rules[i].declarations.length > 0) {
          if (rules[i].declarations[0].position.start.line != rules[i].position.end.line) {
            spacing = "\n" + (new Array(rules[i].position.start.col)).join(" ");
          }
          end = rules[i].declarations[rules[i].declarations.length - 1].position.end;
        }
        if (end === null) newStyle += spacing + loopPostfix;
        else if (end == lastStart) newStyle = converterUtils.removeStyle(newStyle, end, lastStart, 0, 0, 0, spacing + loopPostfix);
        else newStyle = converterUtils.removeStyle(newStyle, end, lastStart, 0, 0, 0, spacing + '}' + spacing + loopPostfix);
        newSel = loopPrefix + spacing + newSel.replace(new RegExp('\\[data-ko-block=' + foundBlockMatch + '\\]', 'g'), '<!-- ko text: \'#\'+id() -->' + foundBlockMatch + '<!-- /ko -->');

        blockDefsUpdater(foundBlockMatch, '', { contextName: 'block' });
      }
      // TODO mensch update (using original mensch library we needed this line, while the patched one doesn't need this code)
      // newSel += " {";
      var localBlockName = foundBlockMatch ? foundBlockMatch : templateName;
      bindingProvider = localWithBindingProvider.bind(this, localBlockName, '');
      var elaboratedStyle = elaborateDeclarations(newStyle, rules[i].declarations, templateUrlConverter, bindingProvider);
      if (elaboratedStyle !== null) newStyle = elaboratedStyle;

      newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, rules[i].position.end, 0, 0, 0, newSel);
    } else {
      console.log("Unknown rule type", rules[i].type, "while parsing <style> rules");
    }
    lastStart = rules[i].position.start;
  }
  return newStyle;
};

module.exports = processStylesheetRules;
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/mensch/lib/parser.js":15,"./declarations.js":67,"./utils.js":74}],74:[function(require,module,exports){
"use strict";
var console = require("./../../../bower_components/console-browserify/index.js");
var jsep = require("./../../../bower_components/jsep/src/jsep.js");

jsep.addBinaryOp("or", 1);
jsep.addBinaryOp("and", 2);
jsep.addBinaryOp("eq", 6);
jsep.addBinaryOp("neq", 6);
jsep.addBinaryOp("lt", 7);
jsep.addBinaryOp("lte", 7);
jsep.addBinaryOp("gt", 7);
jsep.addBinaryOp("gte", 7);

var addSlashes = function(str) {
  return str.replace(/[\\"']/g, '\\$&').replace(/\u0000/g, '\\0');
};

var removeStyle = function(style, startPos, endPos, skipRows, startOffset, endOffset, insert) {
  var styleRows = style.split("\n");
  var start = startOffset;
  var end = endOffset;
  for (var r = 1 + skipRows; r < startPos.line; r++) start += styleRows[r - 1 - skipRows].length + 1;
  start += startPos.col;
  if (endPos !== null) {
    for (var r2 = 1 + skipRows; r2 < endPos.line; r2++) end += styleRows[r2 - 1 - skipRows].length + 1;
    end += endPos.col;
  } else end += style.length + 1;
  var newStyle = style.substr(0, start - 1) + insert + style.substr(end - 1);
  return newStyle;
};

var expressionGenerator = function(node, bindingProvider, defVal) {
  function mapOperator(op) {
    switch (op) {
      case 'or':
        return '||';
      case 'and':
        return '&&';
      case 'lt':
        return '<';
      case 'lte':
        return '<=';
      case 'gt':
        return '>';
      case 'gte':
        return '>=';
      case 'eq':
        return '==';
      case 'neq':
        return '!=';
      default:
        return op;
    }
  }

  function gen(node, bindingProvider, lookupmember, defVal) {
    if (typeof lookupmember == 'undefined') lookupmember = true;

    if (typeof defVal !== 'undefined' && node.type !== "Identifier" && node.type !== "MemberExpression") console.log("Cannot apply default value to variable when using expressions");

    if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
      return '(' + gen(node.left, bindingProvider, lookupmember) + ' ' + mapOperator(node.operator) + ' ' + gen(node.right, bindingProvider, lookupmember) + ')';
    } else if (node.type === 'CallExpression') {
      var args = node.arguments.map(function(n) {
        return gen(n, bindingProvider, lookupmember);
      });
      return gen(node.callee, bindingProvider, lookupmember) + '(' + args.join(', ') + ')';
    } else if (node.type === "UnaryExpression") {
      return node.operator + gen(node.argument, bindingProvider, lookupmember);
    } else if (node.type == 'MemberExpression' && node.computed) {
      throw "Unexpected computed member expression";
      // return gen(node.object) + '[' + gen(node.property) + ']';
    } else if (node.type == 'MemberExpression' && !node.computed) {
      var me = gen(node.object, bindingProvider, false) + '.' + gen(node.property, bindingProvider, false);
      if (lookupmember && node.object.name !== 'Math' && node.object.name !== 'Color') return bindingProvider(me, defVal) + '()';
      return me;
    } else if (node.type === "Literal") {
      return node.raw;
    } else if (node.type === 'Identifier') {
      var id = node.name;
      if (lookupmember) return bindingProvider(id, defVal) + '()';
      else return id;
    } else if (node.type === 'ConditionalExpression') {
      return '(' + gen(node.test, bindingProvider, lookupmember) + ' ? ' + gen(node.consequent, bindingProvider, lookupmember) + ' : ' + gen(node.alternate, bindingProvider, lookupmember) + ')';
    } else if (node.type === 'Compound') {
      throw "Syntax error in expression: operator expected after " + gen(node.body[0], bindingProvider, false);
    } else {
      throw "Found an unsupported expression type: " + node.type;
    }
  }

  return gen(node, bindingProvider, undefined, defVal);
};

var expressionBinding = function(expression, bindingProvider, defaultValue) {
  var matches;
  if (typeof defaultValue !== 'undefined' && defaultValue !== null) {
    var check = expression.trim().replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b/g, '###var###');
    check = check.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    if (check == '###var###') matches = [null, defaultValue];
    else {
      check = '^' + check.replace(/###var###/g, '(.+)') + '$';
      matches = defaultValue.trim().match(new RegExp(check));
      if (!matches) {
        // TODO throw error?
        console.log("Cannot find matches", matches, "for", defaultValue, expression, check, expression);
        throw "Cannot find default value for " + expression + " in " + defaultValue;
      }
    }
  }
  try {
    var vars = 0;
    var result = "'" + expression.replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b|(')/g, function(match, p1, p2, p3) {
      // escaping..
      if (p3) return "\\" + p3;
      vars++;
      var varName = p1 || p2;
      var defVal;
      if (matches) {
        if (typeof matches[vars] !== 'undefined') {
          defVal = matches[vars].trim();
        } else {
          console.log("ABZZZ Cannot find default value for", varName, "in", matches, "as", vars);
        }
      }
      // in case we found p1 we are in a @[sequence] so we start an expression parser
      if (p1) {
        var parsetree = jsep(p1);
        var gentree = expressionGenerator(parsetree, bindingProvider, defVal);
        return "'+" + gentree + "+'";
      }
      return "'+" + bindingProvider(varName, defVal) + "()+'";
    }) + "'";
    result = result.replace(/(^|[^\\])''\+/g, '$1').replace(/\+''/g, '');

    if (vars === 0 && result !== 'false' && result !== 'true') {
      console.error("Unexpected expression with no valid @variable references", expression);
    }
    return result;
  } catch (e) {
    throw "Exception parsing expression " + expression + " " + e;
  }
};

var conditionBinding = function(condition, bindingProvider) {
  var parsetree = jsep(condition);
  var gentree = expressionGenerator(parsetree, bindingProvider);
  return gentree;
};

module.exports = {
  addSlashes: addSlashes,
  removeStyle: removeStyle,
  conditionBinding: conditionBinding,
  expressionBinding: expressionBinding
};
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/jsep/src/jsep.js":3}],75:[function(require,module,exports){
(function (global){
"use strict";

// This is complex code to handle "live" model instrumentation and dependency tracking.
// This adds _wrap and _unwrap methods to the model and also instrument the block list so to automatically
// wrap/upwrap objects on simple array methods (push, splice)

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kowrap = require("./../../../bower_components/knockout.wrap/knockout.wrap.js");
var console = require("./../../../bower_components/console-browserify/index.js");

var _getOptionsObject = function(options) {
  var optionsCouples = options.split('|');
  var opts = {};
  for (var i = 0; i < optionsCouples.length; i++) {
    var opt = optionsCouples[i].split('=');
    opts[opt[0]] = opt.length > 1 ? opt[1] : opt[0];
  }
  return opts;
};

// generate a computed variable handling the fallback to theme variable
var _makeComputed = function(target, def, nullIfEqual, schemeSelector, themePath, themes) {
  var res = ko.computed({
    'read': function() {
      var val = target();
      if (val === null) {
        var scheme = ko.utils.unwrapObservable(schemeSelector);
        if (typeof scheme == 'undefined' || scheme == 'custom') {
          return ko.utils.unwrapObservable(def);
        } else {
          return themes[scheme][themePath];
        }
      } else {
        return val;
      }
    },
    'write': function(value) {
      var scheme = ko.utils.unwrapObservable(schemeSelector);
      var defVal;
      if (typeof scheme == 'undefined' || scheme == 'custom') {
        defVal = ko.utils.peekObservable(def);
      } else {
        defVal = themes[scheme][themePath];
      }

      if (!!nullIfEqual) {
        if (value == defVal) target(null);
        else target(value);
      } else {
        var current = ko.utils.peekObservable(target);
        if (value != defVal || current !== null) target(value);
      }

    }
  });
  return res;
};

var _nextVariantFunction = function(ko, prop, variants) {
  var currentValue = ko.utils.unwrapObservable(prop);
  var variantValue;

  for (var i = 0; i < variants.length; i++) {
    variantValue = ko.utils.peekObservable(variants[i]);
    if (variantValue == currentValue) break;
  }

  if (i == variants.length) {
    console.warn("Didn't find a variant!", prop, currentValue, variants);
    i = variants.length - 1;
  }

  var nextVariant = i + 1;
  if (nextVariant == variants.length) nextVariant = 0;
  var nextValue = ko.utils.peekObservable(variants[nextVariant]);

  prop(nextValue);
};

var _getVariants = function(def) {
  var variantProp = def._variant;
  var variantOptions;
  if (typeof def[variantProp] !== 'object' || typeof def[variantProp]._widget === 'undefined' || (typeof def[variantProp]._options !== 'string' && def[variantProp]._widget !== 'boolean')) {
    console.error("Unexpected variant declaration", variantProp, def[variantProp]);
    throw "Unexpected variant declaration: cannot find property " + variantProp + " or its _options string and it is not a boolean";
  }
  // TODO I read the "keys" but this is not 100% correct because they are not garanteed to be sorted as in declaration
  if (typeof def[variantProp]._options == 'string') {
    variantOptions = Object.keys(_getOptionsObject(def[variantProp]._options));
  } else {
    variantOptions = [true, false];
  }
  return variantOptions;
};

var _makeComputedFunction = function(def, defs, thms, ko, contentModel, isContent, t) {
  if (typeof def == 'undefined') {
    if (typeof ko.utils.unwrapObservable(t).type === 'undefined') {
      console.log("TODO ERROR Found a non-typed def ", def, t);
      throw "Found a non-typed def " + def;
    }
    var type = ko.utils.unwrapObservable(ko.utils.unwrapObservable(t).type);
    def = defs[type];
    if (typeof def !== 'object') console.log("TODO ERROR Found a non-object def ", def, "for", type);
  }

  if (typeof contentModel == 'undefined' && typeof isContent != 'undefined' && isContent) {
    contentModel = t;
  }

  var selfPath = '$root.content().';

  var pp = def._globalStyles;
  if (typeof pp != 'undefined')
    for (var p in pp)
      if (pp.hasOwnProperty(p)) {
        var schemePathOrig = '$root.content().theme().scheme';
        var schemePath, vm, path;

        if (pp[p].substr(0, selfPath.length) == selfPath) {
          path = pp[p].substr(selfPath.length);
          vm = contentModel;
        } else {
          throw "UNEXPECTED globalStyle path (" + pp[p] + ") outside selfPath (" + selfPath + ")";
        }
        if (schemePathOrig.substr(0, selfPath.length) == selfPath) {
          schemePath = schemePathOrig.substr(selfPath.length);
        } else {
          console.log("IS THIS CORRECT?", schemePathOrig, selfPath);
          schemePath = schemePathOrig;
        }

        var schemeSelector = vm;

        var pathParts = path.split('().');
        var themePath = '';
        var skip = true;
        for (var i = 0; i < pathParts.length; i++) {
          vm = ko.utils.unwrapObservable(vm)[pathParts[i]];
          // ugly thing to find the path to the schema color property (sometimes we have theme.bodyTheme, some other we have content.theme.bodyTheme...)
          if (skip) {
            if (pathParts[i] == 'theme') skip = false;
          } else {
            if (themePath.length > 0) themePath += '.';
            themePath += pathParts[i];
          }
        }

        var schemeParts = schemePath.split('().');
        for (var i3 = 0; i3 < schemeParts.length; i3++) {
          schemeSelector = ko.utils.unwrapObservable(schemeSelector)[schemeParts[i3]];
        }

        var nullIfEqual = true;
        var tParts = p.split('.');
        var target = t;
        for (var i2 = 0; i2 < tParts.length; i2++) {
          target = ko.utils.unwrapObservable(target)[tParts[i2]];
        }

        if (!ko.isObservable(target)) throw "Unexpected non observable target " + p + "/" + themePath;

        target._defaultComputed = _makeComputed(target, vm, nullIfEqual, schemeSelector, themePath, thms);
      }

  if (typeof def._variant != 'undefined') {
    var pParts = def._variant.split('.');
    // looks in t and not contentModel because variants are declared on single blocks.
    var pTarget = t;
    var pParent = ko.utils.unwrapObservable(t);
    for (var i4 = 0; i4 < pParts.length; i4++) {
      pTarget = ko.utils.unwrapObservable(pTarget)[pParts[i4]];
    }
    if (typeof pTarget._defaultComputed != 'undefined') {
      console.log("Found variant on a style property: beware variants should be only used on content properties because they don't match the theme fallback behaviour", def._variant);
      pTarget = pTarget._defaultComputed;
    }
    if (typeof pTarget == 'undefined') {
      console.log("ERROR looking for variant target", def._variant, t);
      throw "ERROR looking for variant target " + def._variant;
    }
    pParent._nextVariant = _nextVariantFunction.bind(pTarget, ko, pTarget, _getVariants(def));
  }

  for (var prop2 in def)
    if (def.hasOwnProperty(prop2)) {
      var val = def[prop2];
      if (typeof val == 'object' && val !== null && typeof val._context != 'undefined' && val._context == 'block') {
        var propVm = contentModel[prop2]();
        var newVm = _makeComputedFunction(defs[prop2], defs, thms, ko, contentModel, isContent, propVm);
        t[prop2](newVm);
      } else if (typeof val == 'object' && val !== null && val.type == 'blocks') {
        var mainVm = contentModel[prop2]();
        var blocksVm = mainVm.blocks();
        var oldBlock, blockType, newBlock;
        for (var ib = 0; ib < blocksVm.length; ib++) {
          oldBlock = ko.utils.unwrapObservable(blocksVm[ib]);
          blockType = ko.utils.unwrapObservable(oldBlock.type);
          newBlock = _makeComputedFunction(defs[blockType], defs, thms, ko, contentModel, isContent, oldBlock);
          blocksVm[ib](newBlock);
        }

        var blocksObs = mainVm.blocks;

        _augmentBlocksObservable(blocksObs, _blockInstrumentFunction.bind(mainVm, undefined, defs, thms, ko, undefined, contentModel, isContent));

        contentModel[prop2]._wrap = _makeBlocksWrap.bind(contentModel[prop2], blocksObs._instrumentBlock);
        contentModel[prop2]._unwrap = _unwrap.bind(contentModel[prop2]);
      }
    }

  return t;
};

var _augmentBlocksObservable = function(blocksObs, instrument) {
  blocksObs._instrumentBlock = instrument;
  if (typeof blocksObs.origPush == 'undefined') {
    blocksObs.origPush = blocksObs.push;
    blocksObs.push = _makePush.bind(blocksObs);
    blocksObs.origSplice = blocksObs.splice;
    blocksObs.splice = _makeSplice.bind(blocksObs);
  }
};

var _makeBlocksWrap = function(instrument, inputModel) {
  var model = ko.toJS(inputModel);
  var input = model.blocks;
  model.blocks = [];
  var res = kowrap.fromJS(model, undefined, true)();
  _augmentBlocksObservable(res.blocks, instrument);
  for (var i = 0; i < input.length; i++) {
    var obj = ko.toJS(input[i]);
    // console.log("_makeBlocksWrap set blockId", obj.id, 'block_'+i);
    obj.id = 'block_' + i;
    res.blocks.push(obj);
  }
  this(res);
};

var _makePush = function() {
  if (arguments.length > 1) throw "Array push with multiple arguments not implemented";
  // unwrap observable blocks, otherwise visibility (dependency) handling breaks
  if (arguments.length > 0 && ko.isObservable(arguments[0])) {
    if (typeof arguments[0]._unwrap == 'function') {
      arguments[0] = arguments[0]._unwrap();
    } else {
      console.log("WARN: pushing observable with no _unwrap function (TODO remove me, expected condition)");
    }
  }
  if (!ko.isObservable(arguments[0])) {
    var instrumented = this._instrumentBlock(arguments[0]);
    return this.origPush.apply(this, [instrumented]);
  } else {
    return this.origPush.apply(this, arguments);
  }
};

var _makeSplice = function() {
  if (arguments.length > 3) throw "Array splice with multiple objects not implemented";
  if (arguments.length > 2 && ko.isObservable(arguments[2])) {
    if (typeof arguments[2]._unwrap == 'function') {
      arguments[2] = arguments[2]._unwrap();
    } else {
      console.log("WARN: splicing observable with no _unwrap function (TODO remove me, expected condition)");
    }
  }
  if (arguments.length > 2 && !ko.isObservable(arguments[2])) {
    var instrumented = this._instrumentBlock(arguments[2]);
    return this.origSplice.apply(this, [arguments[0], arguments[1], instrumented]);
  } else {
    return this.origSplice.apply(this, arguments);
  }
};

// def, defs and themes are bound in "_modelInstrument" while the next parameters are exposed by this module
var _blockInstrumentFunction = function(def, defs, themes, knockout, self, modelContent, isContent, self2) {
  // ugly: sometimes we have to bind content but not self, so we repeat self at the end as "self2"
  if (typeof self == 'undefined') self = self2;

  var computedFunctions;
  computedFunctions = {
    '': _makeComputedFunction.bind(self, def, defs, themes, knockout, modelContent, isContent)
  };

  var res = kowrap.fromJS(self, computedFunctions, true);
  res._unwrap = _unwrap.bind(res);
  return res;
};

var _wrap = function(instrument, unwrapped) {
  var newContent = ko.utils.unwrapObservable(instrument(ko, unwrapped, undefined, true));
  this(newContent);
};

var _unwrap = function() {
  return ko.toJS(this);
};

var _modelInstrument = function(model, modelDef, defs) {
  var _instrument = _blockInstrumentFunction.bind(undefined, modelDef, defs, defs['themes']);
  var res = _instrument(ko, model, undefined, true);
  // res._instrument = _instrument;
  res._wrap = _wrap.bind(res, _instrument);
  res._unwrap = _unwrap.bind(res);
  return res;
};

module.exports = _modelInstrument;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/knockout.wrap/knockout.wrap.js":10}],76:[function(require,module,exports){
(function (global){
var tinycolor = require("./../../../bower_components/tinycolor/tinycolor.js");

function Color(tinycolor) {
  this.getBrightness = function(color) {
    return tinycolor(color).getBrightness();
  };
  this.isLight = function(color) {
    return tinycolor(color).isLight();
  };
  this.isDark = function(color) {
    return tinycolor(color).isDark();
  };
  this.getLuminance = function(color) {
    return tinycolor(color).getLuminance();
  };


  this.lighten = function(color, amount) {
    return tinycolor(color).lighten(amount).toHexString();
  };
  this.brighten = function(color, amount) {
    return tinycolor(color).brighten(amount).toHexString();
  };
  this.darken = function(color, amount) {
    return tinycolor(color).darken(amount).toHexString();
  };
  this.desaturate = function(color, amount) {
    return tinycolor(color).desaturate(amount).toHexString();
  };
  this.saturate = function(color, amount) {
    return tinycolor(color).saturate(amount).toHexString();
  };
  this.greyscale = function(color) {
    return tinycolor(color).greyscale().toHexString();
  };
  this.spin = function(color, amount) {
    return tinycolor(color).spin(amount).toHexString();
  };
  this.complement = function(color) {
    return tinycolor(color).complement().toHexString();
  };

  this.mix = tinycolor.mix;
  this.readability = tinycolor.readability;
  this.isReadable = tinycolor.isReadable;
  this.mostReadable = tinycolor.mostReadable;
}

var colorPlugin = function(vm) {
  global.Color = new Color(tinycolor);
};

module.exports = colorPlugin;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/tinycolor/tinycolor.js":18}],77:[function(require,module,exports){
(function (global){
'use strict';

var $ = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;
var console = require("./../../../bower_components/console-browserify/index.js");

function handleMailingName(viewModel) {
  var originalValue;
  viewModel.titleMode = ko.observable('show');
  viewModel.metadata.name = ko.observable(viewModel.metadata.name);

  viewModel.mailingName = ko.computed(function () {
    return viewModel.metadata.name();
  }, viewModel);

  viewModel.enableEditMailingName = function (data, event) {
    console.log('enableEditMailingName', data);
    originalValue = viewModel.metadata.name();
    viewModel.titleMode('edit');
  };

  viewModel.cancelEditMailingName = function (data, event) {
    console.log('cancelEditMailingName');
    viewModel.metadata.name(originalValue);
    originalValue = '';
    viewModel.titleMode('show');
  };

  viewModel.saveEditMailingName = function (data, event) {
    console.log('saveEditMailingName', viewModel.metadata.name());
    viewModel.titleMode('saving');
    viewModel.notifier.info(viewModel.t('edit-title-ajax-pending'));

    $.ajax({
      method: 'POST',
      url: viewModel.metadata.url.update,
      data: {
        name: viewModel.metadata.name()
      },
      success: function success(mosaicoMailing) {
        viewModel.metadata.name(mosaicoMailing.meta.name);
        viewModel.notifier.success(viewModel.t('edit-title-ajax-success'));
      },
      error: function error() {
        viewModel.notifier.error(viewModel.t('edit-title-ajax-fail'));
      },
      complete: function complete() {
        originalValue = '';
        viewModel.titleMode('show');
      }
    });
  };
}

module.exports = handleMailingName;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],78:[function(require,module,exports){
(function (global){
'use strict';

var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;
var url = require('url');
var slugFilename = require('../../../shared/slug-filename.js');

// https://github.com/voidlabs/mosaico/wiki/Mosaico-Plugins

//////
// VIEW-MODEL PLUGINS
//////

var serverStorage = require('./custom-server-storage');
var editTitle = require('./custom-edit-title');
var textEditor = require('./custom-text-editor');
var gallery = require('./custom-gallery');
var removeImage = require('./custom-remove-gallery-image');
// widgets
// https://github.com/voidlabs/mosaico/wiki/Mosaico-Plugins#widget-plugins
var widgetBgimage = require('./custom-widget-bgimage');

var setEditorIcon = function setEditorIcon(opts) {
  return function (viewModel) {
    viewModel.logoPath = false;
    viewModel.logoUrl = false;
    viewModel.logoAlt = false;
    viewModel.brandName = opts.brandName;
  };
};

function extendViewModel(opts, customExtensions) {
  customExtensions.push(serverStorage);
  customExtensions.push(setEditorIcon(opts));
  customExtensions.push(editTitle);
  customExtensions.push(gallery(opts));
  customExtensions.push(removeImage);
  // widget should be differenciating of VM extentions by
  // template-loader.js#pluginsCall
  customExtensions.push(widgetBgimage(opts));
}

//////
// KNOCKOUT EXTEND
//////

function templateUrlConverter(opts) {
  var assets = opts.metadata.assets || {};
  return function customTemplateUrlConverter(url) {
    if (!url) return null;
    console.log('customTemplateUrlConverter', url);
    // handle: [unsubscribe_link] or mailto:[mail]
    if (/\]$/.test(url)) return null;
    // handle absolute url: http
    if (/^http/.test(url)) return null;
    // handle ESP tags: in URL <%
    if (/<%/.test(url)) return null;
    // handle other urls: img/social_def/twitter_ok.png
    var urlRegexp = /([^\/]*)$/;
    var extentionRegexp = /\.[0-9a-z]+$/;
    // as it is done, all files are flatten in asset folder (uploads or S3)
    url = urlRegexp.exec(url)[1];
    // handle every other case:
    //   *|UNSUB|*
    //   #pouic
    if (!extentionRegexp.test(url)) return null;
    console.log('customTemplateUrlConverter', url);
    // All images at uploaded are renamed with md5
    //    block thumbnails are based on html block ID
    //    => we need to maintain a dictionary of name -> md5 name
    //    here come the assets block
    // we still keep the slug part for backward compatibility reason with old image name conventions
    url = slugFilename(url);
    url = assets[url] ? opts.imgProcessorBackend + assets[url] : null;
    return url;
  };
}

// knockout is a global object.
// So we can extend it easily

// this equivalent to the original app.js#applyBindingOptions
function extendKnockout(opts) {

  //----- TINYMCE

  // Change tinyMCE full editor options
  if (opts.lang === 'fr') {
    textEditor.language_url = '/tinymce-langs/fr_FR.js';
    textEditor.language = 'fr_FR';
    tinymce.util.I18n.add('fr_FR', {
      'Cancel': 'Annuler',
      'in pixel': 'en pixel',
      'Enter a font-size': 'Entrez une taille de police',
      'Letter spacing': 'Interlettrage',
      'Font size': 'Taille de police',
      'Font size: ': 'Taille : ',
      'minimum size: 8px': 'taille minimum : 8px',
      'no decimals': 'pas de décimales'
    });
  }
  //- https://www.tinymce.com/docs/configure/url-handling/#convert_urls
  textEditor = $.extend({ convert_urls: false }, textEditor, opts.tinymce);
  ko.bindingHandlers.wysiwyg.fullOptions = textEditor;

  // mirror options to the small version of tinymce
  ko.bindingHandlers.wysiwyg.standardOptions = {
    convert_urls: false,
    external_plugins: {
      paste: textEditor.external_plugins.paste
    },
    theme_url: textEditor.theme_url,
    skin_url: textEditor.skin_url

    //----- URLS HANDLING

    // This is not used by knockout per se.
    // Store this function in KO global object so it can be accessed by template-loader.js#templateLoader
    // customTemplateUrlConverter is used:
    //  - for preview images on left bar
    //  - for static links in templates
  };ko.bindingHandlers.wysiwygSrc.templateUrlConverter = templateUrlConverter(opts);

  // options have been set in the editor template
  var imgProcessorBackend = url.parse(opts.imgProcessorBackend);

  // send the non-resized image url
  ko.bindingHandlers.fileupload.remoteFilePreprocessor = function (file) {
    console.info('REMOTE FILE PREPROCESSOR');
    console.log(file);
    var fileUrl = url.format({
      protocol: imgProcessorBackend.protocol,
      host: imgProcessorBackend.host,
      pathname: imgProcessorBackend.pathname
    });
    file.url = url.resolve(fileUrl, url.parse(file.url).pathname);
    return file;
  };

  // push "convertedUrl" method to the wysiwygSrc binding
  ko.bindingHandlers.wysiwygSrc.convertedUrl = function (src, method, width, height) {
    var imageName = url.parse(src).pathname;
    if (!imageName) console.warn('no pathname for image', src);
    console.info('CONVERTED URL', imageName, method, width, height);
    imageName = imageName.replace('/img/', '');
    var path = opts.basePath + '/' + method;
    path = path + '/' + width + 'x' + height + '/' + imageName;
    return path;
  };

  ko.bindingHandlers.wysiwygSrc.placeholderUrl = function (width, height, text) {
    // console.info('PLACEHOLDER URL', width, height, text)
    return opts.basePath + '/placeholder/' + width + 'x' + height + '.png';
  };
}

module.exports = {
  extendViewModel: extendViewModel,
  extendKnockout: extendKnockout
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../shared/slug-filename.js":43,"./custom-edit-title":77,"./custom-gallery":79,"./custom-remove-gallery-image":80,"./custom-server-storage":81,"./custom-text-editor":82,"./custom-widget-bgimage":83,"url":33}],79:[function(require,module,exports){
(function (global){
'use strict';

var console = require("./../../../bower_components/console-browserify/index.js");
var $ = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;
var _find = require('lodash.find');

function galleryLoader(opts) {

  var galleryUrl = opts.fileuploadConfig.url;

  return function (viewModel) {

    viewModel.mailingGallery = ko.observableArray([]);
    viewModel.templateGallery = ko.observableArray([]);
    viewModel.mailingGalleryStatus = ko.observable(false);
    viewModel.templateGalleryStatus = ko.observable(false);

    function loadGallery(type) {
      var url = galleryUrl[type];
      var gallery = viewModel[type + 'Gallery'];
      var status = viewModel[type + 'GalleryStatus'];
      return function () {
        status('loading');
        // retrieve the full list of remote files
        $.getJSON(url, function (data) {
          for (var i = 0; i < data.files.length; i++) {
            data.files[i] = viewModel.remoteFileProcessor(data.files[i]);
          }status(data.files.length);
          gallery(data.files.reverse());
        }).fail(function () {
          status(false);
          viewModel.notifier.error(viewModel.t('Unexpected error listing files'));
        });
      };
    }

    // this is used as a paramater in fileupload binding
    // see toolbox.tmpl.html `#toolimagesgallery fileupload`
    // fileupload binding will iterate on every uploaded file and call this callback
    // fileupload.js => e.type == 'fileuploaddone' for more details
    function loadImage(type) {
      var gallery = viewModel[type + 'Gallery'];
      var status = viewModel[type + 'GalleryStatus'];
      return function (img) {
        var imageName = img.name;
        // call gallery(), because it is a knockout observable and not a real array
        // Don't show twice the same image
        var isAlreadyUploaded = _find(gallery(), function (file) {
          return file.name === imageName;
        });
        if (isAlreadyUploaded) return;
        // Don't update the gallery until it has been opened once
        // This was leading to preventing the whole gallery to be fetched…
        // …if we had uploaded an image in the editor
        if (status() === false) return;
        gallery.unshift(img);
        status(gallery().length);
      };
    }

    viewModel.loadMailingGallery = loadGallery('mailing');
    viewModel.loadTemplateGallery = loadGallery('template');
    viewModel.loadMailingImage = loadImage('mailing');
    viewModel.loadTemplateImage = loadImage('template');

    var galleryOpen = viewModel.showGallery.subscribe(function (newValue) {
      if (newValue === true && viewModel.mailingGalleryStatus() === false) {
        viewModel.loadMailingGallery();
        galleryOpen.dispose();
      }
    });

    var tabChange = viewModel.selectedImageTab.subscribe(function (newValue) {
      if (newValue === 1 && viewModel.templateGalleryStatus() === false) {
        viewModel.loadTemplateGallery();
        tabChange.dispose();
      }
    }, viewModel, 'change');
  };
}

module.exports = galleryLoader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"lodash.find":23}],80:[function(require,module,exports){
(function (global){
'use strict';

var console = require("./../../../bower_components/console-browserify/index.js");
var $ = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;

function removeGalleryImage(viewModel) {

  viewModel.removeImage = function (data, type, event) {
    var deleteUrl = data.deleteUrl;

    $.ajax({
      url: deleteUrl,
      method: 'DELETE',
      // `type` options is an alias for `method` option.
      // Use `type` because `method` is not supported jQuery prior to 1.9.0.
      // actual bower version is 1.12.4 :(
      type: 'DELETE',
      success: function success(res) {
        viewModel.notifier.success(viewModel.t('gallery-remove-image-success'));
        var gallery = viewModel[type + 'Gallery'];
        var status = viewModel[type + 'GalleryStatus'];
        status(res.files.length);
        gallery(res.files.reverse());
      },
      error: function error(err) {
        console.log(err);
        viewModel.notifier.error(viewModel.t('gallery-remove-image-fail'));
      }
    });
  };
}

module.exports = removeGalleryImage;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],81:[function(require,module,exports){
(function (global){
'use strict';

var console = require("./../../../bower_components/console-browserify/index.js");
var $ = typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null;
var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;
var _omit = require('lodash.omit');
var isEmail = require('validator/lib/isEmail');

function getData(viewModel) {
  // gather meta
  // remove keys that aren't necessary to update
  var datas = _omit(ko.toJS(viewModel.metadata), ['urlConverter', 'template']);
  datas.data = viewModel.exportJS();
  return datas;
}

var loader = function loader(viewModel) {
  console.info('init server storage (save, test, download)');

  //////
  // SAVE
  //////

  var saveCmd = {
    name: 'Save', // l10n happens in the template
    enabled: ko.observable(true)
  };
  saveCmd.execute = function () {
    saveCmd.enabled(false);
    var data = getData(viewModel);
    console.info('SAVE DATA');
    console.log(data);

    // force JSON for bodyparser to catch up
    // => keep types server side
    $.ajax({
      url: window.location.href,
      method: 'POST',
      contentType: 'application/json',
      data: JSON.stringify(data),
      success: onPostSuccess,
      error: onPostError,
      complete: onPostComplete
    });

    // use callback for easier jQuery updates
    // => Deprecation notice for .success(), .error(), and .complete()
    function onPostSuccess(data, textStatus, jqXHR) {
      console.log('save success');
      viewModel.notifier.success(viewModel.t('save-message-success'));
    }

    function onPostError(jqXHR, textStatus, errorThrown) {
      console.log('save error');
      console.log(errorThrown);
      viewModel.notifier.error(viewModel.t('save-message-error'));
    }

    function onPostComplete() {
      saveCmd.enabled(true);
    }
  };

  //////
  // EMAIL
  //////

  var testCmd = {
    name: 'Test', // l10n happens in the template
    enabled: ko.observable(true)
  };
  testCmd.execute = function () {
    console.info('TEST');
    console.log(viewModel.metadata.url.send);
    testCmd.enabled(false);
    var email = viewModel.t('Insert here the recipient email address');
    email = global.prompt(viewModel.t("Test email address"), email);

    // Don't validate `null` values => isEmail will error
    if (!email) return testCmd.enabled(true);

    if (!isEmail(email)) {
      global.alert(viewModel.t('Invalid email address'));
      return testCmd.enabled(true);
    }

    console.log("TODO testing...", email);
    var metadata = ko.toJS(viewModel.metadata);
    var datas = {
      rcpt: email,
      html: viewModel.exportHTML()
    };
    $.ajax({
      url: viewModel.metadata.url.send,
      method: 'POST',
      data: datas,
      success: onTestSuccess,
      error: onTestError,
      complete: onTestComplete
    });

    function onTestSuccess(data, textStatus, jqXHR) {
      console.log('test success');
      viewModel.notifier.success(viewModel.t("Test email sent..."));
    }

    function onTestError(jqXHR, textStatus, errorThrown) {
      console.log('test error');
      console.log(errorThrown);
      viewModel.notifier.error(viewModel.t('Unexpected error talking to server: contact us!'));
    }

    function onTestComplete() {
      testCmd.enabled(true);
    }
  };

  //////
  // ZIP
  //////

  var downloadCmd = {
    name: 'Download', // l10n happens in the template
    enabled: ko.observable(true)
  };
  downloadCmd.execute = function () {
    console.info('DOWNLOAD');
    downloadCmd.enabled(false);
    viewModel.notifier.info(viewModel.t("Downloading..."));
    viewModel.exportHTMLtoTextarea('#downloadHtmlTextarea');
    $('#downloadHtmlFilename').val(viewModel.metadata.name());
    $('#downloadForm').attr('action', viewModel.metadata.url.zip).submit();
    downloadCmd.enabled(true);
  };

  viewModel.save = saveCmd;
  viewModel.test = testCmd;
  viewModel.download = downloadCmd;
};

module.exports = loader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"lodash.omit":24,"validator/lib/isEmail":39}],82:[function(require,module,exports){
'use strict';

var debounce = require('lodash.debounce');

//////
// DEFINE TINYMCE CUSTOM PLUGINS
//////

//----- LETTER SPACING

// convert a fibonacci suite to em
var defaults = [0, 1, 2, 3, 5, 8, 13].map(function (e) {
  return Math.round(e * 0.1 * 100) / 100;
}).map(function (i) {
  return i + '=' + i + 'em';
}).join(' ');

tinymce.PluginManager.add('spacing', addLetterSpacing);

function addLetterSpacing(editor, url) {
  editor.addButton('letterspacingselect', function () {
    var formats = editor.settings.spacing_formats || defaults;
    var items = formats.split(' ').map(function (item) {
      var text = item;
      var value = item;
      // Allow text=value font sizes.
      var values = item.split('=');
      if (values.length > 1) {
        text = values[0];
        value = values[1];
      }
      return { text: text, value: value };
    });

    function setLetterSpacing(e) {
      if (!e.control.settings.value) return;
      tinymce.activeEditor.formatter.register('letter-spacing', {
        inline: 'span',
        styles: { 'letter-spacing': e.control.settings.value }
      });
      tinymce.activeEditor.formatter.apply('letter-spacing');
    }

    return {
      type: 'listbox',
      text: 'Letter spacing',
      tooltip: 'Letter spacing',
      values: items,
      fixedWidth: true,
      onclick: setLetterSpacing
    };
  });
}

//----- FREE FONT SIZE

// Util function copied from Tiny MCE
function each(o, cb, s) {
  var n, l;

  if (!o) {
    return 0;
  }

  s = s || o;

  if (o.length !== undefined) {
    // Indexed arrays, needed for Safari
    for (n = 0, l = o.length; n < l; n++) {
      if (cb.call(s, o[n], n, o) === false) {
        return 0;
      }
    }
  } else {
    // Hashtables
    for (n in o) {
      if (o.hasOwnProperty(n)) {
        if (cb.call(s, o[n], n, o) === false) {
          return 0;
        }
      }
    }
  }

  return 1;
}

// inspired by tinymce.js#44265
tinymce.PluginManager.add('fontsizedialog', fontsizedialog);

function fontsizedialog(editor, url) {
  console.dir(editor);
  var fontSizeMin = 8;
  var fontSizeMax = 666;
  var selectionFs = false;
  var dialogHelpText = [tinymce.util.I18n.translate('minimum size: 8px'), tinymce.util.I18n.translate('no decimals')].map(function (t) {
    return '• ' + t;
  }).join('<br>');

  editor.addButton('fontsizedialogbutton', {
    text: 'Font size',
    tooltip: 'Font size',
    // add a class to fix button width
    // Haven't found a way to update toolbar size dynamically
    // iterating over https://www.tinymce.com/docs/api/tinymce.ui/tinymce.ui.button/#parents
    // and calling .reflow() doesn't make the trick
    classes: 'fontsizedialogbutton',
    icon: false,
    onPostRender: afterBtnInit,
    onclick: openFsDialog
  });

  function afterBtnInit(initEvent) {
    var btnInstance = initEvent.control;
    var formatName = 'fontsize';
    var self = this;

    editor.on('nodeChange', debounce(onNodeChange, 150));

    function onNodeChange(e) {
      each(e.parents, getFontSize);
      if (!selectionFs) {
        selectionFs = document.defaultView.getComputedStyle(e.parents[0] || e.element, null).getPropertyValue('font-size');
      }
    }

    function getFontSize(node) {
      if (node.style && node.style.fontSize) {
        btnInstance.text(tinymce.util.I18n.translate('Font size: ') + node.style.fontSize);
        selectionFs = node.style.fontSize;
        return false;
      }
      selectionFs = false;
      btnInstance.text(tinymce.util.I18n.translate('Font size'));
    }
  }

  function openFsDialog(btnEvent) {
    var initValue = selectionFs ? /^(\d+)/.exec(selectionFs) : null;
    initValue = Array.isArray(initValue) ? initValue[0] : '';

    editor.windowManager.open({
      title: 'Enter a font-size',
      width: 320,
      height: 120,
      body: [{
        type: 'label',
        multiline: true,
        text: '',
        // multiline “hack” from:
        // http://www.devsumo.com/technotes/2014/07/tinymce-4-multi-line-labels-in-popup-dialogs/
        onPostRender: function onPostRender() {
          this.getEl().innerHTML = dialogHelpText;
        }
      }, {
        type: 'textbox',
        name: 'bsdialogfontsize',
        label: 'in pixel',
        autofocus: true,
        value: initValue,
        onPostRender: function onPostRender() {
          this.$el.attr({
            type: 'number',
            min: fontSizeMin,
            step: 1
          });
        }
      }],
      onsubmit: function onsubmit(e) {
        var newFontSize = ~~e.data.bsdialogfontsize;
        if (newFontSize >= fontSizeMin && newFontSize <= fontSizeMax) {
          editor.execCommand('FontSize', false, newFontSize + 'px');
        } else {
          // tinyMCE notifications are very small…
          // no need to put them for now
          // editor.notificationManager.open({
          //   text: 'Invalid font size',
          //   type: 'error',
          // })
        }
      }
    });
  }
}

//////
// CONFIGURATION
//////

var tinymceConfigFull = {
  toolbar1: 'bold italic forecolor backcolor hr | fontsizedialogbutton styleselect letterspacingselect removeformat | link unlink | pastetext code',
  //- add colorpicker & custom plugins
  //- https://www.tinymce.com/docs/plugins/colorpicker/
  plugins: ["link hr paste lists textcolor colorpicker code spacing fontsizedialog"],
  //- https://www.tinymce.com/docs/configure/content-formatting/#style_formats
  style_formats: [{ title: 'Inline', items: [{ title: 'Bold', icon: "bold", inline: 'strong' }, { title: 'Italic', icon: "italic", inline: 'em' }, { title: 'Underline', icon: "underline", inline: 'span', styles: { 'text-decoration': 'underline' } }, { title: 'Strikethrough', icon: "strikethrough", inline: 'span', styles: { 'text-decoration': 'line-through' } }, { title: 'Superscript', icon: "superscript", inline: 'sup' }, { title: 'Subscript', icon: "subscript", inline: 'sub' }, { title: 'Code', icon: "code", inline: 'code' }] }, { title: 'Alignment', items: [{ title: 'Left', icon: "alignleft", block: 'div', styles: { 'text-align': 'left' } }, { title: 'Center', icon: "aligncenter", block: 'div', styles: { 'text-align': 'center' } }, { title: 'Right', icon: "alignright", block: 'div', styles: { 'text-align': 'right' } }, { title: 'Justify', icon: "alignjustify", block: 'div', styles: { 'text-align': 'justify' } }] }]
};

module.exports = tinymceConfigFull;

},{"lodash.debounce":22}],83:[function(require,module,exports){
(function (global){
'use strict';

var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;
var console = require("./../../../bower_components/console-browserify/index.js");

// we need to declare which paramaters are supported
// so in @supports -ko-blockdefs we can write:
// bgimage {
//   label: Background Image;
//   widget: bgimage;
//   size: 200x100; // <= not used anymore
// }

// other “native” widgets are defined in converter/editor.js
// size is deactivate for now: background-images are used for repeating patterns
var defaultParameters = Object.freeze({
  // size: `100x100`,
});
var transparentGif = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';

var isValidSize = function isValidSize(size) {
  return (/(\d+)x(\d+)/.test(size.trim())
  );
};

function html(propAccessor, onfocusbinding, parameters) {
  return '\n    <input size="7" type="hidden" value="nothing" id="' + propAccessor + '" data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '" />\n    <button data-bind="text: $root.t(\'widget-bgimage-button\'), click: $root.openDialogGallery.bind($element, \'' + propAccessor + '\', \'' + parameters + '\');">pick an image</button>\n    <button data-bind="click: $root.resetBgimage.bind($element, \'' + propAccessor + '\', \'' + parameters + '\'), button: {icons: {primary: \'fa fa-eraser\'}, text: false, label: $root.t(\'widget-bgimage-reset\') }"></button>\n  ';
}

module.exports = function (opts) {
  var basePath = opts.basePath;


  function widget($, ko, kojqui) {
    return {
      widget: 'bgimage',
      defaultParameters: defaultParameters,
      html: html
    };
  }

  function viewModel(vm) {
    vm.showDialogGallery = ko.observable(false);
    vm.currentBgimage = ko.observable(false);
    vm.setBgImage = function (imageName, img, event) {
      // images have to be on an absolute path
      // => Testing by email needs it that way
      // => ZIP download needs it that way
      // vm.currentBgimage()( `${ basePath }/cover/${ vm.currentBgsize() }/${ imageName }` )
      vm.currentBgimage()(basePath + '/img/' + imageName);
      vm.closeDialogGallery();
    };
    vm.resetBgimage = function (propAccessor, parameters, blockProperties, event) {
      blockProperties[propAccessor](transparentGif);
    };
    vm.openDialogGallery = function (propAccessor, parameters, blockProperties, event) {
      // to set the right property, store the concerned setter
      vm.currentBgimage(blockProperties[propAccessor].bind(blockProperties));
      vm.showDialogGallery(true);
    };
    vm.closeDialogGallery = function () {
      vm.currentBgimage(false);
      vm.showDialogGallery(false);
    };

    var dialogGalleryOpen = vm.showDialogGallery.subscribe(function (newValue) {
      if (newValue === true && vm.mailingGalleryStatus() === false) {
        vm.loadMailingGallery();
        dialogGalleryOpen.dispose();
      }
    });
  }

  return {
    widget: widget,
    viewModel: viewModel
  };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],84:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
var console = require("./../../../bower_components/console-browserify/index.js");
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var inlineDocument = require("./../../../bower_components/juice/lib/inline")({}).inlineDocument;

var inlinerPlugin = function(vm) {
  vm.inline = function(doc) {
    // tinymce may have added style attributes to elements that will also have global styles to be inlined
    $('[style]:not([replacedstyle])', doc).each(function(index, el) {
      var $el = $(el);
      $el.attr('replacedstyle', $el.attr('style'));
    });

    var style = [];
    $('style[data-inline="true"]', doc).each(function(index, element) {
      var content = $(element).html();
      content = content.replace(/<!-- ko ((?!--).)*? -->/g, ''); // this replaces the above with a more formal (but slower) solution
      content = content.replace(/<!-- \/ko -->/g, '');
      style.push(content);
      $(element).removeAttr('data-inline');
    });
    var styleText = style.join("\n");
    var $context = function(selector, context) {
      if (typeof context == 'undefined') context = doc;
      return $(selector, context);
    };
    $context.root = function() {
      return $(':root', doc);
    };
    inlineDocument($context, styleText, { styleAttributeName: 'replacedstyle' });
  };
};

module.exports = inlinerPlugin;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/juice/lib/inline":4}],85:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
var console = require("./../../../bower_components/console-browserify/index.js");
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

if (false) {

var lsLoader = function(hash_key, emailProcessorBackend) {
  var mdStr = global.localStorage.getItem("metadata-" + hash_key);
  if (mdStr !== null) {
    var model;
    var td = global.localStorage.getItem("template-" + hash_key);
    if (td !== null) model = JSON.parse(td);
    var md = JSON.parse(mdStr);
    return {
      metadata: md,
      model: model,
      extension: lsCommandPluginFactory(md, emailProcessorBackend)
    };
  } else {
    throw "Cannot find stored data for "+hash_key;
  }
};

var lsCommandPluginFactory = function(md, emailProcessorBackend) {
  var commandsPlugin = function(mdkey, mdname, viewModel) {

    // console.log("loading from metadata", md, model);
    var saveCmd = {
      name: 'Save', // l10n happens in the template
      enabled: ko.observable(true)
    };
    saveCmd.execute = function() {
      saveCmd.enabled(false);
      viewModel.metadata.changed = Date.now();
      if (typeof viewModel.metadata.key == 'undefined') {
        console.warn("Unable to find ket in metadata object...", viewModel.metadata);
        viewModel.metadata.key = mdkey;
      }
      global.localStorage.setItem("metadata-" + mdkey, viewModel.exportMetadata());
      global.localStorage.setItem("template-" + mdkey, viewModel.exportJSON());
      saveCmd.enabled(true);
    };
    var testCmd = {
      name: 'Test', // l10n happens in the template
      enabled: ko.observable(true)
    };
    var downloadCmd = {
      name: 'Download', // l10n happens in the template
      enabled: ko.observable(true)
    };
    testCmd.execute = function() {
      testCmd.enabled(false);
      var email = global.localStorage.getItem("testemail");
      if (email === null || email == 'null') email = viewModel.t('Insert here the recipient email address');
      email = global.prompt(viewModel.t("Test email address"), email);
      if (email.match(/@/)) {
        global.localStorage.setItem("testemail", email);
        console.log("TODO testing...", email);
        var postUrl = emailProcessorBackend ? emailProcessorBackend : '/dl/';
        var post = $.post(postUrl, {
          action: 'email',
          rcpt: email,
          subject: "[test] " + mdkey + " - " + mdname,
          html: viewModel.exportHTML()
        }, null, 'html');
        post.fail(function() {
          console.log("fail", arguments);
          viewModel.notifier.error(viewModel.t('Unexpected error talking to server: contact us!'));
        });
        post.success(function() {
          console.log("success", arguments);
          viewModel.notifier.success(viewModel.t("Test email sent..."));
        });
        post.always(function() {
          testCmd.enabled(true);
        });
      } else {
        global.alert(viewModel.t('Invalid email address'));
        testCmd.enabled(true);
      }
    };
    downloadCmd.execute = function() {
      downloadCmd.enabled(false);
      viewModel.notifier.info(viewModel.t("Downloading..."));
      viewModel.exportHTMLtoTextarea('#downloadHtmlTextarea');
      var postUrl = emailProcessorBackend ? emailProcessorBackend : '/dl/';
      global.document.getElementById('downloadForm').setAttribute("action", postUrl);
      global.document.getElementById('downloadForm').submit();
      downloadCmd.enabled(true);
    };

    viewModel.save = saveCmd;
    viewModel.test = testCmd;
    viewModel.download = downloadCmd;
  }.bind(undefined, md.key, md.name);

  return commandsPlugin;
};

module.exports = lsLoader;

} else if (true) {

module.exports = function() {}

}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],86:[function(require,module,exports){
"use strict";

require("./../../bower_components/knockout-sortable/build/knockout-sortable.min.js");

require("./bindings/jqueryui-spinner.js");
require("./bindings/jqueryui-tabs.js");
require("./bindings/colorpicker.js");
require("./bindings/blocks.js");
require("./bindings/csstext.js");
require("./bindings/bind-iframe.js");
require("./bindings/droppable.js");
require("./bindings/fileupload.js");
require("./bindings/virtuals.js");
require("./bindings/wysiwygs.js");
require("./bindings/scrollfix.js");
require("./bindings/if-subs.js");
require("./bindings/extsortables.js");
require("./bindings/eventable.js");
require("./bindings/tooltips.js");
require("./bindings/extender-pagination.js");
require("./bindings/validated-value.js");
require("./bindings/scrollintoview.js");
},{"./../../bower_components/knockout-sortable/build/knockout-sortable.min.js":8,"./bindings/bind-iframe.js":45,"./bindings/blocks.js":46,"./bindings/colorpicker.js":48,"./bindings/csstext.js":49,"./bindings/droppable.js":50,"./bindings/eventable.js":51,"./bindings/extender-pagination.js":52,"./bindings/extsortables.js":53,"./bindings/fileupload.js":54,"./bindings/if-subs.js":55,"./bindings/jqueryui-spinner.js":56,"./bindings/jqueryui-tabs.js":57,"./bindings/scrollfix.js":59,"./bindings/scrollintoview.js":60,"./bindings/tooltips.js":62,"./bindings/validated-value.js":63,"./bindings/virtuals.js":64,"./bindings/wysiwygs.js":65}],87:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null); // just for the widget plugins
var templateConverter = require("./converter/main.js");
var console = require("./../../bower_components/console-browserify/index.js");
var initializeViewmodel = require("./viewmodel.js");
var templateSystem = require('./bindings/choose-template.js');

// call a given method on every plugin implementing it.
// supports a "reverse" parameter to call the methods from the last one to the first one.
var pluginsCall = function(plugins, methodName, args, reverse) {
  var start, end, diff, res, results;
  results = [];
  if (typeof reverse !== 'undefined' && reverse) {
    start = plugins.length - 1;
    end = 0;
    diff = -1;
  } else {
    start = 0;
    end = plugins.length - 1;
    diff = 1;
  }
  for (var i = start; i != end + diff; i += diff) {
    if (typeof plugins[i][methodName] !== 'undefined') {
      res = plugins[i][methodName].apply(plugins[i], args);
      if (typeof res !== 'undefined') results.push(res);
    }
  }
  return results;
};

// workaround for knockout-jqueryui's buttonset/button disposal:
// https://github.com/gvas/knockout-jqueryui/issues/25
var origDisposeCallback = ko.utils.domNodeDisposal.addDisposeCallback;
ko.utils.domNodeDisposal.addDisposeCallback = function(node, callback) {
  var newCallback = function(node) {
    try {
      callback(node);
    } catch (e) {
      console.warn("Caught unexpected dispose callback exception", e);
    }
  };
  origDisposeCallback(node, newCallback);
};

var bindingPluginMaker = function(performanceAwareCaller) {
  return {
    viewModel: function(viewModel) {
      try {
        performanceAwareCaller('applyBindings', ko.applyBindings.bind(undefined, viewModel));
      } catch (err) {
        console.warn(err, err.stack);
        throw err;
      }
    },
    dispose: function() {
      try {
        performanceAwareCaller('unapplyBindings', ko.cleanNode.bind(this, global.document.body));
      } catch (err) {
        console.warn(err, err.stack);
        throw err;
      }
    }
  };
};

var templateCreator = function(templatePlugin, htmlOrElement, optionalName, templateMode) {
  var tmpName = optionalName;
  if (typeof optionalName != 'undefined' && typeof templateMode != 'undefined') {
    if (typeof htmlOrElement != 'object' || htmlOrElement.tagName.toLowerCase() != 'replacedhtml') tmpName += '-' + templateMode;
  }

  while (typeof tmpName == 'undefined' || tmpName === null || templatePlugin.exists(tmpName)) {
    tmpName = 'anonymous-' + Math.floor((Math.random() * 100000) + 1);
  }

  if (typeof htmlOrElement == 'object' && htmlOrElement.tagName.toLowerCase() == 'replacedhtml') {
    var $el = $(htmlOrElement);
    var $head = $('replacedhead', $el);
    var $body = $('replacedbody', $el);
    templatePlugin.adder(tmpName + '-head', $head.html() || '');
    templatePlugin.adder(tmpName + '-show', $body.html() || '');
    templatePlugin.adder(tmpName + '-preview', $el.html());
    templatePlugin.adder(tmpName + '-wysiwyg', $el.html());

    // $head.attr('data-bind', 'block: content');
    $head.children().detach();
    $head.html("<!-- ko block: content --><!-- /ko -->");
    $head.before('<!-- ko withProperties: { templateMode: \'head\' } -->');
    $head.after('<!-- /ko -->');
    $body.html("<!-- ko block: content --><!-- /ko -->");

    templatePlugin.adder(tmpName + '-iframe', $el[0].outerHTML);

  } else if (typeof htmlOrElement == 'object') {
    templatePlugin.adder(tmpName, htmlOrElement.outerHTML);
  } else {
    templatePlugin.adder(tmpName, htmlOrElement);
  }

  return tmpName;
};

// Adapter to transform "viewModel plugins" into more generic plugins.
function _viewModelPluginInstance(pluginFunction) {
  var instance;
  return {
    viewModel: function(viewModel) {
      instance = pluginFunction(viewModel);
    },
    init: function() {
      if (typeof instance !== 'undefined' && typeof instance.init !== 'undefined') instance.init();
    },
    dispose: function() {
      if (typeof instance !== 'undefined' && typeof instance.dispose !== 'undefined') instance.dispose();
    }
  };
}

if (false) {

var _templateUrlConverter = function(basePath, url) {
  if (!url.match(/^[^\/]*:/) && !url.match(/^\//) && !url.match(/^\[/) && !url.match(/^#?$/)) {
    // TODO this could be smarter joining the urls...
    return basePath + url;
  } else {
    return null;
  }
};

var templateLoader = function(performanceAwareCaller, templateFileName, templateMetadata, jsorjson, extensions, galleryUrl) {
  var templateFile = typeof templateFileName == 'string' ? templateFileName : templateMetadata.template;
  var templatePath = "./";
  var p = templateFile.lastIndexOf('/');
  if (p != -1) {
    templatePath = templateFile.substr(0, p + 1);
  }

  var templateUrlConverter = _templateUrlConverter.bind(undefined, templatePath);

  var metadata;
  if (typeof templateMetadata == 'undefined') {
    metadata = {
      template: templateFile,
      // TODO l10n?
      name: 'No name',
      created: Date.now()
    };
  } else {
    metadata = templateMetadata;
  }

  $.get(templateFile, function(templatecode) {
    var res = templateCompiler(performanceAwareCaller, templateUrlConverter, "template", templatecode, jsorjson, metadata, extensions, galleryUrl);
    res.init();
  });
};

} else if (true) {

// keep function signatures
var templateLoader = function(performanceAwareCaller, templateFileName, templateMetadata, jsorjson, extensions, galleryUrl) {
  console.info('TEMPLATE LOADER')

  // see ext/custom-extensions.js#templateUrlConverter
  var templateUrlConverter = ko.bindingHandlers.wysiwygSrc.templateUrlConverter;

  var metadata  = templateMetadata;

  // Keep XHR to load template.
  // Don't want to output all the html in initialization
  $.ajax({
    url:      templateFileName,
    method:   'GET',
    success:  onSuccess,
    error:    onError,
  });

  function onSuccess(templatecode, textStatus, jqXHR) {
    var res = templateCompiler(performanceAwareCaller, templateUrlConverter, "template", templatecode, jsorjson, metadata, extensions, galleryUrl);
    res.init();
  }

  function onError(jqXHR, textStatus, errorThrown) {
    console.error('cannot retrieve HTML data from template');
    $('.mo-standalone').html('<h1>error</h1><h2>' + errorThrown + '</h2>');
  }
};

}

var templateCompiler = function(performanceAwareCaller, templateUrlConverter, templateName, templatecode, jsorjson, metadata, extensions, galleryUrl) {
  // we strip content before <html> tag and after </html> because jquery doesn't parse it.
  // we'll keep it "raw" and use it in the preview/output methods.
  var res = templatecode.match(/^([\S\s]*)([<]html[^>]*>[\S\s]*<\/html>)([\S\s]*)$/i);
  if (res === null) throw "Unable to find <html> opening and closing tags in the template";
  var prefix = res[1];
  // we parse the html content after replacing the tag name for html/head/body so to avoid jquery issues in parsing.
  var basicStructure = { '<html': 0, '<head': 0, '<body': 0, '</html': 0, '</body': 0, '</head': 0 };
  var html = res[2].replace(/(<\/?)(html|head|body)([^>]*>)/gi, function(match, p1, p2, p3) {
    basicStructure[(p1+p2).toLowerCase()] += 1;
    return p1 + 'replaced' + p2 + p3;
  });
  for (var ele in basicStructure) if (basicStructure.hasOwnProperty(ele)) if (basicStructure[ele] != 1) {
    if (basicStructure[ele] === 0) throw "ERROR: missing mandatory element "+ele+">";
    if (basicStructure[ele] > 1) throw "ERROR: multiple element "+ele+"> occourences are not supported (found "+basicStructure[ele]+" occourences)";
  }
  var postfix = res[3];
  var blockDefs = [];
  var enableUndo = true;
  var enableRecorder = true;
  var baseThreshold = '+$root.contentListeners()';

  var plugins = [];

  if (typeof extensions !== 'undefined') {
    for (var i = 0; i < extensions.length; i++) {
      if (typeof extensions[i] == 'function') {
        plugins.push(_viewModelPluginInstance(extensions[i]));
      } else {
        plugins.push(extensions[i]);
      }
    }
  }

  var createdTemplates = [];
  var templatesPlugin = {
    adder: function(id, html) {
      if (typeof html !== 'string') throw "Template system: cannot create new template " + id;
      var trash = html.match(/(data)?-ko-[^ =:]*/g);
      if (trash) {
        console.error("ERROR: found unexpected -ko- attribute in compiled template", id, ", you probably mispelled it:", trash);
      }
      templateSystem.addTemplate(id, html);
      createdTemplates.push(id);
    },
    exists: function(id) {
      var el = templateSystem.getTemplateContent(id);
      if (typeof el !== 'undefined') return true;
      else return false;
    },
    dispose: function() {
      for (var i = createdTemplates.length - 1; i >= 0; i--) {
        templateSystem.removeTemplate(createdTemplates[i]);
      }
    }
  };

  ko.bindingHandlers['block'].templateExists = templatesPlugin.exists;

  // templatecreator tracks created template (via templateAdder) so to be able to dispose them later
  var myTemplateCreator = templateCreator.bind(undefined, templatesPlugin);

  // first pass: we "compile" the template into a termplateDef object
  var templateDef = performanceAwareCaller('translateTemplate', templateConverter.translateTemplate.bind(undefined, templateName, html, templateUrlConverter, myTemplateCreator));

  // second pass: given the templateDef we create a base content model object for this template.
  var content = performanceAwareCaller('generateModel', templateConverter.wrappedResultModel.bind(undefined, templateDef));

  // third pass: we create "style/content editors" for every block
  var widgets = {};
  var widgetPlugins = pluginsCall(plugins, 'widget', [$, ko, kojqui]);
  for (var wi = 0; wi < widgetPlugins.length; wi++) {
    widgets[widgetPlugins[wi].widget] = widgetPlugins[wi];
  }
  blockDefs.push.apply(blockDefs, performanceAwareCaller('generateEditors', templateConverter.generateEditors.bind(undefined, templateDef, widgets, templateUrlConverter, myTemplateCreator, baseThreshold)));

  var incompatibleTemplate = false;
  if (typeof jsorjson !== 'undefined' && jsorjson !== null) {
    var unwrapped;
    if (typeof jsorjson == 'string') {
      unwrapped = ko.utils.parseJson(jsorjson);
    } else {
      unwrapped = jsorjson;
    }

    // we run a basic compatibility check between the content-model we expect and the initialization model
    var checkModelRes = performanceAwareCaller('checkModel', templateConverter.checkModel.bind(undefined, content._unwrap(), blockDefs, unwrapped));
    // if checkModelRes is 1 then the model is not fully compatible but we fixed it
    if (checkModelRes == 2) {
      console.error("Trying to compile an incompatible template version!", content._unwrap(), blockDefs, unwrapped);
      incompatibleTemplate = true;
    }

    try {
      content._wrap(unwrapped);
    } catch (ex) {
      console.error("Unable to inject model content!", ex);
      incompatibleTemplate = true;
    }
  }

  // This build the template for the preview/output, but concatenating prefix, template and content and stripping the "replaced" prefix added to "problematic" tag (html/head/body)
  var iframeTpl = prefix + templateSystem.getTemplateContent(templateName + '-iframe').replace(/(<\/?)replaced(html|head|body)([^>]*>)/gi, function(match, p1, p2, p3) {
    return p1 + p2 + p3;
  }) + postfix;

  // store this so to restore it on disposale
  var origiFrameTpl = ko.bindingHandlers.bindIframe.tpl;
  ko.bindingHandlers.bindIframe.tpl = iframeTpl;
  var iFramePlugin = {
    dispose: function() {
      ko.bindingHandlers.bindIframe.tpl = origiFrameTpl;
    }
  };

  plugins.push(iFramePlugin);
  plugins.push(templatesPlugin);

  // initialize the viewModel object based on the content model.
  var viewModel = performanceAwareCaller('initializeViewmodel', initializeViewmodel.bind(this, content, blockDefs, templateUrlConverter, galleryUrl));

  viewModel.metadata = metadata;
  // let's run some version check on template and editor used to build the model being loaded.
  var editver = '0.16.0';
  if (typeof viewModel.metadata.editorversion !== 'undefined' && viewModel.metadata.editorversion !== editver) {
    console.warn("The model being loaded has been created with an older editor version", viewModel.metadata.editorversion, "vs", editver);
  }
  viewModel.metadata.editorversion = editver;

  if (typeof templateDef.version !== 'undefined') {
    if (typeof viewModel.metadata.templateversion !== 'undefined' && viewModel.metadata.templateversion !== templateDef.version) {
      console.error("The model being loaded has been created with a different template version", templateDef.version, "vs", viewModel.metadata.templateversion);
    }
    viewModel.metadata.templateversion = templateDef.version;
  }

  templateSystem.init();

  // everything's ready, start knockout bindings.
  plugins.push(bindingPluginMaker(performanceAwareCaller));

  pluginsCall(plugins, 'viewModel', [viewModel]);

  if (incompatibleTemplate) {
    $('#incompatible-template').dialog({
      modal: true,
      appendTo: '#mo-body',
      buttons: {
        Ok: function() {
          $(this).dialog("close");
        }
      }
    });
  }

  return {
    model: viewModel,
    init: function() {
      pluginsCall(plugins, 'init', undefined, true);
    },
    dispose: function() {
      pluginsCall(plugins, 'dispose', undefined, true);
    }
  };

};


var checkFeature = function(feature, func) {
  if (!func()) {
    console.warn("Missing feature", feature);
    throw "Missing feature " + feature;
  }
};

var isCompatible = function() {
  try {
    // window.msMatchMedia would match also IE9
    // IE9 wouldn't be so hard to support, but it doesn't worth it. (preview iframe and automatic scroll are 2 things not working in IE9)
    checkFeature('matchMedia', function() {
      return typeof global.matchMedia != 'undefined';
    });
    checkFeature('XMLHttpRequest 2', function() {
      return 'XMLHttpRequest' in global && 'withCredentials' in new global.XMLHttpRequest();
    });
    checkFeature('ES5 strict', function() {
      return function() { /* "use strict";*/
        return typeof this == 'undefined';
      }();
    });
    checkFeature('CSS borderRadius', function() {
      return typeof global.document.body.style['borderRadius'] != 'undefined';
    });
    checkFeature('CSS boxShadow', function() {
      return typeof global.document.body.style['boxShadow'] != 'undefined';
    });
    checkFeature('CSS boxSizing', function() {
      return typeof global.document.body.style['boxSizing'] != 'undefined';
    });
    checkFeature('CSS backgroundSize', function() {
      return typeof global.document.body.style['backgroundSize'] != 'undefined';
    });
    checkFeature('CSS backgroundOrigin', function() {
      return typeof global.document.body.style['backgroundOrigin'] != 'undefined';
    });
    checkBadBrowserExtensions();
    return true;
  } catch (exception) {
    return false;
  }
};

var checkBadBrowserExtensions = function() {
  var id = 'checkbadbrowsersframe';
  var origTpl = ko.bindingHandlers.bindIframe.tpl;
  ko.bindingHandlers.bindIframe.tpl = "<!DOCTYPE html>\r\n<html>\r\n<head><title>A</title>\r\n</head>\r\n<body><p style=\"color: blue\" align=\"right\" data-bind=\"style: { color: 'red' }\">B</p><div data-bind=\"text: content\"></div></body>\r\n</html>\r\n";
  $('body').append('<iframe id="' + id + '" data-bind="bindIframe: $data"></iframe>');
  var frameEl = global.document.getElementById(id);
  ko.applyBindings({ content: "dummy content" }, frameEl);
  // Obsolete method didn't work on IE11 when using "HTML5 doctype":
  // var docType = new XMLSerializer().serializeToString(global.document.doctype);
  var node = frameEl.contentWindow.document.doctype;
  var docType = "<!DOCTYPE " + node.name +
    (node.publicId ? ' PUBLIC "' + node.publicId + '"' : '') +
    (!node.publicId && node.systemId ? ' SYSTEM' : '') +
    (node.systemId ? ' "' + node.systemId + '"' : '') + '>';
  var content = docType + "\n" + frameEl.contentWindow.document.documentElement.outerHTML;
  ko.cleanNode(frameEl);
  ko.removeNode(frameEl);
  ko.bindingHandlers.bindIframe.tpl = origTpl;

  var expected = "<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p align=\"right\" style=\"color: red;\" data-bind=\"style: { color: 'red' }\">B</p><div data-bind=\"text: content\">dummy content</div>\n\n</body></html>";
  var expected2 = "<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p style=\"color: red;\" data-bind=\"style: { color: 'red' }\" align=\"right\">B</p><div data-bind=\"text: content\">dummy content</div>\n\n</body></html>";
  var expected3 = "<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p style=\"color: red;\" align=\"right\" data-bind=\"style: { color: 'red' }\">B</p><div data-bind=\"text: content\">dummy content</div>\n\n</body></html>";
  if (expected !== content && expected2 !== content && expected3 !== content) {
    console.info("BadBrowser.FrameContentCheck", content.length, expected.length, expected2.length, expected3.length, content == expected, content == expected2, content == expected3);
    console.info(content);
    throw "Unexpected frame content. Misbehaving browser: "+content.length+"/"+expected.length+"/"+expected2.length+"/"+expected3.length;
  }
};

var fixPageEvents = function() {
  // This is global code to prevent dragging/dropping in the page where we don't deal with it.
  // IE8 doesn't have window.addEventListener, but doesn't support drag&drop too.
  if (global.addEventListener) {
    // prevent generic file droppping in the page
    global.addEventListener("drag", function(e) {
      // console.log("browser is using drag listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("dragstart", function(e) {
      // console.log("browser is using dragstart listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("dragover", function(e) {
      // this is called on mouse move on every supported browser.
      // console.log("browser is using dragover listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("drop", function(e) {
      // console.log("browser is using drop listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.document.body.addEventListener('drop', function(e) {
      // I browser supportati entrato tutti qui quando si droppa qualcosa sul body
      // console.log("browser is using drop listener on body tag");
      e.preventDefault();
    }, false);
  }
  if (global.document.ondragstart) {
    global.document.ondragstart = function() {
      // console.log("browser called ondragstart. return false!");
      return false;
    };
  }
};

module.exports = {
  compile: templateCompiler,
  load: templateLoader,
  isCompatible: isCompatible,
  fixPageEvents: fixPageEvents
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./bindings/choose-template.js":47,"./converter/main.js":70,"./viewmodel.js":91}],88:[function(require,module,exports){
"use strict";

var console = require("./../../bower_components/console-browserify/index.js");

var _call = function(whatToCall) {
  return whatToCall();
};

var logs = [];

var _timedCall = function(name, whatToCall) {
  var res;
  var start = new Date().getTime();
  if (typeof console == 'object' && console.time) console.time(name);
  res = _call(whatToCall);
  if (typeof console == 'object' && console.time) console.timeEnd(name);
  var diff = new Date().getTime() - start;
  if (typeof console == 'object' && !console.time) console.log(name, "took", diff, "ms");
  logs.push({
    name: name,
    time: diff
  });
  // max logs
  if (logs.length > 100) logs.unshift();
  return res;
};

module.exports = {
  timedCall: _timedCall,
  logs: logs
};
},{"./../../bower_components/console-browserify/index.js":1}],89:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var undoManager = require("./../../../bower_components/knockout-undomanager/knockout-undomanager.js");
var undoserializer = require("./undoserializer.js");

var addUndoStackExtensionMaker = function(performanceAwareCaller) {
  return function(viewModel) {

    viewModel.contentListeners(viewModel.contentListeners() + 2);

    // TODO the labels should be computed observables (needs changes in undomanager projects)
    var undoRedoStack = undoManager(viewModel.content, {
      levels: 100,
      undoLabel: ko.computed(function() { return viewModel.t("Undo (#COUNT#)"); }),
      redoLabel: ko.computed(function() { return viewModel.t("Redo"); })
    });
    viewModel.undo = undoRedoStack.undoCommand;
    viewModel.undo.execute = performanceAwareCaller.bind(viewModel, 'undo', viewModel.undo.execute);
    viewModel.redo = undoRedoStack.redoCommand;
    viewModel.redo.execute = performanceAwareCaller.bind(viewModel, 'redo', viewModel.redo.execute);
    viewModel.undoReset = performanceAwareCaller.bind(viewModel, 'undoReset', undoRedoStack.reset);
    viewModel.setUndoModeMerge = undoRedoStack.setModeMerge;
    viewModel.setUndoModeOnce = undoRedoStack.setModeOnce;
    undoRedoStack.setModeIgnore();
    undoRedoStack.setUndoActionMaker(undoserializer.makeUndoAction.bind(undefined, viewModel.content));
    undoserializer.watchEnabled(true);

    return {
      pause: function() {
        undoRedoStack.setModeIgnore();
      },
      run: function() {
        undoRedoStack.setModeOnce();
      },
      init: function() {
        undoRedoStack.setModeOnce();
      },
      dispose: function() {
        viewModel.contentListeners(viewModel.contentListeners() - 2);
        undoserializer.watchEnabled(false);
        undoRedoStack.dispose();
      }
    };

  };
};

module.exports = addUndoStackExtensionMaker;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/knockout-undomanager/knockout-undomanager.js":9,"./undoserializer.js":90}],90:[function(require,module,exports){
(function (global){
"use strict";
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
// This module deals with serialization/deserialization of a "tree-path" representing the path to reach the given leaf.
// In order to be correctly serialized we have to move from "reference" to "string" and viceversa.

var _reference = function(model, path) {
  var p = 0;
  var p1, p2;
  var m = model;
  while (p < path.length) {
    switch (path.charAt(p)) {
      case '(':
        if (path.charAt(p + 1) == ')') {
          m = m();
        } else {
          // TODO error
        }
        p += 2;
        break;
      case '[':
        p2 = path.indexOf(']', p);
        m = m[path.substring(p + 1, p2)];
        p = p2 + 1;
        break;
      case '.':
        p1 = path.indexOf('(', p);
        if (p1 == -1) p1 = path.length;
        p2 = path.indexOf('[', p);
        if (p2 == -1) p2 = path.length;
        p2 = Math.min(p1, p2);
        m = m[path.substring(p + 1, p2)];
        p = p2;
        break;
      default:
        // TODO error
    }
  }
  return m;
};

var _getPath = function(parents, child) {
  var path = "";
  var p;
  for (var k = 0; k <= parents.length; k++) {
    p = k < parents.length ? parents[k] : child;
    if (ko.isObservable(p)) path += '()';
    if (typeof p._fieldName !== 'undefined') {
      path += "." + p._fieldName;
    } else if (k > 0 && typeof parents[k - 1].pop == 'function') {
      var parentArray = ko.isObservable(parents[k - 1]) ? ko.utils.peekObservable(parents[k - 1]) : parents[k - 1];
      var pos = ko.utils.arrayIndexOf(parentArray, p);
      if (pos != -1) {
        path += "[" + pos + "]";
      } else {
        // NOTE this happen, sometimes when TinyMCE sends updates for objects already removed.
        console.error("Unexpected object not found in parent array", parentArray, p, k, parents.length, ko.toJS(parentArray), ko.utils.unwrapObservable(p));
        throw "Unexpected object not found in parent array";
      }
    } else {
      console.error("Unexpected parent with no _fieldName and no parent array", k, parents);
      throw "Unexpected parent with no _fieldName and no parent array";
    }
  }
  return path;
};

var makeDereferencedUndoAction = function(undoFunc, model, path, value, item) {
  var child = _reference(model, path);
  undoFunc(child, value, item);
};

var listener;

var _setListener = function(listenfunc) {
  listener = listenfunc;
};

/* dereferencing path and changing value with "toJS" */
var makeUndoActionDereferenced = function(model, undoFunc, parents, child, oldVal, item) {
  try {
    var path = _getPath(parents, child);

    // Transform actions in simple JS objects.
    if (typeof oldVal === 'object' || typeof oldVal === 'function') oldVal = ko.toJS(oldVal);
    if (typeof item !== 'undefined' && (typeof item.value === 'object' || typeof item.value === 'function')) {
      var newItem = ko.toJS(item);
      item = newItem;
    }

    if (typeof listener !== 'undefined') {
      try {
        listener(path, child, oldVal, item);
      } catch (e) {
        console.log("Undoserializer ignoring exception in listener callback");
      }
    }

    return makeDereferencedUndoAction.bind(undefined, undoFunc, model, path, oldVal, item);
  } catch (e) {
    // NOTE this happens, from time to time, when TinyMCE sends updates for deleted content.
    console.error("Exception processing undo", e, parents, child, item);
  }
};

var watchEnabled;
var _watchEnabled = function(newVal) {
  if (typeof newVal !== 'undefined')
    watchEnabled = newVal;
  else
    return watchEnabled;
};

module.exports = {
  dereference: _getPath,
  reference: _reference,
  makeUndoAction: makeUndoActionDereferenced,
  setListener: _setListener,
  watchEnabled: _watchEnabled
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],91:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../bower_components/console-browserify/index.js");
var performanceAwareCaller = require("./timed-call.js").timedCall;

var toastr = require("./../../bower_components/toastr/toastr.js");
toastr.options = {
  "closeButton": false,
  "debug": false,
  "positionClass": "toast-bottom-full-width",
  "target": "#mo-body",
  "onclick": null,
  "showDuration": "300",
  "hideDuration": "1000",
  "timeOut": "5000",
  "extendedTimeOut": "1000",
  "showEasing": "swing",
  "hideEasing": "linear",
  "showMethod": "fadeIn",
  "hideMethod": "fadeOut"
};

/* NOTE: translations moved to "plugin"
var strings = {
  'show preview and send test': 'Visualizza una anteprima e fai un invio di test',
  // Strings for app.js
  'Download': 'Download',
  'Test': 'Test',
  'Save': 'Salva',
  'Downloading...': "Download in corso...",
  'Invalid email address': "Indirizzo email invalido",
  "Test email sent...": "Email di test inviata...",
  'Unexpected error talking to server: contact us!': 'Errore di comunicazione con il server: contattaci!',
  'Insert here the recipient email address': 'Inserisci qui l\'indirizzo email a cui spedire',
  "Test email address": "Indirizzo email di test",
  // viewModel
  'Block removed: use undo button to restore it...': 'Blocco eliminato: usa il pulsante annulla per recuperarlo...',
  'New block added after the selected one (__pos__)': 'Nuovo blocco aggiunto sotto a quello selezionato (__pos__)',
  'New block added at the model bottom (__pos__)': 'Nuovo blocco aggiunto in fondo al modello (__pos__)',
  // undomain.js
  'Undo (#COUNT#)': 'Annulla (#COUNT#)',
  'Redo': 'Ripristina',
  // editor.js
  'Selected element has no editable properties': 'L\'elemento selezionato non fornisce proprietà editabili',
  'This style is specific for this block: click here to remove the custom style and revert to the theme value': 'Questo stile è specifico di questo blocco: clicca qui per annullare lo stile personalizzato',
  'Switch between global and block level styles editing': 'Permette di specificare se si vuole modificare lo stile generale o solamente quello specifico del blocco selezionato',
  // main.tpl.html
  'Undo last operation': 'Annulla ultima operazione',
  'Redo last operation': 'Ripeti operazione annullata',
  'Show image gallery': 'Visualizza galleria immagini',
  'Gallery': 'Galleria',
  'Preview': 'Anteprima',
  'Show live preview': 'Mostra anteprima live',
  'Large screen': 'Schermo grande',
  'Tablet': 'Tablet',
  'Smartphone': 'Smartphone',
  'Show preview and send test': 'Visualizza una anteprima e fai un invio di test',
  'Download template': 'Scarica il template',
  'Save template': 'Salva il template',
  'Saved model is obsolete': 'Modello salvato obsoleto',
  '<p>The saved model has been created with a previous, non completely compatible version, of the template</p><p>Some content or style in the model <b>COULD BE LOST</b> if you will <b>save</b></p><p>Contact us for more informations!</p>': '<p>Il modello salvato è stato creato con una versione precedente del template non del tutto compatibile</p><p>Alcuni contenuti o stili del modello <b>POTREBBERO ESSERE PERSI</b> se procederai e deciderai di <b>salvare</b></p><p>Contattaci se hai dei dubbi!</p>',

  // TODO this cannot be done in knockout as with uncompatible browsers we don't initialize
  // 'Usupported browser': 'Browser non compatibile',
  // '<p>Your browser is not supported.</p><p>Use a different browser or try updaring your browser.</p><p>Supported browsers: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>': '<p>Il tuo browser non è supportato.</p><p>Accedi con un browser differente o prova ad aggiornare il tuo browser.</p><p>Browser supportati: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>',

  // toolbox
  'Blocks': 'Blocchi',
  'Blocks ready to be added to the template': 'Elenco contenuti aggiungibili al messaggio',
  'Content': 'Contenuto',
  'Edit content options': 'Modifica opzioni contenuti',
  'Style': 'Stile',
  'Edit style options': 'Modifica opzioni grafiche',
  'Block __name__': 'Blocco __name__',
  'Click or drag to add this block to the template': 'Clicca o trascina per aggiungere al messaggio',
  'Add': 'Aggiungi',
  'By clicking on message parts you will select a block and content options, if any, will show here': 'Cliccando su alcune parti del messaggio selezionerai un blocco e le opzioni contenutistiche, se disponibili, compariranno qui',
  'By clicking on message parts you will select a block and style options, if available, will show here': 'Cliccando su alcune parti del messaggio selezionerai un blocco e le opzioni di stile, se disponibili, compariranno qui',
  'Click or drag files here': 'Clicca o trascina i file qui!',
  'No images uploaded, yet': 'Non hai ancora caricato immagini',
  'Show images from the gallery': 'Visualizza le immagini caricate nella tua area',
  'Loading...': 'Caricamento...',
  'Load gallery': 'Carica galleria',
  'Loading gallery...': 'Caricamento in corso...',
  'The gallery is empty': 'Nessuna immagine nella galleria',
  // img-wysiwyg.tmlp
  'Remove image': 'Rimuovi immagine',
  'Open the image editing tool': 'Avvia strumento modifica immagine',
  'Upload a new image': 'Carica una nuova immagine',
  'Drop an image here': 'Trascina una immagine qui',
  'Drop an image here or click the upload button': 'Trascina una immagine qui o clicca sul pulsante di caricamento',
  // gallery
  'Drag this image and drop it on any template image placeholder': 'Trascina questa immagine sulla posizione in cui vuoi inserirla',
  'Gallery:': 'Galleria:',
  'Session images': 'Immagini di sessione',
  'Recents': 'Recenti',
  'Remote gallery': 'Galleria remota',

  // customstyle
  'Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class="customStyled"><span>"small cube" </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul>': 'Blocco personalizzato.<ul><li>In questa modalità se cambi una proprietà verrà modificata solamente per questo specifico blocco (invece che per tutti i blocchi della stessa sezione).</li><li>Per segnalare la personalizzazione apparirà l\'icona <span class="customStyled"><span> del "cubetto"</span></span> a fianco delle proprietà. Cliccando questa icona tornerai al valore comune.</li></ul>',
  // blocks-wysiwyg
  'Drop here blocks from the "Blocks" tab': 'Trascina qui i blocchi dalla scheda \'Blocchi\'',
  // block-wysiwyg
  'Drag this handle to move the block': 'Trascina per spostare il blocco altrove',
  'Move this block upside': 'Sposta il blocco in su',
  'Move this block downside': 'Sposta il blocco in giu',
  'Delete block': 'Elimina blocco',
  'Duplicate block': 'Duplica blocco',
  'Switch block variant': 'Cambia variante blocco',
  // colorpicker
  'Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.': 'Colori Tema,Colori Standard,Colori Web,Colori Tema,Torna alla tavolozza,Storico,storico colori vuoto',

  'Drop here': 'Rilascia qui',

};
*/

function initializeEditor(content, blockDefs, thumbPathConverter, galleryUrl) {

  var viewModel = {
    galleryRecent: ko.observableArray([]),
    galleryRemote: ko.observableArray([]),
    selectedBlock: ko.observable(null),
    selectedItem: ko.observable(null),
    selectedTool: ko.observable(0),
    selectedImageTab: ko.observable(0),
    dragging: ko.observable(false),
    draggingImage: ko.observable(false),
    galleryLoaded: ko.observable(false),
    showPreviewFrame: ko.observable(false),
    previewMode: ko.observable('mobile'),
    showToolbox: ko.observable(true),
    showTheme: ko.observable(false),
    showGallery: ko.observable(false),
    debug: ko.observable(false),
    contentListeners: ko.observable(0),

    logoPath: 'dist/img/mosaico32.png',
    logoUrl: '.',
    logoAlt: 'mosaico'
  };

  // viewModel.content = content._instrument(ko, content, undefined, true);
  viewModel.content = content;
  viewModel.blockDefs = blockDefs;

  viewModel.notifier = toastr;

  // Does token substitution in i18next style
  viewModel.tt = function(key, paramObj) {
    if (typeof paramObj !== 'undefined')
      for (var prop in paramObj)
        if (paramObj.hasOwnProperty(prop)) {
          key = key.replace(new RegExp('__' + prop + '__', 'g'), paramObj[prop]);
        }
    return key;
  };

  // Simply maps to tt: language plugins can override this method to define their own language
  // handling.
  // If this method invokes an observable (e.g: viewModel.lang()) then the UI language will automatically
  // update when the "lang" observable changes.
  viewModel.t = viewModel.tt;

  // currently called by editor.html to translate template-defined keys (label, help, descriptions)
  // the editor always uses the "template" category for that strings.
  // you can override this method as you like in order to provide translation or change the strings in any way.
  viewModel.ut = function(category, key) {
    return key;
  };

  viewModel.templatePath = thumbPathConverter;

  viewModel.remoteUrlProcessor = function(url) {
    return url;
  };

  viewModel.remoteFileProcessor = function(fileObj) {
    if (typeof fileObj.url !== 'undefined') fileObj.url = viewModel.remoteUrlProcessor(fileObj.url);
    if (typeof fileObj.thumbnailUrl !== 'undefined') fileObj.thumbnailUrl = viewModel.remoteUrlProcessor(fileObj.thumbnailUrl);
    // deleteUrl?
    return fileObj;
  };

  // toolbox.tmpl.html
  viewModel.loadGallery = function() {
    viewModel.galleryLoaded('loading');
    var url = galleryUrl ? galleryUrl : '/upload/';
    // retrieve the full list of remote files
    $.getJSON(url, function(data) {
      for (var i = 0; i < data.files.length; i++) data.files[i] = viewModel.remoteFileProcessor(data.files[i]);
      viewModel.galleryLoaded(data.files.length);
      // TODO do I want this call to return relative paths? Or just absolute paths?
      viewModel.galleryRemote(data.files.reverse());
    }).fail(function() {
      viewModel.galleryLoaded(false);
      viewModel.notifier.error(viewModel.t('Unexpected error listing files'));
    });
  };

  // img-wysiwyg.tmpl.html
  viewModel.fileToImage = function(obj, event, ui) {
    // console.log("fileToImage", obj);
    return obj.url;
  };

  // block-wysiwyg.tmpl.html
  viewModel.removeBlock = function(data, parent) {
    // let's unselect the block
    if (ko.utils.unwrapObservable(viewModel.selectedBlock) == ko.utils.unwrapObservable(data)) {
      viewModel.selectBlock(null, true);
    }
    var res = parent.blocks.remove(data);
    // TODO This message should be different depending on undo plugin presence.
    viewModel.notifier.info(viewModel.t('Block removed: use undo button to restore it...'));
    return res;
  };

  // block-wysiwyg.tmpl.html
  viewModel.duplicateBlock = function(index, parent) {
    var idx = ko.utils.unwrapObservable(index);
    // Deinstrument/deobserve the object
    var unwrapped = ko.toJS(ko.utils.unwrapObservable(parent.blocks)[idx]);
    // We need to remove the id so that a new one will be assigned to the clone
    if (typeof unwrapped.id !== 'undefined') unwrapped.id = '';
    // insert the cloned block
    parent.blocks.splice(idx + 1, 0, unwrapped);
  };

  // block-wysiwyg.tmpl.html
  viewModel.moveBlock = function(index, parent, up) {
    var idx = ko.utils.unwrapObservable(index);
    var parentBlocks = ko.utils.unwrapObservable(parent.blocks);
    if ((up && idx > 0) || (!up && idx < parentBlocks.length - 1)) {
      var destIndex = idx + (up ? -1 : 1);
      var destBlock = parentBlocks[destIndex];
      viewModel.startMultiple();
      parent.blocks.splice(destIndex, 1);
      parent.blocks.splice(idx, 0, destBlock);
      viewModel.stopMultiple();
    }
  };

  // test method, command line use only
  viewModel.loadDefaultBlocks = function() {
    // cloning the whole "mainBlocks" object so that undomanager will
    // see it as a single operation (maybe I could use "startMultiple"/"stopMultiple".
    var res = ko.toJS(viewModel.content().mainBlocks);
    res.blocks = [];
    var input = ko.utils.unwrapObservable(viewModel.blockDefs);
    for (var i = 0; i < input.length; i++) {
      var obj = ko.toJS(input[i]);
      // generating ids for blocks, maybe this would work also leaving it empty.
      obj.id = 'block_' + i;
      res.blocks.push(obj);
    }
    performanceAwareCaller('setMainBlocks', viewModel.content().mainBlocks._wrap.bind(viewModel.content().mainBlocks, res));
  };

  // gallery-images.tmpl.html
  viewModel.addImage = function(img) {
    var selectedImg = $('#main-wysiwyg-area .selectable-img.selecteditem');
    if (selectedImg.length == 1 && typeof img == 'object' && typeof img.url !== 'undefined') {
      ko.contextFor(selectedImg[0])._src(img.url);
      return true;
    } else {
      return false;
    }
  };

  // toolbox.tmpl.html
  viewModel.addBlock = function(obj, event) {
    // if there is a selected block we try to add the block just after the selected one.
    var selected = viewModel.selectedBlock();
    // search the selected block position.
    var found;
    if (selected !== null) {
      // TODO "mainBlocks" is an hardcoded thing.
      for (var i = viewModel.content().mainBlocks().blocks().length - 1; i >= 0; i--) {
        if (viewModel.content().mainBlocks().blocks()[i]() == selected) {
          found = i;
          break;
        }
      }
    }
    var pos;
    if (typeof found !== 'undefined') {
      pos = found + 1;
      viewModel.content().mainBlocks().blocks.splice(pos, 0, obj);
      viewModel.notifier.info(viewModel.t('New block added after the selected one (__pos__)', {
        pos: pos
      }));
    } else {
      viewModel.content().mainBlocks().blocks.push(obj);
      pos = viewModel.content().mainBlocks().blocks().length - 1;
      viewModel.notifier.info(viewModel.t('New block added at the model bottom (__pos__)', {
        pos: pos
      }));
    }
    // find the newly added block and select it!
    var added = viewModel.content().mainBlocks().blocks()[pos]();
    viewModel.selectBlock(added, true);
    // prevent click propagation (losing url hash - see #43)
    return false;
  };

  // Used by stylesheet.js to create multiple styles
  viewModel.findObjectsOfType = function(data, type) {
    var res = [];
    var obj = ko.utils.unwrapObservable(data);
    for (var prop in obj)
      if (obj.hasOwnProperty(prop)) {
        var val = ko.utils.unwrapObservable(obj[prop]);
        // TODO this is not the right way to deal with "block list" objects.
        if (prop.match(/Blocks$/)) {
          var contents = ko.utils.unwrapObservable(val.blocks);
          for (var i = 0; i < contents.length; i++) {
            var c = ko.utils.unwrapObservable(contents[i]);
            if (type === null || ko.utils.unwrapObservable(c.type) == type) res.push(c);
          }
          // TODO investigate which condition provide a null value.
        } else if (typeof val == 'object' && val !== null) {
          if (type === null || ko.utils.unwrapObservable(val.type) == type) res.push(val);
        }
      }
    return res;
  };

  /*
  viewModel.placeholderHelper = 'sortable-placeholder';
  if (false) {
    viewModel.placeholderHelper = {
      element: function(currentItem) {
        return $('<div />').removeClass('ui-draggable').addClass('sortable-placeholder').css('position', 'relative').css('width', '100%').css('height', currentItem.css('height')).css('opacity', '.8')[0];
      },
      update: function(container, p) {
       return;
      }
    };
  }
  */

  // Attempt to insert the block in the destination layout during dragging
  viewModel.placeholderHelper = {
    element: function(currentItem) {
      return $(currentItem[0].outerHTML).removeClass('ui-draggable').addClass('sortable-placeholder').css('display', 'block').css('position', 'relative').css('width', '100%').css('height', 'auto').css('opacity', '.8')[0];
    },
    update: function(container, p) {
      return;
    }
  };

  // TODO the undumanager should be pluggable.
  // Used by "moveBlock" and blocks-wysiwyg.tmpl.html to "merge" drag/drop operations into a single undo/redo op.
  viewModel.startMultiple = function() {
    if (typeof viewModel.setUndoModeMerge !== 'undefined') viewModel.setUndoModeMerge();
  };
  viewModel.stopMultiple = function() {
    if (typeof viewModel.setUndoModeOnce !== 'undefined') viewModel.setUndoModeOnce();
  };

  // Used by code generated by editor.js
  viewModel.localGlobalSwitch = function(prop, globalProp) {
    var current = prop();
    if (current === null) prop(globalProp());
    else prop(null);
    return false;
  };

  // Used by editor and main "converter" to support item selection
  viewModel.selectItem = function(valueAccessor, item, block) {
    var val = ko.utils.peekObservable(valueAccessor);
    if (typeof block !== 'undefined') viewModel.selectBlock(block, false, true);
    if (val != item) {
      valueAccessor(item);
      // On selectItem if we were on "Blocks" toolbox tab we move to "Content" toolbox tab.
      if (item !== null && viewModel.selectedTool() === 0) viewModel.selectedTool(1);
    }
    return false;
  }.bind(viewModel, viewModel.selectedItem);

  viewModel.isSelectedItem = function(item) {
    return viewModel.selectedItem() == item;
  };

  viewModel.selectBlock = function(valueAccessor, item, doNotSelect, doNotUnselectItem) {
    var val = ko.utils.peekObservable(valueAccessor);
    if (!doNotUnselectItem) viewModel.selectItem(null);
    if (val != item) {
      valueAccessor(item);
      // hide gallery on block selection
      viewModel.showGallery(false);
      if (item !== null && !doNotSelect && viewModel.selectedTool() === 0) viewModel.selectedTool(1);
    }
  }.bind(viewModel, viewModel.selectedBlock);

  // DEBUG
  viewModel.countSubscriptions = function(model, debug) {
    var res = 0;
    for (var prop in model)
      if (model.hasOwnProperty(prop)) {
        var p = model[prop];
        if (ko.isObservable(p)) {
          if (typeof p._defaultComputed != 'undefined') {
            if (typeof debug != 'undefined') console.log(debug + "/" + prop + "/_", p._defaultComputed.getSubscriptionsCount());
            res += p._defaultComputed.getSubscriptionsCount();
          }
          if (typeof debug != 'undefined') console.log(debug + "/" + prop + "/-", p.getSubscriptionsCount());
          res += p.getSubscriptionsCount();
          p = ko.utils.unwrapObservable(p);
        }
        if (typeof p == 'object' && p !== null) {
          var tot = viewModel.countSubscriptions(p, typeof debug != 'undefined' ? debug + '/' + prop + "@" : undefined);
          if (typeof debug != 'undefined') console.log(debug + "/" + prop + "@", tot);
          res += tot;
        }
      }
    return res;
  };

  // DEBUG
  viewModel.loopSubscriptionsCount = function() {
    var count = viewModel.countSubscriptions(viewModel.content());
    global.document.getElementById('subscriptionsCount').innerHTML = count;
    global.setTimeout(viewModel.loopSubscriptionsCount, 1000);
  };

  viewModel.export = function() {
    var content = performanceAwareCaller("exportHTML", viewModel.exportHTML);
    return content;
  };

  function conditional_restore(html) {
    return html.replace(/<replacedcc[^>]* condition="([^"]*)"[^>]*>([\s\S]*?)<\/replacedcc>/g, function(match, condition, body) {
      var dd = '<!--[if '+condition.replace(/&amp;/, '&')+']>';
      dd += body.replace(/<!-- cc:bc:([A-Za-z:]*) -->(<\/cc>)?<!-- cc:ac:\1 -->/g, '</$1>') // restore closing tags (including lost tags)
            .replace(/><\/cc><!-- cc:sc -->/g, '/>') // restore selfclosing tags
            .replace(/<!-- cc:bo:([A-Za-z:]*) --><cc/g, '<$1') // restore open tags
            .replace(/^.*<!-- cc:start -->/,'') // remove content before start
            .replace(/<!-- cc:end -->.*$/,''); // remove content after end
      dd += '<![endif]-->';
      return dd;
    });
  }

  viewModel.exportHTML = function() {
    console.log('viewModel.exportHTML')
    var id = 'exportframe';
    $('body').append('<iframe id="' + id + '" data-bind="bindIframe: $data"></iframe>');
    var frameEl = global.document.getElementById(id);
    ko.applyBindings(viewModel, frameEl);

    ko.cleanNode(frameEl);

    if (viewModel.inline) viewModel.inline(frameEl.contentWindow.document);

    // Obsolete method didn't work on IE11 when using "HTML5 doctype":
    // var docType = new XMLSerializer().serializeToString(global.document.doctype);
    var node = frameEl.contentWindow.document.doctype;
    var docType = "<!DOCTYPE " + node.name +
      (node.publicId ? ' PUBLIC "' + node.publicId + '"' : '') +
      (!node.publicId && node.systemId ? ' SYSTEM' : '') +
      (node.systemId ? ' "' + node.systemId + '"' : '') + '>';
    var content = docType + "\n" + frameEl.contentWindow.document.documentElement.outerHTML;
    ko.removeNode(frameEl);

    content = content.replace(/<script ([^>]* )?type="text\/html"[^>]*>[\s\S]*?<\/script>/gm, '');
    // content = content.replace(/<!-- ko .*? -->/g, ''); // sometimes we have expressions like (<!-- ko var > 2 -->)
    content = content.replace(/<!-- ko ((?!--).)*? -->/g, ''); // this replaces the above with a more formal (but slower) solution
    content = content.replace(/<!-- \/ko -->/g, '');
    // Remove data-bind/data-block attributes
    content = content.replace(/ data-bind="[^"]*"/gm, '');
    // Remove trash leftover by TinyMCE
    content = content.replace(/ data-mce-(href|src|style)="[^"]*"/gm, '');

    // Replace "replacedstyle" to "style" attributes (chrome puts replacedstyle after style)
    content = content.replace(/ style="[^"]*"([^>]*) replaced(style="[^"]*")/gm, '$1 $2');
    // Replace "replacedstyle" to "style" attributes (ie/ff have reverse order)
    content = content.replace(/ replaced(style="[^"]*")([^>]*) style="[^"]*"/gm, ' $1$2');
    content = content.replace(/ replaced(style="[^"]*")/gm, ' $1');

    // same as style, but for http-equiv (some browser break it if we don't replace, but then we find it duplicated)
    content = content.replace(/ http-equiv="[^"]*"([^>]*) replaced(http-equiv="[^"]*")/gm, '$1 $2');
    content = content.replace(/ replaced(http-equiv="[^"]*")([^>]*) http-equiv="[^"]*"/gm, ' $1$2');
    content = content.replace(/ replaced(http-equiv="[^"]*")/gm, ' $1');

    // CUSTOM BACKEND: Restore ESP tags
    // https://github.com/goodenough/mosaico/issues/2
    content = content.replace(/&lt;%/g, '<%');
    content = content.replace(/%&gt;/g, '%>');

    // We already replace style and http-equiv and we don't need this.
    // content = content.replace(/ replaced([^= ]*=)/gm, ' $1');
    // Restore conditional comments
    content = conditional_restore(content);
    var trash = content.match(/ data-[^ =]+(="[^"]+")? /) || content.match(/ replaced([^= ]*=)/);
    if (trash) {
      console.warn("Output HTML contains unexpected data- attributes or replaced attributes", trash);
    }

    return content;
  };

  viewModel.exportHTMLtoTextarea = function(textareaid) {
    $(textareaid).val(viewModel.exportHTML());
  };

  viewModel.exportJSONtoTextarea = function(textareaid) {
    $(textareaid).val(viewModel.exportJSON());
  };

  viewModel.importJSONfromTextarea = function(textareaid) {
    viewModel.importJSON($(textareaid).val());
  };

  viewModel.exportMetadata = function() {
    var json = ko.toJSON(viewModel.metadata);
    return json;
  };

  viewModel.exportJSON = function() {
    var json = ko.toJSON(viewModel.content);
    return json;
  };

  viewModel.exportJS = function() {
    return ko.toJS(viewModel.content);
  };

  viewModel.importJSON = function(json) {
    var unwrapped = ko.utils.parseJson(json);
    viewModel.content._wrap(unwrapped);
  };

  viewModel.exportTheme = function() {
    var flat = {};
    var mod = viewModel.content().theme();

    var _export = function(prefix, flat, mod) {
      for (var prop in mod)
        if (mod.hasOwnProperty(prop)) {
          var a = ko.utils.unwrapObservable(mod[prop]);
          if (a !== null && typeof a == 'object') {
            _export(prop + '.', flat, a);
          } else {
            flat[prefix + prop] = a;
          }
        }
    };

    _export('', flat, mod);

    var output = '';
    for (var prop in flat)
      if (flat.hasOwnProperty(prop) && prop != 'type') {
        output += prop + ": " + flat[prop] + ";" + "\n";
      }

    return output;
  };

  // moxiemanager (or file browser/imageeditor) extension points.
  // Just implement editImage or linkDialog methods
  // viewModel.editImage = function(src, done) {} : implement this method to enable image editing (src is a wirtableObservable).
  // viewModel.linkDialog = function() {}: implement this method using "this" to find the input element $(this).val is a writableObservable.

  viewModel.loadImage = function(img) {
    // push image at top of "recent" gallery
    viewModel.galleryRecent.unshift(img);
    // select recent gallery tab
    viewModel.selectedImageTab(0);
  };

  viewModel.dialog = function(selector, options) {
    $(selector).dialog(options);
  };

  // Dummy log method overridden by extensions
  viewModel.log = function(category, msg) {
    // console.log("viewModel.log", category, msg);
  };

  // Can't keep that piece of code: interfere with my own listener
  if (false) {

  // automatically load the gallery when the gallery tab is selected
  viewModel.selectedImageTab.subscribe(function(newValue) {
    if (newValue == 1 && viewModel.galleryLoaded() === false) {
      viewModel.loadGallery();
    }
  }, viewModel, 'change');

  }

  return viewModel;

}

module.exports = initializeEditor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./../../bower_components/toastr/toastr.js":19,"./timed-call.js":88}]},{},[44,20])(44)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZXZvbC1jb2xvcnBpY2tlci9qcy9ldm9sLmNvbG9ycGlja2VyLm1pbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvanNlcC9zcmMvanNlcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvanVpY2UvbGliL2lubGluZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvanVpY2UvbGliL3Byb3BlcnR5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9qdWljZS9saWIvc2VsZWN0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2p1aWNlL2xpYi91dGlscy5qcyIsImJvd2VyX2NvbXBvbmVudHMva25vY2tvdXQtc29ydGFibGUvYnVpbGQva25vY2tvdXQtc29ydGFibGUubWluLmpzIiwiYm93ZXJfY29tcG9uZW50cy9rbm9ja291dC11bmRvbWFuYWdlci9rbm9ja291dC11bmRvbWFuYWdlci5qcyIsImJvd2VyX2NvbXBvbmVudHMva25vY2tvdXQud3JhcC9rbm9ja291dC53cmFwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9rbm9ja291dGpzLXJlYWN0b3Ivc3JjL2tub2Nrb3V0LnJlYWN0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL21lbnNjaC9pbmRleC5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9kZWJ1Zy5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9sZXhlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9wYXJzZXIuanMiLCJib3dlcl9jb21wb25lbnRzL21lbnNjaC9saWIvc3RyaW5naWZ5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9zbGljay9wYXJzZXIuanMiLCJib3dlcl9jb21wb25lbnRzL3Rpbnljb2xvci90aW55Y29sb3IuanMiLCJib3dlcl9jb21wb25lbnRzL3RvYXN0ci90b2FzdHIuanMiLCJidWlsZC90ZW1wbGF0ZXMuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmZpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLm9taXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3MtYnJvd3NlcmlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwZWFraW5ndXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwZWFraW5ndXJsL2xpYi9zcGVha2luZ3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0J5dGVMZW5ndGguanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0VtYWlsLmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNGUUROLmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdXRpbC9hc3NlcnRTdHJpbmcuanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi91dGlsL21lcmdlLmpzIiwic2hhcmVkL3NsdWctZmlsZW5hbWUuanMiLCJzcmMvanMvYXBwLmpzIiwic3JjL2pzL2JpbmRpbmdzL2JpbmQtaWZyYW1lLmpzIiwic3JjL2pzL2JpbmRpbmdzL2Jsb2Nrcy5qcyIsInNyYy9qcy9iaW5kaW5ncy9jaG9vc2UtdGVtcGxhdGUuanMiLCJzcmMvanMvYmluZGluZ3MvY29sb3JwaWNrZXIuanMiLCJzcmMvanMvYmluZGluZ3MvY3NzdGV4dC5qcyIsInNyYy9qcy9iaW5kaW5ncy9kcm9wcGFibGUuanMiLCJzcmMvanMvYmluZGluZ3MvZXZlbnRhYmxlLmpzIiwic3JjL2pzL2JpbmRpbmdzL2V4dGVuZGVyLXBhZ2luYXRpb24uanMiLCJzcmMvanMvYmluZGluZ3MvZXh0c29ydGFibGVzLmpzIiwic3JjL2pzL2JpbmRpbmdzL2ZpbGV1cGxvYWQuanMiLCJzcmMvanMvYmluZGluZ3MvaWYtc3Vicy5qcyIsInNyYy9qcy9iaW5kaW5ncy9qcXVlcnl1aS1zcGlubmVyLmpzIiwic3JjL2pzL2JpbmRpbmdzL2pxdWVyeXVpLXRhYnMuanMiLCJzcmMvanMvYmluZGluZ3Mvc2NyaXB0LXRlbXBsYXRlLmpzIiwic3JjL2pzL2JpbmRpbmdzL3Njcm9sbGZpeC5qcyIsInNyYy9qcy9iaW5kaW5ncy9zY3JvbGxpbnRvdmlldy5qcyIsInNyYy9qcy9iaW5kaW5ncy9zdHJpbmctdGVtcGxhdGUuanMiLCJzcmMvanMvYmluZGluZ3MvdG9vbHRpcHMuanMiLCJzcmMvanMvYmluZGluZ3MvdmFsaWRhdGVkLXZhbHVlLmpzIiwic3JjL2pzL2JpbmRpbmdzL3ZpcnR1YWxzLmpzIiwic3JjL2pzL2JpbmRpbmdzL3d5c2l3eWdzLmpzIiwic3JjL2pzL2NvbnZlcnRlci9jaGVja21vZGVsLmpzIiwic3JjL2pzL2NvbnZlcnRlci9kZWNsYXJhdGlvbnMuanMiLCJzcmMvanMvY29udmVydGVyL2RvbXV0aWxzLmpzIiwic3JjL2pzL2NvbnZlcnRlci9lZGl0b3IuanMiLCJzcmMvanMvY29udmVydGVyL21haW4uanMiLCJzcmMvanMvY29udmVydGVyL21vZGVsLmpzIiwic3JjL2pzL2NvbnZlcnRlci9wYXJzZXIuanMiLCJzcmMvanMvY29udmVydGVyL3N0eWxlc2hlZXQuanMiLCJzcmMvanMvY29udmVydGVyL3V0aWxzLmpzIiwic3JjL2pzL2NvbnZlcnRlci93cmFwcGVyLmpzIiwic3JjL2pzL2V4dC9jb2xvci5qcyIsInNyYy9qcy9leHQvY3VzdG9tLWVkaXQtdGl0bGUuanMiLCJzcmMvanMvZXh0L2N1c3RvbS1leHRlbnNpb25zLmpzIiwic3JjL2pzL2V4dC9jdXN0b20tZ2FsbGVyeS5qcyIsInNyYy9qcy9leHQvY3VzdG9tLXJlbW92ZS1nYWxsZXJ5LWltYWdlLmpzIiwic3JjL2pzL2V4dC9jdXN0b20tc2VydmVyLXN0b3JhZ2UuanMiLCJzcmMvanMvZXh0L2N1c3RvbS10ZXh0LWVkaXRvci5qcyIsInNyYy9qcy9leHQvY3VzdG9tLXdpZGdldC1iZ2ltYWdlLmpzIiwic3JjL2pzL2V4dC9pbmxpbmVyLmpzIiwic3JjL2pzL2V4dC9sb2NhbHN0b3JhZ2UuanMiLCJzcmMvanMva28tYmluZGluZ3MuanMiLCJzcmMvanMvdGVtcGxhdGUtbG9hZGVyLmpzIiwic3JjL2pzL3RpbWVkLWNhbGwuanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb21haW4uanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb3NlcmlhbGl6ZXIuanMiLCJzcmMvanMvdmlld21vZGVsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZLQTtBQUNBOzs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ByQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcjVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2g5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcERBOztBQUVBLElBQUksSUFBVyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxRQUFQLENBQWhDLEdBQW1ELE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxPQUFPLFFBQVAsQ0FBaEMsR0FBbUQsSUFBckg7QUFDQSxJQUFJLEtBQVcsT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLE9BQU8sSUFBUCxDQUFoQyxHQUErQyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxJQUFQLENBQWhDLEdBQStDLElBQTdHO0FBQ0EsSUFBSSxVQUFVLFFBQVEseURBQVIsQ0FBZDs7QUFFQSxTQUFTLGlCQUFULENBQTJCLFNBQTNCLEVBQXNDO0FBQ3BDLE1BQUksYUFBSjtBQUNBLFlBQVUsU0FBVixHQUE4QixHQUFHLFVBQUgsQ0FBYyxNQUFkLENBQTlCO0FBQ0EsWUFBVSxRQUFWLENBQW1CLElBQW5CLEdBQThCLEdBQUcsVUFBSCxDQUFjLFVBQVUsUUFBVixDQUFtQixJQUFqQyxDQUE5Qjs7QUFFQSxZQUFVLFdBQVYsR0FBOEIsR0FBRyxRQUFILENBQVksWUFBVztBQUNuRCxXQUFPLFVBQVUsUUFBVixDQUFtQixJQUFuQixFQUFQO0FBQ0QsR0FGNkIsRUFFM0IsU0FGMkIsQ0FBOUI7O0FBSUEsWUFBVSxxQkFBVixHQUFtQyxVQUFVLElBQVYsRUFBZ0IsS0FBaEIsRUFBdUI7QUFDeEQsWUFBUSxHQUFSLENBQVksdUJBQVosRUFBcUMsSUFBckM7QUFDQSxvQkFBZ0IsVUFBVSxRQUFWLENBQW1CLElBQW5CLEVBQWhCO0FBQ0EsY0FBVSxTQUFWLENBQW9CLE1BQXBCO0FBQ0QsR0FKRDs7QUFNQSxZQUFVLHFCQUFWLEdBQW1DLFVBQVUsSUFBVixFQUFnQixLQUFoQixFQUF1QjtBQUN4RCxZQUFRLEdBQVIsQ0FBWSx1QkFBWjtBQUNBLGNBQVUsUUFBVixDQUFtQixJQUFuQixDQUF3QixhQUF4QjtBQUNBLG9CQUFnQixFQUFoQjtBQUNBLGNBQVUsU0FBVixDQUFvQixNQUFwQjtBQUNELEdBTEQ7O0FBT0EsWUFBVSxtQkFBVixHQUFpQyxVQUFVLElBQVYsRUFBZ0IsS0FBaEIsRUFBdUI7QUFDdEQsWUFBUSxHQUFSLENBQVkscUJBQVosRUFBbUMsVUFBVSxRQUFWLENBQW1CLElBQW5CLEVBQW5DO0FBQ0EsY0FBVSxTQUFWLENBQW9CLFFBQXBCO0FBQ0EsY0FBVSxRQUFWLENBQW1CLElBQW5CLENBQXdCLFVBQVUsQ0FBVixDQUFZLHlCQUFaLENBQXhCOztBQUVBLE1BQUUsSUFBRixDQUFPO0FBQ0wsY0FBUSxNQURIO0FBRUwsV0FBUSxVQUFVLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsTUFGMUI7QUFHTCxZQUFRO0FBQ04sY0FBTSxVQUFVLFFBQVYsQ0FBbUIsSUFBbkI7QUFEQSxPQUhIO0FBTUwsZUFBUyxpQkFBVSxjQUFWLEVBQTBCO0FBQ2pDLGtCQUFVLFFBQVYsQ0FBbUIsSUFBbkIsQ0FBeUIsZUFBZSxJQUFmLENBQW9CLElBQTdDO0FBQ0Esa0JBQVUsUUFBVixDQUFtQixPQUFuQixDQUEyQixVQUFVLENBQVYsQ0FBWSx5QkFBWixDQUEzQjtBQUNELE9BVEk7QUFVTCxhQUFPLGlCQUFZO0FBQ2pCLGtCQUFVLFFBQVYsQ0FBbUIsS0FBbkIsQ0FBeUIsVUFBVSxDQUFWLENBQVksc0JBQVosQ0FBekI7QUFDRCxPQVpJO0FBYUwsZ0JBQVUsb0JBQVk7QUFDcEIsd0JBQWdCLEVBQWhCO0FBQ0Esa0JBQVUsU0FBVixDQUFvQixNQUFwQjtBQUNEO0FBaEJJLEtBQVA7QUFrQkQsR0F2QkQ7QUF3QkQ7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLGlCQUFqQjs7Ozs7O0FDdERBOztBQUVBLElBQUksS0FBaUIsT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLE9BQU8sSUFBUCxDQUFoQyxHQUErQyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxJQUFQLENBQWhDLEdBQStDLElBQW5IO0FBQ0EsSUFBSSxNQUFnQixRQUFRLEtBQVIsQ0FBcEI7QUFDQSxJQUFJLGVBQWdCLFFBQVEsa0NBQVIsQ0FBcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQU0sZ0JBQWdCLFFBQVEseUJBQVIsQ0FBdEI7QUFDQSxJQUFNLFlBQWdCLFFBQVEscUJBQVIsQ0FBdEI7QUFDQSxJQUFNLGFBQWdCLFFBQVEsc0JBQVIsQ0FBdEI7QUFDQSxJQUFNLFVBQWdCLFFBQVEsa0JBQVIsQ0FBdEI7QUFDQSxJQUFNLGNBQWdCLFFBQVEsK0JBQVIsQ0FBdEI7QUFDQTtBQUNBO0FBQ0EsSUFBTSxnQkFBZ0IsUUFBUSx5QkFBUixDQUF0Qjs7QUFHQSxJQUFNLGdCQUFnQixTQUFoQixhQUFnQjtBQUFBLFNBQVEscUJBQWE7QUFDekMsY0FBVSxRQUFWLEdBQXNCLEtBQXRCO0FBQ0EsY0FBVSxPQUFWLEdBQXNCLEtBQXRCO0FBQ0EsY0FBVSxPQUFWLEdBQXNCLEtBQXRCO0FBQ0EsY0FBVSxTQUFWLEdBQXNCLEtBQUssU0FBM0I7QUFDRCxHQUxxQjtBQUFBLENBQXRCOztBQU9BLFNBQVMsZUFBVCxDQUF5QixJQUF6QixFQUErQixnQkFBL0IsRUFBaUQ7QUFDL0MsbUJBQWlCLElBQWpCLENBQXVCLGFBQXZCO0FBQ0EsbUJBQWlCLElBQWpCLENBQXVCLGNBQWMsSUFBZCxDQUF2QjtBQUNBLG1CQUFpQixJQUFqQixDQUF1QixTQUF2QjtBQUNBLG1CQUFpQixJQUFqQixDQUF1QixRQUFRLElBQVIsQ0FBdkI7QUFDQSxtQkFBaUIsSUFBakIsQ0FBdUIsV0FBdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQWlCLElBQWpCLENBQXVCLGNBQWMsSUFBZCxDQUF2QjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG9CQUFULENBQThCLElBQTlCLEVBQW9DO0FBQ2xDLE1BQUksU0FBUyxLQUFLLFFBQUwsQ0FBYyxNQUFkLElBQXdCLEVBQXJDO0FBQ0EsU0FBTyxTQUFTLDBCQUFULENBQW9DLEdBQXBDLEVBQXlDO0FBQzlDLFFBQUksQ0FBQyxHQUFMLEVBQVUsT0FBTyxJQUFQO0FBQ1IsWUFBUSxHQUFSLENBQVksNEJBQVosRUFBMEMsR0FBMUM7QUFDRjtBQUNBLFFBQUksTUFBTSxJQUFOLENBQVcsR0FBWCxDQUFKLEVBQXFCLE9BQU8sSUFBUDtBQUNyQjtBQUNBLFFBQUksUUFBUSxJQUFSLENBQWEsR0FBYixDQUFKLEVBQXVCLE9BQU8sSUFBUDtBQUN2QjtBQUNBLFFBQUksS0FBSyxJQUFMLENBQVUsR0FBVixDQUFKLEVBQW9CLE9BQU8sSUFBUDtBQUNwQjtBQUNBLFFBQUksWUFBa0IsV0FBdEI7QUFDQSxRQUFJLGtCQUFrQixjQUF0QjtBQUNBO0FBQ0EsVUFBTSxVQUFVLElBQVYsQ0FBZSxHQUFmLEVBQW9CLENBQXBCLENBQU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLENBQUMsZ0JBQWdCLElBQWhCLENBQXFCLEdBQXJCLENBQUwsRUFBZ0MsT0FBTyxJQUFQO0FBQ2hDLFlBQVEsR0FBUixDQUFZLDRCQUFaLEVBQTBDLEdBQTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQU0sYUFBYyxHQUFkLENBQU47QUFDQSxVQUFNLE9BQVEsR0FBUixJQUFnQixLQUFLLG1CQUFMLEdBQTJCLE9BQVEsR0FBUixDQUEzQyxHQUEyRCxJQUFqRTtBQUNBLFdBQU8sR0FBUDtBQUNELEdBM0JEO0FBNEJEOztBQUVEO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGNBQVQsQ0FBd0IsSUFBeEIsRUFBOEI7O0FBRTVCOztBQUVBO0FBQ0EsTUFBSSxLQUFLLElBQUwsS0FBYyxJQUFsQixFQUF3QjtBQUN0QixlQUFXLFlBQVgsR0FBMEIseUJBQTFCO0FBQ0EsZUFBVyxRQUFYLEdBQTBCLE9BQTFCO0FBQ0EsWUFBUSxJQUFSLENBQWEsSUFBYixDQUFrQixHQUFsQixDQUFzQixPQUF0QixFQUErQjtBQUM3QixnQkFBVSxTQURtQjtBQUU3QixrQkFBWSxVQUZpQjtBQUc3QiwyQkFBcUIsNkJBSFE7QUFJN0Isd0JBQWtCLGVBSlc7QUFLN0IsbUJBQWEsa0JBTGdCO0FBTTdCLHFCQUFlLFdBTmM7QUFPN0IsMkJBQXFCLHNCQVBRO0FBUTdCLHFCQUFlO0FBUmMsS0FBL0I7QUFVRDtBQUNEO0FBQ0EsZUFBYSxFQUFFLE1BQUYsQ0FBVSxFQUFDLGNBQWMsS0FBZixFQUFWLEVBQWlDLFVBQWpDLEVBQTZDLEtBQUssT0FBbEQsQ0FBYjtBQUNBLEtBQUcsZUFBSCxDQUFtQixPQUFuQixDQUEyQixXQUEzQixHQUF5QyxVQUF6Qzs7QUFFQTtBQUNBLEtBQUcsZUFBSCxDQUFtQixPQUFuQixDQUEyQixlQUEzQixHQUE2QztBQUMzQyxrQkFBYyxLQUQ2QjtBQUUzQyxzQkFBa0I7QUFDaEIsYUFBTyxXQUFXLGdCQUFYLENBQTRCO0FBRG5CLEtBRnlCO0FBSzNDLGVBQVksV0FBVyxTQUxvQjtBQU0zQyxjQUFZLFdBQVc7O0FBR3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmNkMsR0FBN0MsQ0FnQkEsR0FBRyxlQUFILENBQW1CLFVBQW5CLENBQThCLG9CQUE5QixHQUFxRCxxQkFBcUIsSUFBckIsQ0FBckQ7O0FBRUE7QUFDQSxNQUFJLHNCQUFzQixJQUFJLEtBQUosQ0FBVyxLQUFLLG1CQUFoQixDQUExQjs7QUFFQTtBQUNBLEtBQUcsZUFBSCxDQUFtQixVQUFuQixDQUE4QixzQkFBOUIsR0FBdUQsVUFBVSxJQUFWLEVBQWdCO0FBQ3JFLFlBQVEsSUFBUixDQUFhLDBCQUFiO0FBQ0EsWUFBUSxHQUFSLENBQVksSUFBWjtBQUNBLFFBQUksVUFBVSxJQUFJLE1BQUosQ0FBVztBQUN2QixnQkFBVSxvQkFBb0IsUUFEUDtBQUV2QixZQUFVLG9CQUFvQixJQUZQO0FBR3ZCLGdCQUFVLG9CQUFvQjtBQUhQLEtBQVgsQ0FBZDtBQUtBLFNBQUssR0FBTCxHQUFXLElBQUksT0FBSixDQUFZLE9BQVosRUFBcUIsSUFBSSxLQUFKLENBQVUsS0FBSyxHQUFmLEVBQW9CLFFBQXpDLENBQVg7QUFDQSxXQUFPLElBQVA7QUFDRCxHQVZEOztBQVlBO0FBQ0EsS0FBRyxlQUFILENBQW1CLFVBQW5CLENBQThCLFlBQTlCLEdBQTZDLFVBQVMsR0FBVCxFQUFjLE1BQWQsRUFBc0IsS0FBdEIsRUFBNkIsTUFBN0IsRUFBcUM7QUFDaEYsUUFBSSxZQUFZLElBQUksS0FBSixDQUFVLEdBQVYsRUFBZSxRQUEvQjtBQUNBLFFBQUksQ0FBQyxTQUFMLEVBQWdCLFFBQVEsSUFBUixDQUFhLHVCQUFiLEVBQXNDLEdBQXRDO0FBQ2hCLFlBQVEsSUFBUixDQUFhLGVBQWIsRUFBOEIsU0FBOUIsRUFBeUMsTUFBekMsRUFBaUQsS0FBakQsRUFBd0QsTUFBeEQ7QUFDQSxnQkFBZ0IsVUFBVSxPQUFWLENBQWtCLE9BQWxCLEVBQTJCLEVBQTNCLENBQWhCO0FBQ0EsUUFBSSxPQUFZLEtBQUssUUFBTCxHQUFnQixHQUFoQixHQUFzQixNQUF0QztBQUNBLFdBQWdCLE9BQU8sR0FBUCxHQUFhLEtBQWIsR0FBcUIsR0FBckIsR0FBMkIsTUFBM0IsR0FBb0MsR0FBcEMsR0FBMEMsU0FBMUQ7QUFDQSxXQUFPLElBQVA7QUFDRCxHQVJEOztBQVVBLEtBQUcsZUFBSCxDQUFtQixVQUFuQixDQUE4QixjQUE5QixHQUErQyxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDM0U7QUFDQSxXQUFPLEtBQUssUUFBTCxHQUFnQixlQUFoQixHQUFrQyxLQUFsQyxHQUEwQyxHQUExQyxHQUFnRCxNQUFoRCxHQUF5RCxNQUFoRTtBQUNELEdBSEQ7QUFJRDs7QUFFRCxPQUFPLE9BQVAsR0FBaUI7QUFDZixrQ0FEZTtBQUVmO0FBRmUsQ0FBakI7Ozs7OztBQzNKQTs7QUFFQSxJQUFJLFVBQVUsUUFBUSx5REFBUixDQUFkO0FBQ0EsSUFBSSxJQUFXLE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxPQUFPLFFBQVAsQ0FBaEMsR0FBbUQsT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLE9BQU8sUUFBUCxDQUFoQyxHQUFtRCxJQUFySDtBQUNBLElBQUksS0FBVyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxJQUFQLENBQWhDLEdBQStDLE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxPQUFPLElBQVAsQ0FBaEMsR0FBK0MsSUFBN0c7QUFDQSxJQUFJLFFBQVUsUUFBUSxhQUFSLENBQWQ7O0FBRUEsU0FBUyxhQUFULENBQXdCLElBQXhCLEVBQStCOztBQUU3QixNQUFJLGFBQWEsS0FBSyxnQkFBTCxDQUFzQixHQUF2Qzs7QUFFQSxTQUFPLFVBQVUsU0FBVixFQUFxQjs7QUFFMUIsY0FBVSxjQUFWLEdBQWtDLEdBQUcsZUFBSCxDQUFtQixFQUFuQixDQUFsQztBQUNBLGNBQVUsZUFBVixHQUFrQyxHQUFHLGVBQUgsQ0FBbUIsRUFBbkIsQ0FBbEM7QUFDQSxjQUFVLG9CQUFWLEdBQWtDLEdBQUcsVUFBSCxDQUFjLEtBQWQsQ0FBbEM7QUFDQSxjQUFVLHFCQUFWLEdBQWtDLEdBQUcsVUFBSCxDQUFjLEtBQWQsQ0FBbEM7O0FBRUEsYUFBUyxXQUFULENBQXNCLElBQXRCLEVBQTZCO0FBQzNCLFVBQUksTUFBVyxXQUFZLElBQVosQ0FBZjtBQUNBLFVBQUksVUFBVyxVQUFXLE9BQU8sU0FBbEIsQ0FBZjtBQUNBLFVBQUksU0FBVyxVQUFXLE9BQU8sZUFBbEIsQ0FBZjtBQUNBLGFBQU8sWUFBVztBQUNoQixlQUFPLFNBQVA7QUFDQTtBQUNBLFVBQUUsT0FBRixDQUFVLEdBQVYsRUFBZSxVQUFXLElBQVgsRUFBa0I7QUFDL0IsZUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssS0FBTCxDQUFXLE1BQS9CLEVBQXVDLEdBQXZDO0FBQTRDLGlCQUFLLEtBQUwsQ0FBVyxDQUFYLElBQWdCLFVBQVUsbUJBQVYsQ0FBOEIsS0FBSyxLQUFMLENBQVcsQ0FBWCxDQUE5QixDQUFoQjtBQUE1QyxXQUNBLE9BQVEsS0FBSyxLQUFMLENBQVcsTUFBbkI7QUFDQSxrQkFBUyxLQUFLLEtBQUwsQ0FBVyxPQUFYLEVBQVQ7QUFDRCxTQUpELEVBSUcsSUFKSCxDQUlRLFlBQVc7QUFDakIsaUJBQVEsS0FBUjtBQUNBLG9CQUFVLFFBQVYsQ0FBbUIsS0FBbkIsQ0FBeUIsVUFBVSxDQUFWLENBQVksZ0NBQVosQ0FBekI7QUFDRCxTQVBEO0FBUUQsT0FYRDtBQVlEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBUyxTQUFULENBQW9CLElBQXBCLEVBQTJCO0FBQ3pCLFVBQUksVUFBVyxVQUFXLE9BQU8sU0FBbEIsQ0FBZjtBQUNBLFVBQUksU0FBVyxVQUFXLE9BQU8sZUFBbEIsQ0FBZjtBQUNBLGFBQU8sVUFBVyxHQUFYLEVBQWlCO0FBQ3RCLFlBQUksWUFBb0IsSUFBSSxJQUE1QjtBQUNBO0FBQ0E7QUFDQSxZQUFJLG9CQUFvQixNQUFPLFNBQVAsRUFBa0IsVUFBVSxJQUFWLEVBQWlCO0FBQ3pELGlCQUFPLEtBQUssSUFBTCxLQUFjLFNBQXJCO0FBQ0QsU0FGdUIsQ0FBeEI7QUFHQSxZQUFLLGlCQUFMLEVBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFlBQUssYUFBYSxLQUFsQixFQUEwQjtBQUMxQixnQkFBUSxPQUFSLENBQWlCLEdBQWpCO0FBQ0EsZUFBUSxVQUFVLE1BQWxCO0FBQ0QsT0FkRDtBQWVEOztBQUVELGNBQVUsa0JBQVYsR0FBa0MsWUFBYSxTQUFiLENBQWxDO0FBQ0EsY0FBVSxtQkFBVixHQUFrQyxZQUFhLFVBQWIsQ0FBbEM7QUFDQSxjQUFVLGdCQUFWLEdBQWtDLFVBQVcsU0FBWCxDQUFsQztBQUNBLGNBQVUsaUJBQVYsR0FBa0MsVUFBVyxVQUFYLENBQWxDOztBQUVBLFFBQU0sY0FBYyxVQUFVLFdBQVYsQ0FBc0IsU0FBdEIsQ0FBaUMsb0JBQVk7QUFDL0QsVUFBSSxhQUFhLElBQWIsSUFBcUIsVUFBVSxvQkFBVixPQUFxQyxLQUE5RCxFQUFxRTtBQUNuRSxrQkFBVSxrQkFBVjtBQUNBLG9CQUFZLE9BQVo7QUFDRDtBQUNGLEtBTG1CLENBQXBCOztBQU9BLFFBQU0sWUFBWSxVQUFVLGdCQUFWLENBQTJCLFNBQTNCLENBQXNDLG9CQUFZO0FBQ2xFLFVBQUksYUFBYSxDQUFiLElBQWtCLFVBQVUscUJBQVYsT0FBc0MsS0FBNUQsRUFBbUU7QUFDakUsa0JBQVUsbUJBQVY7QUFDQSxrQkFBVSxPQUFWO0FBQ0Q7QUFDRixLQUxpQixFQUtmLFNBTGUsRUFLSixRQUxJLENBQWxCO0FBT0QsR0FwRUQ7QUFzRUQ7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLGFBQWpCOzs7Ozs7QUNuRkE7O0FBRUEsSUFBSSxVQUFVLFFBQVEseURBQVIsQ0FBZDtBQUNBLElBQUksSUFBVyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxRQUFQLENBQWhDLEdBQW1ELE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxPQUFPLFFBQVAsQ0FBaEMsR0FBbUQsSUFBckg7QUFDQSxJQUFJLEtBQVcsT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLE9BQU8sSUFBUCxDQUFoQyxHQUErQyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxJQUFQLENBQWhDLEdBQStDLElBQTdHOztBQUVBLFNBQVMsa0JBQVQsQ0FBNkIsU0FBN0IsRUFBeUM7O0FBRXZDLFlBQVUsV0FBVixHQUF3QixVQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0IsS0FBdEIsRUFBNkI7QUFDbkQsUUFBSSxZQUFZLEtBQUssU0FBckI7O0FBRUEsTUFBRSxJQUFGLENBQU87QUFDTCxXQUFRLFNBREg7QUFFTCxjQUFRLFFBRkg7QUFHTDtBQUNBO0FBQ0E7QUFDQSxZQUFRLFFBTkg7QUFPTCxlQUFTLGlCQUFVLEdBQVYsRUFBZTtBQUN0QixrQkFBVSxRQUFWLENBQW1CLE9BQW5CLENBQTJCLFVBQVUsQ0FBVixDQUFZLDhCQUFaLENBQTNCO0FBQ0EsWUFBSSxVQUFXLFVBQVcsT0FBTyxTQUFsQixDQUFmO0FBQ0EsWUFBSSxTQUFXLFVBQVcsT0FBTyxlQUFsQixDQUFmO0FBQ0EsZUFBUSxJQUFJLEtBQUosQ0FBVSxNQUFsQjtBQUNBLGdCQUFTLElBQUksS0FBSixDQUFVLE9BQVYsRUFBVDtBQUNELE9BYkk7QUFjTCxhQUFPLGVBQVUsR0FBVixFQUFlO0FBQ3BCLGdCQUFRLEdBQVIsQ0FBWSxHQUFaO0FBQ0Esa0JBQVUsUUFBVixDQUFtQixLQUFuQixDQUF5QixVQUFVLENBQVYsQ0FBWSwyQkFBWixDQUF6QjtBQUNEO0FBakJJLEtBQVA7QUFtQkQsR0F0QkQ7QUF3QkQ7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLGtCQUFqQjs7Ozs7O0FDbENBOztBQUVBLElBQUksVUFBVSxRQUFRLHlEQUFSLENBQWQ7QUFDQSxJQUFJLElBQVcsT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLE9BQU8sUUFBUCxDQUFoQyxHQUFtRCxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxRQUFQLENBQWhDLEdBQW1ELElBQXJIO0FBQ0EsSUFBSSxLQUFXLE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxPQUFPLElBQVAsQ0FBaEMsR0FBK0MsT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLE9BQU8sSUFBUCxDQUFoQyxHQUErQyxJQUE3RztBQUNBLElBQUksUUFBVSxRQUFRLGFBQVIsQ0FBZDtBQUNBLElBQUksVUFBVSxRQUFRLHVCQUFSLENBQWQ7O0FBRUEsU0FBUyxPQUFULENBQWlCLFNBQWpCLEVBQTRCO0FBQzFCO0FBQ0E7QUFDQSxNQUFJLFFBQVMsTUFBTSxHQUFHLElBQUgsQ0FBUSxVQUFVLFFBQWxCLENBQU4sRUFBbUMsQ0FBQyxjQUFELEVBQWlCLFVBQWpCLENBQW5DLENBQWI7QUFDQSxRQUFNLElBQU4sR0FBYSxVQUFVLFFBQVYsRUFBYjtBQUNBLFNBQU8sS0FBUDtBQUNEOztBQUVELElBQUksU0FBUyxTQUFULE1BQVMsQ0FBVSxTQUFWLEVBQXFCO0FBQ2hDLFVBQVEsSUFBUixDQUFhLDRDQUFiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJLFVBQVU7QUFDWixVQUFNLE1BRE0sRUFDRTtBQUNkLGFBQVMsR0FBRyxVQUFILENBQWMsSUFBZDtBQUZHLEdBQWQ7QUFJQSxVQUFRLE9BQVIsR0FBa0IsWUFBVztBQUMzQixZQUFRLE9BQVIsQ0FBZ0IsS0FBaEI7QUFDQSxRQUFJLE9BQU8sUUFBUSxTQUFSLENBQVg7QUFDQSxZQUFRLElBQVIsQ0FBYSxXQUFiO0FBQ0EsWUFBUSxHQUFSLENBQVksSUFBWjs7QUFFQTtBQUNBO0FBQ0EsTUFBRSxJQUFGLENBQU87QUFDTCxXQUFjLE9BQU8sUUFBUCxDQUFnQixJQUR6QjtBQUVMLGNBQWMsTUFGVDtBQUdMLG1CQUFjLGtCQUhUO0FBSUwsWUFBYyxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBSlQ7QUFLTCxlQUFjLGFBTFQ7QUFNTCxhQUFjLFdBTlQ7QUFPTCxnQkFBYztBQVBULEtBQVA7O0FBVUE7QUFDQTtBQUNBLGFBQVMsYUFBVCxDQUF1QixJQUF2QixFQUE2QixVQUE3QixFQUF5QyxLQUF6QyxFQUFnRDtBQUM5QyxjQUFRLEdBQVIsQ0FBWSxjQUFaO0FBQ0EsZ0JBQVUsUUFBVixDQUFtQixPQUFuQixDQUE0QixVQUFVLENBQVYsQ0FBWSxzQkFBWixDQUE1QjtBQUNEOztBQUVELGFBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QixVQUE1QixFQUF3QyxXQUF4QyxFQUFxRDtBQUNuRCxjQUFRLEdBQVIsQ0FBWSxZQUFaO0FBQ0EsY0FBUSxHQUFSLENBQVksV0FBWjtBQUNBLGdCQUFVLFFBQVYsQ0FBbUIsS0FBbkIsQ0FBeUIsVUFBVSxDQUFWLENBQVksb0JBQVosQ0FBekI7QUFDRDs7QUFFRCxhQUFTLGNBQVQsR0FBMEI7QUFDeEIsY0FBUSxPQUFSLENBQWdCLElBQWhCO0FBQ0Q7QUFDRixHQWxDRDs7QUFvQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUksVUFBVTtBQUNaLFVBQU0sTUFETSxFQUNFO0FBQ2QsYUFBUyxHQUFHLFVBQUgsQ0FBYyxJQUFkO0FBRkcsR0FBZDtBQUlBLFVBQVEsT0FBUixHQUFrQixZQUFXO0FBQzNCLFlBQVEsSUFBUixDQUFhLE1BQWI7QUFDQSxZQUFRLEdBQVIsQ0FBWSxVQUFVLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsSUFBbkM7QUFDQSxZQUFRLE9BQVIsQ0FBZ0IsS0FBaEI7QUFDQSxRQUFJLFFBQVEsVUFBVSxDQUFWLENBQVkseUNBQVosQ0FBWjtBQUNBLFlBQVksT0FBTyxNQUFQLENBQWMsVUFBVSxDQUFWLENBQVksb0JBQVosQ0FBZCxFQUFpRCxLQUFqRCxDQUFaOztBQUVBO0FBQ0EsUUFBSyxDQUFDLEtBQU4sRUFBYyxPQUFPLFFBQVEsT0FBUixDQUFnQixJQUFoQixDQUFQOztBQUVkLFFBQUksQ0FBQyxRQUFRLEtBQVIsQ0FBTCxFQUFxQjtBQUNuQixhQUFPLEtBQVAsQ0FBYSxVQUFVLENBQVYsQ0FBWSx1QkFBWixDQUFiO0FBQ0EsYUFBTyxRQUFRLE9BQVIsQ0FBZ0IsSUFBaEIsQ0FBUDtBQUNEOztBQUVELFlBQVEsR0FBUixDQUFZLGlCQUFaLEVBQStCLEtBQS9CO0FBQ0EsUUFBSSxXQUFZLEdBQUcsSUFBSCxDQUFRLFVBQVUsUUFBbEIsQ0FBaEI7QUFDQSxRQUFJLFFBQVk7QUFDZCxZQUFVLEtBREk7QUFFZCxZQUFVLFVBQVUsVUFBVjtBQUZJLEtBQWhCO0FBSUEsTUFBRSxJQUFGLENBQU87QUFDTCxXQUFjLFVBQVUsUUFBVixDQUFtQixHQUFuQixDQUF1QixJQURoQztBQUVMLGNBQWMsTUFGVDtBQUdMLFlBQWMsS0FIVDtBQUlMLGVBQWMsYUFKVDtBQUtMLGFBQWMsV0FMVDtBQU1MLGdCQUFjO0FBTlQsS0FBUDs7QUFTQSxhQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkIsVUFBN0IsRUFBeUMsS0FBekMsRUFBZ0Q7QUFDOUMsY0FBUSxHQUFSLENBQVksY0FBWjtBQUNBLGdCQUFVLFFBQVYsQ0FBbUIsT0FBbkIsQ0FBMkIsVUFBVSxDQUFWLENBQVksb0JBQVosQ0FBM0I7QUFDRDs7QUFFRCxhQUFTLFdBQVQsQ0FBcUIsS0FBckIsRUFBNEIsVUFBNUIsRUFBd0MsV0FBeEMsRUFBcUQ7QUFDbkQsY0FBUSxHQUFSLENBQVksWUFBWjtBQUNBLGNBQVEsR0FBUixDQUFZLFdBQVo7QUFDQSxnQkFBVSxRQUFWLENBQW1CLEtBQW5CLENBQXlCLFVBQVUsQ0FBVixDQUFZLGlEQUFaLENBQXpCO0FBQ0Q7O0FBRUQsYUFBUyxjQUFULEdBQTBCO0FBQ3hCLGNBQVEsT0FBUixDQUFnQixJQUFoQjtBQUNEO0FBQ0YsR0E1Q0Q7O0FBOENBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJLGNBQWM7QUFDaEIsVUFBUSxVQURRLEVBQ0k7QUFDcEIsYUFBUyxHQUFHLFVBQUgsQ0FBYyxJQUFkO0FBRk8sR0FBbEI7QUFJQSxjQUFZLE9BQVosR0FBc0IsWUFBVztBQUMvQixZQUFRLElBQVIsQ0FBYSxVQUFiO0FBQ0EsZ0JBQVksT0FBWixDQUFvQixLQUFwQjtBQUNBLGNBQVUsUUFBVixDQUFtQixJQUFuQixDQUF3QixVQUFVLENBQVYsQ0FBWSxnQkFBWixDQUF4QjtBQUNBLGNBQVUsb0JBQVYsQ0FBK0IsdUJBQS9CO0FBQ0EsTUFBRSx1QkFBRixFQUEyQixHQUEzQixDQUErQixVQUFVLFFBQVYsQ0FBbUIsSUFBbkIsRUFBL0I7QUFDQSxNQUFFLGVBQUYsRUFDQyxJQURELENBQ00sUUFETixFQUNnQixVQUFVLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsR0FEdkMsRUFFQyxNQUZEO0FBR0EsZ0JBQVksT0FBWixDQUFvQixJQUFwQjtBQUNELEdBVkQ7O0FBWUEsWUFBVSxJQUFWLEdBQXNCLE9BQXRCO0FBQ0EsWUFBVSxJQUFWLEdBQXNCLE9BQXRCO0FBQ0EsWUFBVSxRQUFWLEdBQXNCLFdBQXRCO0FBRUQsQ0E3SEQ7O0FBK0hBLE9BQU8sT0FBUCxHQUFpQixNQUFqQjs7Ozs7QUMvSUE7O0FBRUEsSUFBSSxXQUFXLFFBQVEsaUJBQVIsQ0FBZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLFdBQVcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixFQUFuQixFQUNkLEdBRGMsQ0FDVixVQUFVLENBQVYsRUFBYTtBQUFFLFNBQU8sS0FBSyxLQUFMLENBQVksSUFBSSxHQUFMLEdBQVksR0FBdkIsSUFBOEIsR0FBckM7QUFBMEMsQ0FEL0MsRUFFZCxHQUZjLENBRVYsVUFBVSxDQUFWLEVBQWE7QUFBRSxTQUFPLElBQUksR0FBSixHQUFVLENBQVYsR0FBYyxJQUFyQjtBQUEyQixDQUZoQyxFQUdkLElBSGMsQ0FHVCxHQUhTLENBQWY7O0FBS0EsUUFBUSxhQUFSLENBQXNCLEdBQXRCLENBQTBCLFNBQTFCLEVBQXFDLGdCQUFyQzs7QUFFQSxTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3JDLFNBQU8sU0FBUCxDQUFpQixxQkFBakIsRUFBd0MsWUFBWTtBQUNsRCxRQUFJLFVBQVksT0FBTyxRQUFQLENBQWdCLGVBQWhCLElBQW1DLFFBQW5EO0FBQ0EsUUFBSSxRQUFZLFFBQVEsS0FBUixDQUFjLEdBQWQsRUFBbUIsR0FBbkIsQ0FBd0IsVUFBVSxJQUFWLEVBQWdCO0FBQ3RELFVBQUksT0FBUSxJQUFaO0FBQ0EsVUFBSSxRQUFRLElBQVo7QUFDQTtBQUNBLFVBQUksU0FBUyxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWI7QUFDQSxVQUFJLE9BQU8sTUFBUCxHQUFnQixDQUFwQixFQUF1QjtBQUNyQixlQUFPLE9BQU8sQ0FBUCxDQUFQO0FBQ0EsZ0JBQVEsT0FBTyxDQUFQLENBQVI7QUFDRDtBQUNELGFBQU8sRUFBQyxNQUFNLElBQVAsRUFBYSxPQUFPLEtBQXBCLEVBQVA7QUFDRCxLQVZlLENBQWhCOztBQVlBLGFBQVMsZ0JBQVQsQ0FBMEIsQ0FBMUIsRUFBNkI7QUFDM0IsVUFBSSxDQUFDLEVBQUUsT0FBRixDQUFVLFFBQVYsQ0FBbUIsS0FBeEIsRUFBK0I7QUFDL0IsY0FBUSxZQUFSLENBQXFCLFNBQXJCLENBQStCLFFBQS9CLENBQXdDLGdCQUF4QyxFQUEwRDtBQUN4RCxnQkFBUyxNQUQrQztBQUV4RCxnQkFBUyxFQUFFLGtCQUFtQixFQUFFLE9BQUYsQ0FBVSxRQUFWLENBQW1CLEtBQXhDO0FBRitDLE9BQTFEO0FBSUEsY0FBUSxZQUFSLENBQXFCLFNBQXJCLENBQStCLEtBQS9CLENBQXFDLGdCQUFyQztBQUNEOztBQUVELFdBQU87QUFDTCxZQUFZLFNBRFA7QUFFTCxZQUFZLGdCQUZQO0FBR0wsZUFBWSxnQkFIUDtBQUlMLGNBQVksS0FKUDtBQUtMLGtCQUFZLElBTFA7QUFNTCxlQUFZO0FBTlAsS0FBUDtBQVNELEdBaENEO0FBaUNEOztBQUVEOztBQUVBO0FBQ0EsU0FBUyxJQUFULENBQWMsQ0FBZCxFQUFpQixFQUFqQixFQUFxQixDQUFyQixFQUF3QjtBQUN0QixNQUFJLENBQUosRUFBTyxDQUFQOztBQUVBLE1BQUksQ0FBQyxDQUFMLEVBQVE7QUFDTixXQUFPLENBQVA7QUFDRDs7QUFFRCxNQUFJLEtBQUssQ0FBVDs7QUFFQSxNQUFJLEVBQUUsTUFBRixLQUFhLFNBQWpCLEVBQTRCO0FBQzFCO0FBQ0EsU0FBSyxJQUFJLENBQUosRUFBTyxJQUFJLEVBQUUsTUFBbEIsRUFBMEIsSUFBSSxDQUE5QixFQUFpQyxHQUFqQyxFQUFzQztBQUNwQyxVQUFJLEdBQUcsSUFBSCxDQUFRLENBQVIsRUFBVyxFQUFFLENBQUYsQ0FBWCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixNQUEyQixLQUEvQixFQUFzQztBQUNwQyxlQUFPLENBQVA7QUFDRDtBQUNGO0FBQ0YsR0FQRCxNQU9PO0FBQ0w7QUFDQSxTQUFLLENBQUwsSUFBVSxDQUFWLEVBQWE7QUFDWCxVQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCO0FBQ3ZCLFlBQUksR0FBRyxJQUFILENBQVEsQ0FBUixFQUFXLEVBQUUsQ0FBRixDQUFYLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLE1BQTJCLEtBQS9CLEVBQXNDO0FBQ3BDLGlCQUFPLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPLENBQVA7QUFDRDs7QUFFRDtBQUNBLFFBQVEsYUFBUixDQUFzQixHQUF0QixDQUEwQixnQkFBMUIsRUFBNEMsY0FBNUM7O0FBRUEsU0FBUyxjQUFULENBQXdCLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ25DLFVBQVEsR0FBUixDQUFZLE1BQVo7QUFDQSxNQUFJLGNBQWtCLENBQXRCO0FBQ0EsTUFBSSxjQUFrQixHQUF0QjtBQUNBLE1BQUksY0FBa0IsS0FBdEI7QUFDQSxNQUFJLGlCQUFrQixDQUNwQixRQUFRLElBQVIsQ0FBYSxJQUFiLENBQWtCLFNBQWxCLENBQTRCLG1CQUE1QixDQURvQixFQUVwQixRQUFRLElBQVIsQ0FBYSxJQUFiLENBQWtCLFNBQWxCLENBQTRCLGFBQTVCLENBRm9CLEVBSXJCLEdBSnFCLENBSWhCLFVBQVUsQ0FBVixFQUFhO0FBQUUsV0FBTyxPQUFPLENBQWQ7QUFBZ0IsR0FKZixFQUtyQixJQUxxQixDQUtmLE1BTGUsQ0FBdEI7O0FBT0EsU0FBTyxTQUFQLENBQWlCLHNCQUFqQixFQUF5QztBQUN2QyxVQUFjLFdBRHlCO0FBRXZDLGFBQWMsV0FGeUI7QUFHdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFjLHNCQVB5QjtBQVF2QyxVQUFjLEtBUnlCO0FBU3ZDLGtCQUFjLFlBVHlCO0FBVXZDLGFBQWM7QUFWeUIsR0FBekM7O0FBYUEsV0FBUyxZQUFULENBQXNCLFNBQXRCLEVBQWlDO0FBQy9CLFFBQUksY0FBYyxVQUFVLE9BQTVCO0FBQ0EsUUFBSSxhQUFjLFVBQWxCO0FBQ0EsUUFBSSxPQUFjLElBQWxCOztBQUVBLFdBQU8sRUFBUCxDQUFVLFlBQVYsRUFBd0IsU0FBUyxZQUFULEVBQXVCLEdBQXZCLENBQXhCOztBQUVBLGFBQVMsWUFBVCxDQUF1QixDQUF2QixFQUEyQjtBQUN6QixXQUFLLEVBQUUsT0FBUCxFQUFnQixXQUFoQjtBQUNBLFVBQUksQ0FBQyxXQUFMLEVBQWtCO0FBQ2hCLHNCQUFjLFNBQVMsV0FBVCxDQUFxQixnQkFBckIsQ0FBc0MsRUFBRSxPQUFGLENBQVUsQ0FBVixLQUFnQixFQUFFLE9BQXhELEVBQWlFLElBQWpFLEVBQ2IsZ0JBRGEsQ0FDSSxXQURKLENBQWQ7QUFFRDtBQUNGOztBQUVELGFBQVMsV0FBVCxDQUFxQixJQUFyQixFQUEyQjtBQUN6QixVQUFJLEtBQUssS0FBTCxJQUFjLEtBQUssS0FBTCxDQUFXLFFBQTdCLEVBQXVDO0FBQ3JDLG9CQUFZLElBQVosQ0FBa0IsUUFBUSxJQUFSLENBQWEsSUFBYixDQUFrQixTQUFsQixDQUE0QixhQUE1QixJQUE2QyxLQUFLLEtBQUwsQ0FBVyxRQUExRTtBQUNBLHNCQUFjLEtBQUssS0FBTCxDQUFXLFFBQXpCO0FBQ0EsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxvQkFBYyxLQUFkO0FBQ0Esa0JBQVksSUFBWixDQUFrQixRQUFRLElBQVIsQ0FBYSxJQUFiLENBQWtCLFNBQWxCLENBQTRCLFdBQTVCLENBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTLFlBQVQsQ0FBc0IsUUFBdEIsRUFBZ0M7QUFDOUIsUUFBSSxZQUFZLGNBQWMsU0FBUyxJQUFULENBQWMsV0FBZCxDQUFkLEdBQTJDLElBQTNEO0FBQ0EsZ0JBQWdCLE1BQU0sT0FBTixDQUFjLFNBQWQsSUFBMkIsVUFBVSxDQUFWLENBQTNCLEdBQTBDLEVBQTFEOztBQUVBLFdBQU8sYUFBUCxDQUFxQixJQUFyQixDQUEwQjtBQUN4QixhQUFPLG1CQURpQjtBQUV4QixhQUFPLEdBRmlCO0FBR3hCLGNBQVEsR0FIZ0I7QUFJeEIsWUFBTSxDQUNKO0FBQ0UsY0FBWSxPQURkO0FBRUUsbUJBQVksSUFGZDtBQUdFLGNBQVksRUFIZDtBQUlFO0FBQ0E7QUFDQSxzQkFBYyx3QkFBWTtBQUN4QixlQUFLLEtBQUwsR0FBYSxTQUFiLEdBQXlCLGNBQXpCO0FBQ0Q7QUFSSCxPQURJLEVBV0o7QUFDRSxjQUFVLFNBRFo7QUFFRSxjQUFVLGtCQUZaO0FBR0UsZUFBVSxVQUhaO0FBSUUsbUJBQVcsSUFKYjtBQUtFLGVBQVcsU0FMYjtBQU1FLHNCQUFjLHdCQUFZO0FBQ3hCLGVBQUssR0FBTCxDQUFTLElBQVQsQ0FBYztBQUNaLGtCQUFRLFFBREk7QUFFWixpQkFBUSxXQUZJO0FBR1osa0JBQVE7QUFISSxXQUFkO0FBS0Q7QUFaSCxPQVhJLENBSmtCO0FBOEJ4QixnQkFBVSxrQkFBVSxDQUFWLEVBQWE7QUFDckIsWUFBSSxjQUFjLENBQUMsQ0FBQyxFQUFFLElBQUYsQ0FBTyxnQkFBM0I7QUFDQSxZQUFJLGVBQWUsV0FBZixJQUE4QixlQUFlLFdBQWpELEVBQThEO0FBQzVELGlCQUFPLFdBQVAsQ0FBbUIsVUFBbkIsRUFBK0IsS0FBL0IsRUFBc0MsY0FBYyxJQUFwRDtBQUNELFNBRkQsTUFFTztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Y7QUExQ3VCLEtBQTFCO0FBNENEO0FBRUY7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLElBQUksb0JBQW9CO0FBQ3RCLFlBQVUsdUlBRFk7QUFFdEI7QUFDQTtBQUNBLFdBQVMsQ0FBQyx1RUFBRCxDQUphO0FBS3RCO0FBQ0EsaUJBQWUsQ0FDYixFQUFDLE9BQU8sUUFBUixFQUFrQixPQUFPLENBQ3ZCLEVBQUMsT0FBTyxNQUFSLEVBQXlCLE1BQU0sTUFBL0IsRUFBZ0QsUUFBUSxRQUF4RCxFQUR1QixFQUV2QixFQUFDLE9BQU8sUUFBUixFQUF5QixNQUFNLFFBQS9CLEVBQWdELFFBQVEsSUFBeEQsRUFGdUIsRUFHdkIsRUFBQyxPQUFPLFdBQVIsRUFBeUIsTUFBTSxXQUEvQixFQUFnRCxRQUFRLE1BQXhELEVBQWdFLFFBQVEsRUFBQyxtQkFBb0IsV0FBckIsRUFBeEUsRUFIdUIsRUFJdkIsRUFBQyxPQUFPLGVBQVIsRUFBeUIsTUFBTSxlQUEvQixFQUFnRCxRQUFRLE1BQXhELEVBQWdFLFFBQVEsRUFBQyxtQkFBb0IsY0FBckIsRUFBeEUsRUFKdUIsRUFLdkIsRUFBQyxPQUFPLGFBQVIsRUFBeUIsTUFBTSxhQUEvQixFQUFnRCxRQUFRLEtBQXhELEVBTHVCLEVBTXZCLEVBQUMsT0FBTyxXQUFSLEVBQXlCLE1BQU0sV0FBL0IsRUFBZ0QsUUFBUSxLQUF4RCxFQU51QixFQU92QixFQUFDLE9BQU8sTUFBUixFQUF5QixNQUFNLE1BQS9CLEVBQWdELFFBQVEsTUFBeEQsRUFQdUIsQ0FBekIsRUFEYSxFQVViLEVBQUMsT0FBTyxXQUFSLEVBQXFCLE9BQU8sQ0FDMUIsRUFBQyxPQUFPLE1BQVIsRUFBbUIsTUFBTSxXQUF6QixFQUF5QyxPQUFPLEtBQWhELEVBQXVELFFBQVEsRUFBQyxjQUFlLE1BQWhCLEVBQS9ELEVBRDBCLEVBRTFCLEVBQUMsT0FBTyxRQUFSLEVBQW1CLE1BQU0sYUFBekIsRUFBeUMsT0FBTyxLQUFoRCxFQUF1RCxRQUFRLEVBQUMsY0FBZSxRQUFoQixFQUEvRCxFQUYwQixFQUcxQixFQUFDLE9BQU8sT0FBUixFQUFtQixNQUFNLFlBQXpCLEVBQXlDLE9BQU8sS0FBaEQsRUFBdUQsUUFBUSxFQUFDLGNBQWUsT0FBaEIsRUFBL0QsRUFIMEIsRUFJMUIsRUFBQyxPQUFPLFNBQVIsRUFBbUIsTUFBTSxjQUF6QixFQUF5QyxPQUFPLEtBQWhELEVBQXVELFFBQVEsRUFBQyxjQUFlLFNBQWhCLEVBQS9ELEVBSjBCLENBQTVCLEVBVmE7QUFOTyxDQUF4Qjs7QUF5QkEsT0FBTyxPQUFQLEdBQWlCLGlCQUFqQjs7OztBQzlOQTs7QUFFQSxJQUFNLEtBQWUsT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLE9BQU8sSUFBUCxDQUFoQyxHQUErQyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsT0FBTyxJQUFQLENBQWhDLEdBQStDLElBQW5IO0FBQ0EsSUFBTSxVQUFjLFFBQVEseURBQVIsQ0FBcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQU0sb0JBQW9CLE9BQU8sTUFBUCxDQUFjO0FBQ3RDO0FBRHNDLENBQWQsQ0FBMUI7QUFHQSxJQUFNLHFHQUFOOztBQUVBLElBQU0sY0FBZ0IsU0FBaEIsV0FBZ0I7QUFBQSxTQUFRLGVBQWMsSUFBZCxDQUFvQixLQUFLLElBQUwsRUFBcEI7QUFBUjtBQUFBLENBQXRCOztBQUdBLFNBQVMsSUFBVCxDQUFlLFlBQWYsRUFBNkIsY0FBN0IsRUFBNkMsVUFBN0MsRUFBMEQ7QUFDeEQsc0VBQ3NELFlBRHRELDRCQUN5RixZQUR6RixVQUMwRyxjQUQxRywrSEFFOEcsWUFGOUcsY0FFaUksVUFGakksd0dBR2lFLFlBSGpFLGNBR29GLFVBSHBGO0FBS0Q7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLGdCQUFRO0FBQUEsTUFFZixRQUZlLEdBRUYsSUFGRSxDQUVmLFFBRmU7OztBQUl2QixXQUFTLE1BQVQsQ0FBaUIsQ0FBakIsRUFBb0IsRUFBcEIsRUFBd0IsTUFBeEIsRUFBaUM7QUFDL0IsV0FBTztBQUNMLGNBQVEsU0FESDtBQUVMLDBDQUZLO0FBR0w7QUFISyxLQUFQO0FBS0Q7O0FBRUQsV0FBUyxTQUFULENBQW9CLEVBQXBCLEVBQXlCO0FBQ3ZCLE9BQUcsaUJBQUgsR0FBd0IsR0FBRyxVQUFILENBQWUsS0FBZixDQUF4QjtBQUNBLE9BQUcsY0FBSCxHQUF3QixHQUFHLFVBQUgsQ0FBZSxLQUFmLENBQXhCO0FBQ0EsT0FBRyxVQUFILEdBQXdCLFVBQUUsU0FBRixFQUFhLEdBQWIsRUFBa0IsS0FBbEIsRUFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFHLGNBQUgsR0FBeUIsUUFBekIsYUFBMkMsU0FBM0M7QUFDQSxTQUFHLGtCQUFIO0FBQ0QsS0FQRDtBQVFBLE9BQUcsWUFBSCxHQUF3QixVQUFFLFlBQUYsRUFBZ0IsVUFBaEIsRUFBNEIsZUFBNUIsRUFBNkMsS0FBN0MsRUFBd0Q7QUFDOUUsc0JBQWlCLFlBQWpCLEVBQWlDLGNBQWpDO0FBQ0QsS0FGRDtBQUdBLE9BQUcsaUJBQUgsR0FBd0IsVUFBRSxZQUFGLEVBQWdCLFVBQWhCLEVBQTRCLGVBQTVCLEVBQTZDLEtBQTdDLEVBQXdEO0FBQzlFO0FBQ0EsU0FBRyxjQUFILENBQW1CLGdCQUFpQixZQUFqQixFQUFnQyxJQUFoQyxDQUFzQyxlQUF0QyxDQUFuQjtBQUNBLFNBQUcsaUJBQUgsQ0FBc0IsSUFBdEI7QUFDRCxLQUpEO0FBS0EsT0FBRyxrQkFBSCxHQUF3QixZQUFNO0FBQzVCLFNBQUcsY0FBSCxDQUFtQixLQUFuQjtBQUNBLFNBQUcsaUJBQUgsQ0FBc0IsS0FBdEI7QUFDRCxLQUhEOztBQUtBLFFBQU0sb0JBQW9CLEdBQUcsaUJBQUgsQ0FBcUIsU0FBckIsQ0FBZ0Msb0JBQVk7QUFDcEUsVUFBSSxhQUFhLElBQWIsSUFBcUIsR0FBRyxvQkFBSCxPQUE4QixLQUF2RCxFQUE4RDtBQUM1RCxXQUFHLGtCQUFIO0FBQ0EsMEJBQWtCLE9BQWxCO0FBQ0Q7QUFDRixLQUx5QixDQUExQjtBQU1EOztBQUVELFNBQU87QUFDTCxrQkFESztBQUVMO0FBRkssR0FBUDtBQUlELENBaEREOzs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDamVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIilcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxudmFyIGNvbnNvbGVcbnZhciB0aW1lcyA9IHt9XG5cbmlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbC5jb25zb2xlXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGVcbn0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9XG59XG5cbnZhciBmdW5jdGlvbnMgPSBbXG4gICAgW2xvZywgXCJsb2dcIl1cbiAgICAsIFtpbmZvLCBcImluZm9cIl1cbiAgICAsIFt3YXJuLCBcIndhcm5cIl1cbiAgICAsIFtlcnJvciwgXCJlcnJvclwiXVxuICAgICwgW3RpbWUsIFwidGltZVwiXVxuICAgICwgW3RpbWVFbmQsIFwidGltZUVuZFwiXVxuICAgICwgW3RyYWNlLCBcInRyYWNlXCJdXG4gICAgLCBbZGlyLCBcImRpclwiXVxuICAgICwgW2Fzc2VydCwgXCJhc3NlcnRcIl1cbl1cblxuZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgdmFyIG5hbWUgPSB0dXBsZVsxXVxuXG4gICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVcblxuZnVuY3Rpb24gbG9nKCkge31cblxuZnVuY3Rpb24gaW5mbygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgdGltZXNbbGFiZWxdID0gRGF0ZS5ub3coKVxufVxuXG5mdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgdmFyIHRpbWUgPSB0aW1lc1tsYWJlbF1cbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbDogXCIgKyBsYWJlbClcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGltZVxuICAgIGNvbnNvbGUubG9nKGxhYmVsICsgXCI6IFwiICsgZHVyYXRpb24gKyBcIm1zXCIpXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgIGVyci5uYW1lID0gXCJUcmFjZVwiXG4gICAgZXJyLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG59XG5cbmZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqZWN0KSArIFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIGFzc2VydChleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBhcnIgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICAgYXNzZXJ0Lm9rKGZhbHNlLCB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcnIpKVxuICAgIH1cbn1cbiIsIi8qXG4gICBldm9sLmNvbG9ycGlja2VyIDMuMi4yXG4gICAoYykgMjAxNSBPbGl2aWVyIEdpdWxpZXJpXG4gICBodHRwOi8vZXZvbHV0ZXVyLmdpdGh1Yi5pby9jb2xvcnBpY2tlci9cbiovXG4hZnVuY3Rpb24oYSxiKXt2YXIgYz0wLGQ9d2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQsZT1kLmluZGV4T2YoXCJNU0lFIFwiKT4wLGY9ZT9cIi1pZVwiOlwiXCIsZz1lPyExOi9tb3ppbGxhLy50ZXN0KGQudG9Mb3dlckNhc2UoKSkmJiEvd2Via2l0Ly50ZXN0KGQudG9Mb3dlckNhc2UoKSksaD1bXSxpPVtcImZmZmZmZlwiLFwiMDAwMDAwXCIsXCJlZWVjZTFcIixcIjFmNDk3ZFwiLFwiNGY4MWJkXCIsXCJjMDUwNGRcIixcIjliYmI1OVwiLFwiODA2NGEyXCIsXCI0YmFjYzZcIixcImY3OTY0NlwiXSxqPVtcImYyZjJmMlwiLFwiN2Y3ZjdmXCIsXCJkZGQ5YzNcIixcImM2ZDlmMFwiLFwiZGJlNWYxXCIsXCJmMmRjZGJcIixcImViZjFkZFwiLFwiZTVlMGVjXCIsXCJkYmVlZjNcIixcImZkZWFkYVwiLFwiZDhkOGQ4XCIsXCI1OTU5NTlcIixcImM0YmQ5N1wiLFwiOGRiM2UyXCIsXCJiOGNjZTRcIixcImU1YjliN1wiLFwiZDdlM2JjXCIsXCJjY2MxZDlcIixcImI3ZGRlOFwiLFwiZmJkNWI1XCIsXCJiZmJmYmZcIixcIjNmM2YzZlwiLFwiOTM4OTUzXCIsXCI1NDhkZDRcIixcIjk1YjNkN1wiLFwiZDk5Njk0XCIsXCJjM2Q2OWJcIixcImIyYTJjN1wiLFwiOTJjZGRjXCIsXCJmYWMwOGZcIixcImE1YTVhNVwiLFwiMjYyNjI2XCIsXCI0OTQ0MjlcIixcIjE3MzY1ZFwiLFwiMzY2MDkyXCIsXCI5NTM3MzRcIixcIjc2OTIzY1wiLFwiNWY0OTdhXCIsXCIzMTg1OWJcIixcImUzNmMwOVwiLFwiN2Y3ZjdmXCIsXCIwYzBjMGNcIixcIjFkMWIxMFwiLFwiMGYyNDNlXCIsXCIyNDQwNjFcIixcIjYzMjQyM1wiLFwiNGY2MTI4XCIsXCIzZjMxNTFcIixcIjIwNTg2N1wiLFwiOTc0ODA2XCJdLGs9W1wiYzAwMDAwXCIsXCJmZjAwMDBcIixcImZmYzAwMFwiLFwiZmZmZjAwXCIsXCI5MmQwNTBcIixcIjAwYjA1MFwiLFwiMDBiMGYwXCIsXCIwMDcwYzBcIixcIjAwMjA2MFwiLFwiNzAzMGEwXCJdLGw9W1tcIjAwMzM2NlwiLFwiMzM2Njk5XCIsXCIzMzY2Y2NcIixcIjAwMzM5OVwiLFwiMDAwMDk5XCIsXCIwMDAwY2NcIixcIjAwMDA2NlwiXSxbXCIwMDY2NjZcIixcIjAwNjY5OVwiLFwiMDA5OWNjXCIsXCIwMDY2Y2NcIixcIjAwMzNjY1wiLFwiMDAwMGZmXCIsXCIzMzMzZmZcIixcIjMzMzM5OVwiXSxbXCI2Njk5OTlcIixcIjAwOTk5OVwiLFwiMzNjY2NjXCIsXCIwMGNjZmZcIixcIjAwOTlmZlwiLFwiMDA2NmZmXCIsXCIzMzY2ZmZcIixcIjMzMzNjY1wiLFwiNjY2Njk5XCJdLFtcIjMzOTk2NlwiLFwiMDBjYzk5XCIsXCIwMGZmY2NcIixcIjAwZmZmZlwiLFwiMzNjY2ZmXCIsXCIzMzk5ZmZcIixcIjY2OTlmZlwiLFwiNjY2NmZmXCIsXCI2NjAwZmZcIixcIjY2MDBjY1wiXSxbXCIzMzk5MzNcIixcIjAwY2M2NlwiLFwiMDBmZjk5XCIsXCI2NmZmY2NcIixcIjY2ZmZmZlwiLFwiNjZjY2ZmXCIsXCI5OWNjZmZcIixcIjk5OTlmZlwiLFwiOTk2NmZmXCIsXCI5OTMzZmZcIixcIjk5MDBmZlwiXSxbXCIwMDY2MDBcIixcIjAwY2MwMFwiLFwiMDBmZjAwXCIsXCI2NmZmOTlcIixcIjk5ZmZjY1wiLFwiY2NmZmZmXCIsXCJjY2NjZmZcIixcImNjOTlmZlwiLFwiY2M2NmZmXCIsXCJjYzMzZmZcIixcImNjMDBmZlwiLFwiOTkwMGNjXCJdLFtcIjAwMzMwMFwiLFwiMDA5OTMzXCIsXCIzM2NjMzNcIixcIjY2ZmY2NlwiLFwiOTlmZjk5XCIsXCJjY2ZmY2NcIixcImZmZmZmZlwiLFwiZmZjY2ZmXCIsXCJmZjk5ZmZcIixcImZmNjZmZlwiLFwiZmYwMGZmXCIsXCJjYzAwY2NcIixcIjY2MDA2NlwiXSxbXCIzMzMzMDBcIixcIjAwOTkwMFwiLFwiNjZmZjMzXCIsXCI5OWZmNjZcIixcImNjZmY5OVwiLFwiZmZmZmNjXCIsXCJmZmNjY2NcIixcImZmOTljY1wiLFwiZmY2NmNjXCIsXCJmZjMzY2NcIixcImNjMDA5OVwiLFwiOTkzMzk5XCJdLFtcIjMzNjYwMFwiLFwiNjY5OTAwXCIsXCI5OWZmMzNcIixcImNjZmY2NlwiLFwiZmZmZjk5XCIsXCJmZmNjOTlcIixcImZmOTk5OVwiLFwiZmY2Njk5XCIsXCJmZjMzOTlcIixcImNjMzM5OVwiLFwiOTkwMDk5XCJdLFtcIjY2NjYzM1wiLFwiOTljYzAwXCIsXCJjY2ZmMzNcIixcImZmZmY2NlwiLFwiZmZjYzY2XCIsXCJmZjk5NjZcIixcImZmNjY2NlwiLFwiZmYwMDY2XCIsXCJkNjAwOTRcIixcIjk5MzM2NlwiXSxbXCJhNTg4MDBcIixcImNjY2MwMFwiLFwiZmZmZjAwXCIsXCJmZmNjMDBcIixcImZmOTkzM1wiLFwiZmY2NjAwXCIsXCJmZjAwMzNcIixcImNjMDA2NlwiLFwiNjYwMDMzXCJdLFtcIjk5NjYzM1wiLFwiY2M5OTAwXCIsXCJmZjk5MDBcIixcImNjNjYwMFwiLFwiZmYzMzAwXCIsXCJmZjAwMDBcIixcImNjMDAwMFwiLFwiOTkwMDMzXCJdLFtcIjY2MzMwMFwiLFwiOTk2NjAwXCIsXCJjYzMzMDBcIixcIjk5MzMwMFwiLFwiOTkwMDAwXCIsXCI4MDAwMDBcIixcIjk5MzMzM1wiXV0sbT1cIiMwMDAwZmZmZlwiLG49ZnVuY3Rpb24oYSl7dmFyIGI9YS50b1N0cmluZygxNik7cmV0dXJuIDE9PWIubGVuZ3RoJiYoYj1cIjBcIitiKSxifSxvPWZ1bmN0aW9uKGEpe3JldHVybiBuKE51bWJlcihhKSl9LHA9ZnVuY3Rpb24oYSl7dmFyIGI9bihhKTtyZXR1cm4gYitiK2J9LHE9ZnVuY3Rpb24oYSl7aWYoYS5sZW5ndGg+MTApe3ZhciBiPTErYS5pbmRleE9mKFwiKFwiKSxjPWEuaW5kZXhPZihcIilcIiksZD1hLnN1YnN0cmluZyhiLGMpLnNwbGl0KFwiLFwiKTtyZXR1cm5bXCIjXCIsbyhkWzBdKSxvKGRbMV0pLG8oZFsyXSldLmpvaW4oXCJcIil9cmV0dXJuIGF9O2Eud2lkZ2V0KFwiZXZvbC5jb2xvcnBpY2tlclwiLHt2ZXJzaW9uOlwiMy4yLjFcIixvcHRpb25zOntjb2xvcjpudWxsLHNob3dPbjpcImJvdGhcIixoaWRlQnV0dG9uOiExLGRpc3BsYXlJbmRpY2F0b3I6ITAsdHJhbnNwYXJlbnRDb2xvcjohMSxoaXN0b3J5OiEwLGRlZmF1bHRQYWxldHRlOlwidGhlbWVcIixzdHJpbmdzOlwiVGhlbWUgQ29sb3JzLFN0YW5kYXJkIENvbG9ycyxXZWIgQ29sb3JzLFRoZW1lIENvbG9ycyxCYWNrIHRvIFBhbGV0dGUsSGlzdG9yeSxObyBoaXN0b3J5IHlldC5cIn0sX2FjdGl2ZTohMSxfY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcztzd2l0Y2godGhpcy5fcGFsZXR0ZUlkeD1cInRoZW1lXCI9PXRoaXMub3B0aW9ucy5kZWZhdWx0UGFsZXR0ZT8xOjIsdGhpcy5faWQ9XCJldm8tY3BcIitjKyssdGhpcy5fZW5hYmxlZD0hMCx0aGlzLm9wdGlvbnMuc2hvd09uPXRoaXMub3B0aW9ucy5oaWRlQnV0dG9uP1wiZm9jdXNcIjp0aGlzLm9wdGlvbnMuc2hvd09uLHRoaXMuZWxlbWVudC5nZXQoMCkudGFnTmFtZSl7Y2FzZVwiSU5QVVRcIjp2YXIgZD10aGlzLm9wdGlvbnMuY29sb3IsaD10aGlzLmVsZW1lbnQsaT0oXCJmb2N1c1wiPT09dGhpcy5vcHRpb25zLnNob3dPbj9cIlwiOlwiZXZvLXBvaW50ZXIgXCIpK1wiZXZvLWNvbG9yaW5kXCIrKGc/XCItZmZcIjpmKSsodGhpcy5vcHRpb25zLmhpZGVCdXR0b24/XCIgZXZvLWhpZGRlbi1idXR0b25cIjpcIlwiKSxqPVwiXCI7aWYodGhpcy5faXNQb3B1cD0hMCx0aGlzLl9wYWxldHRlPW51bGwsbnVsbCE9PWQpaC52YWwoZCk7ZWxzZXt2YXIgaz1oLnZhbCgpO1wiXCIhPT1rJiYoZD10aGlzLm9wdGlvbnMuY29sb3I9ayl9ZD09PW0/aSs9XCIgZXZvLXRyYW5zcGFyZW50XCI6aj1udWxsIT09ZD9cImJhY2tncm91bmQtY29sb3I6XCIrZDpcIlwiLGguYWRkQ2xhc3MoXCJjb2xvclBpY2tlciBcIit0aGlzLl9pZCkud3JhcCgnPGRpdiBzdHlsZT1cIndpZHRoOicrKHRoaXMub3B0aW9ucy5oaWRlQnV0dG9uP3RoaXMuZWxlbWVudC53aWR0aCgpOnRoaXMuZWxlbWVudC53aWR0aCgpKzMyKStcInB4O1wiKyhlP1wibWFyZ2luLWJvdHRvbTotMjFweDtcIjpcIlwiKSsoZz9cInBhZGRpbmc6MXB4IDA7XCI6XCJcIikrJ1wiPjwvZGl2PicpLmFmdGVyKCc8ZGl2IGNsYXNzPVwiJytpKydcIiBzdHlsZT1cIicraisnXCI+PC9kaXY+Jykub24oXCJrZXl1cCBvbnBhc3RlXCIsZnVuY3Rpb24oYyl7dmFyIGQ9YSh0aGlzKS52YWwoKTtkIT1iLm9wdGlvbnMuY29sb3ImJmIuX3NldFZhbHVlKGQsITApfSk7dmFyIGw9dGhpcy5vcHRpb25zLnNob3dPbjsoXCJib3RoXCI9PT1sfHxcImZvY3VzXCI9PT1sKSYmaC5vbihcImZvY3VzXCIsZnVuY3Rpb24oKXtiLnNob3dQYWxldHRlKCl9KSwoXCJib3RoXCI9PT1sfHxcImJ1dHRvblwiPT09bCkmJmgubmV4dCgpLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5zdG9wUHJvcGFnYXRpb24oKSxiLnNob3dQYWxldHRlKCksITF9KTticmVhaztkZWZhdWx0OnRoaXMuX2lzUG9wdXA9ITEsdGhpcy5fcGFsZXR0ZT10aGlzLmVsZW1lbnQuaHRtbCh0aGlzLl9wYWxldHRlSFRNTCgpKS5hdHRyKFwiYXJpYS1oYXNwb3B1cFwiLFwidHJ1ZVwiKSx0aGlzLl9iaW5kQ29sb3JzKCl9aWYodGhpcy5vcHRpb25zLmhpc3RvcnkmJihkJiZ0aGlzLl9hZGQySGlzdG9yeShkKSx0aGlzLm9wdGlvbnMuaW5pdGlhbEhpc3RvcnkpKXt2YXIgbj10aGlzLm9wdGlvbnMuaW5pdGlhbEhpc3Rvcnk7Zm9yKHZhciBvIGluIG4pdGhpcy5fYWRkMkhpc3RvcnkobltvXSl9fSxfcGFsZXR0ZUhUTUw6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9wYWxldHRlSWR4PU1hdGguYWJzKHRoaXMuX3BhbGV0dGVJZHgpLGI9dGhpcy5vcHRpb25zLGM9Yi5zdHJpbmdzLnNwbGl0KFwiLFwiKSxkPSc8ZGl2IGNsYXNzPVwiZXZvLXBvcCcrZisnIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCInKyh0aGlzLl9pc1BvcHVwPycgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZVwiJzpcIlwiKStcIj48c3Bhbj5cIit0aGlzW1wiX3BhbGV0dGVIVE1MXCIrYV0oKSsnPC9zcGFuPjxkaXYgY2xhc3M9XCJldm8tbW9yZVwiPjxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIj4nK2NbMSthXStcIjwvYT5cIjtyZXR1cm4gYi5oaXN0b3J5JiYoZCs9JzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cImV2by1oaXN0XCI+JytjWzVdK1wiPC9hPlwiKSxkKz1cIjwvZGl2PlwiLGIuZGlzcGxheUluZGljYXRvciYmKGQrPXRoaXMuX2NvbG9ySW5kSFRNTCh0aGlzLm9wdGlvbnMuY29sb3IpK3RoaXMuX2NvbG9ySW5kSFRNTChcIlwiKSksZCs9XCI8L2Rpdj5cIn0sX2NvbG9ySW5kSFRNTDpmdW5jdGlvbihhKXt2YXIgYj1lP1wiZXZvLWNvbG9yYm94LWllIFwiOlwiXCIsYz1cIlwiO3JldHVybiBhP2E9PT1tP2IrPVwiZXZvLXRyYW5zcGFyZW50XCI6Yz1cImJhY2tncm91bmQtY29sb3I6XCIrYTpjPVwiZGlzcGxheTpub25lXCIsJzxkaXYgY2xhc3M9XCJldm8tY29sb3JcIiBzdHlsZT1cImZsb2F0OmxlZnRcIj48ZGl2IHN0eWxlPVwiJytjKydcIiBjbGFzcz1cIicrYisnXCI+PC9kaXY+PHNwYW4+JysoYT9hOlwiXCIpK1wiPC9zcGFuPjwvZGl2PlwifSxfcGFsZXR0ZUhUTUwxOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMub3B0aW9ucyxiPWEuc3RyaW5ncy5zcGxpdChcIixcIiksYz0nPHRkIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojJyxkPWU/J1wiPjxkaXYgc3R5bGU9XCJ3aWR0aDoycHg7XCI+PC9kaXY+PC90ZD4nOidcIj48c3Bhbi8+PC90ZD4nLGc9Jzx0cj48dGggY29sc3Bhbj1cIjEwXCIgY2xhc3M9XCJ1aS13aWRnZXQtY29udGVudFwiPicsaD0nPHRhYmxlIGNsYXNzPVwiZXZvLXBhbGV0dGUnK2YrJ1wiPicrZytiWzBdK1wiPC90aD48L3RyPjx0cj5cIixsPTA7MTA+bDtsKyspaCs9YytpW2xdK2Q7Zm9yKGgrPVwiPC90cj5cIixlfHwoaCs9Jzx0cj48dGggY29sc3Bhbj1cIjEwXCI+PC90aD48L3RyPicpLGgrPSc8dHIgY2xhc3M9XCJ0b3BcIj4nLGw9MDsxMD5sO2wrKyloKz1jK2pbbF0rZDtmb3IodmFyIG09MTs0Pm07bSsrKWZvcihoKz0nPC90cj48dHIgY2xhc3M9XCJpblwiPicsbD0wOzEwPmw7bCsrKWgrPWMralsxMCptK2xdK2Q7Zm9yKGgrPSc8L3RyPjx0ciBjbGFzcz1cImJvdHRvbVwiPicsbD00MDs1MD5sO2wrKyloKz1jK2pbbF0rZDtmb3IoaCs9XCI8L3RyPlwiK2csYS50cmFuc3BhcmVudENvbG9yJiYoaCs9JzxkaXYgY2xhc3M9XCJldm8tdHJhbnNwYXJlbnQgZXZvLXRyLWJveFwiPjwvZGl2PicpLGgrPWJbMV0rXCI8L3RoPjwvdHI+PHRyPlwiLGw9MDsxMD5sO2wrKyloKz1jK2tbbF0rZDtyZXR1cm4gaCs9XCI8L3RyPjwvdGFibGU+XCJ9LF9wYWxldHRlSFRNTDI6ZnVuY3Rpb24oKXtmb3IodmFyIGEsYixjPSc8dGQgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiMnLGQ9ZT8nXCI+PGRpdiBzdHlsZT1cIndpZHRoOjVweDtcIj48L2Rpdj48L3RkPic6J1wiPjxzcGFuLz48L3RkPicsZz0nPHRhYmxlIGNsYXNzPVwiZXZvLXBhbGV0dGUyJytmKydcIj48dHI+JyxoPVwiPC90cj48L3RhYmxlPlwiLGk9JzxkaXYgY2xhc3M9XCJldm8tcGFsY2VudGVyXCI+JyxqPTAsaz1sLmxlbmd0aDtrPmo7aisrKXtpKz1nO3ZhciBtPWxbal07Zm9yKGE9MCxiPW0ubGVuZ3RoO2I+YTthKyspaSs9YyttW2FdK2Q7aSs9aH1pKz0nPGRpdiBjbGFzcz1cImV2by1zZXBcIi8+Jzt2YXIgbj1cIlwiO2ZvcihpKz1nLGE9MjU1O2E+MTA7YS09MTApaSs9YytwKGEpK2QsYS09MTAsbis9YytwKGEpK2Q7cmV0dXJuIGkrPWgrZytuK2grXCI8L2Rpdj5cIn0sX3N3aXRjaFBhbGV0dGU6ZnVuY3Rpb24oYil7aWYodGhpcy5fZW5hYmxlZCl7dmFyIGMsZCxlLGY9dGhpcy5vcHRpb25zLnN0cmluZ3Muc3BsaXQoXCIsXCIpO2lmKGEoYikuaGFzQ2xhc3MoXCJldm8taGlzdFwiKSl7dmFyIGc9Wyc8dGFibGUgY2xhc3M9XCJldm8tcGFsZXR0ZVwiPjx0cj48dGggY2xhc3M9XCJ1aS13aWRnZXQtY29udGVudFwiPicsZls1XSxcIjwvdGg+PC90cj48L3RyPjwvdGFibGU+XCIsJzxkaXYgY2xhc3M9XCJldm8tY0hpc3RcIj4nXTtpZigwPT09aC5sZW5ndGgpZy5wdXNoKFwiPHA+Jm5ic3A7XCIsZls2XSxcIjwvcD5cIik7ZWxzZSBmb3IodmFyIGk9aC5sZW5ndGgtMTtpPi0xO2ktLSk5PT09aFtpXS5sZW5ndGg/Zy5wdXNoKCc8ZGl2IGNsYXNzPVwiZXZvLXRyYW5zcGFyZW50XCI+PC9kaXY+Jyk6Zy5wdXNoKCc8ZGl2IHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonLGhbaV0sJ1wiPjwvZGl2PicpO2cucHVzaChcIjwvZGl2PlwiKSxjPS10aGlzLl9wYWxldHRlSWR4LGQ9Zy5qb2luKFwiXCIpLGU9Zls0XX1lbHNlIHRoaXMuX3BhbGV0dGVJZHg8MD8oYz0tdGhpcy5fcGFsZXR0ZUlkeCx0aGlzLl9wYWxldHRlLmZpbmQoXCIuZXZvLWhpc3RcIikuc2hvdygpKTpjPTI9PXRoaXMuX3BhbGV0dGVJZHg/MToyLGQ9dGhpc1tcIl9wYWxldHRlSFRNTFwiK2NdKCksZT1mW2MrMV0sdGhpcy5fcGFsZXR0ZUlkeD1jO3RoaXMuX3BhbGV0dGVJZHg9Yzt2YXIgaj10aGlzLl9wYWxldHRlLmZpbmQoXCIuZXZvLW1vcmVcIikucHJldigpLmh0bWwoZCkuZW5kKCkuY2hpbGRyZW4oKS5lcSgwKS5odG1sKGUpOzA+YyYmai5uZXh0KCkuaGlkZSgpfX0sX2Rvd25PclVwUG9zaXRpb25pbmc6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5lbGVtZW50LGI9MDtudWxsIT09YSYmMTAwPmI7KXtpZihcInZpc2libGVcIiE9YS5jc3MoXCJvdmVyZmxvd1wiKSl7dmFyIGM9dGhpcy5fcGFsZXR0ZS5vZmZzZXQoKS50b3ArdGhpcy5fcGFsZXR0ZS5oZWlnaHQoKSxkPWEub2Zmc2V0KCkudG9wK2EuaGVpZ2h0KCksZT10aGlzLl9wYWxldHRlLm9mZnNldCgpLnRvcC10aGlzLl9wYWxldHRlLmhlaWdodCgpLXRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpLGY9YS5vZmZzZXQoKS50b3AsZz1jPmQmJmU+ZjtnP3RoaXMuX3BhbGV0dGUuY3NzKHtib3R0b206dGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkrXCJweFwifSk6dGhpcy5fcGFsZXR0ZS5jc3Moe2JvdHRvbTpcImF1dG9cIn0pO2JyZWFrfWlmKFwiSFRNTFwiPT1hWzBdLnRhZ05hbWUpYnJlYWs7YT1hLm9mZnNldFBhcmVudCgpLGIrK319LHNob3dQYWxldHRlOmZ1bmN0aW9uKCl7aWYodGhpcy5fZW5hYmxlZCYmKHRoaXMuX2FjdGl2ZT0hMCxhKFwiLmNvbG9yUGlja2VyXCIpLm5vdChcIi5cIit0aGlzLl9pZCkuY29sb3JwaWNrZXIoXCJoaWRlUGFsZXR0ZVwiKSxudWxsPT09dGhpcy5fcGFsZXR0ZSkpe3RoaXMuX3BhbGV0dGU9dGhpcy5lbGVtZW50Lm5leHQoKS5hZnRlcih0aGlzLl9wYWxldHRlSFRNTCgpKS5uZXh0KCkub24oXCJjbGlja1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnN0b3BQcm9wYWdhdGlvbigpLCExfSksdGhpcy5fYmluZENvbG9ycygpO3ZhciBiPXRoaXM7dGhpcy5faXNQb3B1cCYmKHRoaXMuX2Rvd25PclVwUG9zaXRpb25pbmcoKSxhKGRvY3VtZW50LmJvZHkpLm9uKFwiY2xpY2suXCIrYi5faWQsZnVuY3Rpb24oYSl7YS50YXJnZXQhPWIuZWxlbWVudC5nZXQoMCkmJmIuaGlkZVBhbGV0dGUoKX0pLm9uKFwia2V5dXAuXCIrYi5faWQsZnVuY3Rpb24oYSl7Mjc9PT1hLmtleUNvZGUmJmIuaGlkZVBhbGV0dGUoKX0pKX1yZXR1cm4gdGhpc30saGlkZVBhbGV0dGU6ZnVuY3Rpb24oKXtpZih0aGlzLl9pc1BvcHVwJiZ0aGlzLl9wYWxldHRlKXthKGRvY3VtZW50LmJvZHkpLm9mZihcImNsaWNrLlwiK3RoaXMuX2lkKTt2YXIgYj10aGlzO3RoaXMuX3BhbGV0dGUub2ZmKFwibW91c2VvdmVyIGNsaWNrXCIsXCJ0ZCwuZXZvLXRyYW5zcGFyZW50XCIpLmZhZGVPdXQoZnVuY3Rpb24oKXtiLl9wYWxldHRlLnJlbW92ZSgpLGIuX3BhbGV0dGU9Yi5fY1R4dD1udWxsfSkuZmluZChcIi5ldm8tbW9yZSBhXCIpLm9mZihcImNsaWNrXCIpfXJldHVybiB0aGlzfSxfYmluZENvbG9yczpmdW5jdGlvbigpe3ZhciBiPXRoaXMsYz10aGlzLm9wdGlvbnMsZD10aGlzLl9wYWxldHRlLmZpbmQoXCJkaXYuZXZvLWNvbG9yXCIpLGU9Yy5oaXN0b3J5P1widGQsLmV2by1jSGlzdD5kaXZcIjpcInRkXCI7Yy50cmFuc3BhcmVudENvbG9yJiYoZSs9XCIsLmV2by10cmFuc3BhcmVudFwiKSx0aGlzLl9jVHh0MT1kLmVxKDApLmNoaWxkcmVuKCkuZXEoMCksdGhpcy5fY1R4dDI9ZC5lcSgxKS5jaGlsZHJlbigpLmVxKDApLHRoaXMuX3BhbGV0dGUub24oXCJjbGlja1wiLGUsZnVuY3Rpb24oYyl7aWYoYi5fZW5hYmxlZCl7dmFyIGQ9YSh0aGlzKTtiLl9zZXRWYWx1ZShkLmhhc0NsYXNzKFwiZXZvLXRyYW5zcGFyZW50XCIpP206cShkLmF0dHIoXCJzdHlsZVwiKS5zdWJzdHJpbmcoMTcpKSksYi5fYWN0aXZlPSExfX0pLm9uKFwibW91c2VvdmVyXCIsZSxmdW5jdGlvbihjKXtpZihiLl9lbmFibGVkKXt2YXIgZD1hKHRoaXMpLGU9ZC5oYXNDbGFzcyhcImV2by10cmFuc3BhcmVudFwiKT9tOnEoZC5hdHRyKFwic3R5bGVcIikuc3Vic3RyaW5nKDE3KSk7Yi5vcHRpb25zLmRpc3BsYXlJbmRpY2F0b3ImJmIuX3NldENvbG9ySW5kKGUsMiksYi5fYWN0aXZlJiZiLmVsZW1lbnQudHJpZ2dlcihcIm1vdXNlb3Zlci5jb2xvclwiLGUpfX0pLmZpbmQoXCIuZXZvLW1vcmUgYVwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtiLl9zd2l0Y2hQYWxldHRlKHRoaXMpfSl9LHZhbDpmdW5jdGlvbihhKXtyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgYT90aGlzLm9wdGlvbnMuY29sb3I6KHRoaXMuX3NldFZhbHVlKGEpLHRoaXMpfSxfc2V0VmFsdWU6ZnVuY3Rpb24oYSxiKXthPWEucmVwbGFjZSgvIC9nLFwiXCIpLHRoaXMub3B0aW9ucy5jb2xvcj1hLHRoaXMuX2lzUG9wdXA/KGJ8fHRoaXMuaGlkZVBhbGV0dGUoKSx0aGlzLl9zZXRCb3hDb2xvcih0aGlzLmVsZW1lbnQudmFsKGEpLm5leHQoKSxhKSk6dGhpcy5fc2V0Q29sb3JJbmQoYSwxKSx0aGlzLm9wdGlvbnMuaGlzdG9yeSYmdGhpcy5fcGFsZXR0ZUlkeD4wJiZ0aGlzLl9hZGQySGlzdG9yeShhKSx0aGlzLmVsZW1lbnQudHJpZ2dlcihcImNoYW5nZS5jb2xvclwiLGEpfSxfc2V0Q29sb3JJbmQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzW1wiX2NUeHRcIitiXTt0aGlzLl9zZXRCb3hDb2xvcihjLGEpLGMubmV4dCgpLmh0bWwoYSl9LF9zZXRCb3hDb2xvcjpmdW5jdGlvbihhLGIpe2I9PT1tP2EuYWRkQ2xhc3MoXCJldm8tdHJhbnNwYXJlbnRcIikucmVtb3ZlQXR0cihcInN0eWxlXCIpOmEucmVtb3ZlQ2xhc3MoXCJldm8tdHJhbnNwYXJlbnRcIikuYXR0cihcInN0eWxlXCIsXCJiYWNrZ3JvdW5kLWNvbG9yOlwiK2IpfSxfc2V0T3B0aW9uOmZ1bmN0aW9uKGEsYil7XCJjb2xvclwiPT1hP3RoaXMuX3NldFZhbHVlKGIsITApOnRoaXMub3B0aW9uc1thXT1ifSxfYWRkMkhpc3Rvcnk6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWgubGVuZ3RoLGM9MDtiPmM7YysrKWlmKGE9PWhbY10pcmV0dXJuO2I+MjcmJmguc2hpZnQoKSxoLnB1c2goYSl9LGNsZWFyOmZ1bmN0aW9uKCl7dGhpcy5oaWRlUGFsZXR0ZSgpLnZhbChcIlwiKX0sZW5hYmxlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50O3JldHVybiB0aGlzLl9pc1BvcHVwP2EucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpOmEuY3NzKHtvcGFjaXR5OlwiMVwiLFwicG9pbnRlci1ldmVudHNcIjpcImF1dG9cIn0pLFwiZm9jdXNcIiE9PXRoaXMub3B0aW9ucy5zaG93T24mJnRoaXMuZWxlbWVudC5uZXh0KCkuYWRkQ2xhc3MoXCJldm8tcG9pbnRlclwiKSxhLnJlbW92ZUF0dHIoXCJhcmlhLWRpc2FibGVkXCIpLHRoaXMuX2VuYWJsZWQ9ITAsdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDtyZXR1cm4gdGhpcy5faXNQb3B1cD9hLmF0dHIoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIik6KHRoaXMuaGlkZVBhbGV0dGUoKSxhLmNzcyh7b3BhY2l0eTpcIjAuM1wiLFwicG9pbnRlci1ldmVudHNcIjpcIm5vbmVcIn0pKSxcImZvY3VzXCIhPT10aGlzLm9wdGlvbnMuc2hvd09uJiZ0aGlzLmVsZW1lbnQubmV4dCgpLnJlbW92ZUNsYXNzKFwiZXZvLXBvaW50ZXJcIiksYS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSx0aGlzLl9lbmFibGVkPSExLHRoaXN9LGlzRGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fZW5hYmxlZH0sZGVzdHJveTpmdW5jdGlvbigpe2EoZG9jdW1lbnQuYm9keSkub2ZmKFwiY2xpY2suXCIrdGhpcy5faWQpLHRoaXMuX3BhbGV0dGUmJih0aGlzLl9wYWxldHRlLm9mZihcIm1vdXNlb3ZlciBjbGlja1wiLFwidGQsLmV2by1jSGlzdD5kaXYsLmV2by10cmFuc3BhcmVudFwiKS5maW5kKFwiLmV2by1tb3JlIGFcIikub2ZmKFwiY2xpY2tcIiksdGhpcy5faXNQb3B1cCYmdGhpcy5fcGFsZXR0ZS5yZW1vdmUoKSx0aGlzLl9wYWxldHRlPXRoaXMuX2NUeHQ9bnVsbCksdGhpcy5faXNQb3B1cCYmdGhpcy5lbGVtZW50Lm5leHQoKS5vZmYoXCJjbGlja1wiKS5yZW1vdmUoKS5lbmQoKS5vZmYoXCJmb2N1c1wiKS51bndyYXAoKSx0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xvclBpY2tlciBcIit0aGlzLmlkKS5lbXB0eSgpLGEuV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyl9fSl9KGpRdWVyeSk7IiwiLy8gICAgIEphdmFTY3JpcHQgRXhwcmVzc2lvbiBQYXJzZXIgKEpTRVApIDwlPSB2ZXJzaW9uICU+XG4vLyAgICAgSlNFUCBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuLy8gICAgIGh0dHA6Ly9qc2VwLmZyb20uc28vXG5cbi8qZ2xvYmFsIG1vZHVsZTogdHJ1ZSwgZXhwb3J0czogdHJ1ZSwgY29uc29sZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uIChyb290KSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0Ly8gTm9kZSBUeXBlc1xuXHQvLyAtLS0tLS0tLS0tXG5cdFxuXHQvLyBUaGlzIGlzIHRoZSBmdWxsIHNldCBvZiB0eXBlcyB0aGF0IGFueSBKU0VQIG5vZGUgY2FuIGJlLlxuXHQvLyBTdG9yZSB0aGVtIGhlcmUgdG8gc2F2ZSBzcGFjZSB3aGVuIG1pbmlmaWVkXG5cdHZhciBDT01QT1VORCA9ICdDb21wb3VuZCcsXG5cdFx0SURFTlRJRklFUiA9ICdJZGVudGlmaWVyJyxcblx0XHRNRU1CRVJfRVhQID0gJ01lbWJlckV4cHJlc3Npb24nLFxuXHRcdExJVEVSQUwgPSAnTGl0ZXJhbCcsXG5cdFx0VEhJU19FWFAgPSAnVGhpc0V4cHJlc3Npb24nLFxuXHRcdENBTExfRVhQID0gJ0NhbGxFeHByZXNzaW9uJyxcblx0XHRVTkFSWV9FWFAgPSAnVW5hcnlFeHByZXNzaW9uJyxcblx0XHRCSU5BUllfRVhQID0gJ0JpbmFyeUV4cHJlc3Npb24nLFxuXHRcdExPR0lDQUxfRVhQID0gJ0xvZ2ljYWxFeHByZXNzaW9uJyxcblx0XHRDT05ESVRJT05BTF9FWFAgPSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcblx0XHRBUlJBWV9FWFAgPSAnQXJyYXlFeHByZXNzaW9uJyxcblxuXHRcdFBFUklPRF9DT0RFID0gNDYsIC8vICcuJ1xuXHRcdENPTU1BX0NPREUgID0gNDQsIC8vICcsJ1xuXHRcdFNRVU9URV9DT0RFID0gMzksIC8vIHNpbmdsZSBxdW90ZVxuXHRcdERRVU9URV9DT0RFID0gMzQsIC8vIGRvdWJsZSBxdW90ZXNcblx0XHRPUEFSRU5fQ09ERSA9IDQwLCAvLyAoXG5cdFx0Q1BBUkVOX0NPREUgPSA0MSwgLy8gKVxuXHRcdE9CUkFDS19DT0RFID0gOTEsIC8vIFtcblx0XHRDQlJBQ0tfQ09ERSA9IDkzLCAvLyBdXG5cdFx0UVVNQVJLX0NPREUgPSA2MywgLy8gP1xuXHRcdFNFTUNPTF9DT0RFID0gNTksIC8vIDtcblx0XHRDT0xPTl9DT0RFICA9IDU4LCAvLyA6XG5cblx0XHR0aHJvd0Vycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgaW5kZXgpIHtcblx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlICsgJyBhdCBjaGFyYWN0ZXIgJyArIGluZGV4KTtcblx0XHRcdGVycm9yLmluZGV4ID0gaW5kZXg7XG5cdFx0XHRlcnJvci5kZXNjcmlwdGlvbiA9IG1lc3NhZ2U7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9LFxuXG5cdC8vIE9wZXJhdGlvbnNcblx0Ly8gLS0tLS0tLS0tLVxuXHRcblx0Ly8gU2V0IGB0YCB0byBgdHJ1ZWAgdG8gc2F2ZSBzcGFjZSAod2hlbiBtaW5pZmllZCwgbm90IGd6aXBwZWQpXG5cdFx0dCA9IHRydWUsXG5cdC8vIFVzZSBhIHF1aWNrbHktYWNjZXNzaWJsZSBtYXAgdG8gc3RvcmUgYWxsIG9mIHRoZSB1bmFyeSBvcGVyYXRvcnNcblx0Ly8gVmFsdWVzIGFyZSBzZXQgdG8gYHRydWVgIChpdCByZWFsbHkgZG9lc24ndCBtYXR0ZXIpXG5cdFx0dW5hcnlfb3BzID0geyctJzogdCwgJyEnOiB0LCAnfic6IHQsICcrJzogdH0sXG5cdC8vIEFsc28gdXNlIGEgbWFwIGZvciB0aGUgYmluYXJ5IG9wZXJhdGlvbnMgYnV0IHNldCB0aGVpciB2YWx1ZXMgdG8gdGhlaXJcblx0Ly8gYmluYXJ5IHByZWNlZGVuY2UgZm9yIHF1aWNrIHJlZmVyZW5jZTpcblx0Ly8gc2VlIFtPcmRlciBvZiBvcGVyYXRpb25zXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09yZGVyX29mX29wZXJhdGlvbnMjUHJvZ3JhbW1pbmdfbGFuZ3VhZ2UpXG5cdFx0YmluYXJ5X29wcyA9IHtcblx0XHRcdCd8fCc6IDEsICcmJic6IDIsICd8JzogMywgICdeJzogNCwgICcmJzogNSxcblx0XHRcdCc9PSc6IDYsICchPSc6IDYsICc9PT0nOiA2LCAnIT09JzogNixcblx0XHRcdCc8JzogNywgICc+JzogNywgICc8PSc6IDcsICAnPj0nOiA3LCBcblx0XHRcdCc8PCc6OCwgICc+Pic6IDgsICc+Pj4nOiA4LFxuXHRcdFx0JysnOiA5LCAnLSc6IDksXG5cdFx0XHQnKic6IDEwLCAnLyc6IDEwLCAnJSc6IDEwXG5cdFx0fSxcblx0Ly8gR2V0IHJldHVybiB0aGUgbG9uZ2VzdCBrZXkgbGVuZ3RoIG9mIGFueSBvYmplY3Rcblx0XHRnZXRNYXhLZXlMZW4gPSBmdW5jdGlvbihvYmopIHtcblx0XHRcdHZhciBtYXhfbGVuID0gMCwgbGVuO1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0XHRcdGlmKChsZW4gPSBrZXkubGVuZ3RoKSA+IG1heF9sZW4gJiYgb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRtYXhfbGVuID0gbGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF4X2xlbjtcblx0XHR9LFxuXHRcdG1heF91bm9wX2xlbiA9IGdldE1heEtleUxlbih1bmFyeV9vcHMpLFxuXHRcdG1heF9iaW5vcF9sZW4gPSBnZXRNYXhLZXlMZW4oYmluYXJ5X29wcyksXG5cdC8vIExpdGVyYWxzXG5cdC8vIC0tLS0tLS0tLS1cblx0Ly8gU3RvcmUgdGhlIHZhbHVlcyB0byByZXR1cm4gZm9yIHRoZSB2YXJpb3VzIGxpdGVyYWxzIHdlIG1heSBlbmNvdW50ZXJcblx0XHRsaXRlcmFscyA9IHtcblx0XHRcdCd0cnVlJzogdHJ1ZSxcblx0XHRcdCdmYWxzZSc6IGZhbHNlLFxuXHRcdFx0J251bGwnOiBudWxsXG5cdFx0fSxcblx0Ly8gRXhjZXB0IGZvciBgdGhpc2AsIHdoaWNoIGlzIHNwZWNpYWwuIFRoaXMgY291bGQgYmUgY2hhbmdlZCB0byBzb21ldGhpbmcgbGlrZSBgJ3NlbGYnYCBhcyB3ZWxsXG5cdFx0dGhpc19zdHIgPSAndGhpcycsXG5cdC8vIFJldHVybnMgdGhlIHByZWNlZGVuY2Ugb2YgYSBiaW5hcnkgb3BlcmF0b3Igb3IgYDBgIGlmIGl0IGlzbid0IGEgYmluYXJ5IG9wZXJhdG9yXG5cdFx0YmluYXJ5UHJlY2VkZW5jZSA9IGZ1bmN0aW9uKG9wX3ZhbCkge1xuXHRcdFx0cmV0dXJuIGJpbmFyeV9vcHNbb3BfdmFsXSB8fCAwO1xuXHRcdH0sXG5cdC8vIFV0aWxpdHkgZnVuY3Rpb24gKGdldHMgY2FsbGVkIGZyb20gbXVsdGlwbGUgcGxhY2VzKVxuXHQvLyBBbHNvIG5vdGUgdGhhdCBgYSAmJiBiYCBhbmQgYGEgfHwgYmAgYXJlICpsb2dpY2FsKiBleHByZXNzaW9ucywgbm90IGJpbmFyeSBleHByZXNzaW9uc1xuXHRcdGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG5cdFx0XHR2YXIgdHlwZSA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJykgPyBMT0dJQ0FMX0VYUCA6IEJJTkFSWV9FWFA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcGVyYXRvcjogb3BlcmF0b3IsXG5cdFx0XHRcdGxlZnQ6IGxlZnQsXG5cdFx0XHRcdHJpZ2h0OiByaWdodFxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdC8vIGBjaGAgaXMgYSBjaGFyYWN0ZXIgY29kZSBpbiB0aGUgbmV4dCB0aHJlZSBmdW5jdGlvbnNcblx0XHRpc0RlY2ltYWxEaWdpdCA9IGZ1bmN0aW9uKGNoKSB7XG5cdFx0XHRyZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU3KTsgLy8gMC4uLjlcblx0XHR9LFxuXHRcdGlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oY2gpIHtcblx0XHRcdHJldHVybiAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAvLyBgJGAgYW5kIGBfYFxuXHRcdFx0XHRcdChjaCA+PSA2NSAmJiBjaCA8PSA5MCkgfHwgLy8gQS4uLlpcblx0XHRcdFx0XHQoY2ggPj0gOTcgJiYgY2ggPD0gMTIyKSB8fCAvLyBhLi4uelxuICAgICAgICAgICAgICAgICAgICAoY2ggPj0gMTI4ICYmICFiaW5hcnlfb3BzW1N0cmluZy5mcm9tQ2hhckNvZGUoY2gpXSk7IC8vIGFueSBub24tQVNDSUkgdGhhdCBpcyBub3QgYW4gb3BlcmF0b3Jcblx0XHR9LFxuXHRcdGlzSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihjaCkge1xuXHRcdFx0cmV0dXJuIChjaCA9PT0gMzYpIHx8IChjaCA9PT0gOTUpIHx8IC8vIGAkYCBhbmQgYF9gXG5cdFx0XHRcdFx0KGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAvLyBBLi4uWlxuXHRcdFx0XHRcdChjaCA+PSA5NyAmJiBjaCA8PSAxMjIpIHx8IC8vIGEuLi56XG5cdFx0XHRcdFx0KGNoID49IDQ4ICYmIGNoIDw9IDU3KSB8fCAvLyAwLi4uOVxuICAgICAgICAgICAgICAgICAgICAoY2ggPj0gMTI4ICYmICFiaW5hcnlfb3BzW1N0cmluZy5mcm9tQ2hhckNvZGUoY2gpXSk7IC8vIGFueSBub24tQVNDSUkgdGhhdCBpcyBub3QgYW4gb3BlcmF0b3Jcblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2luZ1xuXHRcdC8vIC0tLS0tLS1cblx0XHQvLyBgZXhwcmAgaXMgYSBzdHJpbmcgd2l0aCB0aGUgcGFzc2VkIGluIGV4cHJlc3Npb25cblx0XHRqc2VwID0gZnVuY3Rpb24oZXhwcikge1xuXHRcdFx0Ly8gYGluZGV4YCBzdG9yZXMgdGhlIGNoYXJhY3RlciBudW1iZXIgd2UgYXJlIGN1cnJlbnRseSBhdCB3aGlsZSBgbGVuZ3RoYCBpcyBhIGNvbnN0YW50XG5cdFx0XHQvLyBBbGwgb2YgdGhlIGdvYmJsZXMgYmVsb3cgd2lsbCBtb2RpZnkgYGluZGV4YCBhcyB3ZSBtb3ZlIGFsb25nXG5cdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRjaGFyQXRGdW5jID0gZXhwci5jaGFyQXQsXG5cdFx0XHRcdGNoYXJDb2RlQXRGdW5jID0gZXhwci5jaGFyQ29kZUF0LFxuXHRcdFx0XHRleHBySSA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGNoYXJBdEZ1bmMuY2FsbChleHByLCBpKTsgfSxcblx0XHRcdFx0ZXhwcklDb2RlID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gY2hhckNvZGVBdEZ1bmMuY2FsbChleHByLCBpKTsgfSxcblx0XHRcdFx0bGVuZ3RoID0gZXhwci5sZW5ndGgsXG5cblx0XHRcdFx0Ly8gUHVzaCBgaW5kZXhgIHVwIHRvIHRoZSBuZXh0IG5vbi1zcGFjZSBjaGFyYWN0ZXJcblx0XHRcdFx0Z29iYmxlU3BhY2VzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGNoID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHQvLyBzcGFjZSBvciB0YWJcblx0XHRcdFx0XHR3aGlsZShjaCA9PT0gMzIgfHwgY2ggPT09IDkpIHtcblx0XHRcdFx0XHRcdGNoID0gZXhwcklDb2RlKCsraW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZSBtYWluIHBhcnNpbmcgZnVuY3Rpb24uIE11Y2ggb2YgdGhpcyBjb2RlIGlzIGRlZGljYXRlZCB0byB0ZXJuYXJ5IGV4cHJlc3Npb25zXG5cdFx0XHRcdGdvYmJsZUV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgdGVzdCA9IGdvYmJsZUJpbmFyeUV4cHJlc3Npb24oKSxcblx0XHRcdFx0XHRcdGNvbnNlcXVlbnQsIGFsdGVybmF0ZTtcblx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRpZihleHBySUNvZGUoaW5kZXgpID09PSBRVU1BUktfQ09ERSkge1xuXHRcdFx0XHRcdFx0Ly8gVGVybmFyeSBleHByZXNzaW9uOiB0ZXN0ID8gY29uc2VxdWVudCA6IGFsdGVybmF0ZVxuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGNvbnNlcXVlbnQgPSBnb2JibGVFeHByZXNzaW9uKCk7XG5cdFx0XHRcdFx0XHRpZighY29uc2VxdWVudCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdFeHBlY3RlZCBleHByZXNzaW9uJywgaW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0XHRpZihleHBySUNvZGUoaW5kZXgpID09PSBDT0xPTl9DT0RFKSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdGFsdGVybmF0ZSA9IGdvYmJsZUV4cHJlc3Npb24oKTtcblx0XHRcdFx0XHRcdFx0aWYoIWFsdGVybmF0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkIGV4cHJlc3Npb24nLCBpbmRleCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBDT05ESVRJT05BTF9FWFAsXG5cdFx0XHRcdFx0XHRcdFx0dGVzdDogdGVzdCxcblx0XHRcdFx0XHRcdFx0XHRjb25zZXF1ZW50OiBjb25zZXF1ZW50LFxuXHRcdFx0XHRcdFx0XHRcdGFsdGVybmF0ZTogYWx0ZXJuYXRlXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdFeHBlY3RlZCA6JywgaW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGVzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU2VhcmNoIGZvciB0aGUgb3BlcmF0aW9uIHBvcnRpb24gb2YgdGhlIHN0cmluZyAoZS5nLiBgK2AsIGA9PT1gKVxuXHRcdFx0XHQvLyBTdGFydCBieSB0YWtpbmcgdGhlIGxvbmdlc3QgcG9zc2libGUgYmluYXJ5IG9wZXJhdGlvbnMgKDMgY2hhcmFjdGVyczogYD09PWAsIGAhPT1gLCBgPj4+YClcblx0XHRcdFx0Ly8gYW5kIG1vdmUgZG93biBmcm9tIDMgdG8gMiB0byAxIGNoYXJhY3RlciB1bnRpbCBhIG1hdGNoaW5nIGJpbmFyeSBvcGVyYXRpb24gaXMgZm91bmRcblx0XHRcdFx0Ly8gdGhlbiwgcmV0dXJuIHRoYXQgYmluYXJ5IG9wZXJhdGlvblxuXHRcdFx0XHRnb2JibGVCaW5hcnlPcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdHZhciBiaW9wLCB0b19jaGVjayA9IGV4cHIuc3Vic3RyKGluZGV4LCBtYXhfYmlub3BfbGVuKSwgdGNfbGVuID0gdG9fY2hlY2subGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlKHRjX2xlbiA+IDApIHtcblx0XHRcdFx0XHRcdGlmKGJpbmFyeV9vcHMuaGFzT3duUHJvcGVydHkodG9fY2hlY2spKSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ICs9IHRjX2xlbjtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvX2NoZWNrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG9fY2hlY2sgPSB0b19jaGVjay5zdWJzdHIoMCwgLS10Y19sZW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgZ29iYmxpbmcgYW4gaW5kaXZpZHVhbCBleHByZXNzaW9uLFxuXHRcdFx0XHQvLyBlLmcuIGAxYCwgYDErMmAsIGBhKyhiKjIpLU1hdGguc3FydCgyKWBcblx0XHRcdFx0Z29iYmxlQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBjaF9pLCBub2RlLCBiaW9wLCBwcmVjLCBzdGFjaywgYmlvcF9pbmZvLCBsZWZ0LCByaWdodCwgaTtcblxuXHRcdFx0XHRcdC8vIEZpcnN0LCB0cnkgdG8gZ2V0IHRoZSBsZWZ0bW9zdCB0aGluZ1xuXHRcdFx0XHRcdC8vIFRoZW4sIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgYmluYXJ5IG9wZXJhdG9yIG9wZXJhdGluZyBvbiB0aGF0IGxlZnRtb3N0IHRoaW5nXG5cdFx0XHRcdFx0bGVmdCA9IGdvYmJsZVRva2VuKCk7XG5cdFx0XHRcdFx0YmlvcCA9IGdvYmJsZUJpbmFyeU9wKCk7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGVyZSB3YXNuJ3QgYSBiaW5hcnkgb3BlcmF0b3IsIGp1c3QgcmV0dXJuIHRoZSBsZWZ0bW9zdCBub2RlXG5cdFx0XHRcdFx0aWYoIWJpb3ApIHtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBzdGFydCBhIHN0YWNrIHRvIHByb3Blcmx5IHBsYWNlIHRoZSBiaW5hcnkgb3BlcmF0aW9ucyBpbiB0aGVpclxuXHRcdFx0XHRcdC8vIHByZWNlZGVuY2Ugc3RydWN0dXJlXG5cdFx0XHRcdFx0YmlvcF9pbmZvID0geyB2YWx1ZTogYmlvcCwgcHJlYzogYmluYXJ5UHJlY2VkZW5jZShiaW9wKX07XG5cblx0XHRcdFx0XHRyaWdodCA9IGdvYmJsZVRva2VuKCk7XG5cdFx0XHRcdFx0aWYoIXJpZ2h0KSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBhZnRlciBcIiArIGJpb3AsIGluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RhY2sgPSBbbGVmdCwgYmlvcF9pbmZvLCByaWdodF07XG5cblx0XHRcdFx0XHQvLyBQcm9wZXJseSBkZWFsIHdpdGggcHJlY2VkZW5jZSB1c2luZyBbcmVjdXJzaXZlIGRlc2NlbnRdKGh0dHA6Ly93d3cuZW5nci5tdW4uY2EvfnRoZW8vTWlzYy9leHBfcGFyc2luZy5odG0pXG5cdFx0XHRcdFx0d2hpbGUoKGJpb3AgPSBnb2JibGVCaW5hcnlPcCgpKSkge1xuXHRcdFx0XHRcdFx0cHJlYyA9IGJpbmFyeVByZWNlZGVuY2UoYmlvcCk7XG5cblx0XHRcdFx0XHRcdGlmKHByZWMgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRiaW9wX2luZm8gPSB7IHZhbHVlOiBiaW9wLCBwcmVjOiBwcmVjIH07XG5cblx0XHRcdFx0XHRcdC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cblx0XHRcdFx0XHRcdHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcblx0XHRcdFx0XHRcdFx0cmlnaHQgPSBzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRcdFx0YmlvcCA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRsZWZ0ID0gc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBjcmVhdGVCaW5hcnlFeHByZXNzaW9uKGJpb3AsIGxlZnQsIHJpZ2h0KTtcblx0XHRcdFx0XHRcdFx0c3RhY2sucHVzaChub2RlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bm9kZSA9IGdvYmJsZVRva2VuKCk7XG5cdFx0XHRcdFx0XHRpZighbm9kZSkge1xuXHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBhZnRlciBcIiArIGJpb3AsIGluZGV4KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goYmlvcF9pbmZvLCBub2RlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpID0gc3RhY2subGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRub2RlID0gc3RhY2tbaV07XG5cdFx0XHRcdFx0d2hpbGUoaSA+IDEpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBjcmVhdGVCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBub2RlKTsgXG5cdFx0XHRcdFx0XHRpIC09IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEFuIGluZGl2aWR1YWwgcGFydCBvZiBhIGJpbmFyeSBleHByZXNzaW9uOlxuXHRcdFx0XHQvLyBlLmcuIGBmb28uYmFyKGJheilgLCBgMWAsIGBcImFiY1wiYCwgYChhICUgMilgIChiZWNhdXNlIGl0J3MgaW4gcGFyZW50aGVzaXMpXG5cdFx0XHRcdGdvYmJsZVRva2VuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGNoLCB0b19jaGVjaywgdGNfbGVuO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdGNoID0gZXhwcklDb2RlKGluZGV4KTtcblxuXHRcdFx0XHRcdGlmKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gUEVSSU9EX0NPREUpIHtcblx0XHRcdFx0XHRcdC8vIENoYXIgY29kZSA0NiBpcyBhIGRvdCBgLmAgd2hpY2ggY2FuIHN0YXJ0IG9mZiBhIG51bWVyaWMgbGl0ZXJhbFxuXHRcdFx0XHRcdFx0cmV0dXJuIGdvYmJsZU51bWVyaWNMaXRlcmFsKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGNoID09PSBTUVVPVEVfQ09ERSB8fCBjaCA9PT0gRFFVT1RFX0NPREUpIHtcblx0XHRcdFx0XHRcdC8vIFNpbmdsZSBvciBkb3VibGUgcXVvdGVzXG5cdFx0XHRcdFx0XHRyZXR1cm4gZ29iYmxlU3RyaW5nTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihpc0lkZW50aWZpZXJTdGFydChjaCkgfHwgY2ggPT09IE9QQVJFTl9DT0RFKSB7IC8vIG9wZW4gcGFyZW50aGVzaXNcblx0XHRcdFx0XHRcdC8vIGBmb29gLCBgYmFyLmJhemBcblx0XHRcdFx0XHRcdHJldHVybiBnb2JibGVWYXJpYWJsZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2ggPT09IE9CUkFDS19DT0RFKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ29iYmxlQXJyYXkoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dG9fY2hlY2sgPSBleHByLnN1YnN0cihpbmRleCwgbWF4X3Vub3BfbGVuKTtcblx0XHRcdFx0XHRcdHRjX2xlbiA9IHRvX2NoZWNrLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlKHRjX2xlbiA+IDApIHtcblx0XHRcdFx0XHRcdFx0aWYodW5hcnlfb3BzLmhhc093blByb3BlcnR5KHRvX2NoZWNrKSkge1xuXHRcdFx0XHRcdFx0XHRcdGluZGV4ICs9IHRjX2xlbjtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogVU5BUllfRVhQLFxuXHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0b3I6IHRvX2NoZWNrLFxuXHRcdFx0XHRcdFx0XHRcdFx0YXJndW1lbnQ6IGdvYmJsZVRva2VuKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg6IHRydWVcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRvX2NoZWNrID0gdG9fY2hlY2suc3Vic3RyKDAsIC0tdGNfbGVuKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gUGFyc2Ugc2ltcGxlIG51bWVyaWMgbGl0ZXJhbHM6IGAxMmAsIGAzLjRgLCBgLjVgLiBEbyB0aGlzIGJ5IHVzaW5nIGEgc3RyaW5nIHRvXG5cdFx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgZXZlcnl0aGluZyBpbiB0aGUgbnVtZXJpYyBsaXRlcmFsIGFuZCB0aGVuIGNhbGxpbmcgYHBhcnNlRmxvYXRgIG9uIHRoYXQgc3RyaW5nXG5cdFx0XHRcdGdvYmJsZU51bWVyaWNMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIG51bWJlciA9ICcnLCBjaCwgY2hDb2RlO1xuXHRcdFx0XHRcdHdoaWxlKGlzRGVjaW1hbERpZ2l0KGV4cHJJQ29kZShpbmRleCkpKSB7XG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoZXhwcklDb2RlKGluZGV4KSA9PT0gUEVSSU9EX0NPREUpIHsgLy8gY2FuIHN0YXJ0IHdpdGggYSBkZWNpbWFsIG1hcmtlclxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGV4cHJJKGluZGV4KyspO1xuXG5cdFx0XHRcdFx0XHR3aGlsZShpc0RlY2ltYWxEaWdpdChleHBySUNvZGUoaW5kZXgpKSkge1xuXHRcdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNoID0gZXhwckkoaW5kZXgpO1xuXHRcdFx0XHRcdGlmKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykgeyAvLyBleHBvbmVudCBtYXJrZXJcblx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcblx0XHRcdFx0XHRcdGNoID0gZXhwckkoaW5kZXgpO1xuXHRcdFx0XHRcdFx0aWYoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7IC8vIGV4cG9uZW50IHNpZ25cblx0XHRcdFx0XHRcdFx0bnVtYmVyICs9IGV4cHJJKGluZGV4KyspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUoaXNEZWNpbWFsRGlnaXQoZXhwcklDb2RlKGluZGV4KSkpIHsgLy9leHBvbmVudCBpdHNlbGZcblx0XHRcdFx0XHRcdFx0bnVtYmVyICs9IGV4cHJJKGluZGV4KyspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoIWlzRGVjaW1hbERpZ2l0KGV4cHJJQ29kZShpbmRleC0xKSkgKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkIGV4cG9uZW50ICgnICsgbnVtYmVyICsgZXhwckkoaW5kZXgpICsgJyknLCBpbmRleCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXG5cdFx0XHRcdFx0Y2hDb2RlID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHQvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhpcyBpc24ndCBhIHZhcmlhYmxlIG5hbWUgdGhhdCBzdGFydCB3aXRoIGEgbnVtYmVyICgxMjNhYmMpXG5cdFx0XHRcdFx0aWYoaXNJZGVudGlmaWVyU3RhcnQoY2hDb2RlKSkge1xuXHRcdFx0XHRcdFx0dGhyb3dFcnJvcignVmFyaWFibGUgbmFtZXMgY2Fubm90IHN0YXJ0IHdpdGggYSBudW1iZXIgKCcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0bnVtYmVyICsgZXhwckkoaW5kZXgpICsgJyknLCBpbmRleCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGNoQ29kZSA9PT0gUEVSSU9EX0NPREUpIHtcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1VuZXhwZWN0ZWQgcGVyaW9kJywgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBMSVRFUkFMLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcblx0XHRcdFx0XHRcdHJhdzogbnVtYmVyXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBQYXJzZXMgYSBzdHJpbmcgbGl0ZXJhbCwgc3RhcmluZyB3aXRoIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzIHdpdGggYmFzaWMgc3VwcG9ydCBmb3IgZXNjYXBlIGNvZGVzXG5cdFx0XHRcdC8vIGUuZy4gYFwiaGVsbG8gd29ybGRcImAsIGAndGhpcyBpc1xcbkpTRVAnYFxuXHRcdFx0XHRnb2JibGVTdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHN0ciA9ICcnLCBxdW90ZSA9IGV4cHJJKGluZGV4KyspLCBjbG9zZWQgPSBmYWxzZSwgY2g7XG5cblx0XHRcdFx0XHR3aGlsZShpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y2ggPSBleHBySShpbmRleCsrKTtcblx0XHRcdFx0XHRcdGlmKGNoID09PSBxdW90ZSkge1xuXHRcdFx0XHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihjaCA9PT0gJ1xcXFwnKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENoZWNrIGZvciBhbGwgb2YgdGhlIGNvbW1vbiBlc2NhcGUgY29kZXNcblx0XHRcdFx0XHRcdFx0Y2ggPSBleHBySShpbmRleCsrKTtcblx0XHRcdFx0XHRcdFx0c3dpdGNoKGNoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbic6IHN0ciArPSAnXFxuJzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAncic6IHN0ciArPSAnXFxyJzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAndCc6IHN0ciArPSAnXFx0JzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYic6IHN0ciArPSAnXFxiJzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZic6IHN0ciArPSAnXFxmJzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAndic6IHN0ciArPSAnXFx4MEInOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0IDogc3RyICs9ICdcXFxcJyArIGNoO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gY2g7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIWNsb3NlZCkge1xuXHRcdFx0XHRcdFx0dGhyb3dFcnJvcignVW5jbG9zZWQgcXVvdGUgYWZ0ZXIgXCInK3N0cisnXCInLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IExJVEVSQUwsXG5cdFx0XHRcdFx0XHR2YWx1ZTogc3RyLFxuXHRcdFx0XHRcdFx0cmF3OiBxdW90ZSArIHN0ciArIHF1b3RlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEdvYmJsZXMgb25seSBpZGVudGlmaWVyc1xuXHRcdFx0XHQvLyBlLmcuOiBgZm9vYCwgYF92YWx1ZWAsIGAkeDFgXG5cdFx0XHRcdC8vIEFsc28sIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoYXQgaWRlbnRpZmllciBpcyBhIGxpdGVyYWw6XG5cdFx0XHRcdC8vIChlLmcuIGB0cnVlYCwgYGZhbHNlYCwgYG51bGxgKSBvciBgdGhpc2Bcblx0XHRcdFx0Z29iYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBjaCA9IGV4cHJJQ29kZShpbmRleCksIHN0YXJ0ID0gaW5kZXgsIGlkZW50aWZpZXI7XG5cblx0XHRcdFx0XHRpZihpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1VuZXhwZWN0ZWQgJyArIGV4cHJJKGluZGV4KSwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjaCA9IGV4cHJJQ29kZShpbmRleCk7XG5cdFx0XHRcdFx0XHRpZihpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlkZW50aWZpZXIgPSBleHByLnNsaWNlKHN0YXJ0LCBpbmRleCk7XG5cblx0XHRcdFx0XHRpZihsaXRlcmFscy5oYXNPd25Qcm9wZXJ0eShpZGVudGlmaWVyKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dHlwZTogTElURVJBTCxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGxpdGVyYWxzW2lkZW50aWZpZXJdLFxuXHRcdFx0XHRcdFx0XHRyYXc6IGlkZW50aWZpZXJcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGlkZW50aWZpZXIgPT09IHRoaXNfc3RyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyB0eXBlOiBUSElTX0VYUCB9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBJREVOVElGSUVSLFxuXHRcdFx0XHRcdFx0XHRuYW1lOiBpZGVudGlmaWVyXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHb2JibGVzIGEgbGlzdCBvZiBhcmd1bWVudHMgd2l0aGluIHRoZSBjb250ZXh0IG9mIGEgZnVuY3Rpb24gY2FsbFxuXHRcdFx0XHQvLyBvciBhcnJheSBsaXRlcmFsLiBUaGlzIGZ1bmN0aW9uIGFsc28gYXNzdW1lcyB0aGF0IHRoZSBvcGVuaW5nIGNoYXJhY3RlclxuXHRcdFx0XHQvLyBgKGAgb3IgYFtgIGhhcyBhbHJlYWR5IGJlZW4gZ29iYmxlZCwgYW5kIGdvYmJsZXMgZXhwcmVzc2lvbnMgYW5kIGNvbW1hc1xuXHRcdFx0XHQvLyB1bnRpbCB0aGUgdGVybWluYXRvciBjaGFyYWN0ZXIgYClgIG9yIGBdYCBpcyBlbmNvdW50ZXJlZC5cblx0XHRcdFx0Ly8gZS5nLiBgZm9vKGJhciwgYmF6KWAsIGBteV9mdW5jKClgLCBvciBgW2JhciwgYmF6XWBcblx0XHRcdFx0Z29iYmxlQXJndW1lbnRzID0gZnVuY3Rpb24odGVybWluYXRpb24pIHtcblx0XHRcdFx0XHR2YXIgY2hfaSwgYXJncyA9IFtdLCBub2RlLCBjbG9zZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR3aGlsZShpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHRcdGlmKGNoX2kgPT09IHRlcm1pbmF0aW9uKSB7IC8vIGRvbmUgcGFyc2luZ1xuXHRcdFx0XHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoY2hfaSA9PT0gQ09NTUFfQ09ERSkgeyAvLyBiZXR3ZWVuIGV4cHJlc3Npb25zXG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRub2RlID0gZ29iYmxlRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRcdFx0XHRpZighbm9kZSB8fCBub2RlLnR5cGUgPT09IENPTVBPVU5EKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3dFcnJvcignRXhwZWN0ZWQgY29tbWEnLCBpbmRleCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YXJncy5wdXNoKG5vZGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIWNsb3NlZCkge1xuXHRcdFx0XHRcdFx0dGhyb3dFcnJvcignRXhwZWN0ZWQgJyArIFN0cmluZy5mcm9tQ2hhckNvZGUodGVybWluYXRpb24pLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBhcmdzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdvYmJsZSBhIG5vbi1saXRlcmFsIHZhcmlhYmxlIG5hbWUuIFRoaXMgdmFyaWFibGUgbmFtZSBtYXkgaW5jbHVkZSBwcm9wZXJ0aWVzXG5cdFx0XHRcdC8vIGUuZy4gYGZvb2AsIGBiYXIuYmF6YCwgYGZvb1snYmFyJ10uYmF6YFxuXHRcdFx0XHQvLyBJdCBhbHNvIGdvYmJsZXMgZnVuY3Rpb24gY2FsbHM6XG5cdFx0XHRcdC8vIGUuZy4gYE1hdGguYWNvcyhvYmouYW5nbGUpYFxuXHRcdFx0XHRnb2JibGVWYXJpYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBjaF9pLCBub2RlO1xuXHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYoY2hfaSA9PT0gT1BBUkVOX0NPREUpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBnb2JibGVHcm91cCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZ29iYmxlSWRlbnRpZmllcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHR3aGlsZShjaF9pID09PSBQRVJJT0RfQ09ERSB8fCBjaF9pID09PSBPQlJBQ0tfQ09ERSB8fCBjaF9pID09PSBPUEFSRU5fQ09ERSkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGlmKGNoX2kgPT09IFBFUklPRF9DT0RFKSB7XG5cdFx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdFx0XHRub2RlID0ge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IE1FTUJFUl9FWFAsXG5cdFx0XHRcdFx0XHRcdFx0Y29tcHV0ZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogbm9kZSxcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eTogZ29iYmxlSWRlbnRpZmllcigpXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoY2hfaSA9PT0gT0JSQUNLX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBNRU1CRVJfRVhQLFxuXHRcdFx0XHRcdFx0XHRcdGNvbXB1dGVkOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogbm9kZSxcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eTogZ29iYmxlRXhwcmVzc2lvbigpXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHRcdFx0aWYoY2hfaSAhPT0gQ0JSQUNLX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCBbJywgaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoY2hfaSA9PT0gT1BBUkVOX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQSBmdW5jdGlvbiBjYWxsIGlzIGJlaW5nIG1hZGU7IGdvYmJsZSBhbGwgdGhlIGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRub2RlID0ge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IENBTExfRVhQLFxuXHRcdFx0XHRcdFx0XHRcdCdhcmd1bWVudHMnOiBnb2JibGVBcmd1bWVudHMoQ1BBUkVOX0NPREUpLFxuXHRcdFx0XHRcdFx0XHRcdGNhbGxlZTogbm9kZVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmVzcG9uc2libGUgZm9yIHBhcnNpbmcgYSBncm91cCBvZiB0aGluZ3Mgd2l0aGluIHBhcmVudGhlc2VzIGAoKWBcblx0XHRcdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgaXQgbmVlZHMgdG8gZ29iYmxlIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdC8vIGFuZCB0aGVuIHRyaWVzIHRvIGdvYmJsZSBldmVyeXRoaW5nIHdpdGhpbiB0aGF0IHBhcmVudGhlc2lzLCBhc3N1bWluZ1xuXHRcdFx0XHQvLyB0aGF0IHRoZSBuZXh0IHRoaW5nIGl0IHNob3VsZCBzZWUgaXMgdGhlIGNsb3NlIHBhcmVudGhlc2lzLiBJZiBub3QsXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV4cHJlc3Npb24gcHJvYmFibHkgZG9lc24ndCBoYXZlIGEgYClgXG5cdFx0XHRcdGdvYmJsZUdyb3VwID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHR2YXIgbm9kZSA9IGdvYmJsZUV4cHJlc3Npb24oKTtcblx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRpZihleHBySUNvZGUoaW5kZXgpID09PSBDUEFSRU5fQ09ERSkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCAoJywgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSZXNwb25zaWJsZSBmb3IgcGFyc2luZyBBcnJheSBsaXRlcmFscyBgWzEsIDIsIDNdYFxuXHRcdFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpdCBuZWVkcyB0byBnb2JibGUgdGhlIG9wZW5pbmcgYnJhY2tldFxuXHRcdFx0XHQvLyBhbmQgdGhlbiB0cmllcyB0byBnb2JibGUgdGhlIGV4cHJlc3Npb25zIGFzIGFyZ3VtZW50cy5cblx0XHRcdFx0Z29iYmxlQXJyYXkgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBBUlJBWV9FWFAsXG5cdFx0XHRcdFx0XHRlbGVtZW50czogZ29iYmxlQXJndW1lbnRzKENCUkFDS19DT0RFKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0bm9kZXMgPSBbXSwgY2hfaSwgbm9kZTtcblx0XHRcdFx0XG5cdFx0XHR3aGlsZShpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblxuXHRcdFx0XHQvLyBFeHByZXNzaW9ucyBjYW4gYmUgc2VwYXJhdGVkIGJ5IHNlbWljb2xvbnMsIGNvbW1hcywgb3IganVzdCBpbmZlcnJlZCB3aXRob3V0IGFueVxuXHRcdFx0XHQvLyBzZXBhcmF0b3JzXG5cdFx0XHRcdGlmKGNoX2kgPT09IFNFTUNPTF9DT0RFIHx8IGNoX2kgPT09IENPTU1BX0NPREUpIHtcblx0XHRcdFx0XHRpbmRleCsrOyAvLyBpZ25vcmUgc2VwYXJhdG9yc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFRyeSB0byBnb2JibGUgZWFjaCBleHByZXNzaW9uIGluZGl2aWR1YWxseVxuXHRcdFx0XHRcdGlmKChub2RlID0gZ29iYmxlRXhwcmVzc2lvbigpKSkge1xuXHRcdFx0XHRcdFx0bm9kZXMucHVzaChub2RlKTtcblx0XHRcdFx0XHQvLyBJZiB3ZSB3ZXJlbid0IGFibGUgdG8gZmluZCBhIGJpbmFyeSBleHByZXNzaW9uIGFuZCBhcmUgb3V0IG9mIHJvb20sIHRoZW5cblx0XHRcdFx0XHQvLyB0aGUgZXhwcmVzc2lvbiBwYXNzZWQgaW4gcHJvYmFibHkgaGFzIHRvbyBtdWNoXG5cdFx0XHRcdFx0fSBlbHNlIGlmKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmV4cGVjdGVkIFwiJyArIGV4cHJJKGluZGV4KSArICdcIicsIGluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBvbmx5IG9uZSBleHByZXNzaW9uIGp1c3QgdHJ5IHJldHVybmluZyB0aGUgZXhwcmVzc2lvblxuXHRcdFx0aWYobm9kZXMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiBub2Rlc1swXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogQ09NUE9VTkQsXG5cdFx0XHRcdFx0Ym9keTogbm9kZXNcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdC8vIFRvIGJlIGZpbGxlZCBpbiBieSB0aGUgdGVtcGxhdGVcblx0anNlcC52ZXJzaW9uID0gJzwlPSB2ZXJzaW9uICU+Jztcblx0anNlcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0phdmFTY3JpcHQgRXhwcmVzc2lvbiBQYXJzZXIgKEpTRVApIHYnICsganNlcC52ZXJzaW9uOyB9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAuYWRkVW5hcnlPcFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BfbmFtZSBUaGUgbmFtZSBvZiB0aGUgdW5hcnkgb3AgdG8gYWRkXG5cdCAqIEByZXR1cm4ganNlcFxuXHQgKi9cblx0anNlcC5hZGRVbmFyeU9wID0gZnVuY3Rpb24ob3BfbmFtZSkge1xuXHRcdG1heF91bm9wX2xlbiA9IE1hdGgubWF4KG9wX25hbWUubGVuZ3RoLCBtYXhfdW5vcF9sZW4pO1xuXHRcdHVuYXJ5X29wc1tvcF9uYW1lXSA9IHQ7IHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAuYWRkQmluYXJ5T3Bcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wX25hbWUgVGhlIG5hbWUgb2YgdGhlIGJpbmFyeSBvcCB0byBhZGRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHByZWNlZGVuY2UgVGhlIHByZWNlZGVuY2Ugb2YgdGhlIGJpbmFyeSBvcCAoY2FuIGJlIGEgZmxvYXQpXG5cdCAqIEByZXR1cm4ganNlcFxuXHQgKi9cblx0anNlcC5hZGRCaW5hcnlPcCA9IGZ1bmN0aW9uKG9wX25hbWUsIHByZWNlZGVuY2UpIHtcblx0XHRtYXhfYmlub3BfbGVuID0gTWF0aC5tYXgob3BfbmFtZS5sZW5ndGgsIG1heF9iaW5vcF9sZW4pO1xuXHRcdGJpbmFyeV9vcHNbb3BfbmFtZV0gPSBwcmVjZWRlbmNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAuYWRkTGl0ZXJhbFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBsaXRlcmFsIHRvIGFkZFxuXHQgKiBAcGFyYW0geyp9IGxpdGVyYWxfdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBsaXRlcmFsXG5cdCAqIEByZXR1cm4ganNlcFxuXHQgKi9cblx0anNlcC5hZGRMaXRlcmFsID0gZnVuY3Rpb24obGl0ZXJhbF9uYW1lLCBsaXRlcmFsX3ZhbHVlKSB7XG5cdFx0bGl0ZXJhbHNbbGl0ZXJhbF9uYW1lXSA9IGxpdGVyYWxfdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QganNlcC5yZW1vdmVVbmFyeU9wXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcF9uYW1lIFRoZSBuYW1lIG9mIHRoZSB1bmFyeSBvcCB0byByZW1vdmVcblx0ICogQHJldHVybiBqc2VwXG5cdCAqL1xuXHRqc2VwLnJlbW92ZVVuYXJ5T3AgPSBmdW5jdGlvbihvcF9uYW1lKSB7XG5cdFx0ZGVsZXRlIHVuYXJ5X29wc1tvcF9uYW1lXTtcblx0XHRpZihvcF9uYW1lLmxlbmd0aCA9PT0gbWF4X3Vub3BfbGVuKSB7XG5cdFx0XHRtYXhfdW5vcF9sZW4gPSBnZXRNYXhLZXlMZW4odW5hcnlfb3BzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QganNlcC5yZW1vdmVCaW5hcnlPcFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BfbmFtZSBUaGUgbmFtZSBvZiB0aGUgYmluYXJ5IG9wIHRvIHJlbW92ZVxuXHQgKiBAcmV0dXJuIGpzZXBcblx0ICovXG5cdGpzZXAucmVtb3ZlQmluYXJ5T3AgPSBmdW5jdGlvbihvcF9uYW1lKSB7XG5cdFx0ZGVsZXRlIGJpbmFyeV9vcHNbb3BfbmFtZV07XG5cdFx0aWYob3BfbmFtZS5sZW5ndGggPT09IG1heF9iaW5vcF9sZW4pIHtcblx0XHRcdG1heF9iaW5vcF9sZW4gPSBnZXRNYXhLZXlMZW4oYmluYXJ5X29wcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAucmVtb3ZlTGl0ZXJhbFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBsaXRlcmFsIHRvIHJlbW92ZVxuXHQgKiBAcmV0dXJuIGpzZXBcblx0ICovXG5cdGpzZXAucmVtb3ZlTGl0ZXJhbCA9IGZ1bmN0aW9uKGxpdGVyYWxfbmFtZSkge1xuXHRcdGRlbGV0ZSBsaXRlcmFsc1tsaXRlcmFsX25hbWVdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vIEluIGRlc2t0b3AgZW52aXJvbm1lbnRzLCBoYXZlIGEgd2F5IHRvIHJlc3RvcmUgdGhlIG9sZCB2YWx1ZSBmb3IgYGpzZXBgXG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgb2xkX2pzZXAgPSByb290LmpzZXA7XG5cdFx0Ly8gVGhlIHN0YXIgb2YgdGhlIHNob3chIEl0J3MgYSBmdW5jdGlvbiFcblx0XHRyb290LmpzZXAgPSBqc2VwO1xuXHRcdC8vIEFuZCBhIGNvdXJ0ZW91cyBmdW5jdGlvbiB3aWxsaW5nIHRvIG1vdmUgb3V0IG9mIHRoZSB3YXkgZm9yIG90aGVyIHNpbWlsYXJseS1uYW1lZCBvYmplY3RzIVxuXHRcdGpzZXAubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYocm9vdC5qc2VwID09PSBqc2VwKSB7XG5cdFx0XHRcdHJvb3QuanNlcCA9IG9sZF9qc2VwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGpzZXA7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBJbiBOb2RlLkpTIGVudmlyb25tZW50c1xuXHRcdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdFx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ganNlcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5wYXJzZSA9IGpzZXA7XG5cdFx0fVxuXHR9XG59KHRoaXMpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1ha2VKdWljZUNsaWVudChqdWljZUNsaWVudCkge1xuXG5qdWljZUNsaWVudC5pZ25vcmVkUHNldWRvcyA9IFsnaG92ZXInLCAnYWN0aXZlJywgJ2ZvY3VzJywgJ3Zpc2l0ZWQnLCAnbGluayddO1xuanVpY2VDbGllbnQud2lkdGhFbGVtZW50cyA9IFsnVEFCTEUnLCAnVEQnLCAnSU1HJ107XG5qdWljZUNsaWVudC5oZWlnaHRFbGVtZW50cyA9IFsnVEFCTEUnLCAnVEQnLCAnSU1HJ107XG5qdWljZUNsaWVudC50YWJsZUVsZW1lbnRzID0gWydUQUJMRScsICdURCcsICdUSCcsICdUUicsICdURCcsICdDQVBUSU9OJywgJ0NPTEdST1VQJywgJ0NPTCcsICdUSEVBRCcsICdUQk9EWScsICdURk9PVCddO1xuanVpY2VDbGllbnQubm9uVmlzdWFsRWxlbWVudHMgPSBbICdIRUFEJywgJ1RJVExFJywgJ0JBU0UnLCAnTElOSycsICdTVFlMRScsICdNRVRBJywgJ1NDUklQVCcsICdOT1NDUklQVCcgXTtcbmp1aWNlQ2xpZW50LnN0eWxlVG9BdHRyaWJ1dGUgPSB7XG4gICdiYWNrZ3JvdW5kLWNvbG9yJzogJ2JnY29sb3InLFxuICAnYmFja2dyb3VuZC1pbWFnZSc6ICdiYWNrZ3JvdW5kJyxcbiAgJ3RleHQtYWxpZ24nOiAnYWxpZ24nLFxuICAndmVydGljYWwtYWxpZ24nOiAndmFsaWduJ1xufTtcbmp1aWNlQ2xpZW50LmV4Y2x1ZGVkUHJvcGVydGllcyA9IFtdO1xuXG5qdWljZUNsaWVudC5qdWljZURvY3VtZW50ID0ganVpY2VEb2N1bWVudDtcbmp1aWNlQ2xpZW50LmlubGluZURvY3VtZW50ID0gaW5saW5lRG9jdW1lbnQ7XG5cbmZ1bmN0aW9uIGlubGluZURvY3VtZW50KCQsIGNzcywgb3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcnVsZXMgPSB1dGlscy5wYXJzZUNTUyhjc3MpO1xuICB2YXIgZWRpdGVkRWxlbWVudHMgPSBbXTtcbiAgdmFyIHN0eWxlQXR0cmlidXRlTmFtZSA9ICdzdHlsZSc7XG4gIFxuICBpZiAob3B0aW9ucy5zdHlsZUF0dHJpYnV0ZU5hbWUpIHtcbiAgICBzdHlsZUF0dHJpYnV0ZU5hbWUgPSBvcHRpb25zLnN0eWxlQXR0cmlidXRlTmFtZTtcbiAgfVxuXG4gIHJ1bGVzLmZvckVhY2goaGFuZGxlUnVsZSk7XG4gIGVkaXRlZEVsZW1lbnRzLmZvckVhY2goc2V0U3R5bGVBdHRycyk7XG5cbiAgaWYgKG9wdGlvbnMuaW5saW5lUHNldWRvRWxlbWVudHMpIHtcbiAgICBlZGl0ZWRFbGVtZW50cy5mb3JFYWNoKGlubGluZVBzZXVkb0VsZW1lbnRzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFwcGx5V2lkdGhBdHRyaWJ1dGVzKSB7XG4gICAgZWRpdGVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgc2V0RGltZW5zaW9uQXR0cnMoZWwsICd3aWR0aCcpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXBwbHlIZWlnaHRBdHRyaWJ1dGVzKSB7XG4gICAgZWRpdGVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgc2V0RGltZW5zaW9uQXR0cnMoZWwsICdoZWlnaHQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFwcGx5QXR0cmlidXRlc1RhYmxlRWxlbWVudHMpIHtcbiAgICBlZGl0ZWRFbGVtZW50cy5mb3JFYWNoKHNldEF0dHJpYnV0ZXNPblRhYmxlRWxlbWVudHMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaW5zZXJ0UHJlc2VydmVkRXh0cmFDc3MgJiYgb3B0aW9ucy5leHRyYUNzcykge1xuICAgIHZhciBwcmVzZXJ2ZWRUZXh0ID0gdXRpbHMuZ2V0UHJlc2VydmVkVGV4dChvcHRpb25zLmV4dHJhQ3NzLCB7XG4gICAgICBtZWRpYVF1ZXJpZXM6IG9wdGlvbnMucHJlc2VydmVNZWRpYVF1ZXJpZXMsXG4gICAgICBmb250RmFjZXM6IG9wdGlvbnMucHJlc2VydmVGb250RmFjZXNcbiAgICB9KTtcbiAgICBpZiAocHJlc2VydmVkVGV4dCkge1xuICAgICAgdmFyICRhcHBlbmRUbyA9IG51bGw7XG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRQcmVzZXJ2ZWRFeHRyYUNzcyAhPT0gdHJ1ZSkge1xuICAgICAgICAkYXBwZW5kVG8gPSAkKG9wdGlvbnMuaW5zZXJ0UHJlc2VydmVkRXh0cmFDc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGFwcGVuZFRvID0gJCgnaGVhZCcpO1xuICAgICAgICBpZiAoISRhcHBlbmRUby5sZW5ndGgpIHsgJGFwcGVuZFRvID0gJCgnYm9keScpOyB9XG4gICAgICAgIGlmICghJGFwcGVuZFRvLmxlbmd0aCkgeyAkYXBwZW5kVG8gPSAkLnJvb3QoKTsgfVxuICAgICAgfVxuXG4gICAgICAkYXBwZW5kVG8uZmlyc3QoKS5hcHBlbmQoJzxzdHlsZT4nICsgcHJlc2VydmVkVGV4dCArICc8L3N0eWxlPicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJ1bGUocnVsZSkge1xuICAgIHZhciBzZWwgPSBydWxlWzBdO1xuICAgIHZhciBzdHlsZSA9IHJ1bGVbMV07XG4gICAgdmFyIHNlbGVjdG9yID0gbmV3IHV0aWxzLlNlbGVjdG9yKHNlbCk7XG4gICAgdmFyIHBhcnNlZFNlbGVjdG9yID0gc2VsZWN0b3IucGFyc2VkKCk7XG4gICAgdmFyIHBzZXVkb0VsZW1lbnRUeXBlID0gZ2V0UHNldWRvRWxlbWVudFR5cGUocGFyc2VkU2VsZWN0b3IpO1xuXG4gICAgLy8gc2tpcCBydWxlIGlmIHRoZSBzZWxlY3RvciBoYXMgYW55IHBzZXVkb3Mgd2hpY2ggYXJlIGlnbm9yZWRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnNlZFNlbGVjdG9yLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViU2VsID0gcGFyc2VkU2VsZWN0b3JbaV07XG4gICAgICBpZiAoc3ViU2VsLnBzZXVkb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJTZWwucHNldWRvcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBzdWJTZWxQc2V1ZG8gPSBzdWJTZWwucHNldWRvc1tqXTtcbiAgICAgICAgICBpZiAoanVpY2VDbGllbnQuaWdub3JlZFBzZXVkb3MuaW5kZXhPZihzdWJTZWxQc2V1ZG8ubmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwc2V1ZG9FbGVtZW50VHlwZSkge1xuICAgICAgdmFyIGxhc3QgPSBwYXJzZWRTZWxlY3RvcltwYXJzZWRTZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBwc2V1ZG9zID0gbGFzdC5wc2V1ZG9zO1xuICAgICAgbGFzdC5wc2V1ZG9zID0gZmlsdGVyRWxlbWVudFBzZXVkb3MobGFzdC5wc2V1ZG9zKTtcbiAgICAgIHNlbCA9IHBhcnNlZFNlbGVjdG9yLnRvU3RyaW5nKCk7XG4gICAgICBsYXN0LnBzZXVkb3MgPSBwc2V1ZG9zO1xuICAgIH1cblxuICAgIHZhciBlbHM7XG4gICAgdHJ5IHtcbiAgICAgIGVscyA9ICQoc2VsKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHNraXAgaW52YWxpZCBzZWxlY3RvclxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVscy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsID0gdGhpcztcblxuICAgICAgaWYgKGVsLm5hbWUgJiYganVpY2VDbGllbnQubm9uVmlzdWFsRWxlbWVudHMuaW5kZXhPZihlbC5uYW1lLnRvVXBwZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocHNldWRvRWxlbWVudFR5cGUpIHtcbiAgICAgICAgdmFyIHBzZXVkb0VsUHJvcE5hbWUgPSAncHNldWRvJyArIHBzZXVkb0VsZW1lbnRUeXBlO1xuICAgICAgICB2YXIgcHNldWRvRWwgPSBlbFtwc2V1ZG9FbFByb3BOYW1lXTtcbiAgICAgICAgaWYgKCFwc2V1ZG9FbCkge1xuICAgICAgICAgIHBzZXVkb0VsID0gZWxbcHNldWRvRWxQcm9wTmFtZV0gPSAkKCc8c3BhbiAvPicpLmdldCgwKTtcbiAgICAgICAgICBwc2V1ZG9FbC5wc2V1ZG9FbGVtZW50VHlwZSA9IHBzZXVkb0VsZW1lbnRUeXBlO1xuICAgICAgICAgIHBzZXVkb0VsLnBzZXVkb0VsZW1lbnRQYXJlbnQgPSBlbDtcbiAgICAgICAgICBlbFtwc2V1ZG9FbFByb3BOYW1lXSA9IHBzZXVkb0VsO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gcHNldWRvRWw7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWwuc3R5bGVQcm9wcykge1xuICAgICAgICBlbC5zdHlsZVByb3BzID0ge307XG5cbiAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaGFzIGlubGluZSBzdHlsZXMsIGZha2Ugc2VsZWN0b3Igd2l0aCB0b3Btb3N0IHNwZWNpZmljaXR5XG4gICAgICAgIGlmICgkKGVsKS5hdHRyKHN0eWxlQXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICB2YXIgY3NzVGV4dCA9ICcqIHsgJyArICQoZWwpLmF0dHIoc3R5bGVBdHRyaWJ1dGVOYW1lKSArICcgfSAnO1xuICAgICAgICAgIGFkZFByb3BzKHV0aWxzLnBhcnNlQ1NTKGNzc1RleHQpWzBdWzFdLCBuZXcgdXRpbHMuU2VsZWN0b3IoJzxzdHlsZT4nLCB0cnVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSByZWZlcmVuY2UgdG8gYW4gZWxlbWVudCB3ZSBuZWVkIHRvIGNvbXBpbGUgc3R5bGU9XCJcIiBhdHRyIGZvclxuICAgICAgICBlZGl0ZWRFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcHJvcGVydGllc1xuICAgICAgZnVuY3Rpb24gYWRkUHJvcHMoc3R5bGUsIHNlbGVjdG9yKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3R5bGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHN0eWxlW2ldLnR5cGUgPT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBzdHlsZVtpXS5uYW1lO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVbaV0udmFsdWU7XG4gICAgICAgICAgICB2YXIgaW1wb3J0YW50ID0gc3R5bGVbaV0udmFsdWUubWF0Y2goLyFpbXBvcnRhbnQkLykgIT09IG51bGw7XG4gICAgICAgICAgICBpZiAoaW1wb3J0YW50ICYmICFvcHRpb25zLnByZXNlcnZlSW1wb3J0YW50KSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccyohaW1wb3J0YW50JC8sICcnKTtcbiAgICAgICAgICAgIC8vIGFkZHMgbGluZSBudW1iZXIgYW5kIGNvbHVtbiBudW1iZXIgZm9yIHRoZSBwcm9wZXJ0aWVzIGFzIFwiYWRkaXRpb25hbFByaW9yaXR5XCIgdG8gdGhlIFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyBiZWNhdXNlIGluIENTUyB0aGUgcG9zaXRpb24gZGlyZWN0bHkgYWZmZWN0IHRoZSBwcmlvcml0eS5cbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsUHJpb3JpdHkgPSBbc3R5bGVbaV0ucG9zaXRpb24uc3RhcnQubGluZSwgc3R5bGVbaV0ucG9zaXRpb24uc3RhcnQuY29sXTtcbiAgICAgICAgICAgIHZhciBwcm9wID0gbmV3IHV0aWxzLlByb3BlcnR5KG5hbWUsIHZhbHVlLCBzZWxlY3RvciwgaW1wb3J0YW50ID8gMiA6IDAsIGFkZGl0aW9uYWxQcmlvcml0eSk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBlbC5zdHlsZVByb3BzW25hbWVdO1xuXG4gICAgICAgICAgICAvLyBpZiBwcm9wZXJ0eSBuYW1lIGlzIG5vdCBpbiB0aGUgZXhjbHVkZWQgcHJvcGVydGllcyBhcnJheVxuICAgICAgICAgICAgaWYgKGp1aWNlQ2xpZW50LmV4Y2x1ZGVkUHJvcGVydGllcy5pbmRleE9mKG5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcuY29tcGFyZShwcm9wKSA9PT0gcHJvcCB8fCAhZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGluZyBhIHByb3BlcnR5IGxldCB1cyBjaGFuZ2UgdGhlIG9yZGVyIChtb3ZlIGl0IHRvIHRoZSBlbmQgaW4gdGhlIHNldFN0eWxlQXR0cnMgbG9vcClcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc2VsZWN0b3IgIT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgZWwuc3R5bGVQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBtYWtlIFwicHJvcFwiIGEgc3BlY2lhbCBjb21wb3NlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgIHByb3AubmV4dFByb3AgPSBleGlzdGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbC5zdHlsZVByb3BzW25hbWVdID0gcHJvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZGRQcm9wcyhzdHlsZSwgc2VsZWN0b3IpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3R5bGVBdHRycyhlbCkge1xuICAgIHZhciBsID0gT2JqZWN0LmtleXMoZWwuc3R5bGVQcm9wcykubGVuZ3RoO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIC8vIEhlcmUgd2UgbG9vcCBlYWNoIHByb3BlcnR5IGFuZCBtYWtlIHN1cmUgdG8gXCJleHBhbmRcIlxuICAgIC8vIGxpbmtlZCBcIm5leHRQcm9wXCIgcHJvcGVydGllcyBoYXBwZW5pbmcgd2hlbiB0aGUgc2FtZSBwcm9wZXJ0eVxuICAgIC8vIGlzIGRlY2xhcmVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHNlbGVjdG9yLlxuICAgIE9iamVjdC5rZXlzKGVsLnN0eWxlUHJvcHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbnAgPSBlbC5zdHlsZVByb3BzW2tleV07XG4gICAgICB3aGlsZSAodHlwZW9mIG5wICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wcy5wdXNoKG5wKTtcbiAgICAgICAgbnAgPSBucC5uZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBzb3J0IHByb3BlcnRpZXMgYnkgdGhlaXIgb3JpZ2luYXRpbmcgc2VsZWN0b3IncyBzcGVjaWZpY2l0eSBzbyB0aGF0XG4gICAgLy8gcHJvcHMgbGlrZSBcInBhZGRpbmdcIiBhbmQgXCJwYWRkaW5nLWJvdHRvbVwiIGFyZSByZXNvbHZlZCBhcyBleHBlY3RlZC5cbiAgICBwcm9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNvbXBhcmVGdW5jKGIpO1xuICAgIH0pO1xuICAgIHZhciBzdHJpbmcgPSBwcm9wc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIC8vIENvbnRlbnQgYmVjb21lcyB0aGUgaW5uZXJIVE1MIG9mIHBzZXVkbyBlbGVtZW50cywgbm90IHVzZWQgYXMgYVxuICAgICAgICAvLyBzdHlsZSBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gcHJvcC5wcm9wICE9PSAnY29udGVudCc7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wLnByb3AgKyAnOiAnICsgcHJvcC52YWx1ZS5yZXBsYWNlKC9bXCJdL2csICdcXCcnKSArICc7JztcbiAgICAgIH0pXG4gICAgICAuam9pbignICcpO1xuICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICQoZWwpLmF0dHIoc3R5bGVBdHRyaWJ1dGVOYW1lLCBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlubGluZVBzZXVkb0VsZW1lbnRzKGVsKSB7XG4gICAgaWYgKGVsLnBzZXVkb0VsZW1lbnRUeXBlICYmIGVsLnN0eWxlUHJvcHMuY29udGVudCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlQ29udGVudChlbC5zdHlsZVByb3BzLmNvbnRlbnQudmFsdWUpO1xuICAgICAgaWYgKHBhcnNlZC5pbWcpIHtcbiAgICAgICAgZWwubmFtZSA9ICdpbWcnO1xuICAgICAgICAkKGVsKS5hdHRyKCdzcmMnLCBwYXJzZWQuaW1nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoZWwpLnRleHQocGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wc2V1ZG9FbGVtZW50UGFyZW50O1xuICAgICAgaWYgKGVsLnBzZXVkb0VsZW1lbnRUeXBlID09PSAnYmVmb3JlJykge1xuICAgICAgICAkKHBhcmVudCkucHJlcGVuZChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHBhcmVudCkuYXBwZW5kKGVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXREaW1lbnNpb25BdHRycyhlbCwgZGltZW5zaW9uKSB7XG4gICAgaWYgKCFlbC5uYW1lKSB7IHJldHVybjsgfVxuICAgIHZhciBlbE5hbWUgPSBlbC5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGp1aWNlQ2xpZW50W2RpbWVuc2lvbiArICdFbGVtZW50cyddLmluZGV4T2YoZWxOYW1lKSA+IC0xKSB7XG4gICAgICBmb3IgKHZhciBpIGluIGVsLnN0eWxlUHJvcHMpIHtcbiAgICAgICAgaWYgKGVsLnN0eWxlUHJvcHNbaV0ucHJvcCA9PT0gZGltZW5zaW9uKSB7XG4gICAgICAgICAgaWYgKGVsLnN0eWxlUHJvcHNbaV0udmFsdWUubWF0Y2goL3B4LykpIHtcbiAgICAgICAgICAgIHZhciBweFNpemUgPSBlbC5zdHlsZVByb3BzW2ldLnZhbHVlLnJlcGxhY2UoJ3B4JywgJycpO1xuICAgICAgICAgICAgJChlbCkuYXR0cihkaW1lbnNpb24sIHB4U2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqdWljZUNsaWVudC50YWJsZUVsZW1lbnRzLmluZGV4T2YoZWxOYW1lKSA+IC0xICYmIGVsLnN0eWxlUHJvcHNbaV0udmFsdWUubWF0Y2goL1xcJS8pKSB7XG4gICAgICAgICAgICAkKGVsKS5hdHRyKGRpbWVuc2lvbiwgZWwuc3R5bGVQcm9wc1tpXS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXR0cmlidXRlc09uVGFibGVFbGVtZW50cyhlbCkge1xuICAgIGlmICghZWwubmFtZSkgeyByZXR1cm47IH1cbiAgICB2YXIgZWxOYW1lID0gZWwubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBzdHlsZVByb3BzID0gT2JqZWN0LmtleXMoanVpY2VDbGllbnQuc3R5bGVUb0F0dHJpYnV0ZSk7XG5cbiAgICBpZiAoanVpY2VDbGllbnQudGFibGVFbGVtZW50cy5pbmRleE9mKGVsTmFtZSkgPiAtMSkge1xuICAgICAgZm9yICh2YXIgaSBpbiBlbC5zdHlsZVByb3BzKSB7XG4gICAgICAgIGlmIChzdHlsZVByb3BzLmluZGV4T2YoZWwuc3R5bGVQcm9wc1tpXS5wcm9wKSA+IC0xKSB7XG4gICAgICAgICAgJChlbCkuYXR0cihqdWljZUNsaWVudC5zdHlsZVRvQXR0cmlidXRlW2VsLnN0eWxlUHJvcHNbaV0ucHJvcF0sIGVsLnN0eWxlUHJvcHNbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29udGVudChjb250ZW50KSB7XG4gIGlmIChjb250ZW50ID09PSAnbm9uZScgfHwgY29udGVudCA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaW1hZ2VVcmxNYXRjaCA9IGNvbnRlbnQubWF0Y2goL15cXHMqdXJsXFxzKlxcKFxccyooLio/KVxccypcXClcXHMqJC9pKTtcbiAgaWYgKGltYWdlVXJsTWF0Y2gpIHtcbiAgICB2YXIgdXJsID0gaW1hZ2VVcmxNYXRjaFsxXS5yZXBsYWNlKC9eWydcIl18WydcIl0kL2csICcnKTtcbiAgICByZXR1cm4geyBpbWc6IHVybCB9O1xuICB9XG5cbiAgLy8gTmFpdmUgcGFyc2luZywgYXNzdW1lIHdlbGwtZm9ybWVkIHZhbHVlXG4gIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEsIGNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gIC8vIE5haXZlIHVuZXNjYXBlLCBhc3N1bWUgbm8gdW5pY29kZSBjaGFyIGNvZGVzXG4gIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICByZXR1cm4gY29udGVudDtcbn1cblxuLy8gUmV0dXJuIFwiYmVmb3JlXCIgb3IgXCJhZnRlclwiIGlmIHRoZSBnaXZlbiBzZWxlY3RvciBpcyBhIHBzZXVkbyBlbGVtZW50IChlLmcuLFxuLy8gYTo6YWZ0ZXIpLlxuZnVuY3Rpb24gZ2V0UHNldWRvRWxlbWVudFR5cGUoc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwc2V1ZG9zID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0ucHNldWRvcztcbiAgaWYgKCFwc2V1ZG9zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwc2V1ZG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzUHNldWRvRWxlbWVudE5hbWUocHNldWRvc1tpXSkpIHtcbiAgICAgIHJldHVybiBwc2V1ZG9zW2ldLm5hbWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzUHNldWRvRWxlbWVudE5hbWUocHNldWRvKSB7XG4gIHJldHVybiBwc2V1ZG8ubmFtZSA9PT0gJ2JlZm9yZScgfHwgcHNldWRvLm5hbWUgPT09ICdhZnRlcic7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckVsZW1lbnRQc2V1ZG9zKHBzZXVkb3MpIHtcbiAgcmV0dXJuIHBzZXVkb3MuZmlsdGVyKGZ1bmN0aW9uKHBzZXVkbykge1xuICAgIHJldHVybiAhaXNQc2V1ZG9FbGVtZW50TmFtZShwc2V1ZG8pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ganVpY2VEb2N1bWVudCgkLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB1dGlscy5nZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcbiAgdmFyIGNzcyA9IGV4dHJhY3RDc3NGcm9tRG9jdW1lbnQoJCwgb3B0aW9ucyk7XG4gIGNzcyArPSAnXFxuJyArIG9wdGlvbnMuZXh0cmFDc3M7XG4gIGlubGluZURvY3VtZW50KCQsIGNzcywgb3B0aW9ucyk7XG4gIHJldHVybiAkO1xufVxuXG5mdW5jdGlvbiBnZXRTdHlsZXNEYXRhKCQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHN0eWxlc0xpc3QgPSAkKCdzdHlsZScpO1xuICB2YXIgc3R5bGVEYXRhTGlzdCwgc3R5bGVEYXRhLCBzdHlsZUVsZW1lbnQ7XG4gIHN0eWxlc0xpc3QuZWFjaChmdW5jdGlvbigpIHtcbiAgICBzdHlsZUVsZW1lbnQgPSB0aGlzO1xuICAgIHN0eWxlRGF0YUxpc3QgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcbiAgICBpZiAoc3R5bGVEYXRhTGlzdC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3R5bGVEYXRhID0gc3R5bGVEYXRhTGlzdFswXS5kYXRhO1xuICAgIGlmIChvcHRpb25zLmFwcGx5U3R5bGVUYWdzICYmICQoc3R5bGVFbGVtZW50KS5hdHRyKCdkYXRhLWVtYmVkJykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHN0eWxlRGF0YSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlbW92ZVN0eWxlVGFncyAmJiAkKHN0eWxlRWxlbWVudCkuYXR0cignZGF0YS1lbWJlZCcpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwcmVzZXJ2ZWRUZXh0ID0gdXRpbHMuZ2V0UHJlc2VydmVkVGV4dChzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUsIHtcbiAgICAgICAgbWVkaWFRdWVyaWVzOiBvcHRpb25zLnByZXNlcnZlTWVkaWFRdWVyaWVzLFxuICAgICAgICBmb250RmFjZXM6IG9wdGlvbnMucHJlc2VydmVGb250RmFjZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXNlcnZlZFRleHQpIHtcbiAgICAgICAgc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gcHJlc2VydmVkVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoc3R5bGVFbGVtZW50KS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgJChzdHlsZUVsZW1lbnQpLnJlbW92ZUF0dHIoJ2RhdGEtZW1iZWQnKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0Q3NzRnJvbURvY3VtZW50KCQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdHMgPSBnZXRTdHlsZXNEYXRhKCQsIG9wdGlvbnMpO1xuICB2YXIgY3NzID0gcmVzdWx0cy5qb2luKCdcXG4nKTtcbiAgcmV0dXJuIGNzcztcbn1cblxucmV0dXJuIGp1aWNlQ2xpZW50O1xuXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ1NTIHByb3BlcnR5IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge1NlbGVjdG9yfSBzZWxlY3RvciB0aGUgcHJvcGVydHkgb3JpZ2luYXRlcyBmcm9tXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHByaW9yaXR5IDAgZm9yIG5vcm1hbCBwcm9wZXJ0aWVzLCAyIGZvciAhaW1wb3J0YW50IHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBhZGRpdGlvbmFsIGFycmF5IG9mIGludGVnZXJzIHJlcHJlc2VudGluZyBtb3JlIGRldGFpbGVkIHByaW9yaXRpZXMgKHNvcnRpbmcpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFByb3BlcnR5KHByb3AsIHZhbHVlLCBzZWxlY3RvciwgcHJpb3JpdHksIGFkZGl0aW9uYWxQcmlvcml0eSkge1xuICB0aGlzLnByb3AgPSBwcm9wO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG4gIHRoaXMuYWRkaXRpb25hbFByaW9yaXR5ID0gYWRkaXRpb25hbFByaW9yaXR5IHx8IFtdO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHdpdGggYW5vdGhlciBQcm9wZXJ0eSBiYXNlZCBvbiBTZWxlY3RvciNzcGVjaWZpY2l0eS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblByb3BlcnR5LnByb3RvdHlwZS5jb21wYXJlRnVuYyA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gIHZhciBhID0gW107XG4gIGEucHVzaC5hcHBseShhLCB0aGlzLnNlbGVjdG9yLnNwZWNpZmljaXR5KCkpO1xuICBhLnB1c2guYXBwbHkoYSwgdGhpcy5hZGRpdGlvbmFsUHJpb3JpdHkpO1xuICBhWzBdICs9IHRoaXMucHJpb3JpdHk7XG4gIHZhciBiID0gW107XG4gIGIucHVzaC5hcHBseShiLCBwcm9wZXJ0eS5zZWxlY3Rvci5zcGVjaWZpY2l0eSgpKTtcbiAgYi5wdXNoLmFwcGx5KGIsIHByb3BlcnR5LmFkZGl0aW9uYWxQcmlvcml0eSk7XG4gIGJbMF0gKz0gcHJvcGVydHkucHJpb3JpdHk7XG4gIHJldHVybiB1dGlscy5jb21wYXJlRnVuYyhhLCBiKTtcbn07XG5cblByb3BlcnR5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgdmFyIHdpbm5lciA9IHRoaXMuY29tcGFyZUZ1bmMocHJvcGVydHkpO1xuICBpZiAod2lubmVyID09PSAxKSByZXR1cm4gdGhpcztcbiAgcmV0dXJuIHByb3BlcnR5O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgQ1NTIHByb3BlcnR5XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucHJvcCArICc6ICcgKyB0aGlzLnZhbHVlLnJlcGxhY2UoL1snXCJdKy9nLCAnJykgKyAnOyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZShcIi4vLi4vLi4vc2xpY2svcGFyc2VyXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTZWxlY3RvcjtcblxuLyoqXG4gKiBDU1Mgc2VsZWN0b3IgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIHRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbmFsbHksIHByZWNhbGN1bGF0ZWQgc3BlY2lmaWNpdHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2VsZWN0b3IodGV4dCwgc3R5bGVBdHRyaWJ1dGUpIHtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5zcGVjID0gdW5kZWZpbmVkO1xuICB0aGlzLnN0eWxlQXR0cmlidXRlID0gc3R5bGVBdHRyaWJ1dGUgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IHBhcnNlZCBzZWxlY3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNlbGVjdG9yLnByb3RvdHlwZS5wYXJzZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnRva2VucykgeyB0aGlzLnRva2VucyA9IHBhcnNlKHRoaXMudGV4dCk7IH1cbiAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLyoqXG4gKiBMYXp5IHNwZWNpZmljaXR5IGdldHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VsZWN0b3IucHJvdG90eXBlLnNwZWNpZmljaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZUF0dHJpYnV0ZSA9IHRoaXMuc3R5bGVBdHRyaWJ1dGU7XG4gIGlmICghdGhpcy5zcGVjKSB7IHRoaXMuc3BlYyA9IHNwZWNpZmljaXR5KHRoaXMudGV4dCwgdGhpcy5wYXJzZWQoKSk7IH1cbiAgcmV0dXJuIHRoaXMuc3BlYztcblxuICBmdW5jdGlvbiBzcGVjaWZpY2l0eSh0ZXh0LCBwYXJzZWQpIHtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBwYXJzZWQgfHwgcGFyc2UodGV4dCk7XG4gICAgdmFyIHNwZWMgPSBbc3R5bGVBdHRyaWJ1dGUgPyAxIDogMCwgMCwgMCwgMF07XG4gICAgdmFyIG5vdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaV07XG4gICAgICB2YXIgcHNldWRvcyA9IGV4cHJlc3Npb24ucHNldWRvcztcblxuICAgICAgLy8gaWQgYXdhcmRzIGEgcG9pbnQgaW4gdGhlIHNlY29uZCBjb2x1bW5cbiAgICAgIGlmIChleHByZXNzaW9uLmlkKSB7IHNwZWNbMV0rKzsgfVxuXG4gICAgICAvLyBjbGFzc2VzIGFuZCBhdHRyaWJ1dGVzIGF3YXJkIGEgcG9pbnQgZWFjaCBpbiB0aGUgdGhpcmQgY29sdW1uXG4gICAgICBpZiAoZXhwcmVzc2lvbi5hdHRyaWJ1dGVzKSB7IHNwZWNbMl0gKz0gZXhwcmVzc2lvbi5hdHRyaWJ1dGVzLmxlbmd0aDsgfVxuICAgICAgaWYgKGV4cHJlc3Npb24uY2xhc3NMaXN0KSB7IHNwZWNbMl0gKz0gZXhwcmVzc2lvbi5jbGFzc0xpc3QubGVuZ3RoOyB9XG5cbiAgICAgIC8vIHRhZyBhd2FyZHMgYSBwb2ludCBpbiB0aGUgZm91cnRoIGNvbHVtblxuICAgICAgaWYgKGV4cHJlc3Npb24udGFnICYmIGV4cHJlc3Npb24udGFnICE9PSAnKicpIHsgc3BlY1szXSsrOyB9XG5cbiAgICAgIC8vIHBzZXVkb3MgYXdhcmQgYSBwb2ludCBlYWNoIGluIHRoZSBmb3VydGggY29sdW1uXG4gICAgICBpZiAocHNldWRvcykge1xuICAgICAgICBzcGVjWzNdICs9IHBzZXVkb3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcHNldWRvcy5sZW5ndGg7IHArKykge1xuICAgICAgICAgIGlmIChwc2V1ZG9zW3BdLm5hbWUgPT09ICdub3QnKSB7XG4gICAgICAgICAgICBub3RzLnB1c2gocHNldWRvc1twXS52YWx1ZSk7XG4gICAgICAgICAgICBzcGVjWzNdLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaWkgPSBub3RzLmxlbmd0aDsgaWktLTspIHtcbiAgICAgIHZhciBub3QgPSBzcGVjaWZpY2l0eShub3RzW2lpXSk7XG4gICAgICBmb3IgKHZhciBqaiA9IDQ7IGpqLS07KSB7IHNwZWNbampdICs9IG5vdFtqal07IH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BlYztcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzZWxlY3RvciBhbmQgcmV0dXJucyB0aGUgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQGFwaSBwcml2YXRlLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcGFyc2VyKHRleHQpWzBdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgbWVuc2NoID0gcmVxdWlyZShcIi4vLi4vLi4vbWVuc2NoL2luZGV4LmpzXCIpO1xudmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG9zID0gcmVxdWlyZSgnb3MnKTtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuZXhwb3J0cy5TZWxlY3RvciA9IFNlbGVjdG9yO1xuZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHNlbGVjdG9ycy5cbiAqXG4gKiBAbGljZW5zZSBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSAtIE1JVFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yVGV4dCBmcm9tIG1lbnNjaFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiBleHRyYWN0KHNlbGVjdG9yVGV4dCkge1xuICB2YXIgYXR0ciA9IDA7XG4gIHZhciBzZWxzID0gW107XG4gIHZhciBzZWwgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGVjdG9yVGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgYyA9IHNlbGVjdG9yVGV4dC5jaGFyQXQoaSk7XG5cbiAgICBpZiAoYXR0cikge1xuICAgICAgaWYgKCddJyA9PT0gYyB8fCAnKScgPT09IGMpIHsgYXR0ci0tOyB9XG4gICAgICBzZWwgKz0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcsJyA9PT0gYykge1xuICAgICAgICBzZWxzLnB1c2goc2VsKTtcbiAgICAgICAgc2VsID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJ1snID09PSBjIHx8ICcoJyA9PT0gYykgeyBhdHRyKys7IH1cbiAgICAgICAgaWYgKHNlbC5sZW5ndGggfHwgKGMgIT09ICcsJyAmJiBjICE9PSAnXFxuJyAmJiBjICE9PSAnICcpKSB7IHNlbCArPSBjOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbC5sZW5ndGgpIHtcbiAgICBzZWxzLnB1c2goc2VsKTtcbiAgfVxuXG4gIHJldHVybiBzZWxzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGFyc2UgdHJlZSBmb3IgYSBDU1Mgc291cmNlLlxuICogSWYgaXQgZW5jb3VudGVycyBtdWx0aXBsZSBzZWxlY3RvcnMgc2VwYXJhdGVkIGJ5IGEgY29tbWEsIGl0IHNwbGl0cyB0aGVcbiAqIHRyZWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNzcyBzb3VyY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZUNTUyA9IGZ1bmN0aW9uKGNzcykge1xuICB2YXIgcGFyc2VkID0gbWVuc2NoLnBhcnNlKGNzcywge3Bvc2l0aW9uOiB0cnVlLCBjb21tZW50czogdHJ1ZX0pO1xuICB2YXIgcnVsZXMgPSB0eXBlb2YgcGFyc2VkLnN0eWxlc2hlZXQgIT0gJ3VuZGVmaW5lZCcgJiYgcGFyc2VkLnN0eWxlc2hlZXQucnVsZXMgPyBwYXJzZWQuc3R5bGVzaGVldC5ydWxlcyA6IFtdO1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocnVsZXNbaV0udHlwZSA9PSAncnVsZScpIHtcbiAgICAgIHZhciBydWxlID0gcnVsZXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3JzID0gcnVsZS5zZWxlY3RvcnM7XG5cbiAgICAgIGZvciAodmFyIGlpID0gMCwgbGwgPSBzZWxlY3RvcnMubGVuZ3RoOyBpaSA8IGxsOyBpaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKFtzZWxlY3RvcnNbaWldLCBydWxlLmRlY2xhcmF0aW9uc10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgcHJlc2VydmVkIHRleHQgZm9yIGEgQ1NTIHNvdXJjZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIHNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5nZXRQcmVzZXJ2ZWRUZXh0ID0gZnVuY3Rpb24oY3NzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZWQgPSBtZW5zY2gucGFyc2UoY3NzLCB7cG9zaXRpb246IHRydWUsIGNvbW1lbnRzOiB0cnVlfSk7XG4gIHZhciBydWxlcyA9IHR5cGVvZiBwYXJzZWQuc3R5bGVzaGVldCAhPSAndW5kZWZpbmVkJyAmJiBwYXJzZWQuc3R5bGVzaGVldC5ydWxlcyA/IHBhcnNlZC5zdHlsZXNoZWV0LnJ1bGVzIDogW107XG4gIHZhciBwcmVzZXJ2ZWQgPSBbXTtcbiAgdmFyIGxhc3RTdGFydCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IHJ1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChvcHRpb25zLmZvbnRGYWNlcyAmJiBydWxlc1tpXS50eXBlID09PSAnZm9udC1mYWNlJykgfHxcbiAgICAgICAgKG9wdGlvbnMubWVkaWFRdWVyaWVzICYmIHJ1bGVzW2ldLnR5cGUgPT09ICdtZWRpYScpKSB7XG4gICAgICBwcmVzZXJ2ZWQucHVzaChcbiAgICAgICAgbWVuc2NoLnN0cmluZ2lmeShcbiAgICAgICAgICB7IHN0eWxlc2hlZXQ6IHsgcnVsZXM6IFsgcnVsZXNbaV0gXSB9fSxcbiAgICAgICAgICB7IGNvbW1lbnRzOiBmYWxzZSwgaW5kZW50YXRpb246ICcgICcgfVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBsYXN0U3RhcnQgPSBydWxlc1tpXS5wb3NpdGlvbi5zdGFydDtcbiAgfVxuXG4gIGlmIChwcmVzZXJ2ZWQubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcy5FT0wrcHJlc2VydmVkLmpvaW4ob3MuRU9MKStvcy5FT0w7XG59O1xuXG5leHBvcnRzLm5vcm1hbGl6ZUxpbmVFbmRpbmdzID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcbi9nLCAnXFxyXFxuJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIHNwZWNpZmljaXR5IHZlY3RvcnMsIHJldHVybmluZyB0aGUgd2lubmluZyBvbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yIGFcbiAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvciBiXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb21wYXJlRnVuYyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIG1pbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICBpZiAoYVtpXSA9PT0gYltpXSkgeyBjb250aW51ZTsgfVxuICAgIGlmIChhW2ldID4gYltpXSkgeyByZXR1cm4gMTsgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBhLmxlbmd0aC1iLmxlbmd0aDtcbn07XG5cbmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZUZ1bmMoYSwgYikgPT0gMSA/IGEgOiBiO1xufTtcblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbihvYmosIHNyYykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKG93bi5jYWxsKHNyYywga2V5KSkge1xuICAgICAgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydHMuZ2V0RGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBleHBvcnRzLmV4dGVuZCh7XG4gICAgZXh0cmFDc3M6ICcnLFxuICAgIGluc2VydFByZXNlcnZlZEV4dHJhQ3NzOiB0cnVlLFxuICAgIGFwcGx5U3R5bGVUYWdzOiB0cnVlLFxuICAgIHJlbW92ZVN0eWxlVGFnczogdHJ1ZSxcbiAgICBwcmVzZXJ2ZU1lZGlhUXVlcmllczogdHJ1ZSxcbiAgICBwcmVzZXJ2ZUZvbnRGYWNlczogdHJ1ZSxcbiAgICBhcHBseVdpZHRoQXR0cmlidXRlczogdHJ1ZSxcbiAgICBhcHBseUhlaWdodEF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXBwbHlBdHRyaWJ1dGVzVGFibGVFbGVtZW50czogdHJ1ZSxcbiAgICB1cmw6ICcnXG4gIH0sIG9wdGlvbnMpO1xuXG4gIHJlc3VsdC53ZWJSZXNvdXJjZXMgPSByZXN1bHQud2ViUmVzb3VyY2VzIHx8IHt9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8ga25vY2tvdXQtc29ydGFibGUgMC4xNS4wIHwgKGMpIDIwMTYgUnlhbiBOaWVtZXllciB8ICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4hZnVuY3Rpb24oYSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXCJrbm9ja291dFwiLFwianF1ZXJ5XCIsXCJqcXVlcnktdWkvc29ydGFibGVcIixcImpxdWVyeS11aS9kcmFnZ2FibGVcIl0sYSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSl7dmFyIGI9KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCksYz0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpOyh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXVsndWknXVsnc29ydGFibGUnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddWyd1aSddWydzb3J0YWJsZSddIDogbnVsbCksKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddWyd1aSddWydkcmFnZ2FibGUnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddWyd1aSddWydkcmFnZ2FibGUnXSA6IG51bGwpLGEoYixjKX1lbHNlIGEod2luZG93LmtvLHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhLGIpe3ZhciBjPVwia29fc29ydEl0ZW1cIixkPVwia29fc291cmNlSW5kZXhcIixlPVwia29fc29ydExpc3RcIixmPVwia29fcGFyZW50TGlzdFwiLGc9XCJrb19kcmFnSXRlbVwiLGg9YS51dGlscy51bndyYXBPYnNlcnZhYmxlLGk9YS51dGlscy5kb21EYXRhLmdldCxqPWEudXRpbHMuZG9tRGF0YS5zZXQsaz1iLnVpJiZiLnVpLnZlcnNpb24sbD1rJiZrLmluZGV4T2YoXCIxLjYuXCIpJiZrLmluZGV4T2YoXCIxLjcuXCIpJiYoay5pbmRleE9mKFwiMS44LlwiKXx8XCIxLjguMjRcIj09PWspLG09ZnVuY3Rpb24oYixkKXthLnV0aWxzLmFycmF5Rm9yRWFjaChiLGZ1bmN0aW9uKGEpezE9PT1hLm5vZGVUeXBlJiYoaihhLGMsZCksaihhLGYsaShhLnBhcmVudE5vZGUsZSkpKX0pfSxuPWZ1bmN0aW9uKGIsYyl7dmFyIGQsZT17fSxmPWgoYigpKXx8e307cmV0dXJuIGYuZGF0YT8oZVtjXT1mLmRhdGEsZS5uYW1lPWYudGVtcGxhdGUpOmVbY109YigpLGEudXRpbHMuYXJyYXlGb3JFYWNoKFtcImFmdGVyQWRkXCIsXCJhZnRlclJlbmRlclwiLFwiYXNcIixcImJlZm9yZVJlbW92ZVwiLFwiaW5jbHVkZURlc3Ryb3llZFwiLFwidGVtcGxhdGVFbmdpbmVcIixcInRlbXBsYXRlT3B0aW9uc1wiLFwibm9kZXNcIl0sZnVuY3Rpb24oYil7Zi5oYXNPd25Qcm9wZXJ0eShiKT9lW2JdPWZbYl06YS5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGUuaGFzT3duUHJvcGVydHkoYikmJihlW2JdPWEuYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlW2JdKX0pLFwiZm9yZWFjaFwiPT09YyYmKGUuYWZ0ZXJSZW5kZXI/KGQ9ZS5hZnRlclJlbmRlcixlLmFmdGVyUmVuZGVyPWZ1bmN0aW9uKGEsYil7bS5jYWxsKGIsYSxiKSxkLmNhbGwoYixhLGIpfSk6ZS5hZnRlclJlbmRlcj1tKSxlfSxvPWZ1bmN0aW9uKGEsYil7dmFyIGM9aChiKTtpZihjKWZvcih2YXIgZD0wO2E+ZDtkKyspY1tkXSYmaChjW2RdLl9kZXN0cm95KSYmYSsrO3JldHVybiBhfSxwPWZ1bmN0aW9uKGMsZCl7dmFyIGUsZjtkPyhmPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGQpLGYmJihlPW5ldyBhLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50KGYpLGUudGV4dChiLnRyaW0oZS50ZXh0KCkpKSkpOmIoYykuY29udGVudHMoKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcyYmMSE9PXRoaXMubm9kZVR5cGUmJmMucmVtb3ZlQ2hpbGQodGhpcyl9KX07YS5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGU9e2luaXQ6ZnVuY3Rpb24oayxtLHEscixzKXt2YXIgdCx1LHY9YihrKSx3PWgobSgpKXx8e30seD1uKG0sXCJmb3JlYWNoXCIpLHk9e307cChrLHgubmFtZSksYi5leHRlbmQoITAseSxhLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZSksdy5vcHRpb25zJiZ5Lm9wdGlvbnMmJihhLnV0aWxzLmV4dGVuZCh5Lm9wdGlvbnMsdy5vcHRpb25zKSxkZWxldGUgdy5vcHRpb25zKSxhLnV0aWxzLmV4dGVuZCh5LHcpLHkuY29ubmVjdENsYXNzJiYoYS5pc09ic2VydmFibGUoeS5hbGxvd0Ryb3ApfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB5LmFsbG93RHJvcCk/YS5jb21wdXRlZCh7cmVhZDpmdW5jdGlvbigpe3ZhciBiPWgoeS5hbGxvd0Ryb3ApLGM9XCJmdW5jdGlvblwiPT10eXBlb2YgYj9iLmNhbGwodGhpcyx4LmZvcmVhY2gpOmI7YS51dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3Moayx5LmNvbm5lY3RDbGFzcyxjKX0sZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOmt9LHRoaXMpOmEudXRpbHMudG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGsseS5jb25uZWN0Q2xhc3MseS5hbGxvd0Ryb3ApLGEuYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLmluaXQoayxmdW5jdGlvbigpe3JldHVybiB4fSxxLHIscyksdD15Lm9wdGlvbnMuc3RhcnQsdT15Lm9wdGlvbnMudXBkYXRlLHkub3B0aW9ucy5oZWxwZXJ8fCh5Lm9wdGlvbnMuaGVscGVyPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGMuaXMoXCJ0clwiKSYmYy5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oKXtiKHRoaXMpLndpZHRoKGIodGhpcykud2lkdGgoKSl9KSxjfSk7dmFyIHo9c2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBtLG49eS5vcHRpb25zLnJlY2VpdmU7di5zb3J0YWJsZShhLnV0aWxzLmV4dGVuZCh5Lm9wdGlvbnMse3N0YXJ0OmZ1bmN0aW9uKGIsYyl7dmFyIGU9Yy5pdGVtWzBdO2ooZSxkLGEudXRpbHMuYXJyYXlJbmRleE9mKGMuaXRlbS5wYXJlbnQoKS5jaGlsZHJlbigpLGUpKSxjLml0ZW0uZmluZChcImlucHV0OmZvY3VzXCIpLmNoYW5nZSgpLHQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxyZWNlaXZlOmZ1bmN0aW9uKGEsYil7XCJmdW5jdGlvblwiPT10eXBlb2YgbiYmbi5jYWxsKHRoaXMsYSxiKSxtPWkoYi5pdGVtWzBdLGcpLG0mJihtLmNsb25lJiYobT1tLmNsb25lKCkpLHkuZHJhZ2dlZCYmKG09eS5kcmFnZ2VkLmNhbGwodGhpcyxtLGEsYil8fG0pKX0sdXBkYXRlOmZ1bmN0aW9uKGcsayl7dmFyIG4scCxxLHIscyx0PWsuaXRlbVswXSx2PWsuaXRlbS5wYXJlbnQoKVswXSx3PWkodCxjKXx8bTtpZih3fHxiKHQpLnJlbW92ZSgpLG09bnVsbCx3JiZ0aGlzPT09dnx8IWwmJmIuY29udGFpbnModGhpcyx2KSl7aWYobj1pKHQsZikscT1pKHQsZCkscD1pKHQucGFyZW50Tm9kZSxlKSxyPWEudXRpbHMuYXJyYXlJbmRleE9mKGsuaXRlbS5wYXJlbnQoKS5jaGlsZHJlbigpLHQpLHguaW5jbHVkZURlc3Ryb3llZHx8KHE9byhxLG4pLHI9byhyLHApKSwoeS5iZWZvcmVNb3ZlfHx5LmFmdGVyTW92ZSkmJihzPXtpdGVtOncsc291cmNlUGFyZW50Om4sc291cmNlUGFyZW50Tm9kZTpuJiZrLnNlbmRlcnx8dC5wYXJlbnROb2RlLHNvdXJjZUluZGV4OnEsdGFyZ2V0UGFyZW50OnAsdGFyZ2V0SW5kZXg6cixjYW5jZWxEcm9wOiExfSx5LmJlZm9yZU1vdmUmJnkuYmVmb3JlTW92ZS5jYWxsKHRoaXMscyxnLGspKSxuP2Iobj09PXA/dGhpczprLnNlbmRlcnx8dGhpcykuc29ydGFibGUoXCJjYW5jZWxcIik6Yih0KS5yZW1vdmUoKSxzJiZzLmNhbmNlbERyb3ApcmV0dXJuO2lmKHkuaGFzT3duUHJvcGVydHkoXCJzdHJhdGVneU1vdmVcIikmJnkuc3RyYXRlZ3lNb3ZlIT09ITEpe2lmKHI+PTApaWYobilpZihuIT09cCluLnNwbGljZShxLDEpLHAuc3BsaWNlKHIsMCx3KSxqKHQsYyxudWxsKSxrLml0ZW0ucmVtb3ZlKCk7ZWxzZXt2YXIgej1oKG4pO24udmFsdWVXaWxsTXV0YXRlJiZuLnZhbHVlV2lsbE11dGF0ZSgpLHouc3BsaWNlKHEsMSksei5zcGxpY2UociwwLHcpLG4udmFsdWVIYXNNdXRhdGVkJiZuLnZhbHVlSGFzTXV0YXRlZCgpfWVsc2UgcC5zcGxpY2UociwwLHcpLGoodCxjLG51bGwpLGsuaXRlbS5yZW1vdmUoKX1lbHNlIHI+PTAmJihuJiYobi5zcGxpY2UocSwxKSxhLnByb2Nlc3NBbGxEZWZlcnJlZEJpbmRpbmdVcGRhdGVzJiZhLnByb2Nlc3NBbGxEZWZlcnJlZEJpbmRpbmdVcGRhdGVzKCksYS5vcHRpb25zJiZhLm9wdGlvbnMuZGVmZXJVcGRhdGVzJiZhLnRhc2tzLnJ1bkVhcmx5KCkpLHAuc3BsaWNlKHIsMCx3KSksaih0LGMsbnVsbCk7YS5wcm9jZXNzQWxsRGVmZXJyZWRCaW5kaW5nVXBkYXRlcyYmYS5wcm9jZXNzQWxsRGVmZXJyZWRCaW5kaW5nVXBkYXRlcygpLHkuYWZ0ZXJNb3ZlJiZ5LmFmdGVyTW92ZS5jYWxsKHRoaXMscyxnLGspfXUmJnUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjb25uZWN0V2l0aDp5LmNvbm5lY3RDbGFzcz9cIi5cIit5LmNvbm5lY3RDbGFzczohMX0pKSx2b2lkIDAhPT15LmlzRW5hYmxlZCYmYS5jb21wdXRlZCh7cmVhZDpmdW5jdGlvbigpe3Yuc29ydGFibGUoaCh5LmlzRW5hYmxlZCk/XCJlbmFibGVcIjpcImRpc2FibGVcIil9LGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDprfSl9LDApO3JldHVybiBhLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soayxmdW5jdGlvbigpeyh2LmRhdGEoXCJ1aS1zb3J0YWJsZVwiKXx8di5kYXRhKFwic29ydGFibGVcIikpJiZ2LnNvcnRhYmxlKFwiZGVzdHJveVwiKSxhLnV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcyhrLHkuY29ubmVjdENsYXNzLCExKSxjbGVhclRpbWVvdXQoeil9KSx7Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fSx1cGRhdGU6ZnVuY3Rpb24oYixjLGQsZixnKXt2YXIgaD1uKGMsXCJmb3JlYWNoXCIpO2ooYixlLGguZm9yZWFjaCksYS5iaW5kaW5nSGFuZGxlcnMudGVtcGxhdGUudXBkYXRlKGIsZnVuY3Rpb24oKXtyZXR1cm4gaH0sZCxmLGcpfSxjb25uZWN0Q2xhc3M6XCJrb19jb250YWluZXJcIixhbGxvd0Ryb3A6ITAsYWZ0ZXJNb3ZlOm51bGwsYmVmb3JlTW92ZTpudWxsLG9wdGlvbnM6e319LGEuYmluZGluZ0hhbmRsZXJzLmRyYWdnYWJsZT17aW5pdDpmdW5jdGlvbihjLGQsZSxmLGkpe3ZhciBrPWgoZCgpKXx8e30sbD1rLm9wdGlvbnN8fHt9LG09YS51dGlscy5leHRlbmQoe30sYS5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLm9wdGlvbnMpLG89bihkLFwiZGF0YVwiKSxwPWsuY29ubmVjdENsYXNzfHxhLmJpbmRpbmdIYW5kbGVycy5kcmFnZ2FibGUuY29ubmVjdENsYXNzLHE9dm9pZCAwIT09ay5pc0VuYWJsZWQ/ay5pc0VuYWJsZWQ6YS5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLmlzRW5hYmxlZDtyZXR1cm4gaz1cImRhdGFcImluIGs/ay5kYXRhOmssaihjLGcsayksYS51dGlscy5leHRlbmQobSxsKSxtLmNvbm5lY3RUb1NvcnRhYmxlPXA/XCIuXCIrcDohMSxiKGMpLmRyYWdnYWJsZShtKSx2b2lkIDAhPT1xJiZhLmNvbXB1dGVkKHtyZWFkOmZ1bmN0aW9uKCl7YihjKS5kcmFnZ2FibGUoaChxKT9cImVuYWJsZVwiOlwiZGlzYWJsZVwiKX0sZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOmN9KSxhLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soYyxmdW5jdGlvbigpe2IoYykuZHJhZ2dhYmxlKFwiZGVzdHJveVwiKX0pLGEuYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLmluaXQoYyxmdW5jdGlvbigpe3JldHVybiBvfSxlLGYsaSl9LHVwZGF0ZTpmdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPW4oYyxcImRhdGFcIik7cmV0dXJuIGEuYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLnVwZGF0ZShiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9LGQsZSxmKX0sY29ubmVjdENsYXNzOmEuYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlLmNvbm5lY3RDbGFzcyxvcHRpb25zOntoZWxwZXI6XCJjbG9uZVwifX19KTsiLCIvLyBLbm9ja291dCBVbmRvTWFuYWdlciB2MC4yIHwgKGMpIDIwMTUgU3RlZmFubyBCYWduYXJhXG4vLyBMaWNlbnNlOiBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UpIFxuLy8gcmVxdWlyZXMgXCJrby53YXRjaFwiIG1ldGhvZCBmcm9tIGtub2Nrb3V0LnJlYWN0b3JcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAvLyBNb2R1bGUgc3lzdGVtcyBtYWdpYyBkYW5jZS5cbiAgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgIC8vIENvbW1vbkpTIG9yIE5vZGU6IGhhcmQtY29kZWQgZGVwZW5kZW5jeSBvbiBcImtub2Nrb3V0XCJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCksIHJlcXVpcmUoXCIuLy4uL2tub2Nrb3V0anMtcmVhY3Rvci9zcmMva25vY2tvdXQucmVhY3Rvci5qc1wiKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZVtcImFtZFwiXSkge1xuICAgIC8vIEFNRCBhbm9ueW1vdXMgbW9kdWxlIHdpdGggaGFyZC1jb2RlZCBkZXBlbmRlbmN5IG9uIFwia25vY2tvdXRcIlxuICAgIGRlZmluZShbXCJrbm9ja291dFwiLCBcImtub2Nrb3V0anMtcmVhY3RvclwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIDxzY3JpcHQ+IHRhZzogdXNlIHRoZSBnbG9iYWwgYGtvYCBvYmplY3RcbiAgICBmYWN0b3J5KGtvLCBrby53YXRjaCk7XG4gIH1cbn0oZnVuY3Rpb24gKGtvLCByZWFjdG9yKSB7IFxuXG4gIC8vLyA8c3VtbWFyeT5cbiAgLy8vICAgICBUcmFjayBsYXN0IFwibGV2ZWxzXCIgY2hhbmdlcyB3aXRoaW4gdGhlIGNoYWluZWQgb2JzZXJ2YWJsZSBkb3duIHRvIGFueSBnaXZlbiBsZXZlbCBhbmRcbiAgLy8vICAgICBzdXBwb3J0cyB1bmRvaW5nL3JlZG9pbmcgdGhlIGNoYW5nZXMuXG4gIC8vLyA8L3N1bW1hcnk+XG4gIC8vLyA8cGFyYW0gbmFtZT1cIm9wdGlvbnNcIiB0eXBlPVwib2JqZWN0XCI+XG4gIC8vLyAgICAgeyBsZXZlbHM6IDIgfSAtPiBSZW1lbWJlciBvbmx5IGxhc3QgXCJsZXZlbHNcIiBjaGFuZ2VzPGJyLz5cbiAgLy8vICAgICB7IHVuZG9MYWJlbDogXCJVbmRvIGl0ICgjQ09VTlQpIVwiIH0gLT4gRGVmaW5lIGEgbGFiZWwgZm9yIHRoZSB1bmRvIGNvbW1hbmQuIFwiI0NPVU5UI1wiIHNlcXVlbmNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgc3RhY2sgbGVuZ3RoLjxici8+XG4gIC8vLyAgICAgeyByZWRvTGFiZWw6IFwiUmVkbyBpdCAoI0NPVU5UKSFcIiB9IC0+IERlZmluZSBhIGxhYmVsIGZvciB0aGUgcmVkbyBjb21tYW5kLiBcIiNDT1VOVCNcIiBzZXF1ZW5jZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHN0YWNrIGxlbmd0aC48YnIvPlxuICAvLy8gPC9wYXJhbT5cbiAgdmFyIHVuZG9NYW5hZ2VyID0gZnVuY3Rpb24gKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHVuZG9TdGFjayA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICAgIHZhciByZWRvU3RhY2sgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB2YXIgbGFzdFB1c2hlZFN0YWNrO1xuICAgIHZhciBTVEFURV9ET0lORyA9IDA7XG4gICAgdmFyIFNUQVRFX1VORE9JTkcgPSAxO1xuICAgIHZhciBTVEFURV9SRURPSU5HID0gMjtcbiAgICB2YXIgc3RhdGUgPSBTVEFURV9ET0lORztcblxuICAgIHZhciBNT0RFX05PUk1BTCA9IDA7IC8vIGFkZCB0byBzdGFjayBldmVyeSBjaGFuZ2VcbiAgICB2YXIgTU9ERV9JR05PUkUgPSAxOyAvLyBkbyBub3QgYWRkIGFueXRoaW5nIHRvIHRoZSBzdGFja1xuICAgIHZhciBNT0RFX09OQ0UgPSAyOyAvLyBvbmx5IG9uZSBzZXF1ZW50aWFsIGNoYW5nZSBmb3IgZWFjaCBwcm9wZXJ0eSBpcyBhZGRlZCB0byB0aGUgc3RhY2tcbiAgICB2YXIgTU9ERV9NRVJHRSA9IDM7IC8vIG1lcmdlIG5leHQgY2hhbmdlIHdpdGggdGhlIGxhc3Qgb25lXG4gICAgdmFyIG1vZGUgPSBNT0RFX05PUk1BTDtcblxuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGxldmVsczogMTAwLFxuICAgICAgdW5kb0xhYmVsOiBcInVuZG8gKCNDT1VOVCMpXCIsXG4gICAgICByZWRvTGFiZWw6IFwicmVkbyAoI0NPVU5UIylcIlxuICAgIH07XG4gICAgXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0ga28udXRpbHMuZXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cbiAgXG4gICAgdmFyIF9wdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgLy8gZHVyYW50ZSBVTkRPL1JFRE8gbGF2b3JpYW1vIHNlbXByZSBpbiBub3JtYWxlXG4gICAgICBpZiAoc3RhdGUgPT0gU1RBVEVfVU5ET0lORykge1xuICAgICAgICBfcHVzaEludChhY3Rpb24sIHJlZG9TdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09IFNUQVRFX1JFRE9JTkcpIHtcbiAgICAgICAgX3B1c2hJbnQoYWN0aW9uLCB1bmRvU3RhY2spO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBTVEFURV9ET0lORykge1xuICAgICAgICBfcHVzaEludChhY3Rpb24sIHVuZG9TdGFjayk7XG4gICAgICAgIHJlZG9TdGFjay5yZW1vdmVBbGwoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHZhciBfdHJ5TWVyZ2UgPSBmdW5jdGlvbiAocHJldiwgbmV3QWN0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHByZXYubWVyZ2VkQWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcHJldi5tZXJnZWRBY3Rpb24obmV3QWN0aW9uKTtcbiAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIF9wdXNoSW50ID0gZnVuY3Rpb24gKGFjdGlvbiwgbXlTdGFjaykge1xuICAgICAgLyogZ2VzdGlvbmUgZGVsIG1lcmdlIGRpIGF6aW9uaTogc2UgbCd1bHRpbWEgYXppb25lIG5lbGxvIHN0YWNrIGhhIHVuIG1ldG9kbyBcIm1lcmdlZEFjdGlvblwiXG4gICAgICAgICBwcm92aWFtbyBhZCBpbnZvY2FybG8gZSBzZSBjaSByZXN0aXR1aXNjZSB1bmEgZnVuemlvbmUgbGEgdXNpYW1vIGFsIHBvc3RvIGRpIGVudHJhbWJlICovXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlVSXCIsIFwiX3B1c2hJbnRcIiwgbXlTdGFjaygpLmxlbmd0aCA+IDAgPyB0eXBlb2YgbXlTdGFjaygpW215U3RhY2soKS5sZW5ndGggLSAxXS5tZXJnZWRBY3Rpb24gOiBcIkVNUFRZXCIpO1xuICAgICAgaWYgKG15U3RhY2soKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBtZXJnZWQgPSBfdHJ5TWVyZ2UobXlTdGFjaygpW215U3RhY2soKS5sZW5ndGggLSAxXSwgYWN0aW9uKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJVUlwiLCBcIl9wdXNoSW50Lm1lcmdlZFwiLCBtZXJnZWQsIFwiTVZcIiwgdHlwZW9mIGFjdGlvbi5tZXJnZWFibGVNb3ZlLCBcIk1BXCIsIHR5cGVvZiBhY3Rpb24ubWVyZ2VhYmxlQWN0aW9uLCBcIk1NXCIsIHR5cGVvZiBhY3Rpb24ubWVyZ2VNZSk7XG4gICAgICAgIGlmIChtZXJnZWQgIT09IG51bGwpIHtcbiAgICAgICAgICBteVN0YWNrKClbbXlTdGFjaygpLmxlbmd0aCAtIDFdID0gbWVyZ2VkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG15U3RhY2soKS5sZW5ndGggPj0gb3B0aW9ucy5sZXZlbHMpIG15U3RhY2suc2hpZnQoKTtcbiAgICAgIGxhc3RQdXNoZWRTdGFjayA9IG15U3RhY2s7XG4gICAgICBteVN0YWNrLnB1c2goYWN0aW9uKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBfeGRvQ29tbWFuZCA9IGZ1bmN0aW9uKGxhYmVsLCB3b3JrU3RhdGUsIHN0YWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShsYWJlbCkucmVwbGFjZSgvI0NPVU5UIy8sIHN0YWNrKCkubGVuZ3RoKTtcbiAgICAgICAgfSksXG4gICAgICAgIGVuYWJsZWQ6IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdGFjaygpLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgfSksXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICBzdGF0ZSA9IHdvcmtTdGF0ZTtcbiAgICAgICAgICAgIHZhciBvbGRNb2RlID0gbW9kZTtcbiAgICAgICAgICAgIG1vZGUgPSBNT0RFX01FUkdFO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJYRE9cIiwgXCJiZWZvcmVcIiwgbGFiZWwpO1xuICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlhET1wiLCBcImFmdGVyXCIsIGxhYmVsKTtcbiAgICAgICAgICAgIF9yZW1vdmVNZXJnZWRBY3Rpb24obGFzdFB1c2hlZFN0YWNrKTtcbiAgICAgICAgICAgIG1vZGUgPSBvbGRNb2RlO1xuICAgICAgICAgICAgc3RhdGUgPSBwcmV2U3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX3JlbW92ZU1lcmdlZEFjdGlvbiA9IGZ1bmN0aW9uKG15U3RhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgbXlTdGFjayA9PSAndW5kZWZpbmVkJykgdGhyb3cgXCJVbmV4cGVjdGVkIG9wZXJhdGlvbjogc3RhY2sgY2xlYW5lciBjYWxsZWQgd2l0aCB1bmRlZmluZWQgc3RhY2tcIjtcbiAgICAgIFxuICAgICAgaWYgKG15U3RhY2soKS5sZW5ndGggPiAwICYmIHR5cGVvZiBteVN0YWNrKClbbXlTdGFjaygpLmxlbmd0aCAtIDFdLm1lcmdlZEFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJSZW1vdmluZyBtZXJnZWRBY3Rpb24gZnJvbSBzdGFja1wiKTtcbiAgICAgICAgZGVsZXRlIG15U3RhY2soKVtteVN0YWNrKCkubGVuZ3RoIC0gMV0ubWVyZ2VkQWN0aW9uO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX2NvbWJpbmVkRnVuY3Rpb24gPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kKSB7XG4gICAgICB2YXIgcmVzID0gKGZ1bmN0aW9uKGYxLCBmMikge1xuICAgICAgICBmMSgpO1xuICAgICAgICBmMigpO1xuICAgICAgfSkuYmluZCh1bmRlZmluZWQsIGZpcnN0LCBzZWNvbmQpO1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdC5tZXJnZWRBY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlcy5tZXJnZWRBY3Rpb24gPSBmaXJzdC5tZXJnZWRBY3Rpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICB2YXIgZXhlY3V0ZVVuZG9BY3Rpb24gPSBmdW5jdGlvbihjaGlsZCwgdmFsdWUsIGl0ZW0pIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiZXhlY3V0ZVVuZG9BY3Rpb25cIiwgY2hpbGQsIHZhbHVlLCBpdGVtKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT0gJ2RlbGV0ZWQnKSB7XG4gICAgICAgICAgY2hpbGQuc3BsaWNlKGl0ZW0uaW5kZXgsIDAsIGl0ZW0udmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uc3RhdHVzID09ICdhZGRlZCcpIHtcbiAgICAgICAgICBjaGlsZC5zcGxpY2UoaXRlbS5pbmRleCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJVbnN1cHByb3RlZCBpdGVtLnN0YXR1czogXCIraXRlbS5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBjb25kaXRpb246IG5vIGl0ZW0gYW5kIG5vIGNoaWxkLm9sZFZhbHVlcyFcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1ha2VVbmRvQWN0aW9uRGVmYXVsdCA9IGZ1bmN0aW9uKHVuZG9GdW5jLCBwYXJlbnRzLCBjaGlsZCwgb2xkVmFsLCBpdGVtKSB7XG4gICAgICByZXR1cm4gdW5kb0Z1bmMuYmluZCh1bmRlZmluZWQsIGNoaWxkLCBvbGRWYWwsIGl0ZW0pO1xuICAgIH07XG5cbiAgICB2YXIgbWFrZVVuZG9BY3Rpb24gPSBtYWtlVW5kb0FjdGlvbkRlZmF1bHQ7XG5cbiAgICB2YXIgY2hhbmdlUHVzaGVyID0gZnVuY3Rpb24ocGFyZW50cywgY2hpbGQsIGl0ZW0pIHtcbiAgICAgIHZhciBvbGRWYWwgPSB0eXBlb2YgY2hpbGQub2xkVmFsdWVzICE9ICd1bmRlZmluZWQnID8gY2hpbGQub2xkVmFsdWVzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGFjdCA9IG1ha2VVbmRvQWN0aW9uKGV4ZWN1dGVVbmRvQWN0aW9uLCBwYXJlbnRzLCBjaGlsZCwgb2xkVmFsLCBpdGVtKTtcblxuICAgICAgaWYgKG1vZGUgPT0gTU9ERV9JR05PUkUpIHJldHVybjtcblxuICAgICAgaWYgKG1vZGUgPT0gTU9ERV9NRVJHRSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVSXCIsIFwibWVyZ2Vtb2RlXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBhY3QubWVyZ2VkQWN0aW9uID0gZnVuY3Rpb24obmV3QWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0FjdGlvbi5tZXJnZU1lICE9PSAndW5kZWZpbmVkJyAmJiBuZXdBY3Rpb24ubWVyZ2VNZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbWJpbmVkRnVuY3Rpb24obmV3QWN0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGFjdC5tZXJnZU1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLm9sZFZhbHVlcyAmJiBtb2RlID09IE1PREVfT05DRSkge1xuICAgICAgICAgICAgYWN0Lm1lcmdlZEFjdGlvbiA9IGZ1bmN0aW9uKG9sZENoaWxkLCBvbGRJdGVtLCBuZXdBY3Rpb24pIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdBY3Rpb24ubWVyZ2VhYmxlQWN0aW9uID09ICdvYmplY3QnICYmIG9sZENoaWxkID09IG5ld0FjdGlvbi5tZXJnZWFibGVBY3Rpb24uY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVSXCIsIFwiaWdub3JlIHVwZGF0ZSBmb3IgcHJvcGVydHkgaW4gTU9ERV9PTkNFXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LmJpbmQoYWN0LCBjaGlsZCwgaXRlbSk7XG4gICAgICAgICAgICBhY3QubWVyZ2VhYmxlQWN0aW9uID0geyBjaGlsZDogY2hpbGQsIGl0ZW06IGl0ZW0gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJVUlwiLCBcIml0ZW0uc3RhdHVzXCIsIGl0ZW0uc3RhdHVzKTtcbiAgICAgICAgICAvLyBcIml0ZW1cIiBpcyB2YWx1ZWQgd2hlbiBhbiBpdGVtIGlzIGFkZGVkL3JlbW92ZWQvcmV0ZWluZWQgaW4gYW4gYXJyYXlcbiAgICAgICAgICAvLyBzb21ldGltZXMgS08gZGV0ZWN0IFwibW92ZXNcIiBhbmQgYWRkIGEgXCJtb3ZlZFwiIHByb3BlcnR5IHdpdGggdGhlIGluZGV4IGJ1dFxuICAgICAgICAgIC8vIHRoaXMgZG9lc24ndCBoYXBwZW4gZm9yIGV4YW1wbGUgdXNpbmcga25vY2tvdXQtc29ydGFibGUgb3Igd2hlbiBtb3Zpbmcgb2JqZWN0c1xuICAgICAgICAgIC8vIGJldHdlZW4gYXJyYXlzLlxuICAgICAgICAgIC8vIFNvIHRoaXMgZW5kcyB1cCBoYW5kbGluZyB0aGlzIHdpdGggXCJtZXJnZWFibGVNb3ZlXCIgYW5kIFwibWVyZ2VkQWN0aW9uXCI6IFxuICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uc3RhdHVzID09ICdkZWxldGVkJykge1xuICAgICAgICAgICAgLy8gVE9ETyBzZSBzb25vIGluIE1PREUgPSBNRVJHRSBkZXZvIG1ldHRlZXIgdW5hIGZ1bnppb25lIGRpIG1lcmdlIGNoZSBhY2NldHRhIHR1dHRvLlxuICAgICAgICAgICAgLy8gYWx0cmltZW50aSBsYXNjaW8gcXVlc3RhLlxuICAgICAgICAgICAgYWN0Lm1lcmdlZEFjdGlvbiA9IGZ1bmN0aW9uKG9sZENoaWxkLCBvbGRJdGVtLCBuZXdBY3Rpb24pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJVUlwiLCBcImFjdC5tZXJnZWRBY3Rpb25cIiwgdHlwZW9mIG5ld0FjdGlvbi5tZXJnZWFibGVNb3ZlKTtcbiAgICAgICAgICAgICAgLy8gYSBkZWxldGVkIGFjdGlvbiBpcyBhYmxlIHRvIG1lcmdlIHdpdGggYSBhZGRlZCBhY3Rpb24gaWYgdGhleSBhcHBseSB0byB0aGUgc2FtZVxuICAgICAgICAgICAgICAvLyBvYmplY3QuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3QWN0aW9uLm1lcmdlYWJsZU1vdmUgPT0gJ29iamVjdCcgJiYgb2xkSXRlbS52YWx1ZSA9PSBuZXdBY3Rpb24ubWVyZ2VhYmxlTW92ZS5pdGVtLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIEkgc2ltcGx5IHJldHVybiBhIHNpbmdsZSBhY3Rpb24gcnVubmluZyBib3RoIGFjdGlvbnMgaW4gc2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3YXkgdGhlIFwidW5kb1wiIHdpbGwgbmVlZCB0byB1bmRvIG9ubHkgb25jZSBmb3IgYSBcIm1vdmVcIiBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21iaW5lZEZ1bmN0aW9uKG5ld0FjdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVUlwiLCBcIm5vdCBtZXJnZWFibGVcIiwgdHlwZW9mIG5ld0FjdGlvbi5tZXJnZWFibGVNb3ZlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfS5iaW5kKGFjdCwgY2hpbGQsIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLnN0YXR1cyA9PSAnYWRkZWQnKSB7XG4gICAgICAgICAgICAvLyBhZGQgYSBtZXJnZWFibGVNb3ZlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBuZXh0IGFjdGlvbiBcIm1lcmdlZEFjdGlvblwiIHRvIHNlZSBpZiB0aGlzIGFjdGlvblxuICAgICAgICAgICAgLy8gY2FuIGJlIG1lcmdlZC5cbiAgICAgICAgICAgIGFjdC5tZXJnZWFibGVNb3ZlID0geyBjaGlsZDogY2hpbGQsIGl0ZW06IGl0ZW0gfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYWN0ICE9PSAndW5kZWZpbmVkJykgX3B1c2goYWN0KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWN0b3JPcHRpb25zID0geyBkZXB0aDogLTEsIG9sZFZhbHVlczogMSwgbXV0YWJsZTogdHJ1ZSwgLyogdGFnUGFyZW50c1dpdGhOYW1lOiB0cnVlICovIHRhZ0ZpZWxkczogdHJ1ZSB9O1xuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICB2YXIgcmVhY3QgPSB0eXBlb2YgcmVhY3RvciA9PSAnZnVuY3Rpb24nID8gcmVhY3RvciA6IGtvLndhdGNoO1xuICAgIHZhciByZXMgPSByZWFjdChtb2RlbCwgcmVhY3Rvck9wdGlvbnMsIGNoYW5nZVB1c2hlciwgY29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHVzaDogX3B1c2gsIFxuICAgICAgdW5kb0NvbW1hbmQ6IF94ZG9Db21tYW5kKG9wdGlvbnMudW5kb0xhYmVsLCBTVEFURV9VTkRPSU5HLCB1bmRvU3RhY2spLFxuICAgICAgcmVkb0NvbW1hbmQ6IF94ZG9Db21tYW5kKG9wdGlvbnMucmVkb0xhYmVsLCBTVEFURV9SRURPSU5HLCByZWRvU3RhY2spLFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkgeyB1bmRvU3RhY2sucmVtb3ZlQWxsKCk7IHJlZG9TdGFjay5yZW1vdmVBbGwoKTsgfSxcbiAgICAgIC8vIHNldE1vZGU6IGZ1bmN0aW9uKG5ld01vZGUpIHsgbW9kZSA9IG5ld01vZGU7IF9yZW1vdmVNZXJnZWRBY3Rpb24odW5kb1N0YWNrKTsgfSxcbiAgICAgIHNldE1vZGVPbmNlOiBmdW5jdGlvbigpIHsgbW9kZSA9IE1PREVfT05DRTsgX3JlbW92ZU1lcmdlZEFjdGlvbih1bmRvU3RhY2spOyB9LFxuICAgICAgc2V0TW9kZU1lcmdlOiBmdW5jdGlvbigpIHsgbW9kZSA9IE1PREVfTUVSR0U7IF9yZW1vdmVNZXJnZWRBY3Rpb24odW5kb1N0YWNrKTsgfSxcbiAgICAgIHNldE1vZGVOb3JtYWw6IGZ1bmN0aW9uKCkgeyBtb2RlID0gTU9ERV9OT1JNQUw7IF9yZW1vdmVNZXJnZWRBY3Rpb24odW5kb1N0YWNrKTsgfSxcbiAgICAgIHNldE1vZGVJZ25vcmU6IGZ1bmN0aW9uKCkgeyBtb2RlID0gTU9ERV9JR05PUkU7IF9yZW1vdmVNZXJnZWRBY3Rpb24odW5kb1N0YWNrKTsgfSxcbiAgICAgIHNldFVuZG9BY3Rpb25NYWtlcjogZnVuY3Rpb24obWFrZXIpIHsgbWFrZVVuZG9BY3Rpb24gPSBtYWtlcjsgfSxcbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkgeyAvKiBrby51bndhdGNoKG1vZGVsLCByZWFjdG9yT3B0aW9ucywgY2hhbmdlUHVzaGVyKTsgKi8gcmVzLmRpc3Bvc2UoKTsgfVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIHVuZG9NYW5hZ2VyO1xuICBcbn0pKTsiLCIvLyBLbm9ja291dCBGYXN0IE1hcHBpbmcgdjAuMVxuLy8gTGljZW5zZTogTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdC8vIE1vZHVsZSBzeXN0ZW1zIG1hZ2ljIGRhbmNlLlxuXG5cdGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KUyBvciBOb2RlOiBoYXJkLWNvZGVkIGRlcGVuZGVuY3kgb24gXCJrbm9ja291dFwiXG5cdFx0ZmFjdG9yeSgodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKSwgZXhwb3J0cyk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZVtcImFtZFwiXSkge1xuXHRcdC8vIEFNRCBhbm9ueW1vdXMgbW9kdWxlIHdpdGggaGFyZC1jb2RlZCBkZXBlbmRlbmN5IG9uIFwia25vY2tvdXRcIlxuXHRcdGRlZmluZShbXCJrbm9ja291dFwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIDxzY3JpcHQ+IHRhZzogdXNlIHRoZSBnbG9iYWwgYGtvYCBvYmplY3QsIGF0dGFjaGluZyBhIGB3cmFwYCBwcm9wZXJ0eVxuXHRcdGZhY3Rvcnkoa28sIGtvLndyYXAgPSB7fSk7XG5cdH1cbn0oZnVuY3Rpb24gKGtvLCBleHBvcnRzKSB7XG4gICAgXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBtaW1pY3Mga28ubWFwcGluZ1xuICAgIGV4cG9ydHMuZnJvbUpTID0gZnVuY3Rpb24oanNPYmplY3QsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cylcbiAgICB7XG4gICAgICAgIHJlc2V0KCk7XG5cdHJldHVybiB3cmFwKGpzT2JqZWN0LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpO1xuICAgIH1cblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gdW53cmFwcyB0aGUgb3V0ZXIgZm9yIGFzc2lnbmluZyB0aGUgcmVzdWx0IHRvIGFuIG9ic2VydmFibGVcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L2lzc3Vlcy81MTdcbiAgICBleHBvcnRzLnVwZGF0ZUZyb21KUyA9IGZ1bmN0aW9uKG9ic2VydmFibGUsIGpzT2JqZWN0LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpXG4gICAge1xuICAgICAgICByZXNldCgpO1xuXHRyZXR1cm4gb2JzZXJ2YWJsZShrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHdyYXAoanNPYmplY3QsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cykpKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb25TdHJpbmcsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cykge1xuXHR2YXIgcGFyc2VkID0ga28udXRpbHMucGFyc2VKc29uKGpzb25TdHJpbmcpO1xuXHRhcmd1bWVudHNbMF0gPSBwYXJzZWQ7XG5cdHJldHVybiBleHBvcnRzLmZyb21KUy5hcHBseSh0aGlzLCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpO1xuICAgIH07XG4gICAgXG4gICAgZXhwb3J0cy50b0pTID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcblx0cmV0dXJuIHVud3JhcChvYnNlcnZhYmxlKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnRvSlNPTiA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG5cdHZhciBwbGFpbkphdmFTY3JpcHRPYmplY3QgPSBleHBvcnRzLnRvSlMob2JzZXJ2YWJsZSk7XG5cdHJldHVybiBrby51dGlscy5zdHJpbmdpZnlKc29uKHBsYWluSmF2YVNjcmlwdE9iamVjdCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHR5cGVPZih2YWx1ZSkge1xuXHR2YXIgcyA9IHR5cGVvZiB2YWx1ZTtcblx0aWYgKHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgPT0gRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcyA9ICdkYXRlJztcblx0XHRlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgICAgICAgICAgICAgIHMgPSAnYXJyYXknO1xuICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRzID0gJ251bGwnO1xuICAgICAgICAgICAgfVxuXHR9XG5cdHJldHVybiBzO1xuICAgIH1cblxuICAgIC8vIHVud3JhcHBpbmdcbiAgICBmdW5jdGlvbiB1bndyYXBPYmplY3QobylcbiAgICB7XG5cdHZhciB0ID0ge307XG5cblx0Zm9yICh2YXIgayBpbiBvKVxuXHR7XG5cdCAgICB2YXIgdiA9IG9ba107XG5cblx0ICAgIGlmIChrby5pc0NvbXB1dGVkKHYpKVxuXHRcdGNvbnRpbnVlO1xuXG5cdCAgICB0W2tdID0gdW53cmFwKHYpO1xuXHR9XG5cblx0cmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW53cmFwQXJyYXkoYSlcbiAgICB7XG5cdHZhciByID0gW107XG5cblx0aWYgKCFhIHx8IGEubGVuZ3RoID09IDApXG5cdCAgICByZXR1cm4gcjtcblx0XG5cdGZvciAodmFyIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyArK2kpXG5cdCAgICByLnB1c2godW53cmFwKGFbaV0pKTtcblxuXHRyZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bndyYXAodilcbiAgICB7XG5cdHZhciBpc09ic2VydmFibGUgPSBrby5pc09ic2VydmFibGUodik7XG5cblx0aWYgKGlzT2JzZXJ2YWJsZSlcblx0e1xuXHQgICAgdmFyIHZhbCA9IHYoKTtcblxuXHQgICAgcmV0dXJuIHVud3JhcCh2YWwpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHQgICAgaWYgKHR5cGVPZih2KSA9PSBcImFycmF5XCIpXG5cdCAgICB7XG5cdFx0cmV0dXJuIHVud3JhcEFycmF5KHYpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZU9mKHYpID09IFwib2JqZWN0XCIpXG5cdCAgICB7XG5cdFx0cmV0dXJuIHVud3JhcE9iamVjdCh2KTtcblx0ICAgIH1cblx0ICAgIGVsc2Vcblx0ICAgIHtcblx0XHRyZXR1cm4gdjtcblx0ICAgIH1cblx0fVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0KClcbiAgICB7XG4gICAgICAgIHBhcmVudHMgPSBbe29iajogbnVsbCwgd3JhcHBlZDogbnVsbCwgbHZsOiBcIlwifV07XG4gICAgfSAgICBcbiAgICBcbiAgICAvLyB3cmFwcGluZ1xuXG4gICAgZnVuY3Rpb24gd3JhcE9iamVjdChvLCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpXG4gICAge1xuICAgICAgICAvLyBjaGVjayBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudHNbaV0ub2JqID09PSBvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudHNbaV0ud3JhcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cdHZhciB0ID0ge307XG5cblx0Zm9yICh2YXIgayBpbiBvKVxuXHR7XG5cdCAgICB2YXIgdiA9IG9ba107XG5cbiAgICAgICAgICAgIHBhcmVudHMucHVzaCh7b2JqOiBvLCB3cmFwcGVkOiB0LCBsdmw6IGN1cnJlbnRMdmwoKSArIFwiL1wiICsga30pO1xuXG5cdCAgICB0W2tdID0gd3JhcCh2LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpO1xuXG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuXHR9XG5cblx0aWYgKGNvbXB1dGVkRnVuY3Rpb25zICYmIGNvbXB1dGVkRnVuY3Rpb25zW2N1cnJlbnRMdmwoKV0pXG5cdCAgICB0ID0gY29tcHV0ZWRGdW5jdGlvbnNbY3VycmVudEx2bCgpXSh0KTtcblxuICAgICAgICBpZiAoaGFzRVM1UGx1Z2luKCkpXG4gICAgICAgICAgICBrby50cmFjayh0KTtcblxuXHRpZiAob2JzZXJ2YWJsZU9iamVjdHMpIHJldHVybiBrby5vYnNlcnZhYmxlKHQpO1xuXHRyZXR1cm4gdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwQXJyYXkoYSwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKVxuICAgIHtcblx0dmFyIHIgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcblxuXHRpZiAoIWEgfHwgYS5sZW5ndGggPT0gMClcblx0ICAgIHJldHVybiByO1xuXG5cdGZvciAodmFyIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyArK2kpXG5cdCAgICByLnB1c2god3JhcChhW2ldLCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpKTtcblxuXHRyZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyBhIHN0YWNrLCB1c2VkIGZvciB0d28gcHVycG9zZXM6XG4gICAgLy8gIC0gY2lyY3VsYXIgcmVmZXJlbmNlIGNoZWNraW5nXG4gICAgLy8gIC0gY29tcHV0ZWQgZnVuY3Rpb25zXG4gICAgdmFyIHBhcmVudHM7XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50THZsKClcbiAgICB7XG5cdHJldHVybiBwYXJlbnRzW3BhcmVudHMubGVuZ3RoLTFdLmx2bDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwKHYsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cylcbiAgICB7XG5cdGlmICh0eXBlT2YodikgPT0gXCJhcnJheVwiKVxuXHR7XG5cdCAgICByZXR1cm4gd3JhcEFycmF5KHYsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cyk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZU9mKHYpID09IFwib2JqZWN0XCIpXG5cdHtcblx0ICAgIHJldHVybiB3cmFwT2JqZWN0KHYsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cyk7XG5cdH1cblx0ZWxzZVxuXHR7XG4gICAgICAgICAgICBpZiAoIWhhc0VTNVBsdWdpbigpICYmIHR5cGVvZiB2ICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAge1xuXHQgICAgICAgIHZhciB0ID0ga28ub2JzZXJ2YWJsZSgpO1xuXHQgICAgICAgIHQodik7XG5cdCAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcblx0fVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0VTNVBsdWdpbigpXG4gICAge1xuICAgICAgICByZXR1cm4ga28udHJhY2sgIT0gbnVsbDtcbiAgICB9XG59KSk7XG4iLCIvLyBEZWVwIG9ic2VydmVyIHBsdWdpbiBmb3IgS25vY2tvdXQgaHR0cDovL2tub2Nrb3V0anMuY29tL1xyXG4vLyAoYykgWmlhZCBKZWVyb2J1cmtoYW5cclxuLy8gTGljZW5zZTogTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcclxuLy8gVmVyc2lvbiAxLjMuOFxyXG47IChmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgLy8gQ29tbW9uSlNcclxuICAgIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmYWN0b3J5KCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpKTtcclxuICAgICAgICAvLyBBTURcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFsna25vY2tvdXQnXSwgZmFjdG9yeSk7XHJcbiAgICAgICAgLy8gTm9ybWFsIHNjcmlwdCB0YWdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeSh3aW5kb3cua28pO1xyXG4gICAgfVxyXG59KGZ1bmN0aW9uIChrbykge1xyXG5rby5zdWJzY3JpYmFibGUuZm5bJ3dhdGNoJ10gPSBmdW5jdGlvbiAodGFyZ2V0T3JDYWxsYmFjaywgb3B0aW9ucywgZXZhbHVhdG9yQ2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyAgICAgVHJhY2sgYW5kIG1hbmFnZSBjaGFuZ2VzIHdpdGhpbiB0aGUgY2hhaW5lZCBvYnNlcnZhYmxlIGRvd24gdG8gYW55IGdpdmVuIGxldmVsLiBcclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0YXJnZXRPckNhbGxiYWNrXCI+XHJcbiAgICAvLy8gICAgICBUaGUgc3Vic2NyaXB0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzdWJzY3JpYmFibGVzIHRvIGJlIHdhdGNoZWQuXHJcbiAgICAvLy8gPC9wYXJhbT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9wdGlvbnNcIiB0eXBlPVwib2JqZWN0XCI+XHJcbiAgICAvLy8gICAgIGZhbHNlIC0+IERpc2FibGVzIHRyYWNraW5nIG9uIHRoZSBjaGFpbmVkIG9ic2VydmFibGUuXHJcbiAgICAvLy8gICAgIHsgZGVwdGg6IDIgfSAtPiBUcmFjayBhbGwgbmVzdGVkIHN1YnNjcmliYWJsZXMgZG93biB0byB0aGUgMm5kIGxldmVsKGRlZmF1bHQgaXMgMSkuPGJyLz5cclxuICAgIC8vLyAgICAgeyBkZXB0aDogLTEgfSAtPiBUcmFjayBhbGwgbmVzdGVkIHN1YnNjcmliYWJsZXMuPGJyLz5cclxuICAgIC8vLyAgICAgeyBoaWRlOiBbLi4uXSB9IC0+IFByb3BlcnR5IG9yIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gYmUgaWdub3JlZC48YnIvPlxyXG4gICAgLy8vICAgICB7IGhpZGVBcnJheXM6IHRydWUgfSAtPiBJZ25vcmUgYWxsIG5lc3RlZCBhcnJheXMuPGJyLz5cclxuICAgIC8vLyAgICAgeyBoaWRlV3JhcHBlZFZhbHVlczogdHJ1ZSB9IC0+IElnbm9yZSBvYnNlcnZhYmxlcyB3cmFwcGVkIHVuZGVyIHlldCBhbm90aGVyIHBhcmVudCBvYnNlcnZhYmxlLjxici8+XHJcbiAgICAvLy8gICAgIHsgbXV0YWJsZTogdHJ1ZSB9IC0+IER5bmFtaWNhbGx5IGFkYXB0IHRvIGNoYW5nZXMgbWFkZSB0byB0aGUgdGFyZ2V0IHN0cnVjdHVyZSB0aHJvdWdoIGFueSBzdWJzY3JpYmFibGUuPGJyLz5cclxuICAgIC8vLyAgICAgeyB3YXRjaGVkT25seTogdHJ1ZSB9IC0+IFdhdGNoIG9ubHkgc3Vic2NyaWJhYmxlcyB0YWdnZWQgd2l0aCAud2F0Y2goKS48YnIvPlxyXG4gICAgLy8vICAgICB7IGJlZm9yZVdhdGNoOiBmdW5jdGlvbihwYXJlbnRzLCBjaGlsZCkgey4uLn0gfSAtPiBGdW5jdGlvbiBjYWxsZWQgcHJpb3IgdG8gY3JlYXRpbmcgYSBzdWJzY3JpcHRpb24uIFJldHVybmluZyBmYWxzZSBhYm9ydHMgdGhlIG9wZXJhdGlvbiBhbmQgaWdub3JlcyBpdHMgY2hpbGRyZW4uPGJyLz5cclxuICAgIC8vLyAgICAgeyB3cmFwOiB0cnVlIH0gLT4gV3JhcCBhbGwgZmllbGRzIGludG8gb2JzZXJ2YWJsZXMuIFRoaXMgaGFwcGVucyBvbiB0aGUgZmx5IGZvciBuZXcgYXJyYXkgaXRlbXMob3IgY2hpbGQgb2JqZWN0cyB3aGVuIG11dGFibGUgaXMgc2V0IHRvIHRydWUpLjxici8+XHJcbiAgICAvLy8gICAgIHsgYmVmb3JlV3JhcDogZnVuY3Rpb24ocGFyZW50cywgZmllbGQsIHZhbHVlKSB7Li4ufSB9IC0+IEZ1bmN0aW9uIGNhbGxlZCBwcmlvciB0byB3cmFwcGluZyBhIHZhbHVlIGludG8gYW4gb2JzZXJ2YWJsZS4gUmV0dXJuaW5nIGZhbHNlIGxlYXZlcyBpdCBhcyBpdCBpcy48YnIvPlxyXG4gICAgLy8vICAgICB7IHRhZ0ZpZWxkczogdHJ1ZSB9IC0+IEFkZCB0aGUgcHJvcGVydHkgJ19maWVsZE5hbWUnIHVuZGVyIGVhY2ggcHJvcGVydHkgZm9yIHRleHR1YWwgaWRlbnRpZmljYXRpb24uPGJyLz5cclxuICAgIC8vLyAgICAgeyB0YWdGaWVsZHM6ICdwYXJlbnRzT25seScgfSAtPiBTYW1lIGFzIGFib3ZlIGV4Y2VwdCB0aGF0IGl0IGlzIGxpbWl0ZWQgdG8gcGFyZW50IHByb3BlcnRpZXMgb25seS48YnIvPlxyXG4gICAgLy8vICAgICB7IG9sZFZhbHVlczogMyB9IC0+IEtlZXAgdGhlIGxhc3QgdGhyZWUgdmFsdWVzIGZvciBlYWNoIHN1YnNjcmliYWJsZSB1bmRlciB0aGUgcHJvcGVydHkgJ29sZFZhbHVlcycuPGJyLz5cclxuICAgIC8vLyAgICAgeyBzZWFsOiB0cnVlIH0gLT4gUHJldmVudCBhbnkgc3Vic2VxdWVudCB3YXRjaGVyIGZyb20gd2F0Y2hpbmcgdGhlIHRhcmdldCBhZ2Fpbi48YnIvPlxyXG4gICAgLy8vICAgICB7IHVubG9vcDogdHJ1ZSB9IC0+IEF2b2lkIGNpcmN1bGFyIHBhdGhzIHRocm91Z2ggdGhlIHVzZSBvZiBhIGJyZWFkY3J1bWIgcHJvcGVydHkgJ193YXRjaGVyJyBzZXQgYXQgZWFjaCBub2RlIGxldmVsLjxici8+XHJcbiAgICAvLy8gPC9wYXJhbT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImV2YWx1YXRvckNhbGxiYWNrXCIgdHlwZT1cImZ1bmN0aW9uXCI+XHJcbiAgICAvLy8gICAgIFRoZSAgY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGR1cmluZyBjaGFuZ2VzLiBBbnkgcmV0dXJuIHZhbHVlIGlzIGFzc2lnbmVkIHRvIHRoZSBjaGFpbmVkIG9ic2VydmFibGUuXHJcbiAgICAvLy8gPC9wYXJhbT5cclxuXHJcbiAgICB2YXIgdGFyZ2V0VHlwZSA9IHR5cGVvZiB0YXJnZXRPckNhbGxiYWNrO1xyXG5cclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAnYm9vbGVhbicgfHwgdGFyZ2V0VHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBUdXJuIG9uIG9yIG9mZiB0aGUgd2F0Y2hlciBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgYWxvbmcgd2l0aCBhbnkgb2YgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgIGtvLndhdGNoKHRoaXMsIHsgZW5hYmxlZDogdGFyZ2V0T3JDYWxsYmFjayAhPT0gZmFsc2UgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdmdW5jdGlvbicgJiYgIWtvLmlzU3Vic2NyaWJhYmxlKHRhcmdldE9yQ2FsbGJhY2spKSB7XHJcbiAgICAgICAgLy8gVGFyZ2V0IHRoZSBjaGFpbmVkIHN1YnNjcmliYWJsZSBpdHNlbGYgaWYgbm8gdGFyZ2V0IHN1YnNjcmliYWJsZSBvciBvYmplY3Qgd2FzIHBhc3NlZC5cclxuICAgICAgICBrby53YXRjaCh0aGlzLCBvcHRpb25zIHx8IHt9LCB0YXJnZXRPckNhbGxiYWNrLCBjb250ZXh0IHx8IHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBrby53YXRjaCh0YXJnZXRPckNhbGxiYWNrLCBvcHRpb25zLCBldmFsdWF0b3JDYWxsYmFjaywgY29udGV4dCB8fCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmtvWyd3YXRjaCddID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgZXZhbHVhdG9yQ2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyAgICAgVHJhY2sgYW5kIG1hbmFnZSBjaGFuZ2VzIHdpdGhpbiBhIHNwZWNpZmljIHRhcmdldCBvYmplY3QgZG93biB0byBhbnkgZ2l2ZW4gbGV2ZWwuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwidGFyZ2V0XCI+XHJcbiAgICAvLy8gICAgIEFuIG9iamVjdCBvciBmdW5jdGlvbiBjb250YWluaW5nIHRoZSB0YXJnZXRlZCBzdWJzY3JpYmFibGUocykuXHJcbiAgICAvLy8gPC9wYXJhbT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9wdGlvbnNcIiB0eXBlPVwib2JqZWN0XCI+XHJcbiAgICAvLy8gICAgIHsgZGVwdGg6IDIgfSAtPiBUcmFjayBhbGwgbmVzdGVkIHN1YnNjcmliYWJsZXMgZG93biB0byB0aGUgMm5kIGxldmVsKGRlZmF1bHQgaXMgMSkuPGJyLz5cclxuICAgIC8vLyAgICAgeyBkZXB0aDogLTEgfSAtPiBUcmFjayBhbGwgbmVzdGVkIHN1YnNjcmliYWJsZXMuPGJyLz5cclxuICAgIC8vLyAgICAgeyBoaWRlOiBbLi4uXSB9IC0+IFByb3BlcnR5IG9yIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gYmUgaWdub3JlZC48YnIvPlxyXG4gICAgLy8vICAgICB7IGhpZGVBcnJheXM6IHRydWUgfSAtPiBJZ25vcmUgYWxsIG5lc3RlZCBhcnJheXMuPGJyLz5cclxuICAgIC8vLyAgICAgeyBoaWRlV3JhcHBlZFZhbHVlczogdHJ1ZSB9IC0+IElnbm9yZSBvYnNlcnZhYmxlcyB3cmFwcGVkIHVuZGVyIHlldCBhbm90aGVyIHBhcmVudCBvYnNlcnZhYmxlLjxici8+XHJcbiAgICAvLy8gICAgIHsgbXV0YWJsZTogdHJ1ZSB9IC0+IER5bmFtaWNhbGx5IGFkYXB0IHRvIGNoYW5nZXMgbWFkZSB0byB0aGUgdGFyZ2V0IHN0cnVjdHVyZSB0aHJvdWdoIGFueSBzdWJzY3JpYmFibGUuPGJyLz5cclxuICAgIC8vLyAgICAgeyB3YXRjaGVkT25seTogdHJ1ZSB9IC0+IFdhdGNoIG9ubHkgc3Vic2NyaWJhYmxlcyB0YWdnZWQgd2l0aCAud2F0Y2goKS48YnIvPlxyXG4gICAgLy8vICAgICB7IGJlZm9yZVdhdGNoOiBmdW5jdGlvbihwYXJlbnRzLCBjaGlsZCkgey4uLn0gfSAtPiBGdW5jdGlvbiBjYWxsZWQgcHJpb3IgdG8gY3JlYXRpbmcgYSBzdWJzY3JpcHRpb24uIFJldHVybmluZyBmYWxzZSBhYm9ydHMgdGhlIG9wZXJhdGlvbiBhbmQgaWdub3JlcyBpdHMgY2hpbGRyZW4uPGJyLz5cclxuICAgIC8vLyAgICAgeyB3cmFwOiB0cnVlIH0gLT4gV3JhcCBhbGwgZmllbGRzIGludG8gb2JzZXJ2YWJsZXMuIFRoaXMgaGFwcGVucyBvbiB0aGUgZmx5IGZvciBuZXcgYXJyYXkgaXRlbXMob3IgY2hpbGQgb2JqZWN0cyB3aGVuIG11dGFibGUgaXMgc2V0IHRvIHRydWUpLjxici8+XHJcbiAgICAvLy8gICAgIHsgYmVmb3JlV3JhcDogZnVuY3Rpb24ocGFyZW50cywgZmllbGQsIHZhbHVlKSB7Li4ufSB9IC0+IEZ1bmN0aW9uIGNhbGxlZCBwcmlvciB0byB3cmFwcGluZyBhIHZhbHVlIGludG8gYW4gb2JzZXJ2YWJsZS4gUmV0dXJuaW5nIGZhbHNlIGxlYXZlcyBpdCBhcyBpdCBpcy48YnIvPlxyXG4gICAgLy8vICAgICB7IHRhZ0ZpZWxkczogdHJ1ZSB9IC0+IEFkZCB0aGUgcHJvcGVydHkgJ19maWVsZE5hbWUnIHVuZGVyIGVhY2ggcHJvcGVydHkgZm9yIHRleHR1YWwgaWRlbnRpZmljYXRpb24uPGJyLz5cclxuICAgIC8vLyAgICAgeyB0YWdGaWVsZHM6ICdwYXJlbnRzT25seScgfSAtPiBTYW1lIGFzIGFib3ZlIGV4Y2VwdCB0aGF0IGl0IGlzIGxpbWl0ZWQgdG8gcGFyZW50IHByb3BlcnRpZXMgb25seS48YnIvPlxyXG4gICAgLy8vICAgICB7IG9sZFZhbHVlczogMyB9IC0+IEtlZXAgdGhlIGxhc3QgdGhyZWUgdmFsdWVzIGZvciBlYWNoIHN1YnNjcmliYWJsZSB1bmRlciB0aGUgcHJvcGVydHkgJ29sZFZhbHVlcycuPGJyLz5cclxuICAgIC8vLyAgICAgeyBzZWFsOiB0cnVlIH0gLT4gUHJldmVudCBhbnkgc3Vic2VxdWVudCB3YXRjaGVyIGZyb20gd2F0Y2hpbmcgdGhlIHRhcmdldCBhZ2Fpbi48YnIvPlxyXG4gICAgLy8vICAgICB7IHVubG9vcDogdHJ1ZSB9IC0+IEF2b2lkIGNpcmN1bGFyIHBhdGhzIHRocm91Z2ggdGhlIHVzZSBvZiBhIGJyZWFkY3J1bWIgcHJvcGVydHkgJ193YXRjaGVyJyBzZXQgYXQgZWFjaCBub2RlIGxldmVsLjxici8+XHJcbiAgICAvLy8gICAgIHsgZ2V0dGVyOiBmdW5jdGlvbihwYXJlbnRzLCBjaGlsZCwgcHJvcGVydHkpIHsuLi59IH0gLT4gRnVuY3Rpb24gdXNlZCB0byByZXRyaWV2ZSB0aGUgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gY2hpbGQuIEZhbHNlIGNhbiBiZSByZXR1cm5lZCB0byBpZ25vcmUgdGhlIHByb3BlcnR5Ljxici8+XHJcbiAgICAvLy8gPC9wYXJhbT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImV2YWx1YXRvckNhbGxiYWNrXCIgdHlwZT1cImZ1bmN0aW9uXCI+XHJcbiAgICAvLy8gICAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgZHVyaW5nIGNoYW5nZXMuXHJcbiAgICAvLy8gPC9wYXJhbT5cclxuXHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBldmFsdWF0b3JDYWxsYmFjaztcclxuICAgICAgICBldmFsdWF0b3JDYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XHJcblxyXG4gICAgZnVuY3Rpb24gd2F0Y2hDaGlsZHJlbihjaGlsZCwgcGFyZW50LCBncmFuZFBhcmVudHMsIHVud2F0Y2gsIGtlZXBPZmZQYXJlbnRMaXN0LCBmaWVsZE5hbWUpIHtcclxuICAgICAgICBpZiAoY2hpbGQgJiYgb3B0aW9ucy5kZXB0aCAhPT0gMCAmJiAob3B0aW9ucy5kZXB0aCA9PT0gLTEgfHwgZ3JhbmRQYXJlbnRzLmxlbmd0aCA8IChvcHRpb25zLmRlcHRoIHx8IDEpKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gUHJvY2VlZCBvbiB3YXRjaGVkIGNoaWxkcmVuIG9ubHkgd2hlbiBpbiB3YXRjaGVkLW9ubHkgbW9kZS5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2F0Y2hlZE9ubHkgJiYgIWNoaWxkLndhdGNoYWJsZSAmJiBjaGlsZCAhPSB0YXJnZXQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSB0YXJnZXQgYXMgZmFsc2UgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3YXRjaGVkIGxhdGVyIG9uLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSB8fCBvcHRpb25zLmVuYWJsZWQgPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBjaGlsZC53YXRjaGFibGUgPSBvcHRpb25zLmVuYWJsZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBJZ25vcmUgd2F0Y2gtZGlzYWJsZWQgb2JqZWN0cy5cclxuICAgICAgICAgICAgaWYgKGNoaWxkLndhdGNoYWJsZSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IHN1YnNlcXVlbnQgd2F0Y2hlcnMgZnJvbSB3YXRjaGluZyB0aGUgdGFyZ2V0IHdoZW4gc2VhbGVkLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZWFsID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgY2hpbGQud2F0Y2hhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCeXBhc3MgY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5fd2F0Y2hlciA9PT0gY29udGV4dClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGhpZGRlbiBvYmplY3RzLiBBbHNvIGFwcGxpZXMgdG8gYW55IG9mIHRoZWlyIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa28udXRpbHMuYXJyYXlJbmRleE9mKG9wdGlvbnMuaGlkZSwgY2hpbGQpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJlbnRzLiBVc2luZyBhIGZyZXNoIGFycmF5IHNvIGl0IGlzIG5vdCByZWZlcmVuY2VkIGluIHRoZSBuZXh0IHJlY3Vyc2lvbiBpZiBhbnkuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50cyA9IFtdLmNvbmNhdChncmFuZFBhcmVudHMsIHBhcmVudCAmJiBwYXJlbnQgIT09IHRhcmdldCA/IHBhcmVudCA6IFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRbJ25vdGlmeVN1YnNjcmliZXJzJ10gPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYXJnZXQgaXMgYSBzdWJzY3JpYmFibGUuIFdhdGNoIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdG9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgPT09IHRydWUgJiYgY2hpbGQud2F0Y2hhYmxlID09PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHdha2luZyB1cCBhbiBleGlzdGluZyB3YXRjaGVyLiBMZXQncyBub3QgYWRkIGFub3RoZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bndhdGNoIHx8ICFvcHRpb25zLmJlZm9yZVdhdGNoIHx8IG9wdGlvbnMuYmVmb3JlV2F0Y2guY2FsbChjb250ZXh0LCBwYXJlbnRzLCBjaGlsZCwgZmllbGROYW1lKSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNBcnJheSA9IHR5cGVvZiBjaGlsZC5wb3AgPT09ICdmdW5jdGlvbic7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bndhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VXYXRjaGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25XYXRjaGVyKGNoaWxkLCBpc0FycmF5LCBwYXJlbnRzLCBrZWVwT2ZmUGFyZW50TGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXRjaENoaWxkcmVuKGNoaWxkKCksIGtlZXBPZmZQYXJlbnRMaXN0ID8gbnVsbCA6IGNoaWxkLCBwYXJlbnRzLCB1bndhdGNoLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZVdyYXBwZWRWYWx1ZXMgIT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2F0Y2hDaGlsZHJlbihjaGlsZCgpLCBrZWVwT2ZmUGFyZW50TGlzdCA/IG51bGwgOiBjaGlsZCwgcGFyZW50cywgdW53YXRjaCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga28udXRpbHMub2JqZWN0Rm9yRWFjaChjaGlsZCwgZnVuY3Rpb24gKHByb3BlcnR5LCBzdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9IG9wdGlvbnMuZ2V0dGVyID8gb3B0aW9ucy5nZXR0ZXIuY2FsbChjb250ZXh0LCBwYXJlbnRzLCBjaGlsZCwgcHJvcGVydHkpIDogc3ViO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndyYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCBzaW1wbGUgb2JqZWN0cyBhbmQgYXJyYXlzIGludG8gb2JzZXJ2YWJsZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1Yik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSAnW29iamVjdCBGdW5jdGlvbl0nICYmIHR5cGUgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuYmVmb3JlV3JhcCB8fCBvcHRpb25zLmJlZm9yZVdyYXAuY2FsbChjb250ZXh0LCBwYXJlbnRzLCBjaGlsZCwgc3ViKSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSBjaGlsZFtwcm9wZXJ0eV0gPSB0eXBlID09PSAnW29iamVjdCBBcnJheV0nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ga28ub2JzZXJ2YWJsZUFycmF5KHN1YilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBrby5vYnNlcnZhYmxlKHN1Yik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVubG9vcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViLl93YXRjaGVyID0gdW53YXRjaCA/IHVuZGVmaW5lZCA6IGNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNDaGlsZHJlbiA9IHdhdGNoQ2hpbGRyZW4oc3ViLCBrZWVwT2ZmUGFyZW50TGlzdCA/IG51bGwgOiBjaGlsZCwgcGFyZW50cywgdW53YXRjaCwgbnVsbCwgcHJvcGVydHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50YWdGaWVsZHMgJiYgc3ViLl9maWVsZE5hbWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAob3B0aW9ucy50YWdGaWVsZHMgIT09ICdwYXJlbnRzT25seScgJiYgdHlwZW9mIHN1YiA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc3ViID09PSAnb2JqZWN0JykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIuX2ZpZWxkTmFtZSA9IHByb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyAnW29iamVjdCBBcnJheV0nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhpZGVBcnJheXMgIT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoQ2hpbGRyZW4oY2hpbGRbaV0sIGtlZXBPZmZQYXJlbnRMaXN0ID8gbnVsbCA6IGNoaWxkLCBwYXJlbnRzLCB1bndhdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN1YnNjcmlwdGlvbnMgYXJlIHN0b3JlZCB1bmRlciBlaXRoZXIgdGhlIF9zdWJzY3JpcHRpb25zIGZpZWxkIGZvciB0aGUgZGVidWcgdmVyc2lvblxyXG4gICAgLy8gb3IgdGhlIEYsIEggb3IgTSBmaWVsZHMgd2hlbiBtaW5pZmllZCBkZXBlbmRpbmcgb24gdGhlIHZlcnNpb24gdXNlZC5cclxuICAgIC8vIE5PVEU6IHdlIHVzZWQgdG8gdXNlIGtvLkRFQlVHIHRvIGRldGVjdCB0aGUgZGVidWcgdmVyc2lvbmJ1dCBpdCB3YXMgcmVtb3ZlZCBpbiAzLjQuMCssXHJcbiAgICAvLyAgICAgICBzbyB3ZSBub3cgY2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIFwic3Vic2NyaXB0aW9uXCIgZnVuY3Rpb24uXHJcbiAgICB2YXIgc3Vic2NyaXB0aW9uc0ZpZWxkO1xyXG4gICAgc3dpdGNoICh0eXBlb2Yga28uc3Vic2NyaXB0aW9uID09ICdmdW5jdGlvbicgfHwga28udmVyc2lvbikge1xyXG4gICAgICAgIGNhc2UgdHJ1ZTogc3Vic2NyaXB0aW9uc0ZpZWxkID0gJ19zdWJzY3JpcHRpb25zJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMC4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdGJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMS4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdIJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMi4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdNJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMy4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdHJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuNC4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdLJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuNC4xXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdLJzsgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgXCJVbnN1cHBvcnRlZCBLbm9ja291dCB2ZXJzaW9uLiBPbmx5IHYzLjAuMCB0byB2My40LjEgYXJlIHN1cHBvcnRlZCB3aGVuIG1pbmlmaWVkLiBDdXJyZW50IHZlcnNpb24gaXMgXCIgKyBrby52ZXJzaW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpc3Bvc2VXYXRjaGVyKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIHN1YnNjID0gY2hpbGRbc3Vic2NyaXB0aW9uc0ZpZWxkXTtcclxuXHJcbiAgICAgICAgaWYgKHN1YnNjKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJzYy5jaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3Vic2MuY2hhbmdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzYy5jaGFuZ2VbaV0uX3dhdGNoZXIgPT09IGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjLmNoYW5nZVtpXS5kaXNwb3NlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3Vic2MuYmVmb3JlQ2hhbmdlICYmIChvcHRpb25zLm11dGFibGUgfHwgb3B0aW9ucy5vbGRWYWx1ZXMgPiAwKSlcclxuICAgICAgICAgICAgICAgIC8vIEFsc28gY2xlYW4gdXAgYW55IGJlZm9yZS1jaGFuZ2Ugc3Vic2NyaXB0aW9ucyB1c2VkIGZvciB0cmFja2luZyBvbGQgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnNjLmJlZm9yZUNoYW5nZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2MuYmVmb3JlQ2hhbmdlW2ldLl93YXRjaGVyID09PSBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzYy5iZWZvcmVDaGFuZ2VbaV0uZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN1YnNjLmFycmF5Q2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnNjLmFycmF5Q2hhbmdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzYy5hcnJheUNoYW5nZVtpXS5fd2F0Y2hlciA9PT0gY29udGV4dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2MuYXJyYXlDaGFuZ2VbaV0uZGlzcG9zZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IFwiU3Vic2NyaXB0aW9ucyBmaWVsZCAoLlwiICsgc3Vic2NyaXB0aW9uc0ZpZWxkICsgXCIpIG5vdCBkZWZpbmVkIGZvciBvYnNlcnZhYmxlIGNoaWxkIFwiICsgKGNoaWxkLl9maWVsZE5hbWUgfHwgXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFzc2lnbldhdGNoZXIoY2hpbGQsIGlzQXJyYXksIHBhcmVudHMsIGtlZXBPZmZQYXJlbnRMaXN0KSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gQ2hpbGQgaXMgYW4gb2JzZXJ2YWJsZSBhcnJheS4gV2F0Y2ggYWxsIGNoYW5nZXMgd2l0aGluIGl0LlxyXG4gICAgICAgICAgICBjaGlsZC5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChjaGFuZ2VzLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGV2YWx1YXRvckNhbGxiYWNrLmNhbGwoY29udGV4dCwgcGFyZW50cywgY2hpbGQsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0KHJldHVyblZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLm1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZWQgb3IgYnJhbmQgbmV3IGl0ZW0uIFVud2F0Y2ggb3Igd2F0Y2ggaXQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hDaGlsZHJlbihpdGVtLnZhbHVlLCAoa2VlcE9mZlBhcmVudExpc3QgPyBudWxsIDogY2hpbGQpLCBwYXJlbnRzLCBpdGVtLnN0YXR1cyA9PT0gJ2RlbGV0ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgJ2FycmF5Q2hhbmdlJykuX3dhdGNoZXIgPSBjb250ZXh0O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGlsZC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLndhdGNoYWJsZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBldmFsdWF0b3JDYWxsYmFjay5jYWxsKGNvbnRleHQsIHBhcmVudHMsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQocmV0dXJuVmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tdXRhYmxlICYmIHR5cGVvZiBjaGlsZCgpID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2F0Y2ggdGhlIG5ldyBjb21lci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hDaGlsZHJlbihjaGlsZCgpLCAoa2VlcE9mZlBhcmVudExpc3QgPyBudWxsIDogY2hpbGQpLCBwYXJlbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0sIG51bGwsICdjaGFuZ2UnKS5fd2F0Y2hlciA9IGNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbGRWYWx1ZXMgPiAwIHx8IG9wdGlvbnMubXV0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuc3Vic2NyaWJlKGZ1bmN0aW9uIChvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9sZFZhbHVlcyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG9sZCB2YWx1ZSB0byBoaXN0b3J5IGxpc3QgYmVmb3JlIGV2ZXJ5IHVwZGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IChjaGlsZFsnb2xkVmFsdWVzJ11cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2hpbGRbJ29sZFZhbHVlcyddXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNoaWxkWydvbGRWYWx1ZXMnXSA9IFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KG9sZFZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoID4gb3B0aW9ucy5vbGRWYWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tdXRhYmxlICYmIHR5cGVvZiBvbGRWYWx1ZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGFsbCBzdWJzY3JpcHRpb25zIGZvciB0aGUgb2xkIGNoaWxkIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hDaGlsZHJlbihvbGRWYWx1ZSwgKGtlZXBPZmZQYXJlbnRMaXN0ID8gbnVsbCA6IGNoaWxkKSwgcGFyZW50cywgZmFsc2UsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sIG51bGwsICdiZWZvcmVDaGFuZ2UnKS5fd2F0Y2hlciA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXNlIGEgY29tcHV0ZWQgd2hlbiB0YXJnZXRpbmcgYSBub24td2F0Y2hhYmxlIGZ1bmN0aW9uLlxyXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicgJiYgIWtvLmlzU3Vic2NyaWJhYmxlKHRhcmdldCkpXHJcbiAgICAgICAgcmV0dXJuIGtvLmNvbXB1dGVkKHRhcmdldCwgZXZhbHVhdG9yQ2FsbGJhY2ssIG9wdGlvbnMpO1xyXG5cclxuICAgIHdhdGNoQ2hpbGRyZW4odGFyZ2V0LCBudWxsLCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhdGNoQ2hpbGRyZW4odGFyZ2V0LCBudWxsLCBbXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbn0pKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBsZXggIDogcmVxdWlyZSgnLi9saWIvbGV4ZXInKSxcbiAgICBwYXJzZTogcmVxdWlyZSgnLi9saWIvcGFyc2VyJyksXG4gICAgc3RyaW5naWZ5OiByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKVxufTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuXG5mdW5jdGlvbiBkZWJ1ZyhsYWJlbCkge1xuICByZXR1cm4gX2RlYnVnLmJpbmQobnVsbCwgbGFiZWwpO1xufVxuXG5mdW5jdGlvbiBfZGVidWcobGFiZWwpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIGFyZ3MudW5zaGlmdCgnWycgKyBsYWJlbCArICddJyk7XG4gIHByb2Nlc3Muc3RkZXJyLndyaXRlKGFyZ3Muam9pbignICcpICsgJ1xcbicpO1xufSIsInZhciBERUJVRyA9IGZhbHNlOyAvLyBgdHJ1ZWAgdG8gcHJpbnQgZGVidWdnaW5nIGluZm8uXG52YXIgVElNRVIgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHRpbWUgY2FsbHMgdG8gYGxleCgpYCBhbmQgcHJpbnQgdGhlIHJlc3VsdHMuXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKSgnbGV4Jyk7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGxleDtcblxuLyoqXG4gKiBDb252ZXJ0IGEgQ1NTIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGxleGljYWwgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3MgQ1NTXG4gKiBAcmV0dXJucyB7QXJyYXl9IGxleGljYWwgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGxleChjc3MpIHtcbiAgdmFyIHN0YXJ0OyAvLyBEZWJ1ZyB0aW1lciBzdGFydC5cblxuICB2YXIgYnVmZmVyID0gJyc7ICAgICAgLy8gQ2hhcmFjdGVyIGFjY3VtdWxhdG9yXG4gIHZhciBjaDsgICAgICAgICAgICAgICAvLyBDdXJyZW50IGNoYXJhY3RlclxuICB2YXIgY29sdW1uID0gMDsgICAgICAgLy8gQ3VycmVudCBzb3VyY2UgY29sdW1uIG51bWJlclxuICB2YXIgY3Vyc29yID0gLTE7ICAgICAgLy8gQ3VycmVudCBzb3VyY2UgY3Vyc29yIHBvc2l0aW9uXG4gIHZhciBkZXB0aCA9IDA7ICAgICAgICAvLyBDdXJyZW50IG5lc3RpbmcgZGVwdGhcbiAgdmFyIGxpbmUgPSAxOyAgICAgICAgIC8vIEN1cnJlbnQgc291cmNlIGxpbmUgbnVtYmVyXG4gIHZhciBzdGF0ZSA9ICdiZWZvcmUtc2VsZWN0b3InOyAvLyBDdXJyZW50IHN0YXRlXG4gIHZhciBzdGFjayA9IFtzdGF0ZV07ICAvLyBTdGF0ZSBzdGFja1xuICB2YXIgdG9rZW4gPSB7fTsgICAgICAgLy8gQ3VycmVudCB0b2tlblxuICB2YXIgdG9rZW5zID0gW107ICAgICAgLy8gVG9rZW4gYWNjdW11bGF0b3JcblxuICAvLyBTdXBwb3J0ZWQgQC1ydWxlcywgaW4gcm91Z2hseSBkZXNjZW5kaW5nIG9yZGVyIG9mIHVzYWdlIHByb2JhYmlsaXR5LlxuICB2YXIgYXRSdWxlcyA9IFtcbiAgICAnbWVkaWEnLFxuICAgICdrZXlmcmFtZXMnLFxuICAgIHsgbmFtZTogJy13ZWJraXQta2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy13ZWJraXQtJyB9LFxuICAgIHsgbmFtZTogJy1tb3ota2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy1tb3otJyB9LFxuICAgIHsgbmFtZTogJy1tcy1rZXlmcmFtZXMnLCB0eXBlOiAna2V5ZnJhbWVzJywgcHJlZml4OiAnLW1zLScgfSxcbiAgICB7IG5hbWU6ICctby1rZXlmcmFtZXMnLCB0eXBlOiAna2V5ZnJhbWVzJywgcHJlZml4OiAnLW8tJyB9LFxuICAgICdmb250LWZhY2UnLFxuICAgIHsgbmFtZTogJ2ltcG9ydCcsIHN0YXRlOiAnYmVmb3JlLWF0LXZhbHVlJyB9LFxuICAgIHsgbmFtZTogJ2NoYXJzZXQnLCBzdGF0ZTogJ2JlZm9yZS1hdC12YWx1ZScgfSxcbiAgICAnc3VwcG9ydHMnLFxuICAgICd2aWV3cG9ydCcsXG4gICAgeyBuYW1lOiAnbmFtZXNwYWNlJywgc3RhdGU6ICdiZWZvcmUtYXQtdmFsdWUnIH0sXG4gICAgJ2RvY3VtZW50JyxcbiAgICB7IG5hbWU6ICctbW96LWRvY3VtZW50JywgdHlwZTogJ2RvY3VtZW50JywgcHJlZml4OiAnLW1vei0nIH0sXG4gICAgJ3BhZ2UnXG4gIF07XG5cbiAgLy8gLS0gRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBjaGFyYWN0ZXIgY3Vyc29yIGFuZCByZXR1cm4gdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRDaCgpIHtcbiAgICBza2lwKCk7XG4gICAgcmV0dXJuIGNzc1tjdXJzb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RhdGUgYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBzdGFjay5cbiAgICogVGhlIHN0YWNrIGlzIExJRk8gc28gaW5kZXhpbmcgaXMgZnJvbSB0aGUgcmlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXg9MF0gSW5kZXggdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxIC0gaW5kZXhdIDogc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogTG9vayBhaGVhZCBmb3IgYSBzdHJpbmcgYmVnaW5uaW5nIGZyb20gdGhlIG5leHQgcG9zaXRpb24uIFRoZSBzdHJpbmdcbiAgICogYmVpbmcgbG9va2VkIGZvciBtdXN0IHN0YXJ0IGF0IHRoZSBuZXh0IHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gbG9vayBmb3IuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgd2FzIGZvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNOZXh0U3RyaW5nKHN0cikge1xuICAgIHZhciBzdGFydCA9IGN1cnNvciArIDE7XG4gICAgcmV0dXJuIChzdHIgPT09IGNzcy5zbGljZShzdGFydCwgc3RhcnQgKyBzdHIubGVuZ3RoKSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYSBzdWJzdHJpbmcgYmVnaW5uaW5nIGZyb20gdGhlIG5leHRcbiAgICogcG9zaXRpb24uIFRoZSBzdHJpbmcgYmVpbmcgbG9va2VkIGZvciBtYXkgYmVnaW4gYW55d2hlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YnN0cmluZyB0byBsb29rIGZvci5cbiAgICogQHJldHVybnMge051bWJlcnxmYWxzZX0gVGhlIHBvc2l0aW9uLCBvciBgZmFsc2VgIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmQoc3RyKSB7XG4gICAgdmFyIHBvcyA9IGNzcy5zbGljZShjdXJzb3IpLmluZGV4T2Yoc3RyKTtcblxuICAgIHJldHVybiBwb3MgPiAwID8gcG9zIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjaGFyYWN0ZXIgaXMgbmV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoIENoYXJhY3Rlci5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBuZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gaXNOZXh0Q2hhcihjaCkge1xuICAgIHJldHVybiBjaCA9PT0gcGVlaygxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNoYXJhY3RlciBhdCB0aGUgZ2l2ZW4gY3Vyc29yIG9mZnNldC4gVGhlIG9mZnNldCBpcyByZWxhdGl2ZVxuICAgKiB0byB0aGUgY3Vyc29yLCBzbyBuZWdhdGl2ZSB2YWx1ZXMgbW92ZSBiYWNrd2FyZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTFdIEN1cnNvciBvZmZzZXQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHBlZWsob2Zmc2V0KSB7XG4gICAgcmV0dXJuIGNzc1tjdXJzb3IgKyAob2Zmc2V0IHx8IDEpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGN1cnJlbnQgc3RhdGUgZnJvbSB0aGUgc3RhY2sgYW5kIHNldCB0aGUgbmV3IGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZW1vdmVkIHN0YXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgdmFyIHJlbW92ZWQgPSBzdGFjay5wb3AoKTtcbiAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHN0YXRlIGFuZCBhZGQgaXQgdG8gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3U3RhdGUgVGhlIG5ldyBzdGF0ZS5cbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIG5ldyBzdGFjayBsZW5ndGguXG4gICAqL1xuICBmdW5jdGlvbiBwdXNoU3RhdGUobmV3U3RhdGUpIHtcbiAgICBzdGF0ZSA9IG5ld1N0YXRlO1xuICAgIHN0YWNrLnB1c2goc3RhdGUpO1xuXG4gICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggYSBuZXcgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdTdGF0ZSBUaGUgbmV3IHN0YXRlLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVwbGFjZWQgc3RhdGUuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUobmV3U3RhdGUpIHtcbiAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xuICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID0gc3RhdGUgPSBuZXdTdGF0ZTtcblxuICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGNoYXJhY3RlciBjdXJzb3IuIFBvc2l0aXZlIG51bWJlcnMgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQuXG4gICAqIE5lZ2F0aXZlIG51bWJlcnMgYXJlIG5vdCBzdXBwb3J0ZWQhXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbj0xXSBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byBza2lwLlxuICAgKi9cbiAgZnVuY3Rpb24gc2tpcChuKSB7XG4gICAgaWYgKChuIHx8IDEpID09IDEpIHtcbiAgICAgIGlmIChjc3NbY3Vyc29yXSA9PSAnXFxuJykge1xuICAgICAgICBsaW5lKys7XG4gICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW4rKztcbiAgICAgIH1cbiAgICAgIGN1cnNvcisrO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcFN0ciA9IGNzcy5zbGljZShjdXJzb3IsIGN1cnNvciArIG4pLnNwbGl0KCdcXG4nKTtcbiAgICAgIGlmIChza2lwU3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGluZSArPSBza2lwU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICB9XG4gICAgICBjb2x1bW4gKz0gc2tpcFN0cltza2lwU3RyLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgIGN1cnNvciA9IGN1cnNvciArIG47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgY3VycmVudCB0b2tlbiB0byB0aGUgcGlsZSBhbmQgcmVzZXQgdGhlIGJ1ZmZlci5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFRva2VuKCkge1xuICAgIHRva2VuLmVuZCA9IHtcbiAgICAgIGxpbmU6IGxpbmUsXG4gICAgICBjb2w6IGNvbHVtblxuICAgIH07XG5cbiAgICBERUJVRyAmJiBkZWJ1ZygnYWRkVG9rZW46JywgSlNPTi5zdHJpbmdpZnkodG9rZW4sIG51bGwsIDIpKTtcblxuICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblxuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHRva2VuID0ge307XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUb2tlbiB0eXBlLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVRva2VuKHR5cGUpIHtcbiAgICB0b2tlbiA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBzdGFydDoge1xuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICBjb2wgOiBjb2x1bW5cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gLS0gTWFpbiBMb29wIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qXG4gIFRoZSBtYWluIGxvb3AgaXMgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgcmVhZHMgaW4gb25lIGNoYXJhY3RlciBhdCBhIHRpbWUsXG4gIGFuZCBkZXRlcm1pbmVzIHdoYXQgdG8gZG8gYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGNoYXJhY3Rlci5cbiAgVGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNlcmllcyBvZiBuZXN0ZWQgYHN3aXRjaGAgc3RhdGVtZW50cyBhbmQgdGhlXG4gIGNhc2Ugb3JkZXJzIGhhdmUgYmVlbiBtaWxkbHkgb3B0aW1pemVkIGJhc2VkIG9uIHJvdWdoIHByb2JhYmlsaXRpZXNcbiAgY2FsY3VsYXRlZCBieSBwcm9jZXNzaW5nIGEgc21hbGwgc2FtcGxlIG9mIHJlYWwtd29ybGQgQ1NTLlxuXG4gIEZ1cnRoZXIgb3B0aW1pemF0aW9uIChzdWNoIGFzIGEgZGlzcGF0Y2ggdGFibGUpIHNob3VsZG4ndCBiZSBuZWNlc3NhcnlcbiAgc2luY2UgdGhlIHRvdGFsIG51bWJlciBvZiBjYXNlcyBpcyB2ZXJ5IGxvdy5cbiAgKi9cblxuICBUSU1FUiAmJiAoc3RhcnQgPSBEYXRlLm5vdygpKTtcblxuICB3aGlsZSAoY2ggPSBnZXRDaCgpKSB7XG4gICAgREVCVUcgJiYgZGVidWcoY2gsIGdldFN0YXRlKCkpO1xuXG4gICAgLy8gY29sdW1uICs9IDE7XG5cbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgLy8gU3BhY2VcbiAgICBjYXNlICcgJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnc2VsZWN0b3InOlxuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgY2FzZSAndmFsdWUtcGFyZW4nOlxuICAgICAgY2FzZSAnYXQtZ3JvdXAnOlxuICAgICAgY2FzZSAnYXQtdmFsdWUnOlxuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICAvLyBOZXdsaW5lIG9yIHRhYlxuICAgIGNhc2UgJ1xcbic6XG4gICAgY2FzZSAnXFx0JzpcbiAgICBjYXNlICdcXHInOlxuICAgIGNhc2UgJ1xcZic6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLXBhcmVuJzpcbiAgICAgIGNhc2UgJ2F0LWdyb3VwJzpcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXQtdmFsdWUnOlxuICAgICAgICAvLyBUb2tlbml6ZSBhbiBALXJ1bGUgaWYgYSBzZW1pLWNvbG9uIHdhcyBvbWl0dGVkLlxuICAgICAgICBpZiAoJ1xcbicgPT09IGNoKSB7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSBidWZmZXIudHJpbSgpO1xuICAgICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgKCdcXG4nID09PSBjaCkge1xuICAgICAgLy8gICBjb2x1bW4gPSAwO1xuICAgICAgLy8gICBsaW5lICs9IDE7XG4gICAgICAvLyB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzonOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgdG9rZW4ubmFtZSA9IGJ1ZmZlci50cmltKCk7XG4gICAgICAgIGJ1ZmZlciA9ICcnO1xuXG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnYmVmb3JlLXZhbHVlJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtc2VsZWN0b3InOlxuICAgICAgICBidWZmZXIgKz0gY2g7XG5cbiAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdzZWxlY3RvcicpO1xuICAgICAgICBwdXNoU3RhdGUoJ3NlbGVjdG9yJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzsnOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICduYW1lJzpcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIC8vIFRva2VuaXplIGEgZGVjbGFyYXRpb25cbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgZW1wdHkgc2tpcCB0aGUgZGVjbGFyYXRpb25cbiAgICAgICAgaWYgKGJ1ZmZlci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKSxcbiAgICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnYmVmb3JlLW5hbWUnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3ZhbHVlLXBhcmVuJzpcbiAgICAgICAgLy8gSW5zaWduaWZpY2FudCBzZW1pLWNvbG9uXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F0LXZhbHVlJzpcbiAgICAgICAgLy8gVG9rZW5pemUgYW4gQC1ydWxlXG4gICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKTtcbiAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS1uYW1lJzpcbiAgICAgICAgLy8gRXh0cmFuZW91cyBzZW1pLWNvbG9uXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd7JzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnc2VsZWN0b3InOlxuICAgICAgICAvLyBJZiB0aGUgc2VxdWVuY2UgaXMgYFxce2AgdGhlbiBhc3N1bWUgdGhhdCB0aGUgYnJhY2Ugc2hvdWxkIGJlIGVzY2FwZWQuXG4gICAgICAgIGlmIChwZWVrKC0xKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRva2VuaXplIGEgc2VsZWN0b3JcbiAgICAgICAgdG9rZW4udGV4dCA9IGJ1ZmZlci50cmltKCk7XG4gICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnYmVmb3JlLW5hbWUnKTtcbiAgICAgICAgZGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhdC1ncm91cCc6XG4gICAgICAgIC8vIFRva2VuaXplIGFuIEAtZ3JvdXBcbiAgICAgICAgdG9rZW4ubmFtZSA9IGJ1ZmZlci50cmltKCk7XG5cbiAgICAgICAgLy8gWFhYOiBALXJ1bGVzIGFyZSBzdGFydGluZyB0byBnZXQgaGFpcnlcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgICAgIGNhc2UgJ3ZpZXdwb3J0JyA6XG4gICAgICAgIGNhc2UgJ3BhZ2UnICAgICA6XG4gICAgICAgICAgcHVzaFN0YXRlKCdiZWZvcmUtbmFtZScpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaFN0YXRlKCdiZWZvcmUtc2VsZWN0b3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgIGRlcHRoID0gZGVwdGggKyAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICBjYXNlICdhdC1ydWxlJzpcbiAgICAgICAgLy8gVG9rZW5pemUgYSBkZWNsYXJhdGlvbiBvciBhbiBALXJ1bGVcbiAgICAgICAgdG9rZW4ubmFtZSA9IGJ1ZmZlci50cmltKCk7XG4gICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgIHB1c2hTdGF0ZSgnYmVmb3JlLW5hbWUnKTtcbiAgICAgICAgZGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgIGNhc2UgJ2RvdWJsZS1zdHJpbmcnOlxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XG4gICAgICAgIC8vIElnbm9yZSBicmFjZXMgaW4gY29tbWVudHMgYW5kIHN0cmluZ3NcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd9JzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnYmVmb3JlLW5hbWUnOlxuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAvLyBJZiB0aGUgYnVmZmVyIGNvbnRhaW5zIGFueXRoaW5nLCBpdCBpcyBhIHZhbHVlXG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9IGJ1ZmZlci50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0b2tlbiBoYXMgYSBuYW1lIGFuZCBhIHZhbHVlIGl0IHNob3VsZCBiZSB0b2tlbml6ZWQuXG4gICAgICAgIGlmICh0b2tlbi5uYW1lICYmIHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExlYXZlIHRoZSBibG9ja1xuICAgICAgICBpbml0aWFsaXplVG9rZW4oJ2VuZCcpO1xuICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICBwb3BTdGF0ZSgpO1xuXG4gICAgICAgIC8vIFdlIG1pZ2h0IG5lZWQgdG8gbGVhdmUgYWdhaW4uXG4gICAgICAgIC8vIFhYWDogV2hhdCBhYm91dCAzIGxldmVscyBkZWVwP1xuICAgICAgICBpZiAoJ2F0LWdyb3VwJyA9PT0gZ2V0U3RhdGUoKSkge1xuICAgICAgICAgIGluaXRpYWxpemVUb2tlbignYXQtZ3JvdXAtZW5kJyk7XG4gICAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgICBwb3BTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZGVwdGggPiAwKSB7XG4gICAgICAgICAgZGVwdGggPSBkZXB0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXQtZ3JvdXAnOlxuICAgICAgY2FzZSAnYmVmb3JlLXNlbGVjdG9yJzpcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcbiAgICAgICAgLy8gSWYgdGhlIHNlcXVlbmNlIGlzIGBcXH1gIHRoZW4gYXNzdW1lIHRoYXQgdGhlIGJyYWNlIHNob3VsZCBiZSBlc2NhcGVkLlxuICAgICAgICBpZiAocGVlaygtMSkgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwdGggPiAwKSB7XG4gICAgICAgICAgLy8gTGVhdmUgYmxvY2sgaWYgaW4gYW4gYXQtZ3JvdXBcbiAgICAgICAgICBpZiAoJ2F0LWdyb3VwJyA9PT0gZ2V0U3RhdGUoMSkpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVUb2tlbignYXQtZ3JvdXAtZW5kJyk7XG4gICAgICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICBwb3BTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgICAgIGRlcHRoID0gZGVwdGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgIC8vIElnbm9yZSBicmFjZXMgaW4gY29tbWVudHMgYW5kIHN0cmluZ3MuXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIGNhc2UgJ1wiJzpcbiAgICBjYXNlIFwiJ1wiOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgICAgaWYgKCdcIicgPT09IGNoICYmICdcXFxcJyAhPT0gcGVlaygtMSkpIHtcbiAgICAgICAgICBwb3BTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzaW5nbGUtc3RyaW5nJzpcbiAgICAgICAgaWYgKFwiJ1wiID09PSBjaCAmJiAnXFxcXCcgIT09IHBlZWsoLTEpKSB7XG4gICAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLWF0LXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCdhdC12YWx1ZScpO1xuICAgICAgICBwdXNoU3RhdGUoJ1wiJyA9PT0gY2ggPyAnZG91YmxlLXN0cmluZycgOiAnc2luZ2xlLXN0cmluZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xuICAgICAgICBwdXNoU3RhdGUoJ1wiJyA9PT0gY2ggPyAnZG91YmxlLXN0cmluZycgOiAnc2luZ2xlLXN0cmluZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgIC8vIElnbm9yZSBzdHJpbmdzIHdpdGhpbiBjb21tZW50cy5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgnXFxcXCcgIT09IHBlZWsoLTEpKSB7XG4gICAgICAgICAgcHVzaFN0YXRlKCdcIicgPT09IGNoID8gJ2RvdWJsZS1zdHJpbmcnIDogJ3NpbmdsZS1zdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWZmZXIgKz0gY2g7XG4gICAgICBicmVhaztcblxuICAgIC8vIENvbW1lbnRzXG4gICAgY2FzZSAnLyc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICBjYXNlICdzaW5nbGUtc3RyaW5nJzpcbiAgICAgICAgLy8gSWdub3JlXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICBjYXNlICdzZWxlY3Rvcic6XG4gICAgICBjYXNlICduYW1lJzpcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgaWYgKGlzTmV4dENoYXIoJyonKSkge1xuICAgICAgICAgIC8vIElnbm9yZSBjb21tZW50cyBpbiBzZWxlY3RvcnMsIHByb3BlcnRpZXMgYW5kIHZhbHVlcy4gVGhleSBhcmVcbiAgICAgICAgICAvLyBkaWZmaWN1bHQgdG8gcmVwcmVzZW50IGluIHRoZSBBU1QuXG4gICAgICAgICAgdmFyIHBvcyA9IGZpbmQoJyovJyk7XG5cbiAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBza2lwKHBvcyArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZ2V0U3RhdGUoKSA9PSAnYmVmb3JlLXZhbHVlJykgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xuICAgICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlzTmV4dENoYXIoJyonKSkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbW1lbnQgdG9rZW5cbiAgICAgICAgICBpbml0aWFsaXplVG9rZW4oJ2NvbW1lbnQnKTtcbiAgICAgICAgICBwdXNoU3RhdGUoJ2NvbW1lbnQnKTtcbiAgICAgICAgICBza2lwKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICAvLyBDb21tZW50IGVuZCBvciB1bml2ZXJzYWwgc2VsZWN0b3JcbiAgICBjYXNlICcqJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgIGlmIChpc05leHRDaGFyKCcvJykpIHtcbiAgICAgICAgICAvLyBUb2tlbml6ZSBhIGNvbW1lbnRcbiAgICAgICAgICB0b2tlbi50ZXh0ID0gYnVmZmVyOyAvLyBEb24ndCB0cmltKCkhXG4gICAgICAgICAgc2tpcCgpO1xuICAgICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS1zZWxlY3Rvcic6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdzZWxlY3RvcicpO1xuICAgICAgICBwdXNoU3RhdGUoJ3NlbGVjdG9yJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gQC1ydWxlc1xuICAgIGNhc2UgJ0AnOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgIGNhc2UgJ2RvdWJsZS1zdHJpbmcnOlxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgc3VwcG9ydGVkIEAtcnVsZXMgYW5kIGF0dGVtcHQgdG8gdG9rZW5pemUgb25lLlxuICAgICAgICB2YXIgdG9rZW5pemVkID0gZmFsc2U7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICB2YXIgcnVsZTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gYXRSdWxlcy5sZW5ndGg7ICF0b2tlbml6ZWQgJiYgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgcnVsZSA9IGF0UnVsZXNbal07XG4gICAgICAgICAgbmFtZSA9IHJ1bGUubmFtZSB8fCBydWxlO1xuXG4gICAgICAgICAgaWYgKCFpc05leHRTdHJpbmcobmFtZSkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIHRva2VuaXplZCA9IHRydWU7XG5cbiAgICAgICAgICBpbml0aWFsaXplVG9rZW4obmFtZSk7XG4gICAgICAgICAgcHVzaFN0YXRlKHJ1bGUuc3RhdGUgfHwgJ2F0LWdyb3VwJyk7XG4gICAgICAgICAgc2tpcChuYW1lLmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAocnVsZS5wcmVmaXgpIHtcbiAgICAgICAgICAgIHRva2VuLnByZWZpeCA9IHJ1bGUucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChydWxlLnR5cGUpIHtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBydWxlLnR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0b2tlbml6ZWQpIHtcbiAgICAgICAgICAvLyBLZWVwIG9uIHRydWNraW4nIEFtZXJpY2EhXG4gICAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICAvLyBQYXJlbnRoZXNlcyBhcmUgdHJhY2tlZCB0byBkaXNhbWJpZ3VhdGUgc2VtaS1jb2xvbnMsIHN1Y2ggYXMgd2l0aGluIGFcbiAgICAvLyBkYXRhIFVSSS5cbiAgICBjYXNlICcoJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICBwdXNoU3RhdGUoJ3ZhbHVlLXBhcmVuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcpJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAndmFsdWUtcGFyZW4nOlxuICAgICAgICBwb3BTdGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnYmVmb3JlLXNlbGVjdG9yJzpcbiAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdzZWxlY3RvcicpO1xuICAgICAgICBwdXNoU3RhdGUoJ3NlbGVjdG9yJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtbmFtZSc6XG4gICAgICAgIGluaXRpYWxpemVUb2tlbigncHJvcGVydHknKTtcbiAgICAgICAgcmVwbGFjZVN0YXRlKCduYW1lJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtYXQtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ2F0LXZhbHVlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIgKz0gY2g7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBUSU1FUiAmJiBkZWJ1ZygncmFuIGluJywgKERhdGUubm93KCkgLSBzdGFydCkgKyAnbXMnKTtcblxuICByZXR1cm4gdG9rZW5zO1xufVxuIiwidmFyIERFQlVHID0gZmFsc2U7IC8vIGB0cnVlYCB0byBwcmludCBkZWJ1Z2dpbmcgaW5mby5cbnZhciBUSU1FUiA9IGZhbHNlOyAvLyBgdHJ1ZWAgdG8gdGltZSBjYWxscyB0byBgcGFyc2UoKWAgYW5kIHByaW50IHRoZSByZXN1bHRzLlxuXG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJykoJ3BhcnNlJyk7XG52YXIgbGV4ID0gcmVxdWlyZSgnLi9sZXhlcicpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcblxudmFyIF9jb21tZW50czsgICAvLyBXaGV0aGVyIGNvbW1lbnRzIGFyZSBhbGxvd2VkLlxudmFyIF9kZXB0aDsgICAgICAvLyBDdXJyZW50IGJsb2NrIG5lc3RpbmcgZGVwdGguXG52YXIgX3Bvc2l0aW9uOyAgIC8vIFdoZXRoZXIgdG8gaW5jbHVkZSBsaW5lL2NvbHVtbiBwb3NpdGlvbi5cbnZhciBfdG9rZW5zOyAgICAgLy8gQXJyYXkgb2YgbGV4aWNhbCB0b2tlbnMuXG5cbi8qKlxuICogQ29udmVydCBhIENTUyBzdHJpbmcgb3IgYXJyYXkgb2YgbGV4aWNhbCB0b2tlbnMgaW50byBhIGBzdHJpbmdpZnlgLWFibGUgQVNULlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3MgQ1NTIHN0cmluZyBvciBhcnJheSBvZiBsZXhpY2FsIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbW1lbnRzPWZhbHNlXSBhbGxvdyBjb21tZW50IG5vZGVzIGluIHRoZSBBU1RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGBzdHJpbmdpZnlgLWFibGUgQVNUXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGNzcywgb3B0aW9ucykge1xuICB2YXIgc3RhcnQ7IC8vIERlYnVnIHRpbWVyIHN0YXJ0LlxuXG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIF9jb21tZW50cyA9ICEhb3B0aW9ucy5jb21tZW50cztcbiAgX3Bvc2l0aW9uID0gISFvcHRpb25zLnBvc2l0aW9uO1xuXG4gIF9kZXB0aCA9IDA7XG5cbiAgLy8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgdGhlIGdpdmVuIHRva2Vucywgb3IgdGhlIGxleCgpJ2QgQ1NTIHN0cmluZy5cbiAgX3Rva2VucyA9IEFycmF5LmlzQXJyYXkoY3NzKSA/IGNzcy5zbGljZSgpIDogbGV4KGNzcyk7XG5cbiAgdmFyIHJ1bGU7XG4gIHZhciBydWxlcyA9IFtdO1xuICB2YXIgdG9rZW47XG5cbiAgVElNRVIgJiYgKHN0YXJ0ID0gRGF0ZS5ub3coKSk7XG5cbiAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkpIHtcbiAgICBydWxlID0gcGFyc2VUb2tlbih0b2tlbik7XG4gICAgcnVsZSAmJiBydWxlcy5wdXNoKHJ1bGUpO1xuICB9XG5cbiAgVElNRVIgJiYgZGVidWcoJ3JhbiBpbicsIChEYXRlLm5vdygpIC0gc3RhcnQpICsgJ21zJyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0eWxlc2hlZXRcIixcbiAgICBzdHlsZXNoZWV0OiB7XG4gICAgICBydWxlczogcnVsZXNcbiAgICB9XG4gIH07XG59XG5cbi8vIC0tIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEJ1aWxkIGFuIEFTVCBub2RlIGZyb20gYSBsZXhpY2FsIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBsZXhpY2FsIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW292ZXJyaWRlXSBvYmplY3QgaGFzaCBvZiBwcm9wZXJ0aWVzIHRoYXQgb3ZlcnJpZGUgdGhvc2VcbiAqICAgYWxyZWFkeSBpbiB0aGUgdG9rZW4sIG9yIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdG9rZW4uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBhc3ROb2RlKHRva2VuLCBvdmVycmlkZSkge1xuICBvdmVycmlkZSB8fCAob3ZlcnJpZGUgPSB7fSk7XG5cbiAgdmFyIGtleTtcbiAgdmFyIGtleXMgPSBbJ3R5cGUnLCAnbmFtZScsICd2YWx1ZSddO1xuICB2YXIgbm9kZSA9IHt9O1xuXG4gIC8vIEF2b2lkaW5nIFtdLmZvckVhY2ggZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG5cbiAgICBpZiAodG9rZW5ba2V5XSkge1xuICAgICAgbm9kZVtrZXldID0gb3ZlcnJpZGVba2V5XSB8fCB0b2tlbltrZXldO1xuICAgIH1cbiAgfVxuXG4gIGtleXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKCFub2RlW2tleV0pIHtcbiAgICAgIG5vZGVba2V5XSA9IG92ZXJyaWRlW2tleV07XG4gICAgfVxuICB9XG5cbiAgaWYgKF9wb3NpdGlvbikge1xuICAgIG5vZGUucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogdG9rZW4uc3RhcnQsXG4gICAgICBlbmQ6IHRva2VuLmVuZFxuICAgIH07XG4gIH1cblxuICBERUJVRyAmJiBkZWJ1ZygnYXN0Tm9kZTonLCBKU09OLnN0cmluZ2lmeShub2RlLCBudWxsLCAyKSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgbGV4aWNhbCB0b2tlbiBmcm9tIHRoZSBzdGFjayBhbmQgcmV0dXJuIHRoZSByZW1vdmVkIHRva2VuLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGxleGljYWwgdG9rZW5cbiAqL1xuZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHRva2VuID0gX3Rva2Vucy5zaGlmdCgpO1xuICBERUJVRyAmJiBkZWJ1ZygnbmV4dDonLCBKU09OLnN0cmluZ2lmeSh0b2tlbiwgbnVsbCwgMikpO1xuICByZXR1cm4gdG9rZW47XG59XG5cbi8vIC0tIFBhcnNlKiBGdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQ29udmVydCBhbiBALWdyb3VwIGxleGljYWwgdG9rZW4gdG8gYW4gQVNUIG5vZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIEAtZ3JvdXAgbGV4aWNhbCB0b2tlblxuICogQHJldHVybnMge09iamVjdH0gQC1ncm91cCBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZUF0R3JvdXAodG9rZW4pIHtcbiAgX2RlcHRoID0gX2RlcHRoICsgMTtcblxuICAvLyBBcyB0aGUgQC1ncm91cCB0b2tlbiBpcyBhc3NlbWJsZWQsIHJlbGV2YW50IHRva2VuIHZhbHVlcyBhcmUgY2FwdHVyZWQgaGVyZVxuICAvLyB0ZW1wb3JhcmlseS4gVGhleSB3aWxsIGxhdGVyIGJlIHVzZWQgYXMgYHRva2VuaXplKClgIG92ZXJyaWRlcy5cbiAgdmFyIG92ZXJyaWRlcyA9IHt9O1xuXG4gIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICBjYXNlICdmb250LWZhY2UnOlxuICBjYXNlICd2aWV3cG9ydCcgOlxuICAgIG92ZXJyaWRlcy5kZWNsYXJhdGlvbnMgPSBwYXJzZURlY2xhcmF0aW9ucygpO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ3BhZ2UnOlxuICAgIG92ZXJyaWRlcy5wcmVmaXggPSB0b2tlbi5wcmVmaXg7XG4gICAgb3ZlcnJpZGVzLmRlY2xhcmF0aW9ucyA9IHBhcnNlRGVjbGFyYXRpb25zKCk7XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICBvdmVycmlkZXMucHJlZml4ID0gdG9rZW4ucHJlZml4O1xuICAgIG92ZXJyaWRlcy5ydWxlcyA9IHBhcnNlUnVsZXMoKTtcbiAgfVxuXG4gIHJldHVybiBhc3ROb2RlKHRva2VuLCBvdmVycmlkZXMpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQGltcG9ydCBsZXhpY2FsIHRva2VuIHRvIGFuIEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBAaW1wb3J0IGxleGljYWwgdG9rZW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEBpbXBvcnQgQVNUIG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBdEltcG9ydCh0b2tlbikge1xuICByZXR1cm4gYXN0Tm9kZSh0b2tlbik7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBAY2hhcnNldCB0b2tlbiB0byBhbiBBU1Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gQGNoYXJzZXQgbGV4aWNhbCB0b2tlblxuICogQHJldHVybnMge09iamVjdH0gQGNoYXJzZXQgbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZUNoYXJzZXQodG9rZW4pIHtcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBjb21tZW50IHRva2VuIHRvIGFuIEFTVCBOb2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBjb21tZW50IGxleGljYWwgdG9rZW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGNvbW1lbnQgbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZUNvbW1lbnQodG9rZW4pIHtcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4sIHt0ZXh0OiB0b2tlbi50ZXh0fSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTmFtZXNwYWNlKHRva2VuKSB7XG4gIHJldHVybiBhc3ROb2RlKHRva2VuKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcHJvcGVydHkgbGV4aWNhbCB0b2tlbiB0byBhIHByb3BlcnR5IEFTVCBub2RlLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IHByb3BlcnR5IG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eSh0b2tlbikge1xuICByZXR1cm4gYXN0Tm9kZSh0b2tlbik7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHNlbGVjdG9yIGxleGljYWwgdG9rZW4gdG8gYSBzZWxlY3RvciBBU1Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gc2VsZWN0b3IgbGV4aWNhbCB0b2tlblxuICogQHJldHVybnMge09iamVjdH0gc2VsZWN0b3Igbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZVNlbGVjdG9yKHRva2VuKSB7XG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH1cblxuICByZXR1cm4gYXN0Tm9kZSh0b2tlbiwge1xuICAgIHR5cGU6ICdydWxlJyxcbiAgICBzZWxlY3RvcnM6IHRva2VuLnRleHQuc3BsaXQoJywnKS5tYXAodHJpbSksXG4gICAgZGVjbGFyYXRpb25zOiBwYXJzZURlY2xhcmF0aW9ucyh0b2tlbilcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIGxleGljYWwgdG9rZW4gdG8gYW4gQVNUIG5vZGUuXG4gKlxuICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9IEFTVCBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVG9rZW4odG9rZW4pIHtcbiAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gIC8vIENhc2VzIGFyZSBsaXN0ZWQgaW4gcm91Z2hseSBkZXNjZW5kaW5nIG9yZGVyIG9mIHByb2JhYmlsaXR5LlxuICBjYXNlICdwcm9wZXJ0eSc6IHJldHVybiBwYXJzZVByb3BlcnR5KHRva2VuKTtcblxuICBjYXNlICdzZWxlY3Rvcic6IHJldHVybiBwYXJzZVNlbGVjdG9yKHRva2VuKTtcblxuICBjYXNlICdhdC1ncm91cC1lbmQnOiBfZGVwdGggPSBfZGVwdGggLSAxOyByZXR1cm47XG5cbiAgY2FzZSAnbWVkaWEnICAgICA6XG4gIGNhc2UgJ2tleWZyYW1lcycgOnJldHVybiBwYXJzZUF0R3JvdXAodG9rZW4pO1xuXG4gIGNhc2UgJ2NvbW1lbnQnOiBpZiAoX2NvbW1lbnRzKSB7IHJldHVybiBwYXJzZUNvbW1lbnQodG9rZW4pOyB9IGJyZWFrO1xuXG4gIGNhc2UgJ2NoYXJzZXQnOiByZXR1cm4gcGFyc2VDaGFyc2V0KHRva2VuKTtcbiAgY2FzZSAnaW1wb3J0JzogcmV0dXJuIHBhcnNlQXRJbXBvcnQodG9rZW4pO1xuXG4gIGNhc2UgJ25hbWVzcGFjZSc6IHJldHVybiBwYXJzZU5hbWVzcGFjZSh0b2tlbik7XG5cbiAgY2FzZSAnZm9udC1mYWNlJzpcbiAgY2FzZSAnc3VwcG9ydHMnIDpcbiAgY2FzZSAndmlld3BvcnQnIDpcbiAgY2FzZSAnZG9jdW1lbnQnIDpcbiAgY2FzZSAncGFnZScgICAgIDogcmV0dXJuIHBhcnNlQXRHcm91cCh0b2tlbik7XG4gIH1cblxuICBERUJVRyAmJiBkZWJ1ZygncGFyc2VUb2tlbjogdW5leHBlY3RlZCB0b2tlbjonLCBKU09OLnN0cmluZ2lmeSh0b2tlbikpO1xufVxuXG4vLyAtLSBQYXJzZSBIZWxwZXIgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEl0ZXJhdGl2ZWx5IHBhcnNlcyBsZXhpY2FsIHRva2VucyBmcm9tIHRoZSBzdGFjayBpbnRvIEFTVCBub2RlcyB1bnRpbCBhXG4gKiBjb25kaXRpb25hbCBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAsIGF0IHdoaWNoIHBvaW50IGl0ZXJhdGlvbiB0ZXJtaW5hdGVzXG4gKiBhbmQgYW55IEFTVCBub2RlcyBjb2xsZWN0ZWQgYXJlIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbkZuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiB0aGUgbGV4aWNhbCB0b2tlbiBiZWluZyBwYXJzZWRcbiAqICAgQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdG9rZW4gc2hvdWxkIGJlIHBhcnNlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEByZXR1cm4ge0FycmF5fSBBU1Qgbm9kZXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VUb2tlbnNXaGlsZShjb25kaXRpb25Gbikge1xuICB2YXIgbm9kZTtcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciB0b2tlbjtcblxuICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSAmJiAoY29uZGl0aW9uRm4gJiYgY29uZGl0aW9uRm4odG9rZW4pKSkge1xuICAgIG5vZGUgPSBwYXJzZVRva2VuKHRva2VuKTtcbiAgICBub2RlICYmIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cblxuICAvLyBQbGFjZSBhbiB1bnVzZWQgbm9uLWBlbmRgIGxleGljYWwgdG9rZW4gYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUgIT09ICdlbmQnKSB7XG4gICAgX3Rva2Vucy51bnNoaWZ0KHRva2VuKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc2VyaWVzIG9mIHRva2VucyBpbnRvIGEgc2VxdWVuY2Ugb2YgZGVjbGFyYXRpb24gQVNUIG5vZGVzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX0gZGVjbGFyYXRpb24gbm9kZXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VEZWNsYXJhdGlvbnMoKSB7XG4gIHJldHVybiBwYXJzZVRva2Vuc1doaWxlKGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHJldHVybiAodG9rZW4udHlwZSA9PT0gJ3Byb3BlcnR5JyB8fCB0b2tlbi50eXBlID09PSAnY29tbWVudCcpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc2VyaWVzIG9mIHRva2VucyBpbnRvIGEgc2VxdWVuY2Ugb2YgcnVsZSBub2Rlcy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9IHJ1bGUgbm9kZXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VSdWxlcygpIHtcbiAgcmV0dXJuIHBhcnNlVG9rZW5zV2hpbGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX2RlcHRoOyB9KTtcbn1cbiIsInZhciBERUJVRyA9IGZhbHNlOyAvLyBgdHJ1ZWAgdG8gcHJpbnQgZGVidWdnaW5nIGluZm8uXG52YXIgVElNRVIgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHRpbWUgY2FsbHMgdG8gYHN0cmluZ2lmeSgpYCBhbmQgcHJpbnQgdGhlIHJlc3VsdHMuXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKSgnc3RyaW5naWZ5Jyk7XG5cbnZhciBfY29tbWVudHM7ICAgICAgLy8gV2hldGhlciBjb21tZW50cyBhcmUgYWxsb3dlZCBpbiB0aGUgc3RyaW5naWZpZWQgQ1NTLlxudmFyIF9jb21wcmVzczsgICAgICAvLyBXaGV0aGVyIHRoZSBzdHJpbmdpZmllZCBDU1Mgc2hvdWxkIGJlIGNvbXByZXNzZWQuXG52YXIgX2luZGVudGF0aW9uOyAgIC8vIEluZGVudGF0aW9uIG9wdGlvbiB2YWx1ZS5cbnZhciBfbjsgICAgICAgICAgICAgLy8gQ29tcHJlc3Npb24tYXdhcmUgbmV3bGluZSBjaGFyYWN0ZXIuXG52YXIgX3M7ICAgICAgICAgICAgIC8vIENvbXByZXNzaW9uLWF3YXJlIHNwYWNlIGNoYXJhY3Rlci5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5O1xuXG4vKipcbiAqIENvbnZlcnQgYSBgc3RyaW5naWZ5YC1hYmxlIEFTVCBpbnRvIGEgQ1NTIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYHN0cmluZ2lmeWAtYWJsZSBBU1RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tbWVudHM9ZmFsc2VdIGFsbG93IGNvbW1lbnRzIGluIHRoZSBDU1NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIGNvbXByZXNzIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbmRlbnRhdGlvbj0nJ10gaW5kZW50YXRpb24gc2VxdWVuY2VcbiAqIEByZXR1cm5zIHtTdHJpbmd9IENTU1xuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXN0LCBvcHRpb25zKSB7XG4gIHZhciBzdGFydDsgLy8gRGVidWcgdGltZXIgc3RhcnQuXG5cbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgX2luZGVudGF0aW9uID0gb3B0aW9ucy5pbmRlbnRhdGlvbiB8fCAnJztcbiAgX2NvbXByZXNzID0gISFvcHRpb25zLmNvbXByZXNzO1xuICBfY29tbWVudHMgPSAhIW9wdGlvbnMuY29tbWVudHM7XG5cbiAgaWYgKF9jb21wcmVzcykge1xuICAgIF9uID0gX3MgPSAnJztcbiAgfSBlbHNlIHtcbiAgICBfbiA9ICdcXG4nO1xuICAgIF9zID0gJyAnO1xuICB9XG5cbiAgVElNRVIgJiYgKHN0YXJ0ID0gRGF0ZS5ub3coKSk7XG5cbiAgdmFyIGNzcyA9IHJlZHVjZShhc3Quc3R5bGVzaGVldC5ydWxlcywgc3RyaW5naWZ5Tm9kZSkuam9pbignXFxuJykudHJpbSgpO1xuXG4gIFRJTUVSICYmIGRlYnVnKCdyYW4gaW4nLCAoRGF0ZS5ub3coKSAtIHN0YXJ0KSArICdtcycpO1xuXG4gIHJldHVybiBjc3M7XG59XG5cbi8vIC0tIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIE1vZGlmeSB0aGUgaW5kZW50YXRpb24gbGV2ZWwsIG9yIHJldHVybiBhIGNvbXByZXNzaW9uLWF3YXJlIHNlcXVlbmNlIG9mXG4gKiBzcGFjZXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbD11bmRlZmluZWRdIGluZGVudGF0aW9uIGxldmVsIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzZXF1ZW5jZSBvZiBzcGFjZXNcbiAqL1xuZnVuY3Rpb24gaW5kZW50KGxldmVsKSB7XG4gIHRoaXMubGV2ZWwgfHwgKHRoaXMubGV2ZWwgPSAxKTtcblxuICBpZiAobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsICs9IGxldmVsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChfY29tcHJlc3MpIHsgcmV0dXJuICcnOyB9XG5cbiAgcmV0dXJuIEFycmF5KHRoaXMubGV2ZWwpLmpvaW4oX2luZGVudGF0aW9uIHx8ICcnKTtcbn1cblxuLy8gLS0gU3RyaW5naWZ5IEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gQC1ydWxlIEFTVCBub2RlLlxuICpcbiAqIFVzZSBgc3RyaW5naWZ5QXRHcm91cCgpYCB3aGVuIGRlYWxpbmcgd2l0aCBALWdyb3VwcyB0aGF0IG1heSBjb250YWluIGJsb2Nrc1xuICogc3VjaCBhcyBAbWVkaWEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQC1ydWxlIHR5cGUuIEUuZy4sIGltcG9ydCwgY2hhcnNldFxuICogQHJldHVybnMge1N0cmluZ30gU3RyaW5naWZpZWQgQC1ydWxlXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUF0UnVsZShub2RlKSB7XG4gIHJldHVybiAnQCcgKyBub2RlLnR5cGUgKyAnICcgKyBub2RlLnZhbHVlICsgJzsnICsgX247XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIEAtZ3JvdXAgQVNUIG5vZGUuXG4gKlxuICogVXNlIGBzdHJpbmdpZnlBdFJ1bGUoKWAgd2hlbiBkZWFsaW5nIHdpdGggQC1ydWxlcyB0aGF0IG1heSBub3QgY29udGFpbiBibG9ja3NcbiAqIHN1Y2ggYXMgQGltcG9ydC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBALWdyb3VwIEFTVCBub2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlBdEdyb3VwKG5vZGUpIHtcbiAgdmFyIGxhYmVsID0gJyc7XG4gIHZhciBwcmVmaXggPSBub2RlLnByZWZpeCB8fCAnJztcblxuICBpZiAobm9kZS5uYW1lKSB7XG4gICAgbGFiZWwgPSAnICcgKyBub2RlLm5hbWU7XG4gIH1cblxuICAvLyBGSVhNRTogQC1ydWxlIGNvbmRpdGlvbmFsIGxvZ2ljIGlzIGxlYWtpbmcgZXZlcnl3aGVyZS5cbiAgdmFyIGNob21wID0gbm9kZS50eXBlICE9PSAncGFnZSc7XG5cbiAgcmV0dXJuICdAJyArIHByZWZpeCArIG5vZGUudHlwZSArIGxhYmVsICsgX3MgKyBzdHJpbmdpZnlCbG9jayhub2RlLCBjaG9tcCkgKyBfbjtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgYSBjb21tZW50IEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGNvbW1lbnQgQVNUIG5vZGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnQobm9kZSkge1xuICBpZiAoIV9jb21tZW50cykgeyByZXR1cm4gJyc7IH1cblxuICByZXR1cm4gJy8qJyArIChub2RlLnRleHQgfHwgJycpICsgJyovJyArIF9uO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSBhIHJ1bGUgQVNUIG5vZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgcnVsZSBBU1Qgbm9kZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShub2RlKSB7XG4gIHZhciBsYWJlbDtcblxuICBpZiAobm9kZS5zZWxlY3RvcnMpIHtcbiAgICBsYWJlbCA9IG5vZGUuc2VsZWN0b3JzLmpvaW4oJywnICsgX24pO1xuICB9IGVsc2Uge1xuICAgIGxhYmVsID0gJ0AnICsgbm9kZS50eXBlO1xuICAgIGxhYmVsICs9IG5vZGUubmFtZSA/ICcgJyArIG5vZGUubmFtZSA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIGluZGVudCgpICsgbGFiZWwgKyBfcyArIHN0cmluZ2lmeUJsb2NrKG5vZGUpICsgX247XG59XG5cblxuLy8gLS0gU3RyaW5naWZ5IEhlbHBlciBGdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSZWR1Y2UgYW4gYXJyYXkgYnkgYXBwbHlpbmcgYSBmdW5jdGlvbiB0byBlYWNoIGl0ZW0gYW5kIHJldGFpbmluZyB0aGUgdHJ1dGh5XG4gKiByZXN1bHRzLlxuICpcbiAqIFdoZW4gYGl0ZW0udHlwZWAgaXMgYCdjb21tZW50J2AgYHN0cmluZ2lmeUNvbW1lbnRgIHdpbGwgYmUgYXBwbGllZCBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIGFycmF5IHRvIHJlZHVjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheVxuICogICBAcmV0dXJucyB7TWl4ZWR9IFRydXRoeSB2YWx1ZXMgd2lsbCBiZSByZXRhaW5lZCwgZmFsc3kgdmFsdWVzIG9taXR0ZWRcbiAqIEByZXR1cm5zIHtBcnJheX0gcmV0YWluZWQgcmVzdWx0c1xuICovXG5mdW5jdGlvbiByZWR1Y2UoaXRlbXMsIGZuKSB7XG4gIHJldHVybiBpdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdHMsIGl0ZW0pIHtcbiAgICB2YXIgcmVzdWx0ID0gKGl0ZW0udHlwZSA9PT0gJ2NvbW1lbnQnKSA/IHN0cmluZ2lmeUNvbW1lbnQoaXRlbSkgOiBmbihpdGVtKTtcbiAgICByZXN1bHQgJiYgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gQVNUIG5vZGUgd2l0aCB0aGUgYXNzdW1wdGlvbiB0aGF0IGl0IHJlcHJlc2VudHMgYSBibG9jayBvZlxuICogZGVjbGFyYXRpb25zIG9yIG90aGVyIEAtZ3JvdXAgY29udGVudHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQVNUIG5vZGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbi8vIEZJWE1FOiBjaG9tcCBzaG91bGQgbm90IGJlIGEgbWFnaWMgYm9vbGVhbiBwYXJhbWV0ZXJcbmZ1bmN0aW9uIHN0cmluZ2lmeUJsb2NrKG5vZGUsIGNob21wKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuZGVjbGFyYXRpb25zO1xuICB2YXIgZm4gPSBzdHJpbmdpZnlEZWNsYXJhdGlvbjtcblxuICBpZiAobm9kZS5ydWxlcykge1xuICAgIGNoaWxkcmVuID0gbm9kZS5ydWxlcztcbiAgICBmbiA9IHN0cmluZ2lmeVJ1bGU7XG4gIH1cblxuICBjaGlsZHJlbiA9IHN0cmluZ2lmeUNoaWxkcmVuKGNoaWxkcmVuLCBmbik7XG4gIGNoaWxkcmVuICYmIChjaGlsZHJlbiA9IF9uICsgY2hpbGRyZW4gKyAoY2hvbXAgPyAnJyA6IF9uKSk7XG5cbiAgcmV0dXJuICd7JyArIGNoaWxkcmVuICsgaW5kZW50KCkgKyAnfSc7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIGFycmF5IG9mIGNoaWxkIEFTVCBub2RlcyBieSBjYWxsaW5nIHRoZSBnaXZlbiBzdHJpbmdpZnkgZnVuY3Rpb25cbiAqIG9uY2UgZm9yIGVhY2ggY2hpbGQsIGFuZCBjb25jYXRlbmF0aW5nIHRoZSByZXN1bHRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNoaWxkcmVuIGBub2RlLnJ1bGVzYCBvciBgbm9kZS5kZWNsYXJhdGlvbnNgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBzdHJpbmdpZnkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUNoaWxkcmVuKGNoaWxkcmVuLCBmbikge1xuICBpZiAoIWNoaWxkcmVuKSB7IHJldHVybiAnJzsgfVxuXG4gIGluZGVudCgxKTtcbiAgdmFyIHJlc3VsdHMgPSByZWR1Y2UoY2hpbGRyZW4sIGZuKTtcbiAgaW5kZW50KC0xKTtcblxuICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7IHJldHVybiAnJzsgfVxuXG4gIHJldHVybiByZXN1bHRzLmpvaW4oX24pO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSBhIGRlY2xhcmF0aW9uIEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGRlY2xhcmF0aW9uIEFTVCBub2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlEZWNsYXJhdGlvbihub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5UHJvcGVydHkobm9kZSk7XG4gIH1cblxuICBERUJVRyAmJiBkZWJ1Zygnc3RyaW5naWZ5RGVjbGFyYXRpb246IHVuZXhwZWN0ZWQgbm9kZTonLCBKU09OLnN0cmluZ2lmeShub2RlKSk7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIEFTVCBub2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlOb2RlKG5vZGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgLy8gQ2FzZXMgYXJlIGxpc3RlZCBpbiByb3VnaGx5IGRlc2NlbmRpbmcgb3JkZXIgb2YgcHJvYmFiaWxpdHkuXG4gIGNhc2UgJ3J1bGUnOiByZXR1cm4gc3RyaW5naWZ5UnVsZShub2RlKTtcblxuICBjYXNlICdtZWRpYScgICAgOlxuICBjYXNlICdrZXlmcmFtZXMnOiByZXR1cm4gc3RyaW5naWZ5QXRHcm91cChub2RlKTtcblxuICBjYXNlICdjb21tZW50JzogcmV0dXJuIHN0cmluZ2lmeUNvbW1lbnQobm9kZSk7XG5cbiAgY2FzZSAnaW1wb3J0JyAgIDpcbiAgY2FzZSAnY2hhcnNldCcgIDpcbiAgY2FzZSAnbmFtZXNwYWNlJzogcmV0dXJuIHN0cmluZ2lmeUF0UnVsZShub2RlKTtcblxuICBjYXNlICdmb250LWZhY2UnOlxuICBjYXNlICdzdXBwb3J0cycgOlxuICBjYXNlICd2aWV3cG9ydCcgOlxuICBjYXNlICdkb2N1bWVudCcgOlxuICBjYXNlICdwYWdlJyAgICAgOiByZXR1cm4gc3RyaW5naWZ5QXRHcm91cChub2RlKTtcbiAgfVxuXG4gIERFQlVHICYmIGRlYnVnKCdzdHJpbmdpZnlOb2RlOiB1bmV4cGVjdGVkIG5vZGU6ICcgKyBKU09OLnN0cmluZ2lmeShub2RlKSk7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIEFTVCBwcm9wZXJ0eSBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIEFTVCBwcm9wZXJ0eSBub2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wZXJ0eShub2RlKSB7XG4gIHZhciBuYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lICsgJzonICsgX3MgOiAnJztcblxuICByZXR1cm4gaW5kZW50KCkgKyBuYW1lICsgbm9kZS52YWx1ZSArICc7Jztcbn1cbiIsIi8qXG5TbGljayBQYXJzZXJcbiAtIG9yaWdpbmFsbHkgY3JlYXRlZCBieSB0aGUgYWxtaWdodHkgVGhvbWFzIEF5bG90dCA8QHN1YnRsZWdyYWRpZW50PiAoaHR0cDovL3N1YnRsZWdyYWRpZW50LmNvbSlcbiovXCJ1c2Ugc3RyaWN0XCJcblxuLy8gTm90YWJsZSBjaGFuZ2VzIGZyb20gU2xpY2suUGFyc2VyIDEuMC54XG5cbi8vIFRoZSBwYXJzZXIgbm93IHVzZXMgMiBjbGFzc2VzOiBFeHByZXNzaW9ucyBhbmQgRXhwcmVzc2lvblxuLy8gYG5ldyBFeHByZXNzaW9uc2AgcHJvZHVjZXMgYW4gYXJyYXktbGlrZSBvYmplY3QgY29udGFpbmluZyBhIGxpc3Qgb2YgRXhwcmVzc2lvbiBvYmplY3RzXG4vLyAtIEV4cHJlc3Npb25zOjp0b1N0cmluZygpIHByb2R1Y2VzIGEgY2xlYW5lZCB1cCBleHByZXNzaW9ucyBzdHJpbmdcbi8vIGBuZXcgRXhwcmVzc2lvbmAgcHJvZHVjZXMgYW4gYXJyYXktbGlrZSBvYmplY3Rcbi8vIC0gRXhwcmVzc2lvbjo6dG9TdHJpbmcoKSBwcm9kdWNlcyBhIGNsZWFuZWQgdXAgZXhwcmVzc2lvbiBzdHJpbmdcbi8vIFRoZSBvbmx5IGV4cG9zZWQgbWV0aG9kIGlzIHBhcnNlLCB3aGljaCBwcm9kdWNlcyBhIChjYWNoZWQpIGBuZXcgRXhwcmVzc2lvbnNgIGluc3RhbmNlXG4vLyBwYXJzZWQucmF3IGlzIG5vIGxvbmdlciBwcmVzZW50LCB1c2UgLnRvU3RyaW5nKClcbi8vIHBhcnNlZC5leHByZXNzaW9uIGlzIG5vdyB1c2VsZXNzLCBqdXN0IHVzZSB0aGUgaW5kaWNlc1xuLy8gcGFyc2VkLnJldmVyc2UoKSBoYXMgYmVlbiByZW1vdmVkIGZvciBub3csIGR1ZSB0byBpdHMgYXBwYXJlbnQgdXNlbGVzc25lc3Ncbi8vIE90aGVyIGNoYW5nZXMgaW4gdGhlIEV4cHJlc3Npb25zIG9iamVjdDpcbi8vIC0gY2xhc3NOYW1lcyBhcmUgbm93IHVuaXF1ZSwgYW5kIHNhdmUgYm90aCBlc2NhcGVkIGFuZCB1bmVzY2FwZWQgdmFsdWVzXG4vLyAtIGF0dHJpYnV0ZXMgbm93IHNhdmUgYm90aCBlc2NhcGVkIGFuZCB1bmVzY2FwZWQgdmFsdWVzXG4vLyAtIHBzZXVkb3Mgbm93IHNhdmUgYm90aCBlc2NhcGVkIGFuZCB1bmVzY2FwZWQgdmFsdWVzXG5cbnZhciBlc2NhcGVSZSAgID0gLyhbLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdKS9nLFxuICAgIHVuZXNjYXBlUmUgPSAvXFxcXC9nXG5cbnZhciBlc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpe1xuICAgIC8vIFhSZWdFeHAgdjIuMC4wLWJldGEtM1xuICAgIC8vIMKrIGh0dHBzOi8vZ2l0aHViLmNvbS9zbGV2aXRoYW4vWFJlZ0V4cC9ibG9iL21hc3Rlci9zcmMveHJlZ2V4cC5qc1xuICAgIHJldHVybiAoc3RyaW5nICsgXCJcIikucmVwbGFjZShlc2NhcGVSZSwgJ1xcXFwkMScpXG59XG5cbnZhciB1bmVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgcmV0dXJuIChzdHJpbmcgKyBcIlwiKS5yZXBsYWNlKHVuZXNjYXBlUmUsICcnKVxufVxuXG52YXIgc2xpY2tSZSA9IFJlZ0V4cChcbi8qXG4jIS91c3IvYmluL2VudiBydWJ5XG5wdXRzIFwiXFx0XFx0XCIgKyBEQVRBLnJlYWQuZ3N1YigvXFwoXFw/eFxcKXxcXHMrIy4qJHxcXHMrfFxcXFwkfFxcXFxuLywnJylcbl9fRU5EX19cbiAgICBcIig/eCleKD86XFxcbiAgICAgIFxcXFxzKiAoICwgKSBcXFxccyogICAgICAgICAgICAgICAjIFNlcGFyYXRvciAgICAgICAgICBcXG5cXFxuICAgIHwgXFxcXHMqICggPGNvbWJpbmF0b3I+KyApIFxcXFxzKiAgICMgQ29tYmluYXRvciAgICAgICAgIFxcblxcXG4gICAgfCAgICAgICggXFxcXHMrICkgICAgICAgICAgICAgICAgICMgQ29tYmluYXRvckNoaWxkcmVuIFxcblxcXG4gICAgfCAgICAgICggPHVuaWNvZGU+KyB8IFxcXFwqICkgICAgICMgVGFnICAgICAgICAgICAgICAgIFxcblxcXG4gICAgfCBcXFxcIyAgKCA8dW5pY29kZT4rICAgICAgICkgICAgICMgSUQgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgfCBcXFxcLiAgKCA8dW5pY29kZT4rICAgICAgICkgICAgICMgQ2xhc3NOYW1lICAgICAgICAgIFxcblxcXG4gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEF0dHJpYnV0ZSAgICAgICAgICBcXG5cXFxuICAgIFxcXFxbICBcXFxuICAgICAgICBcXFxccyogKDx1bmljb2RlMT4rKSAgKD86ICBcXFxuICAgICAgICAgICAgXFxcXHMqIChbKl4kIX58XT89KSAgKD86ICBcXFxuICAgICAgICAgICAgICAgIFxcXFxzKiAoPzpcXFxuICAgICAgICAgICAgICAgICAgICAoW1xcXCInXT8pKC4qPylcXFxcOSBcXFxuICAgICAgICAgICAgICAgIClcXFxuICAgICAgICAgICAgKSAgXFxcbiAgICAgICAgKT8gIFxcXFxzKiAgXFxcbiAgICBcXFxcXSg/IVxcXFxdKSBcXG5cXFxuICAgIHwgICA6KyAoIDx1bmljb2RlPisgKSg/OlxcXG4gICAgXFxcXCggKD86XFxcbiAgICAgICAgKD86KFtcXFwiJ10pKFteXFxcXDEyXSopXFxcXDEyKXwoKD86XFxcXChbXildK1xcXFwpfFteKCldKikrKVxcXG4gICAgKSBcXFxcKVxcXG4gICAgKT9cXFxuICAgIClcIlxuKi9cblwiXig/OlxcXFxzKigsKVxcXFxzKnxcXFxccyooPGNvbWJpbmF0b3I+KylcXFxccyp8KFxcXFxzKyl8KDx1bmljb2RlPit8XFxcXCopfFxcXFwjKDx1bmljb2RlPispfFxcXFwuKDx1bmljb2RlPispfFxcXFxbXFxcXHMqKDx1bmljb2RlMT4rKSg/OlxcXFxzKihbKl4kIX58XT89KSg/OlxcXFxzKig/OihbXFxcIiddPykoLio/KVxcXFw5KSkpP1xcXFxzKlxcXFxdKD8hXFxcXF0pfCg6KykoPHVuaWNvZGU+KykoPzpcXFxcKCg/Oig/OihbXFxcIiddKShbXlxcXFwxM10qKVxcXFwxMyl8KCg/OlxcXFwoW14pXStcXFxcKXxbXigpXSopKykpXFxcXCkpPylcIlxuICAgIC5yZXBsYWNlKC88Y29tYmluYXRvcj4vLCAnWycgKyBlc2NhcGUoXCI+K35gIUAkJV4mPXt9XFxcXDs8L1wiKSArICddJylcbiAgICAucmVwbGFjZSgvPHVuaWNvZGU+L2csICcoPzpbXFxcXHdcXFxcdTAwYTEtXFxcXHVGRkZGLV18XFxcXFxcXFxbXlxcXFxzMC05YS1mXSknKVxuICAgIC5yZXBsYWNlKC88dW5pY29kZTE+L2csICcoPzpbOlxcXFx3XFxcXHUwMGExLVxcXFx1RkZGRi1dfFxcXFxcXFxcW15cXFxcczAtOWEtZl0pJylcbilcblxuLy8gUGFydFxuXG52YXIgUGFydCA9IGZ1bmN0aW9uIFBhcnQoY29tYmluYXRvcil7XG4gICAgdGhpcy5jb21iaW5hdG9yID0gY29tYmluYXRvciB8fCBcIiBcIlxuICAgIHRoaXMudGFnID0gXCIqXCJcbn1cblxuUGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuXG4gICAgaWYgKCF0aGlzLnJhdyl7XG5cbiAgICAgICAgdmFyIHhwciA9IFwiXCIsIGssIHBhcnRcblxuICAgICAgICB4cHIgKz0gdGhpcy50YWcgfHwgXCIqXCJcbiAgICAgICAgaWYgKHRoaXMuaWQpIHhwciArPSBcIiNcIiArIHRoaXMuaWRcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NlcykgeHByICs9IFwiLlwiICsgdGhpcy5jbGFzc0xpc3Quam9pbihcIi5cIilcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcykgZm9yIChrID0gMDsgcGFydCA9IHRoaXMuYXR0cmlidXRlc1trKytdOyl7XG4gICAgICAgICAgICB4cHIgKz0gXCJbXCIgKyBwYXJ0Lm5hbWUgKyAocGFydC5vcGVyYXRvciA/IHBhcnQub3BlcmF0b3IgKyAnXCInICsgcGFydC52YWx1ZSArICdcIicgOiAnJykgKyBcIl1cIlxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBzZXVkb3MpIGZvciAoayA9IDA7IHBhcnQgPSB0aGlzLnBzZXVkb3NbaysrXTspe1xuICAgICAgICAgICAgeHByICs9IFwiOlwiICsgcGFydC5uYW1lXG4gICAgICAgICAgICBpZiAocGFydC52YWx1ZSkgeHByICs9IFwiKFwiICsgcGFydC52YWx1ZSArIFwiKVwiXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJhdyA9IHhwclxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmF3XG59XG5cbi8vIEV4cHJlc3Npb25cblxudmFyIEV4cHJlc3Npb24gPSBmdW5jdGlvbiBFeHByZXNzaW9uKCl7XG4gICAgdGhpcy5sZW5ndGggPSAwXG59XG5cbkV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcblxuICAgIGlmICghdGhpcy5yYXcpe1xuXG4gICAgICAgIHZhciB4cHIgPSBcIlwiXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGJpdDsgYml0ID0gdGhpc1tqKytdOyl7XG4gICAgICAgICAgICBpZiAoaiAhPT0gMSkgeHByICs9IFwiIFwiXG4gICAgICAgICAgICBpZiAoYml0LmNvbWJpbmF0b3IgIT09IFwiIFwiKSB4cHIgKz0gYml0LmNvbWJpbmF0b3IgKyBcIiBcIlxuICAgICAgICAgICAgeHByICs9IGJpdFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yYXcgPSB4cHJcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJhd1xufVxuXG52YXIgcmVwbGFjZXIgPSBmdW5jdGlvbihcbiAgICByYXdNYXRjaCxcblxuICAgIHNlcGFyYXRvcixcbiAgICBjb21iaW5hdG9yLFxuICAgIGNvbWJpbmF0b3JDaGlsZHJlbixcblxuICAgIHRhZ05hbWUsXG4gICAgaWQsXG4gICAgY2xhc3NOYW1lLFxuXG4gICAgYXR0cmlidXRlS2V5LFxuICAgIGF0dHJpYnV0ZU9wZXJhdG9yLFxuICAgIGF0dHJpYnV0ZVF1b3RlLFxuICAgIGF0dHJpYnV0ZVZhbHVlLFxuXG4gICAgcHNldWRvTWFya2VyLFxuICAgIHBzZXVkb0NsYXNzLFxuICAgIHBzZXVkb1F1b3RlLFxuICAgIHBzZXVkb0NsYXNzUXVvdGVkVmFsdWUsXG4gICAgcHNldWRvQ2xhc3NWYWx1ZVxuKXtcblxuICAgIHZhciBleHByZXNzaW9uLCBjdXJyZW50XG5cbiAgICBpZiAoc2VwYXJhdG9yIHx8ICF0aGlzLmxlbmd0aCl7XG4gICAgICAgIGV4cHJlc3Npb24gPSB0aGlzW3RoaXMubGVuZ3RoKytdID0gbmV3IEV4cHJlc3Npb25cbiAgICAgICAgaWYgKHNlcGFyYXRvcikgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKCFleHByZXNzaW9uKSBleHByZXNzaW9uID0gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAoY29tYmluYXRvciB8fCBjb21iaW5hdG9yQ2hpbGRyZW4gfHwgIWV4cHJlc3Npb24ubGVuZ3RoKXtcbiAgICAgICAgY3VycmVudCA9IGV4cHJlc3Npb25bZXhwcmVzc2lvbi5sZW5ndGgrK10gPSBuZXcgUGFydChjb21iaW5hdG9yKVxuICAgIH1cblxuICAgIGlmICghY3VycmVudCkgY3VycmVudCA9IGV4cHJlc3Npb25bZXhwcmVzc2lvbi5sZW5ndGggLSAxXVxuXG4gICAgaWYgKHRhZ05hbWUpe1xuXG4gICAgICAgIGN1cnJlbnQudGFnID0gdW5lc2NhcGUodGFnTmFtZSlcblxuICAgIH0gZWxzZSBpZiAoaWQpe1xuXG4gICAgICAgIGN1cnJlbnQuaWQgPSB1bmVzY2FwZShpZClcblxuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lKXtcblxuICAgICAgICB2YXIgdW5lc2NhcGVkID0gdW5lc2NhcGUoY2xhc3NOYW1lKVxuXG4gICAgICAgIHZhciBjbGFzc2VzID0gY3VycmVudC5jbGFzc2VzIHx8IChjdXJyZW50LmNsYXNzZXMgPSB7fSlcbiAgICAgICAgaWYgKCFjbGFzc2VzW3VuZXNjYXBlZF0pe1xuICAgICAgICAgICAgY2xhc3Nlc1t1bmVzY2FwZWRdID0gZXNjYXBlKGNsYXNzTmFtZSlcbiAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSBjdXJyZW50LmNsYXNzTGlzdCB8fCAoY3VycmVudC5jbGFzc0xpc3QgPSBbXSlcbiAgICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKHVuZXNjYXBlZClcbiAgICAgICAgICAgIGNsYXNzTGlzdC5zb3J0KClcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChwc2V1ZG9DbGFzcyl7XG5cbiAgICAgICAgcHNldWRvQ2xhc3NWYWx1ZSA9IHBzZXVkb0NsYXNzVmFsdWUgfHwgcHNldWRvQ2xhc3NRdW90ZWRWYWx1ZVxuXG4gICAgICAgIDsoY3VycmVudC5wc2V1ZG9zIHx8IChjdXJyZW50LnBzZXVkb3MgPSBbXSkpLnB1c2goe1xuICAgICAgICAgICAgdHlwZSAgICAgICAgIDogcHNldWRvTWFya2VyLmxlbmd0aCA9PSAxID8gJ2NsYXNzJyA6ICdlbGVtZW50JyxcbiAgICAgICAgICAgIG5hbWUgICAgICAgICA6IHVuZXNjYXBlKHBzZXVkb0NsYXNzKSxcbiAgICAgICAgICAgIGVzY2FwZWROYW1lICA6IGVzY2FwZShwc2V1ZG9DbGFzcyksXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgOiBwc2V1ZG9DbGFzc1ZhbHVlID8gdW5lc2NhcGUocHNldWRvQ2xhc3NWYWx1ZSkgOiBudWxsLFxuICAgICAgICAgICAgZXNjYXBlZFZhbHVlIDogcHNldWRvQ2xhc3NWYWx1ZSA/IGVzY2FwZShwc2V1ZG9DbGFzc1ZhbHVlKSA6IG51bGxcbiAgICAgICAgfSlcblxuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlS2V5KXtcblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlID8gZXNjYXBlKGF0dHJpYnV0ZVZhbHVlKSA6IG51bGxcblxuICAgICAgICA7KGN1cnJlbnQuYXR0cmlidXRlcyB8fCAoY3VycmVudC5hdHRyaWJ1dGVzID0gW10pKS5wdXNoKHtcbiAgICAgICAgICAgIG9wZXJhdG9yICAgICA6IGF0dHJpYnV0ZU9wZXJhdG9yLFxuICAgICAgICAgICAgbmFtZSAgICAgICAgIDogdW5lc2NhcGUoYXR0cmlidXRlS2V5KSxcbiAgICAgICAgICAgIGVzY2FwZWROYW1lICA6IGVzY2FwZShhdHRyaWJ1dGVLZXkpLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgIDogYXR0cmlidXRlVmFsdWUgPyB1bmVzY2FwZShhdHRyaWJ1dGVWYWx1ZSkgOiBudWxsLFxuICAgICAgICAgICAgZXNjYXBlZFZhbHVlIDogYXR0cmlidXRlVmFsdWUgPyBlc2NhcGUoYXR0cmlidXRlVmFsdWUpIDogbnVsbFxuICAgICAgICB9KVxuXG4gICAgfVxuXG4gICAgcmV0dXJuICcnXG5cbn1cblxuLy8gRXhwcmVzc2lvbnNcblxudmFyIEV4cHJlc3Npb25zID0gZnVuY3Rpb24gRXhwcmVzc2lvbnMoZXhwcmVzc2lvbil7XG4gICAgdGhpcy5sZW5ndGggPSAwXG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIHZhciBvcmlnaW5hbCA9IGV4cHJlc3Npb24sIHJlcGxhY2VkXG5cbiAgICB3aGlsZSAoZXhwcmVzc2lvbil7XG4gICAgICAgIHJlcGxhY2VkID0gZXhwcmVzc2lvbi5yZXBsYWNlKHNsaWNrUmUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxuICAgICAgICB9KVxuICAgICAgICBpZiAocmVwbGFjZWQgPT09IGV4cHJlc3Npb24pIHRocm93IG5ldyBFcnJvcihvcmlnaW5hbCArICcgaXMgYW4gaW52YWxpZCBleHByZXNzaW9uJylcbiAgICAgICAgZXhwcmVzc2lvbiA9IHJlcGxhY2VkXG4gICAgfVxufVxuXG5FeHByZXNzaW9ucy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgIGlmICghdGhpcy5yYXcpe1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZXhwcmVzc2lvbjsgZXhwcmVzc2lvbiA9IHRoaXNbaSsrXTspIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbilcbiAgICAgICAgdGhpcy5yYXcgPSBleHByZXNzaW9ucy5qb2luKFwiLCBcIilcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yYXdcbn1cblxudmFyIGNhY2hlID0ge31cblxudmFyIHBhcnNlID0gZnVuY3Rpb24oZXhwcmVzc2lvbil7XG4gICAgaWYgKGV4cHJlc3Npb24gPT0gbnVsbCkgcmV0dXJuIG51bGxcbiAgICBleHByZXNzaW9uID0gKCcnICsgZXhwcmVzc2lvbikucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG4gICAgcmV0dXJuIGNhY2hlW2V4cHJlc3Npb25dIHx8IChjYWNoZVtleHByZXNzaW9uXSA9IG5ldyBFeHByZXNzaW9ucyhleHByZXNzaW9uKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIiwiLy8gVGlueUNvbG9yIHYxLjQuMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9UaW55Q29sb3Jcbi8vIEJyaWFuIEdyaW5zdGVhZCwgTUlUIExpY2Vuc2VcblxuKGZ1bmN0aW9uKE1hdGgpIHtcblxudmFyIHRyaW1MZWZ0ID0gL15cXHMrLyxcbiAgICB0cmltUmlnaHQgPSAvXFxzKyQvLFxuICAgIHRpbnlDb3VudGVyID0gMCxcbiAgICBtYXRoUm91bmQgPSBNYXRoLnJvdW5kLFxuICAgIG1hdGhNaW4gPSBNYXRoLm1pbixcbiAgICBtYXRoTWF4ID0gTWF0aC5tYXgsXG4gICAgbWF0aFJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG5mdW5jdGlvbiB0aW55Y29sb3IgKGNvbG9yLCBvcHRzKSB7XG5cbiAgICBjb2xvciA9IChjb2xvcikgPyBjb2xvciA6ICcnO1xuICAgIG9wdHMgPSBvcHRzIHx8IHsgfTtcblxuICAgIC8vIElmIGlucHV0IGlzIGFscmVhZHkgYSB0aW55Y29sb3IsIHJldHVybiBpdHNlbGZcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiB0aW55Y29sb3IpIHtcbiAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgY2FsbCB1c2luZyBuZXcgaW5zdGVhZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aW55Y29sb3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGlueWNvbG9yKGNvbG9yLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgcmdiID0gaW5wdXRUb1JHQihjb2xvcik7XG4gICAgdGhpcy5fb3JpZ2luYWxJbnB1dCA9IGNvbG9yLFxuICAgIHRoaXMuX3IgPSByZ2IucixcbiAgICB0aGlzLl9nID0gcmdiLmcsXG4gICAgdGhpcy5fYiA9IHJnYi5iLFxuICAgIHRoaXMuX2EgPSByZ2IuYSxcbiAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwLFxuICAgIHRoaXMuX2Zvcm1hdCA9IG9wdHMuZm9ybWF0IHx8IHJnYi5mb3JtYXQ7XG4gICAgdGhpcy5fZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XG5cbiAgICAvLyBEb24ndCBsZXQgdGhlIHJhbmdlIG9mIFswLDI1NV0gY29tZSBiYWNrIGluIFswLDFdLlxuICAgIC8vIFBvdGVudGlhbGx5IGxvc2UgYSBsaXR0bGUgYml0IG9mIHByZWNpc2lvbiBoZXJlLCBidXQgd2lsbCBmaXggaXNzdWVzIHdoZXJlXG4gICAgLy8gLjUgZ2V0cyBpbnRlcnByZXRlZCBhcyBoYWxmIG9mIHRoZSB0b3RhbCwgaW5zdGVhZCBvZiBoYWxmIG9mIDFcbiAgICAvLyBJZiBpdCB3YXMgc3VwcG9zZWQgdG8gYmUgMTI4LCB0aGlzIHdhcyBhbHJlYWR5IHRha2VuIGNhcmUgb2YgYnkgYGlucHV0VG9SZ2JgXG4gICAgaWYgKHRoaXMuX3IgPCAxKSB7IHRoaXMuX3IgPSBtYXRoUm91bmQodGhpcy5fcik7IH1cbiAgICBpZiAodGhpcy5fZyA8IDEpIHsgdGhpcy5fZyA9IG1hdGhSb3VuZCh0aGlzLl9nKTsgfVxuICAgIGlmICh0aGlzLl9iIDwgMSkgeyB0aGlzLl9iID0gbWF0aFJvdW5kKHRoaXMuX2IpOyB9XG5cbiAgICB0aGlzLl9vayA9IHJnYi5vaztcbiAgICB0aGlzLl90Y19pZCA9IHRpbnlDb3VudGVyKys7XG59XG5cbnRpbnljb2xvci5wcm90b3R5cGUgPSB7XG4gICAgaXNEYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnJpZ2h0bmVzcygpIDwgMTI4O1xuICAgIH0sXG4gICAgaXNMaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0RhcmsoKTtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2s7XG4gICAgfSxcbiAgICBnZXRPcmlnaW5hbElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbElucHV0O1xuICAgIH0sXG4gICAgZ2V0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcbiAgICB9LFxuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfSxcbiAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9BRVJUI2NvbG9yLWNvbnRyYXN0XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHJldHVybiAocmdiLnIgKiAyOTkgKyByZ2IuZyAqIDU4NyArIHJnYi5iICogMTE0KSAvIDEwMDA7XG4gICAgfSxcbiAgICBnZXRMdW1pbmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMudG9SZ2IoKTtcbiAgICAgICAgdmFyIFJzUkdCLCBHc1JHQiwgQnNSR0IsIFIsIEcsIEI7XG4gICAgICAgIFJzUkdCID0gcmdiLnIvMjU1O1xuICAgICAgICBHc1JHQiA9IHJnYi5nLzI1NTtcbiAgICAgICAgQnNSR0IgPSByZ2IuYi8yNTU7XG5cbiAgICAgICAgaWYgKFJzUkdCIDw9IDAuMDM5MjgpIHtSID0gUnNSR0IgLyAxMi45Mjt9IGVsc2Uge1IgPSBNYXRoLnBvdygoKFJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEdzUkdCIDw9IDAuMDM5MjgpIHtHID0gR3NSR0IgLyAxMi45Mjt9IGVsc2Uge0cgPSBNYXRoLnBvdygoKEdzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEJzUkdCIDw9IDAuMDM5MjgpIHtCID0gQnNSR0IgLyAxMi45Mjt9IGVsc2Uge0IgPSBNYXRoLnBvdygoKEJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgcmV0dXJuICgwLjIxMjYgKiBSKSArICgwLjcxNTIgKiBHKSArICgwLjA3MjIgKiBCKTtcbiAgICB9LFxuICAgIHNldEFscGhhOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hID0gYm91bmRBbHBoYSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9Ic3Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzdi5oICogMzYwLCBzOiBoc3YucywgdjogaHN2LnYsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHN2U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc3YuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHN2LnMgKiAxMDApLCB2ID0gbWF0aFJvdW5kKGhzdi52ICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzdihcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzdmEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgcmV0dXJuIHsgaDogaHNsLmggKiAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9Ic2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHZhciBoID0gbWF0aFJvdW5kKGhzbC5oICogMzYwKSwgcyA9IG1hdGhSb3VuZChoc2wucyAqIDEwMCksIGwgPSBtYXRoUm91bmQoaHNsLmwgKiAxMDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwiaHNsKFwiICArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUpXCIgOlxuICAgICAgICAgIFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUsIFwiKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvSGV4OiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCBhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4KGFsbG93M0NoYXIpO1xuICAgIH0sXG4gICAgdG9IZXg4OiBmdW5jdGlvbihhbGxvdzRDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JhVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSwgYWxsb3c0Q2hhcik7XG4gICAgfSxcbiAgICB0b0hleDhTdHJpbmc6IGZ1bmN0aW9uKGFsbG93NENoYXIpIHtcbiAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXg4KGFsbG93NENoYXIpO1xuICAgIH0sXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRoUm91bmQodGhpcy5fciksIGc6IG1hdGhSb3VuZCh0aGlzLl9nKSwgYjogbWF0aFJvdW5kKHRoaXMuX2IpLCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b1JnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKHRoaXMuX3IpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2cpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXCIpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgZzogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcInJnYihcIiAgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9iLCAyNTUpICogMTAwKSArIFwiJSlcIiA6XG4gICAgICAgICAgXCJyZ2JhKFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleE5hbWVzW3JnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRydWUpXSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHRvRmlsdGVyOiBmdW5jdGlvbihzZWNvbmRDb2xvcikge1xuICAgICAgICB2YXIgaGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XG4gICAgICAgIHZhciBzZWNvbmRIZXg4U3RyaW5nID0gaGV4OFN0cmluZztcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZSA9IHRoaXMuX2dyYWRpZW50VHlwZSA/IFwiR3JhZGllbnRUeXBlID0gMSwgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChzZWNvbmRDb2xvcikge1xuICAgICAgICAgICAgdmFyIHMgPSB0aW55Y29sb3Ioc2Vjb25kQ29sb3IpO1xuICAgICAgICAgICAgc2Vjb25kSGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgocy5fciwgcy5fZywgcy5fYiwgcy5fYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoXCIrZ3JhZGllbnRUeXBlK1wic3RhcnRDb2xvcnN0cj1cIitoZXg4U3RyaW5nK1wiLGVuZENvbG9yc3RyPVwiK3NlY29uZEhleDhTdHJpbmcrXCIpXCI7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBmb3JtYXRTZXQgPSAhIWZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuX2Zvcm1hdDtcblxuICAgICAgICB2YXIgZm9ybWF0dGVkU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNBbHBoYSA9IHRoaXMuX2EgPCAxICYmIHRoaXMuX2EgPj0gMDtcbiAgICAgICAgdmFyIG5lZWRzQWxwaGFGb3JtYXQgPSAhZm9ybWF0U2V0ICYmIGhhc0FscGhhICYmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIiB8fCBmb3JtYXQgPT09IFwiaGV4M1wiIHx8IGZvcm1hdCA9PT0gXCJoZXg0XCIgfHwgZm9ybWF0ID09PSBcImhleDhcIiB8fCBmb3JtYXQgPT09IFwibmFtZVwiKTtcblxuICAgICAgICBpZiAobmVlZHNBbHBoYUZvcm1hdCkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBcInRyYW5zcGFyZW50XCIsIGFsbCBvdGhlciBub24tYWxwaGEgZm9ybWF0c1xuICAgICAgICAgICAgLy8gd2lsbCByZXR1cm4gcmdiYSB3aGVuIHRoZXJlIGlzIHRyYW5zcGFyZW5jeS5cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwibmFtZVwiICYmIHRoaXMuX2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b05hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyZ2JcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicHJnYlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvUGVyY2VudGFnZVJnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4M1wiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4NFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4OFN0cmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDhcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhzbFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHNsU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc3ZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzdlN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZyB8fCB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aW55Y29sb3IodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5TW9kaWZpY2F0aW9uOiBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICB2YXIgY29sb3IgPSBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICAgICAgdGhpcy5fciA9IGNvbG9yLl9yO1xuICAgICAgICB0aGlzLl9nID0gY29sb3IuX2c7XG4gICAgICAgIHRoaXMuX2IgPSBjb2xvci5fYjtcbiAgICAgICAgdGhpcy5zZXRBbHBoYShjb2xvci5fYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbGlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihsaWdodGVuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgYnJpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oYnJpZ2h0ZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBkYXJrZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGFya2VuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihkZXNhdHVyYXRlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc2F0dXJhdGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBncmV5c2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZ3JleXNjYWxlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihzcGluLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlDb21iaW5hdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgIH0sXG4gICAgYW5hbG9nb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oYW5hbG9nb3VzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKGNvbXBsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtb25vY2hyb21hdGljOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24obW9ub2Nocm9tYXRpYywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNwbGl0Y29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHNwbGl0Y29tcGxlbWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRyaWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24odHJpYWQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0ZXRyYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0ZXRyYWQsIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcblxuLy8gSWYgaW5wdXQgaXMgYW4gb2JqZWN0LCBmb3JjZSAxIGludG8gXCIxLjBcIiB0byBoYW5kbGUgcmF0aW9zIHByb3Blcmx5XG4vLyBTdHJpbmcgaW5wdXQgcmVxdWlyZXMgXCIxLjBcIiBhcyBpbnB1dCwgc28gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgMVxudGlueWNvbG9yLmZyb21SYXRpbyA9IGZ1bmN0aW9uKGNvbG9yLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBuZXdDb2xvciA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb2xvcltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbG9yID0gbmV3Q29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG59O1xuXG4vLyBHaXZlbiBhIHN0cmluZyBvciBvYmplY3QsIGNvbnZlcnQgdGhhdCBpbnB1dCB0byBSR0Jcbi8vIFBvc3NpYmxlIHN0cmluZyBpbnB1dHM6XG4vL1xuLy8gICAgIFwicmVkXCJcbi8vICAgICBcIiNmMDBcIiBvciBcImYwMFwiXG4vLyAgICAgXCIjZmYwMDAwXCIgb3IgXCJmZjAwMDBcIlxuLy8gICAgIFwiI2ZmMDAwMDAwXCIgb3IgXCJmZjAwMDAwMFwiXG4vLyAgICAgXCJyZ2IgMjU1IDAgMFwiIG9yIFwicmdiICgyNTUsIDAsIDApXCJcbi8vICAgICBcInJnYiAxLjAgMCAwXCIgb3IgXCJyZ2IgKDEsIDAsIDApXCJcbi8vICAgICBcInJnYmEgKDI1NSwgMCwgMCwgMSlcIiBvciBcInJnYmEgMjU1LCAwLCAwLCAxXCJcbi8vICAgICBcInJnYmEgKDEuMCwgMCwgMCwgMSlcIiBvciBcInJnYmEgMS4wLCAwLCAwLCAxXCJcbi8vICAgICBcImhzbCgwLCAxMDAlLCA1MCUpXCIgb3IgXCJoc2wgMCAxMDAlIDUwJVwiXG4vLyAgICAgXCJoc2xhKDAsIDEwMCUsIDUwJSwgMSlcIiBvciBcImhzbGEgMCAxMDAlIDUwJSwgMVwiXG4vLyAgICAgXCJoc3YoMCwgMTAwJSwgMTAwJSlcIiBvciBcImhzdiAwIDEwMCUgMTAwJVwiXG4vL1xuZnVuY3Rpb24gaW5wdXRUb1JHQihjb2xvcikge1xuXG4gICAgdmFyIHJnYiA9IHsgcjogMCwgZzogMCwgYjogMCB9O1xuICAgIHZhciBhID0gMTtcbiAgICB2YXIgcyA9IG51bGw7XG4gICAgdmFyIHYgPSBudWxsO1xuICAgIHZhciBsID0gbnVsbDtcbiAgICB2YXIgb2sgPSBmYWxzZTtcbiAgICB2YXIgZm9ybWF0ID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29sb3IgPSBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLnIpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmcpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmIpKSB7XG4gICAgICAgICAgICByZ2IgPSByZ2JUb1JnYihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFN0cmluZyhjb2xvci5yKS5zdWJzdHIoLTEpID09PSBcIiVcIiA/IFwicHJnYlwiIDogXCJyZ2JcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci52KSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICB2ID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci52KTtcbiAgICAgICAgICAgIHJnYiA9IGhzdlRvUmdiKGNvbG9yLmgsIHMsIHYpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc3ZcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5sKSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICBsID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5sKTtcbiAgICAgICAgICAgIHJnYiA9IGhzbFRvUmdiKGNvbG9yLmgsIHMsIGwpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc2xcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShcImFcIikpIHtcbiAgICAgICAgICAgIGEgPSBjb2xvci5hO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYSA9IGJvdW5kQWxwaGEoYSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvazogb2ssXG4gICAgICAgIGZvcm1hdDogY29sb3IuZm9ybWF0IHx8IGZvcm1hdCxcbiAgICAgICAgcjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLnIsIDApKSxcbiAgICAgICAgZzogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmcsIDApKSxcbiAgICAgICAgYjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmIsIDApKSxcbiAgICAgICAgYTogYVxuICAgIH07XG59XG5cblxuLy8gQ29udmVyc2lvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGByZ2JUb0hzbGAsIGByZ2JUb0hzdmAsIGBoc2xUb1JnYmAsIGBoc3ZUb1JnYmAgbW9kaWZpZWQgZnJvbTpcbi8vIDxodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0PlxuXG4vLyBgcmdiVG9SZ2JgXG4vLyBIYW5kbGUgYm91bmRzIC8gcGVyY2VudGFnZSBjaGVja2luZyB0byBjb25mb3JtIHRvIENTUyBjb2xvciBzcGVjXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8+XG4vLyAqQXNzdW1lczoqIHIsIGcsIGIgaW4gWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIFswLCAyNTVdXG5mdW5jdGlvbiByZ2JUb1JnYihyLCBnLCBiKXtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBib3VuZDAxKHIsIDI1NSkgKiAyNTUsXG4gICAgICAgIGc6IGJvdW5kMDEoZywgMjU1KSAqIDI1NSxcbiAgICAgICAgYjogYm91bmQwMShiLCAyNTUpICogMjU1XG4gICAgfTtcbn1cblxuLy8gYHJnYlRvSHNsYFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC5cbi8vICpBc3N1bWVzOiogciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCBsIH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHNsKHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBoIC89IDY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaDogaCwgczogcywgbDogbCB9O1xufVxuXG4vLyBgaHNsVG9SZ2JgXG4vLyBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLlxuLy8gKkFzc3VtZXM6KiBoIGlzIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDM2MF0gYW5kIHMgYW5kIGwgYXJlIGNvbnRhaW5lZCBbMCwgMV0gb3IgWzAsIDEwMF1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICAgIHZhciByLCBnLCBiO1xuXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKTtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIGwgPSBib3VuZDAxKGwsIDEwMCk7XG5cbiAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICAgICAgaWYodCA8IDApIHQgKz0gMTtcbiAgICAgICAgaWYodCA+IDEpIHQgLT0gMTtcbiAgICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xuICAgICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBpZihzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYiAqIDI1NSB9O1xufVxuXG4vLyBgcmdiVG9Ic3ZgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCB2IH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHN2KHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIHYgPSBtYXg7XG5cbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIHY6IHYgfTtcbn1cblxuLy8gYGhzdlRvUmdiYFxuLy8gQ29udmVydHMgYW4gSFNWIGNvbG9yIHZhbHVlIHRvIFJHQi5cbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCB2IGFyZSBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAxMDBdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIHRoZSBzZXQgWzAsIDI1NV1cbiBmdW5jdGlvbiBoc3ZUb1JnYihoLCBzLCB2KSB7XG5cbiAgICBoID0gYm91bmQwMShoLCAzNjApICogNjtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIHYgPSBib3VuZDAxKHYsIDEwMCk7XG5cbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCksXG4gICAgICAgIGYgPSBoIC0gaSxcbiAgICAgICAgcCA9IHYgKiAoMSAtIHMpLFxuICAgICAgICBxID0gdiAqICgxIC0gZiAqIHMpLFxuICAgICAgICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpLFxuICAgICAgICBtb2QgPSBpICUgNixcbiAgICAgICAgciA9IFt2LCBxLCBwLCBwLCB0LCB2XVttb2RdLFxuICAgICAgICBnID0gW3QsIHYsIHYsIHEsIHAsIHBdW21vZF0sXG4gICAgICAgIGIgPSBbcCwgcCwgdCwgdiwgdiwgcV1bbW9kXTtcblxuICAgIHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfTtcbn1cblxuLy8gYHJnYlRvSGV4YFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIGhleFxuLy8gQXNzdW1lcyByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV1cbi8vIFJldHVybnMgYSAzIG9yIDYgY2hhcmFjdGVyIGhleFxuZnVuY3Rpb24gcmdiVG9IZXgociwgZywgYiwgYWxsb3czQ2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSAzIGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3czQ2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSkge1xuICAgICAgICByZXR1cm4gaGV4WzBdLmNoYXJBdCgwKSArIGhleFsxXS5jaGFyQXQoMCkgKyBoZXhbMl0uY2hhckF0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYHJnYmFUb0hleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgcGx1cyBhbHBoYSB0cmFuc3BhcmVuY3kgdG8gaGV4XG4vLyBBc3N1bWVzIHIsIGcsIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZFxuLy8gYSBpbiBbMCwgMV0uIFJldHVybnMgYSA0IG9yIDggY2hhcmFjdGVyIHJnYmEgaGV4XG5mdW5jdGlvbiByZ2JhVG9IZXgociwgZywgYiwgYSwgYWxsb3c0Q2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSA0IGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3c0Q2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSAmJiBoZXhbM10uY2hhckF0KDApID09IGhleFszXS5jaGFyQXQoMSkpIHtcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKSArIGhleFszXS5jaGFyQXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgcmdiYVRvQXJnYkhleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgdG8gYW4gQVJHQiBIZXg4IHN0cmluZ1xuLy8gUmFyZWx5IHVzZWQsIGJ1dCByZXF1aXJlZCBmb3IgXCJ0b0ZpbHRlcigpXCJcbmZ1bmN0aW9uIHJnYmFUb0FyZ2JIZXgociwgZywgYiwgYSkge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGBlcXVhbHNgXG4vLyBDYW4gYmUgY2FsbGVkIHdpdGggYW55IHRpbnljb2xvciBpbnB1dFxudGlueWNvbG9yLmVxdWFscyA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMikge1xuICAgIGlmICghY29sb3IxIHx8ICFjb2xvcjIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcjEpLnRvUmdiU3RyaW5nKCkgPT0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2JTdHJpbmcoKTtcbn07XG5cbnRpbnljb2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yLmZyb21SYXRpbyh7XG4gICAgICAgIHI6IG1hdGhSYW5kb20oKSxcbiAgICAgICAgZzogbWF0aFJhbmRvbSgpLFxuICAgICAgICBiOiBtYXRoUmFuZG9tKClcbiAgICB9KTtcbn07XG5cblxuLy8gTW9kaWZpY2F0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGxlc3MuanMgZm9yIHNvbWUgb2YgdGhlIGJhc2ljcyBoZXJlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaGVhZC9sZXNzLmpzL2Jsb2IvbWFzdGVyL2xpYi9sZXNzL2Z1bmN0aW9ucy5qcz5cblxuZnVuY3Rpb24gZGVzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wucyAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5zICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IGNsYW1wMDEoaHNsLnMpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gZ3JleXNjYWxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZGVzYXR1cmF0ZSgxMDApO1xufVxuXG5mdW5jdGlvbiBsaWdodGVuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIGJyaWdodGVuKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgcmdiID0gdGlueWNvbG9yKGNvbG9yKS50b1JnYigpO1xuICAgIHJnYi5yID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLnIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuZyA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5nIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmdiLmIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuYiAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJldHVybiB0aW55Y29sb3IocmdiKTtcbn1cblxuZnVuY3Rpb24gZGFya2VuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIFNwaW4gdGFrZXMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBhbW91bnQgd2l0aGluIFstMzYwLCAzNjBdIGluZGljYXRpbmcgdGhlIGNoYW5nZSBvZiBodWUuXG4vLyBWYWx1ZXMgb3V0c2lkZSBvZiB0aGlzIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbnRvIHRoaXMgcmFuZ2UuXG5mdW5jdGlvbiBzcGluKGNvbG9yLCBhbW91bnQpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQpICUgMzYwO1xuICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIENvbWJpbmF0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGFua3MgdG8galF1ZXJ5IHhDb2xvciBmb3Igc29tZSBvZiB0aGUgaWRlYXMgYmVoaW5kIHRoZXNlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2luZnVzaW9uL2pRdWVyeS14Y29sb3IvYmxvYi9tYXN0ZXIvanF1ZXJ5Lnhjb2xvci5qcz5cblxuZnVuY3Rpb24gY29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmggPSAoaHNsLmggKyAxODApICUgMzYwO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gdHJpYWQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxMjApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjQwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gdGV0cmFkKGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgOTApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTgwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI3MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHNwbGl0Y29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDcyKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjE2KSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBhbmFsb2dvdXMoY29sb3IsIHJlc3VsdHMsIHNsaWNlcykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XG4gICAgc2xpY2VzID0gc2xpY2VzIHx8IDMwO1xuXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgcGFydCA9IDM2MCAvIHNsaWNlcztcbiAgICB2YXIgcmV0ID0gW3Rpbnljb2xvcihjb2xvcildO1xuXG4gICAgZm9yIChoc2wuaCA9ICgoaHNsLmggLSAocGFydCAqIHJlc3VsdHMgPj4gMSkpICsgNzIwKSAlIDM2MDsgLS1yZXN1bHRzOyApIHtcbiAgICAgICAgaHNsLmggPSAoaHNsLmggKyBwYXJ0KSAlIDM2MDtcbiAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKGhzbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBtb25vY2hyb21hdGljKGNvbG9yLCByZXN1bHRzKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcbiAgICB2YXIgaHN2ID0gdGlueWNvbG9yKGNvbG9yKS50b0hzdigpO1xuICAgIHZhciBoID0gaHN2LmgsIHMgPSBoc3YucywgdiA9IGhzdi52O1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgbW9kaWZpY2F0aW9uID0gMSAvIHJlc3VsdHM7XG5cbiAgICB3aGlsZSAocmVzdWx0cy0tKSB7XG4gICAgICAgIHJldC5wdXNoKHRpbnljb2xvcih7IGg6IGgsIHM6IHMsIHY6IHZ9KSk7XG4gICAgICAgIHYgPSAodiArIG1vZGlmaWNhdGlvbikgJSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIFV0aWxpdHkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudGlueWNvbG9yLm1peCA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDUwKTtcblxuICAgIHZhciByZ2IxID0gdGlueWNvbG9yKGNvbG9yMSkudG9SZ2IoKTtcbiAgICB2YXIgcmdiMiA9IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiKCk7XG5cbiAgICB2YXIgcCA9IGFtb3VudCAvIDEwMDtcblxuICAgIHZhciByZ2JhID0ge1xuICAgICAgICByOiAoKHJnYjIuciAtIHJnYjEucikgKiBwKSArIHJnYjEucixcbiAgICAgICAgZzogKChyZ2IyLmcgLSByZ2IxLmcpICogcCkgKyByZ2IxLmcsXG4gICAgICAgIGI6ICgocmdiMi5iIC0gcmdiMS5iKSAqIHApICsgcmdiMS5iLFxuICAgICAgICBhOiAoKHJnYjIuYSAtIHJnYjEuYSkgKiBwKSArIHJnYjEuYVxuICAgIH07XG5cbiAgICByZXR1cm4gdGlueWNvbG9yKHJnYmEpO1xufTtcblxuXG4vLyBSZWFkYWJpbGl0eSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWYgKFdDQUcgVmVyc2lvbiAyKVxuXG4vLyBgY29udHJhc3RgXG4vLyBBbmFseXplIHRoZSAyIGNvbG9ycyBhbmQgcmV0dXJucyB0aGUgY29sb3IgY29udHJhc3QgZGVmaW5lZCBieSAoV0NBRyBWZXJzaW9uIDIpXG50aW55Y29sb3IucmVhZGFiaWxpdHkgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuICAgIHZhciBjMSA9IHRpbnljb2xvcihjb2xvcjEpO1xuICAgIHZhciBjMiA9IHRpbnljb2xvcihjb2xvcjIpO1xuICAgIHJldHVybiAoTWF0aC5tYXgoYzEuZ2V0THVtaW5hbmNlKCksYzIuZ2V0THVtaW5hbmNlKCkpKzAuMDUpIC8gKE1hdGgubWluKGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KTtcbn07XG5cbi8vIGBpc1JlYWRhYmxlYFxuLy8gRW5zdXJlIHRoYXQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciBjb21iaW5hdGlvbnMgbWVldCBXQ0FHMiBndWlkZWxpbmVzLlxuLy8gVGhlIHRoaXJkIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIE9iamVjdC5cbi8vICAgICAgdGhlICdsZXZlbCcgcHJvcGVydHkgc3RhdGVzICdBQScgb3IgJ0FBQScgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdBQSc7XG4vLyAgICAgIHRoZSAnc2l6ZScgcHJvcGVydHkgc3RhdGVzICdsYXJnZScgb3IgJ3NtYWxsJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ3NtYWxsJy5cbi8vIElmIHRoZSBlbnRpcmUgb2JqZWN0IGlzIGFic2VudCwgaXNSZWFkYWJsZSBkZWZhdWx0cyB0byB7bGV2ZWw6XCJBQVwiLHNpemU6XCJzbWFsbFwifS5cblxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIpID0+IGZhbHNlXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIse2xldmVsOlwiQUFcIixzaXplOlwibGFyZ2VcIn0pID0+IGZhbHNlXG50aW55Y29sb3IuaXNSZWFkYWJsZSA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCB3Y2FnMikge1xuICAgIHZhciByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShjb2xvcjEsIGNvbG9yMik7XG4gICAgdmFyIHdjYWcyUGFybXMsIG91dDtcblxuICAgIG91dCA9IGZhbHNlO1xuXG4gICAgd2NhZzJQYXJtcyA9IHZhbGlkYXRlV0NBRzJQYXJtcyh3Y2FnMik7XG4gICAgc3dpdGNoICh3Y2FnMlBhcm1zLmxldmVsICsgd2NhZzJQYXJtcy5zaXplKSB7XG4gICAgICAgIGNhc2UgXCJBQXNtYWxsXCI6XG4gICAgICAgIGNhc2UgXCJBQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQWxhcmdlXCI6XG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQUFzbWFsbFwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuXG59O1xuXG4vLyBgbW9zdFJlYWRhYmxlYFxuLy8gR2l2ZW4gYSBiYXNlIGNvbG9yIGFuZCBhIGxpc3Qgb2YgcG9zc2libGUgZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kXG4vLyBjb2xvcnMgZm9yIHRoYXQgYmFzZSwgcmV0dXJucyB0aGUgbW9zdCByZWFkYWJsZSBjb2xvci5cbi8vIE9wdGlvbmFsbHkgcmV0dXJucyBCbGFjayBvciBXaGl0ZSBpZiB0aGUgbW9zdCByZWFkYWJsZSBjb2xvciBpcyB1bnJlYWRhYmxlLlxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjMTIzXCIsIFtcIiMxMjRcIiwgXCIjMTI1XCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6ZmFsc2V9KS50b0hleFN0cmluZygpOyAvLyBcIiMxMTIyNTVcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWV9KS50b0hleFN0cmluZygpOyAgLy8gXCIjZmZmZmZmXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcImxhcmdlXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmYWYzZjNcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiNhODAxNWFcIiwgW1wiI2ZhZjNmM1wiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWUsbGV2ZWw6XCJBQUFcIixzaXplOlwic21hbGxcIn0pLnRvSGV4U3RyaW5nKCk7IC8vIFwiI2ZmZmZmZlwiXG50aW55Y29sb3IubW9zdFJlYWRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9yLCBjb2xvckxpc3QsIGFyZ3MpIHtcbiAgICB2YXIgYmVzdENvbG9yID0gbnVsbDtcbiAgICB2YXIgYmVzdFNjb3JlID0gMDtcbiAgICB2YXIgcmVhZGFiaWxpdHk7XG4gICAgdmFyIGluY2x1ZGVGYWxsYmFja0NvbG9ycywgbGV2ZWwsIHNpemUgO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGluY2x1ZGVGYWxsYmFja0NvbG9ycyA9IGFyZ3MuaW5jbHVkZUZhbGxiYWNrQ29sb3JzIDtcbiAgICBsZXZlbCA9IGFyZ3MubGV2ZWw7XG4gICAgc2l6ZSA9IGFyZ3Muc2l6ZTtcblxuICAgIGZvciAodmFyIGk9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5KGJhc2VDb2xvciwgY29sb3JMaXN0W2ldKTtcbiAgICAgICAgaWYgKHJlYWRhYmlsaXR5ID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSByZWFkYWJpbGl0eTtcbiAgICAgICAgICAgIGJlc3RDb2xvciA9IHRpbnljb2xvcihjb2xvckxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbnljb2xvci5pc1JlYWRhYmxlKGJhc2VDb2xvciwgYmVzdENvbG9yLCB7XCJsZXZlbFwiOmxldmVsLFwic2l6ZVwiOnNpemV9KSB8fCAhaW5jbHVkZUZhbGxiYWNrQ29sb3JzKSB7XG4gICAgICAgIHJldHVybiBiZXN0Q29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycz1mYWxzZTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvci5tb3N0UmVhZGFibGUoYmFzZUNvbG9yLFtcIiNmZmZcIiwgXCIjMDAwXCJdLGFyZ3MpO1xuICAgIH1cbn07XG5cblxuLy8gQmlnIExpc3Qgb2YgQ29sb3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3I+XG52YXIgbmFtZXMgPSB0aW55Y29sb3IubmFtZXMgPSB7XG4gICAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuICAgIGFudGlxdWV3aGl0ZTogXCJmYWViZDdcIixcbiAgICBhcXVhOiBcIjBmZlwiLFxuICAgIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG4gICAgYXp1cmU6IFwiZjBmZmZmXCIsXG4gICAgYmVpZ2U6IFwiZjVmNWRjXCIsXG4gICAgYmlzcXVlOiBcImZmZTRjNFwiLFxuICAgIGJsYWNrOiBcIjAwMFwiLFxuICAgIGJsYW5jaGVkYWxtb25kOiBcImZmZWJjZFwiLFxuICAgIGJsdWU6IFwiMDBmXCIsXG4gICAgYmx1ZXZpb2xldDogXCI4YTJiZTJcIixcbiAgICBicm93bjogXCJhNTJhMmFcIixcbiAgICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gICAgYnVybnRzaWVubmE6IFwiZWE3ZTVkXCIsXG4gICAgY2FkZXRibHVlOiBcIjVmOWVhMFwiLFxuICAgIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG4gICAgY2hvY29sYXRlOiBcImQyNjkxZVwiLFxuICAgIGNvcmFsOiBcImZmN2Y1MFwiLFxuICAgIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuICAgIGNvcm5zaWxrOiBcImZmZjhkY1wiLFxuICAgIGNyaW1zb246IFwiZGMxNDNjXCIsXG4gICAgY3lhbjogXCIwZmZcIixcbiAgICBkYXJrYmx1ZTogXCIwMDAwOGJcIixcbiAgICBkYXJrY3lhbjogXCIwMDhiOGJcIixcbiAgICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuICAgIGRhcmtncmF5OiBcImE5YTlhOVwiLFxuICAgIGRhcmtncmVlbjogXCIwMDY0MDBcIixcbiAgICBkYXJrZ3JleTogXCJhOWE5YTlcIixcbiAgICBkYXJra2hha2k6IFwiYmRiNzZiXCIsXG4gICAgZGFya21hZ2VudGE6IFwiOGIwMDhiXCIsXG4gICAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG4gICAgZGFya29yYW5nZTogXCJmZjhjMDBcIixcbiAgICBkYXJrb3JjaGlkOiBcIjk5MzJjY1wiLFxuICAgIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG4gICAgZGFya3NhbG1vbjogXCJlOTk2N2FcIixcbiAgICBkYXJrc2VhZ3JlZW46IFwiOGZiYzhmXCIsXG4gICAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcbiAgICBkYXJrc2xhdGVncmF5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFwiMmY0ZjRmXCIsXG4gICAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcbiAgICBkYXJrdmlvbGV0OiBcIjk0MDBkM1wiLFxuICAgIGRlZXBwaW5rOiBcImZmMTQ5M1wiLFxuICAgIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuICAgIGRpbWdyYXk6IFwiNjk2OTY5XCIsXG4gICAgZGltZ3JleTogXCI2OTY5NjlcIixcbiAgICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuICAgIGZpcmVicmljazogXCJiMjIyMjJcIixcbiAgICBmbG9yYWx3aGl0ZTogXCJmZmZhZjBcIixcbiAgICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcbiAgICBmdWNoc2lhOiBcImYwZlwiLFxuICAgIGdhaW5zYm9ybzogXCJkY2RjZGNcIixcbiAgICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuICAgIGdvbGQ6IFwiZmZkNzAwXCIsXG4gICAgZ29sZGVucm9kOiBcImRhYTUyMFwiLFxuICAgIGdyYXk6IFwiODA4MDgwXCIsXG4gICAgZ3JlZW46IFwiMDA4MDAwXCIsXG4gICAgZ3JlZW55ZWxsb3c6IFwiYWRmZjJmXCIsXG4gICAgZ3JleTogXCI4MDgwODBcIixcbiAgICBob25leWRldzogXCJmMGZmZjBcIixcbiAgICBob3RwaW5rOiBcImZmNjliNFwiLFxuICAgIGluZGlhbnJlZDogXCJjZDVjNWNcIixcbiAgICBpbmRpZ286IFwiNGIwMDgyXCIsXG4gICAgaXZvcnk6IFwiZmZmZmYwXCIsXG4gICAga2hha2k6IFwiZjBlNjhjXCIsXG4gICAgbGF2ZW5kZXI6IFwiZTZlNmZhXCIsXG4gICAgbGF2ZW5kZXJibHVzaDogXCJmZmYwZjVcIixcbiAgICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG4gICAgbGVtb25jaGlmZm9uOiBcImZmZmFjZFwiLFxuICAgIGxpZ2h0Ymx1ZTogXCJhZGQ4ZTZcIixcbiAgICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuICAgIGxpZ2h0Y3lhbjogXCJlMGZmZmZcIixcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCJmYWZhZDJcIixcbiAgICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRncmVlbjogXCI5MGVlOTBcIixcbiAgICBsaWdodGdyZXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuICAgIGxpZ2h0c2FsbW9uOiBcImZmYTA3YVwiLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFwiMjBiMmFhXCIsXG4gICAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuICAgIGxpZ2h0eWVsbG93OiBcImZmZmZlMFwiLFxuICAgIGxpbWU6IFwiMGYwXCIsXG4gICAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuICAgIGxpbmVuOiBcImZhZjBlNlwiLFxuICAgIG1hZ2VudGE6IFwiZjBmXCIsXG4gICAgbWFyb29uOiBcIjgwMDAwMFwiLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFwiNjZjZGFhXCIsXG4gICAgbWVkaXVtYmx1ZTogXCIwMDAwY2RcIixcbiAgICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG4gICAgbWVkaXVtcHVycGxlOiBcIjkzNzBkYlwiLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBcIjNjYjM3MVwiLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogXCIwMGZhOWFcIixcbiAgICBtZWRpdW10dXJxdW9pc2U6IFwiNDhkMWNjXCIsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuICAgIG1pZG5pZ2h0Ymx1ZTogXCIxOTE5NzBcIixcbiAgICBtaW50Y3JlYW06IFwiZjVmZmZhXCIsXG4gICAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuICAgIG1vY2Nhc2luOiBcImZmZTRiNVwiLFxuICAgIG5hdmFqb3doaXRlOiBcImZmZGVhZFwiLFxuICAgIG5hdnk6IFwiMDAwMDgwXCIsXG4gICAgb2xkbGFjZTogXCJmZGY1ZTZcIixcbiAgICBvbGl2ZTogXCI4MDgwMDBcIixcbiAgICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG4gICAgb3JhbmdlOiBcImZmYTUwMFwiLFxuICAgIG9yYW5nZXJlZDogXCJmZjQ1MDBcIixcbiAgICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG4gICAgcGFsZWdvbGRlbnJvZDogXCJlZWU4YWFcIixcbiAgICBwYWxlZ3JlZW46IFwiOThmYjk4XCIsXG4gICAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcbiAgICBwYWxldmlvbGV0cmVkOiBcImRiNzA5M1wiLFxuICAgIHBhcGF5YXdoaXA6IFwiZmZlZmQ1XCIsXG4gICAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuICAgIHBlcnU6IFwiY2Q4NTNmXCIsXG4gICAgcGluazogXCJmZmMwY2JcIixcbiAgICBwbHVtOiBcImRkYTBkZFwiLFxuICAgIHBvd2RlcmJsdWU6IFwiYjBlMGU2XCIsXG4gICAgcHVycGxlOiBcIjgwMDA4MFwiLFxuICAgIHJlYmVjY2FwdXJwbGU6IFwiNjYzMzk5XCIsXG4gICAgcmVkOiBcImYwMFwiLFxuICAgIHJvc3licm93bjogXCJiYzhmOGZcIixcbiAgICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG4gICAgc2FkZGxlYnJvd246IFwiOGI0NTEzXCIsXG4gICAgc2FsbW9uOiBcImZhODA3MlwiLFxuICAgIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG4gICAgc2VhZ3JlZW46IFwiMmU4YjU3XCIsXG4gICAgc2Vhc2hlbGw6IFwiZmZmNWVlXCIsXG4gICAgc2llbm5hOiBcImEwNTIyZFwiLFxuICAgIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgICBza3libHVlOiBcIjg3Y2VlYlwiLFxuICAgIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcbiAgICBzbGF0ZWdyYXk6IFwiNzA4MDkwXCIsXG4gICAgc2xhdGVncmV5OiBcIjcwODA5MFwiLFxuICAgIHNub3c6IFwiZmZmYWZhXCIsXG4gICAgc3ByaW5nZ3JlZW46IFwiMDBmZjdmXCIsXG4gICAgc3RlZWxibHVlOiBcIjQ2ODJiNFwiLFxuICAgIHRhbjogXCJkMmI0OGNcIixcbiAgICB0ZWFsOiBcIjAwODA4MFwiLFxuICAgIHRoaXN0bGU6IFwiZDhiZmQ4XCIsXG4gICAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICAgIHR1cnF1b2lzZTogXCI0MGUwZDBcIixcbiAgICB2aW9sZXQ6IFwiZWU4MmVlXCIsXG4gICAgd2hlYXQ6IFwiZjVkZWIzXCIsXG4gICAgd2hpdGU6IFwiZmZmXCIsXG4gICAgd2hpdGVzbW9rZTogXCJmNWY1ZjVcIixcbiAgICB5ZWxsb3c6IFwiZmYwXCIsXG4gICAgeWVsbG93Z3JlZW46IFwiOWFjZDMyXCJcbn07XG5cbi8vIE1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgY29sb3JzIHZpYSBgaGV4TmFtZXNbaGV4XWBcbnZhciBoZXhOYW1lcyA9IHRpbnljb2xvci5oZXhOYW1lcyA9IGZsaXAobmFtZXMpO1xuXG5cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tXG5cbi8vIGB7ICduYW1lMSc6ICd2YWwxJyB9YCBiZWNvbWVzIGB7ICd2YWwxJzogJ25hbWUxJyB9YFxuZnVuY3Rpb24gZmxpcChvKSB7XG4gICAgdmFyIGZsaXBwZWQgPSB7IH07XG4gICAgZm9yICh2YXIgaSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBmbGlwcGVkW29baV1dID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZDtcbn1cblxuLy8gUmV0dXJuIGEgdmFsaWQgYWxwaGEgdmFsdWUgWzAsMV0gd2l0aCBhbGwgaW52YWxpZCB2YWx1ZXMgYmVpbmcgc2V0IHRvIDFcbmZ1bmN0aW9uIGJvdW5kQWxwaGEoYSkge1xuICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG4vLyBUYWtlIGlucHV0IGZyb20gWzAsIG5dIGFuZCByZXR1cm4gaXQgYXMgWzAsIDFdXG5mdW5jdGlvbiBib3VuZDAxKG4sIG1heCkge1xuICAgIGlmIChpc09uZVBvaW50WmVybyhuKSkgeyBuID0gXCIxMDAlXCI7IH1cblxuICAgIHZhciBwcm9jZXNzUGVyY2VudCA9IGlzUGVyY2VudGFnZShuKTtcbiAgICBuID0gbWF0aE1pbihtYXgsIG1hdGhNYXgoMCwgcGFyc2VGbG9hdChuKSkpO1xuXG4gICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IHBlcmNlbnRhZ2UgaW50byBudW1iZXJcbiAgICBpZiAocHJvY2Vzc1BlcmNlbnQpIHtcbiAgICAgICAgbiA9IHBhcnNlSW50KG4gKiBtYXgsIDEwKSAvIDEwMDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzXG4gICAgaWYgKChNYXRoLmFicyhuIC0gbWF4KSA8IDAuMDAwMDAxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gWzAsIDFdIHJhbmdlIGlmIGl0IGlzbid0IGFscmVhZHlcbiAgICByZXR1cm4gKG4gJSBtYXgpIC8gcGFyc2VGbG9hdChtYXgpO1xufVxuXG4vLyBGb3JjZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbmZ1bmN0aW9uIGNsYW1wMDEodmFsKSB7XG4gICAgcmV0dXJuIG1hdGhNaW4oMSwgbWF0aE1heCgwLCB2YWwpKTtcbn1cblxuLy8gUGFyc2UgYSBiYXNlLTE2IGhleCB2YWx1ZSBpbnRvIGEgYmFzZS0xMCBpbnRlZ2VyXG5mdW5jdGlvbiBwYXJzZUludEZyb21IZXgodmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTYpO1xufVxuXG4vLyBOZWVkIHRvIGhhbmRsZSAxLjAgYXMgMTAwJSwgc2luY2Ugb25jZSBpdCBpcyBhIG51bWJlciwgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGl0IGFuZCAxXG4vLyA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDIyMDcyL2phdmFzY3JpcHQtaG93LXRvLWRldGVjdC1udW1iZXItYXMtYS1kZWNpbWFsLWluY2x1ZGluZy0xLTA+XG5mdW5jdGlvbiBpc09uZVBvaW50WmVybyhuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCcuJykgIT0gLTEgJiYgcGFyc2VGbG9hdChuKSA9PT0gMTtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIHN0cmluZyBwYXNzZWQgaW4gaXMgYSBwZXJjZW50YWdlXG5mdW5jdGlvbiBpc1BlcmNlbnRhZ2Uobikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiAmJiBuLmluZGV4T2YoJyUnKSAhPSAtMTtcbn1cblxuLy8gRm9yY2UgYSBoZXggdmFsdWUgdG8gaGF2ZSAyIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBhZDIoYykge1xuICAgIHJldHVybiBjLmxlbmd0aCA9PSAxID8gJzAnICsgYyA6ICcnICsgYztcbn1cblxuLy8gUmVwbGFjZSBhIGRlY2ltYWwgd2l0aCBpdCdzIHBlcmNlbnRhZ2UgdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnRUb1BlcmNlbnRhZ2Uobikge1xuICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgbiA9IChuICogMTAwKSArIFwiJVwiO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG4vLyBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gYSBoZXggdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnREZWNpbWFsVG9IZXgoZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZCkgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIENvbnZlcnRzIGEgaGV4IHZhbHVlIHRvIGEgZGVjaW1hbFxuZnVuY3Rpb24gY29udmVydEhleFRvRGVjaW1hbChoKSB7XG4gICAgcmV0dXJuIChwYXJzZUludEZyb21IZXgoaCkgLyAyNTUpO1xufVxuXG52YXIgbWF0Y2hlcnMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI2ludGVnZXJzPlxuICAgIHZhciBDU1NfSU5URUdFUiA9IFwiWy1cXFxcK10/XFxcXGQrJT9cIjtcblxuICAgIC8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXZhbHVlcy8jbnVtYmVyLXZhbHVlPlxuICAgIHZhciBDU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG5cbiAgICAvLyBBbGxvdyBwb3NpdGl2ZS9uZWdhdGl2ZSBpbnRlZ2VyL251bWJlci4gIERvbid0IGNhcHR1cmUgdGhlIGVpdGhlci9vciwganVzdCB0aGUgZW50aXJlIG91dGNvbWUuXG4gICAgdmFyIENTU19VTklUID0gXCIoPzpcIiArIENTU19OVU1CRVIgKyBcIil8KD86XCIgKyBDU1NfSU5URUdFUiArIFwiKVwiO1xuXG4gICAgLy8gQWN0dWFsIG1hdGNoaW5nLlxuICAgIC8vIFBhcmVudGhlc2VzIGFuZCBjb21tYXMgYXJlIG9wdGlvbmFsLCBidXQgbm90IHJlcXVpcmVkLlxuICAgIC8vIFdoaXRlc3BhY2UgY2FuIHRha2UgdGhlIHBsYWNlIG9mIGNvbW1hcyBvciBvcGVuaW5nIHBhcmVuXG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0gzID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0g0ID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBDU1NfVU5JVDogbmV3IFJlZ0V4cChDU1NfVU5JVCksXG4gICAgICAgIHJnYjogbmV3IFJlZ0V4cChcInJnYlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICByZ2JhOiBuZXcgUmVnRXhwKFwicmdiYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoc2w6IG5ldyBSZWdFeHAoXCJoc2xcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgaHNsYTogbmV3IFJlZ0V4cChcImhzbGFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaHN2OiBuZXcgUmVnRXhwKFwiaHN2XCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIGhzdmE6IG5ldyBSZWdFeHAoXCJoc3ZhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhleDM6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICAgICAgaGV4NjogL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLFxuICAgICAgICBoZXg0OiAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICBoZXg4OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvXG4gICAgfTtcbn0pKCk7XG5cbi8vIGBpc1ZhbGlkQ1NTVW5pdGBcbi8vIFRha2UgaW4gYSBzaW5nbGUgc3RyaW5nIC8gbnVtYmVyIGFuZCBjaGVjayB0byBzZWUgaWYgaXQgbG9va3MgbGlrZSBhIENTUyB1bml0XG4vLyAoc2VlIGBtYXRjaGVyc2AgYWJvdmUgZm9yIGRlZmluaXRpb24pLlxuZnVuY3Rpb24gaXNWYWxpZENTU1VuaXQoY29sb3IpIHtcbiAgICByZXR1cm4gISFtYXRjaGVycy5DU1NfVU5JVC5leGVjKGNvbG9yKTtcbn1cblxuLy8gYHN0cmluZ0lucHV0VG9PYmplY3RgXG4vLyBQZXJtaXNzaXZlIHN0cmluZyBwYXJzaW5nLiAgVGFrZSBpbiBhIG51bWJlciBvZiBmb3JtYXRzLCBhbmQgb3V0cHV0IGFuIG9iamVjdFxuLy8gYmFzZWQgb24gZGV0ZWN0ZWQgZm9ybWF0LiAgUmV0dXJucyBgeyByLCBnLCBiIH1gIG9yIGB7IGgsIHMsIGwgfWAgb3IgYHsgaCwgcywgdn1gXG5mdW5jdGlvbiBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKSB7XG5cbiAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UodHJpbUxlZnQsJycpLnJlcGxhY2UodHJpbVJpZ2h0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZWQgPSBmYWxzZTtcbiAgICBpZiAobmFtZXNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZXNbY29sb3JdO1xuICAgICAgICBuYW1lZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yID09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogMCwgZzogMCwgYjogMCwgYTogMCwgZm9ybWF0OiBcIm5hbWVcIiB9O1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtYXRjaCBzdHJpbmcgaW5wdXQgdXNpbmcgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAvLyBLZWVwIG1vc3Qgb2YgdGhlIG51bWJlciBib3VuZGluZyBvdXQgb2YgdGhpcyBmdW5jdGlvbiAtIGRvbid0IHdvcnJ5IGFib3V0IFswLDFdIG9yIFswLDEwMF0gb3IgWzAsMzYwXVxuICAgIC8vIEp1c3QgcmV0dXJuIGFuIG9iamVjdCBhbmQgbGV0IHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBoYW5kbGUgdGhhdC5cbiAgICAvLyBUaGlzIHdheSB0aGUgcmVzdWx0IHdpbGwgYmUgdGhlIHNhbWUgd2hldGhlciB0aGUgdGlueWNvbG9yIGlzIGluaXRpYWxpemVkIHdpdGggc3RyaW5nIG9yIG9iamVjdC5cbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2YS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSksXG4gICAgICAgICAgICBhOiBjb252ZXJ0SGV4VG9EZWNpbWFsKG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10gKyAnJyArIG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0gKyAnJyArIG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgJycgKyBtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0gKyAnJyArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXQ0FHMlBhcm1zKHBhcm1zKSB7XG4gICAgLy8gcmV0dXJuIHZhbGlkIFdDQUcyIHBhcm1zIGZvciBpc1JlYWRhYmxlLlxuICAgIC8vIElmIGlucHV0IHBhcm1zIGFyZSBpbnZhbGlkLCByZXR1cm4ge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn1cbiAgICB2YXIgbGV2ZWwsIHNpemU7XG4gICAgcGFybXMgPSBwYXJtcyB8fCB7XCJsZXZlbFwiOlwiQUFcIiwgXCJzaXplXCI6XCJzbWFsbFwifTtcbiAgICBsZXZlbCA9IChwYXJtcy5sZXZlbCB8fCBcIkFBXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgc2l6ZSA9IChwYXJtcy5zaXplIHx8IFwic21hbGxcIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGV2ZWwgIT09IFwiQUFcIiAmJiBsZXZlbCAhPT0gXCJBQUFcIikge1xuICAgICAgICBsZXZlbCA9IFwiQUFcIjtcbiAgICB9XG4gICAgaWYgKHNpemUgIT09IFwic21hbGxcIiAmJiBzaXplICE9PSBcImxhcmdlXCIpIHtcbiAgICAgICAgc2l6ZSA9IFwic21hbGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcImxldmVsXCI6bGV2ZWwsIFwic2l6ZVwiOnNpemV9O1xufVxuXG4vLyBOb2RlOiBFeHBvcnQgZnVuY3Rpb25cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW55Y29sb3I7XG59XG4vLyBBTUQvcmVxdWlyZWpzOiBEZWZpbmUgdGhlIG1vZHVsZVxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtyZXR1cm4gdGlueWNvbG9yO30pO1xufVxuLy8gQnJvd3NlcjogRXhwb3NlIHRvIHdpbmRvd1xuZWxzZSB7XG4gICAgd2luZG93LnRpbnljb2xvciA9IHRpbnljb2xvcjtcbn1cblxufSkoTWF0aCk7XG4iLCIvKlxuICogVG9hc3RyXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1XG4gKiBBdXRob3JzOiBKb2huIFBhcGEsIEhhbnMgRmrDpGxsZW1hcmssIGFuZCBUaW0gRmVycmVsbC5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBVc2UsIHJlcHJvZHVjdGlvbiwgZGlzdHJpYnV0aW9uLCBhbmQgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29kZSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmRcbiAqIGNvbmRpdGlvbnMgb2YgdGhlIE1JVCBsaWNlbnNlLCBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiBBUklBIFN1cHBvcnQ6IEdyZXRhIEtyYWZzaWdcbiAqXG4gKiBQcm9qZWN0OiBodHRwczovL2dpdGh1Yi5jb20vQ29kZVNldmVuL3RvYXN0clxuICovXG4vKiBnbG9iYWwgZGVmaW5lICovXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmdW5jdGlvbiAoJCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkY29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuICAgICAgICAgICAgdmFyIHRvYXN0SWQgPSAwO1xuICAgICAgICAgICAgdmFyIHRvYXN0VHlwZSA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBpbmZvOiAnaW5mbycsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6ICd3YXJuaW5nJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRvYXN0ciA9IHtcbiAgICAgICAgICAgICAgICBjbGVhcjogY2xlYXIsXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGdldENvbnRhaW5lcjogZ2V0Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGluZm86IGluZm8sXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMi4xLjMnLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IHdhcm5pbmdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBwcmV2aW91c1RvYXN0O1xuXG4gICAgICAgICAgICByZXR1cm4gdG9hc3RyO1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIHRpdGxlLCBvcHRpb25zT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9hc3RUeXBlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGdldE9wdGlvbnMoKS5pY29uQ2xhc3Nlcy5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc092ZXJyaWRlOiBvcHRpb25zT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDb250YWluZXIob3B0aW9ucywgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7IG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7IH1cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyID0gJCgnIycgKyBvcHRpb25zLmNvbnRhaW5lcklkKTtcbiAgICAgICAgICAgICAgICBpZiAoJGNvbnRhaW5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb250YWluZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJGNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb250YWluZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGluZm8obWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUuaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMuaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc092ZXJyaWRlOiBvcHRpb25zT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWNjZXNzKG1lc3NhZ2UsIHRpdGxlLCBvcHRpb25zT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9hc3RUeXBlLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS53YXJuaW5nLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGdldE9wdGlvbnMoKS5pY29uQ2xhc3Nlcy53YXJuaW5nLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyKCR0b2FzdEVsZW1lbnQsIGNsZWFyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIGlmICghJGNvbnRhaW5lcikgeyBnZXRDb250YWluZXIob3B0aW9ucyk7IH1cbiAgICAgICAgICAgICAgICBpZiAoIWNsZWFyVG9hc3QoJHRvYXN0RWxlbWVudCwgb3B0aW9ucywgY2xlYXJPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbnRhaW5lcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZSgkdG9hc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7IGdldENvbnRhaW5lcihvcHRpb25zKTsgfVxuICAgICAgICAgICAgICAgIGlmICgkdG9hc3RFbGVtZW50ICYmICQoJzpmb2N1cycsICR0b2FzdEVsZW1lbnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJGNvbnRhaW5lci5jaGlsZHJlbigpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgZnVuY3Rpb25zXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyQ29udGFpbmVyIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvYXN0c1RvQ2xlYXIgPSAkY29udGFpbmVyLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvYXN0c1RvQ2xlYXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUb2FzdCgkKHRvYXN0c1RvQ2xlYXJbaV0pLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyVG9hc3QgKCR0b2FzdEVsZW1lbnQsIG9wdGlvbnMsIGNsZWFyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IGNsZWFyT3B0aW9ucyAmJiBjbGVhck9wdGlvbnMuZm9yY2UgPyBjbGVhck9wdGlvbnMuZm9yY2UgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoJHRvYXN0RWxlbWVudCAmJiAoZm9yY2UgfHwgJCgnOmZvY3VzJywgJHRvYXN0RWxlbWVudCkubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50W29wdGlvbnMuaGlkZU1ldGhvZF0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuaGlkZUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmhpZGVFYXNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KTsgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAkY29udGFpbmVyID0gJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgb3B0aW9ucy5jb250YWluZXJJZClcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKG9wdGlvbnMucG9zaXRpb25DbGFzcyk7XG5cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyLmFwcGVuZFRvKCQob3B0aW9ucy50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFwVG9EaXNtaXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0b2FzdENsYXNzOiAndG9hc3QnLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJJZDogJ3RvYXN0LWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgICAgICBzaG93TWV0aG9kOiAnZmFkZUluJywgLy9mYWRlSW4sIHNsaWRlRG93biwgYW5kIHNob3cgYXJlIGJ1aWx0IGludG8galF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHNob3dEdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgICAgICAgICBzaG93RWFzaW5nOiAnc3dpbmcnLCAvL3N3aW5nIGFuZCBsaW5lYXIgYXJlIGJ1aWx0IGludG8galF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIG9uU2hvd246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZU1ldGhvZDogJ2ZhZGVPdXQnLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRHVyYXRpb246IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFYXNpbmc6ICdzd2luZycsXG4gICAgICAgICAgICAgICAgICAgIG9uSGlkZGVuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlTWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VEdXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRWFzaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VPbkhvdmVyOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkVGltZU91dDogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAndG9hc3QtZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbzogJ3RvYXN0LWluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogJ3RvYXN0LXN1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZzogJ3RvYXN0LXdhcm5pbmcnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogJ3RvYXN0LWluZm8nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNsYXNzOiAndG9hc3QtdG9wLXJpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgdGltZU91dDogNTAwMCwgLy8gU2V0IHRpbWVPdXQgYW5kIGV4dGVuZGVkVGltZU91dCB0byAwIHRvIG1ha2UgaXQgc3RpY2t5XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlQ2xhc3M6ICd0b2FzdC10aXRsZScsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VDbGFzczogJ3RvYXN0LW1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVIdG1sOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAnYm9keScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlSHRtbDogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiPiZ0aW1lczs8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUNsYXNzOiAndG9hc3QtY2xvc2UtYnV0dG9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmV3ZXN0T25Ub3A6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREdXBsaWNhdGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0NsYXNzOiAndG9hc3QtcHJvZ3Jlc3MnLFxuICAgICAgICAgICAgICAgICAgICBydGw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGlzaChhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbm90aWZ5KG1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIHZhciBpY29uQ2xhc3MgPSBtYXAuaWNvbkNsYXNzIHx8IG9wdGlvbnMuaWNvbkNsYXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobWFwLm9wdGlvbnNPdmVycmlkZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZChvcHRpb25zLCBtYXAub3B0aW9uc092ZXJyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzID0gbWFwLm9wdGlvbnNPdmVycmlkZS5pY29uQ2xhc3MgfHwgaWNvbkNsYXNzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFeGl0KG9wdGlvbnMsIG1hcCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICB0b2FzdElkKys7XG5cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciAkdG9hc3RFbGVtZW50ID0gJCgnPGRpdi8+Jyk7XG4gICAgICAgICAgICAgICAgdmFyICR0aXRsZUVsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJG1lc3NhZ2VFbGVtZW50ID0gJCgnPGRpdi8+Jyk7XG4gICAgICAgICAgICAgICAgdmFyICRwcm9ncmVzc0VsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJGNsb3NlRWxlbWVudCA9ICQob3B0aW9ucy5jbG9zZUh0bWwpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc0JhciA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxJZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWF4SGlkZVRpbWU6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9hc3RJZDogdG9hc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG1hcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBwZXJzb25hbGl6ZVRvYXN0KCk7XG5cbiAgICAgICAgICAgICAgICBkaXNwbGF5VG9hc3QoKTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgcHVibGlzaChyZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1ZyAmJiBjb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHRvYXN0RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMzk7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGVyc29uYWxpemVUb2FzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SWNvbigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaXRsZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldENsb3NlQnV0dG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFByb2dyZXNzQmFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFJUTCgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmlhKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0QXJpYSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyaWFWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hcC5pY29uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvYXN0LXN1Y2Nlc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9hc3QtaW5mbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVZhbHVlID0gICdwb2xpdGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhVmFsdWUgPSAnYXNzZXJ0aXZlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmF0dHIoJ2FyaWEtbGl2ZScsIGFyaWFWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRzKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZU9uSG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuaG92ZXIoc3RpY2tBcm91bmQsIGRlbGF5ZWRIaWRlVG9hc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm9uY2xpY2sgJiYgb3B0aW9ucy50YXBUb0Rpc21pc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuY2xpY2soaGlkZVRvYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlQnV0dG9uICYmICRjbG9zZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjbG9zZUVsZW1lbnQuY2xpY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uQ2xvc2VDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uQ2xvc2VDbGljayhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRvYXN0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jbGljayhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRvYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpc3BsYXlUb2FzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudFtvcHRpb25zLnNob3dNZXRob2RdKFxuICAgICAgICAgICAgICAgICAgICAgICAge2R1cmF0aW9uOiBvcHRpb25zLnNob3dEdXJhdGlvbiwgZWFzaW5nOiBvcHRpb25zLnNob3dFYXNpbmcsIGNvbXBsZXRlOiBvcHRpb25zLm9uU2hvd259XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZU91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRUaW1lb3V0KGhpZGVUb2FzdCwgb3B0aW9ucy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lID0gcGFyc2VGbG9hdChvcHRpb25zLnRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaGlkZUV0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcm9ncmVzc0Jhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh1cGRhdGVQcm9ncmVzcywgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5pY29uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYWRkQ2xhc3Mob3B0aW9ucy50b2FzdENsYXNzKS5hZGRDbGFzcyhpY29uQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0U2VxdWVuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5ld2VzdE9uVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLnByZXBlbmQoJHRvYXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLmFwcGVuZCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFRpdGxlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VmZml4ID0gbWFwLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXNjYXBlSHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGVzY2FwZUh0bWwobWFwLnRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICR0aXRsZUVsZW1lbnQuYXBwZW5kKHN1ZmZpeCkuYWRkQ2xhc3Mob3B0aW9ucy50aXRsZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYXBwZW5kKCR0aXRsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0TWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VmZml4ID0gbWFwLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lc2NhcGVIdG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gZXNjYXBlSHRtbChtYXAubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAkbWVzc2FnZUVsZW1lbnQuYXBwZW5kKHN1ZmZpeCkuYWRkQ2xhc3Mob3B0aW9ucy5tZXNzYWdlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hcHBlbmQoJG1lc3NhZ2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldENsb3NlQnV0dG9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNsb3NlRWxlbWVudC5hZGRDbGFzcyhvcHRpb25zLmNsb3NlQ2xhc3MpLmF0dHIoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnByZXBlbmQoJGNsb3NlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRQcm9ncmVzc0JhcigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwcm9ncmVzc0VsZW1lbnQuYWRkQ2xhc3Mob3B0aW9ucy5wcm9ncmVzc0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQucHJlcGVuZCgkcHJvZ3Jlc3NFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFJUTCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmFkZENsYXNzKCdydGwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZEV4aXQob3B0aW9ucywgbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXZlbnREdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwLm1lc3NhZ2UgPT09IHByZXZpb3VzVG9hc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUb2FzdCA9IG1hcC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoaWRlVG9hc3Qob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG92ZXJyaWRlICYmIG9wdGlvbnMuY2xvc2VNZXRob2QgIT09IGZhbHNlID8gb3B0aW9ucy5jbG9zZU1ldGhvZCA6IG9wdGlvbnMuaGlkZU1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gb3ZlcnJpZGUgJiYgb3B0aW9ucy5jbG9zZUR1cmF0aW9uICE9PSBmYWxzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNsb3NlRHVyYXRpb24gOiBvcHRpb25zLmhpZGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9IG92ZXJyaWRlICYmIG9wdGlvbnMuY2xvc2VFYXNpbmcgIT09IGZhbHNlID8gb3B0aW9ucy5jbG9zZUVhc2luZyA6IG9wdGlvbnMuaGlkZUVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQoJzpmb2N1cycsICR0b2FzdEVsZW1lbnQpLmxlbmd0aCAmJiAhb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocHJvZ3Jlc3NCYXIuaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdG9hc3RFbGVtZW50W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpbnRlcnZhbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbkhpZGRlbiAmJiByZXNwb25zZS5zdGF0ZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkhpZGRlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0ZSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2gocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxheWVkSGlkZVRvYXN0KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lT3V0ID4gMCB8fCBvcHRpb25zLmV4dGVuZGVkVGltZU91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRUaW1lb3V0KGhpZGVUb2FzdCwgb3B0aW9ucy5leHRlbmRlZFRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMuZXh0ZW5kZWRUaW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLmhpZGVFdGEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3RpY2tBcm91bmQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpbnRlcnZhbElkKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaGlkZUV0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuc3RvcCh0cnVlLCB0cnVlKVtvcHRpb25zLnNob3dNZXRob2RdKFxuICAgICAgICAgICAgICAgICAgICAgICAge2R1cmF0aW9uOiBvcHRpb25zLnNob3dEdXJhdGlvbiwgZWFzaW5nOiBvcHRpb25zLnNob3dFYXNpbmd9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlID0gKChwcm9ncmVzc0Jhci5oaWRlRXRhIC0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSkgLyBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZSkgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgICRwcm9ncmVzc0VsZW1lbnQud2lkdGgocGVyY2VudGFnZSArICclJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZ2V0RGVmYXVsdHMoKSwgdG9hc3RyLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7ICRjb250YWluZXIgPSBnZXRDb250YWluZXIoKTsgfVxuICAgICAgICAgICAgICAgIGlmICgkdG9hc3RFbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoJGNvbnRhaW5lci5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RvYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KSgpO1xuICAgIH0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZGVwcywgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgeyAvL05vZGVcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy50b2FzdHIgPSBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xuICAgIH1cbn0pKTtcbiIsInZhciB0ZW1wbGF0ZVN5c3RlbSA9IHJlcXVpcmUoJy4uL3NyYy9qcy9iaW5kaW5ncy9jaG9vc2UtdGVtcGxhdGUuanMnKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbihldmVudCkge1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImFycmF5XCIsIFwiPCEtLSBrbyBmb3JlYWNoOiAkZGF0YSAtLT48IS0tIGtvIGJsb2NrOiAkZGF0YSAtLT48IS0tIC9rbyAtLT48IS0tIC9rbyAtLT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYmxvY2stc2hvd1wiLCBcIjwhLS0ga28gYmxvY2s6ICRkYXRhLCBzY3JvbGxJbnRvVmlldzogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09PSAkZGF0YSAtLT48IS0tIC9rbyAtLT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYmxvY2std3lzaXd5Z1wiLCBcIjxkaXYgY2xhc3M9XFx4MjJlZGl0YWJsZSBibG9ja1xceDIyIGRhdGEtZHJvcC1jb250ZW50PVxceDIyRHJvcCBoZXJlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyAnZGF0YS1kcm9wLWNvbnRlbnQnOiAkcm9vdC50KCdEcm9wIGhlcmUnKSB9LCBjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0QmxvY2sob2JqKTsgcmV0dXJuIHRydWUgfSwgY2xpY2tCdWJibGU6IGZhbHNlLCBjc3M6IHsgc2VsZWN0ZWQ6ICRyb290LnNlbGVjdGVkQmxvY2soKSA9PT0gJGRhdGEgfSwgc2Nyb2xsSW50b1ZpZXc6ICRyb290LnNlbGVjdGVkQmxvY2soKSA9PT0gJGRhdGFcXHgyMj4gIDxkaXYgY2xhc3M9XFx4MjJtby1ibG9ja3NlbGVjdGlvbmhlbHBlclxceDIyPjwvZGl2PiAgPGRpdiBjbGFzcz1cXHgyMnRvb2xzXFx4MjIgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkaW5kZXggIT0gJ3VuZGVmaW5lZCcgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJEcmFnIHRoaXMgaGFuZGxlIHRvIG1vdmUgdGhlIGJsb2NrXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnRHJhZyB0aGlzIGhhbmRsZSB0byBtb3ZlIHRoZSBibG9jaycpIH1cXHgyMiBjbGFzcz1cXHgyMnRvb2wgaGFuZGxlXFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1zb3J0XFx4MjI+PC9pPjwvZGl2PiAgICA8IS0tIGtvIGlmOiAkaW5kZXgoKSA+IDAgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJNb3ZlIHRoaXMgYmxvY2sgdXBzaWRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnTW92ZSB0aGlzIGJsb2NrIHVwc2lkZScpIH1cXHgyMiBjbGFzcz1cXHgyMnRvb2wgbW92ZXVwXFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1zb3J0LWFzY1xceDIyIGRhdGEtYmluZD0nY2xpY2s6ICRyb290Lm1vdmVCbG9jay5iaW5kKCRlbGVtZW50LCAkaW5kZXgsICRwYXJlbnQsIHRydWUpJz48L2k+PC9kaXY+ICAgIDwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiAkaW5kZXgoKSA8ICRwYXJlbnQuYmxvY2tzKCkubGVuZ3RoIC0xIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyTW92ZSB0aGlzIGJsb2NrIGRvd25zaWRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnTW92ZSB0aGlzIGJsb2NrIGRvd25zaWRlJykgfVxceDIyIGNsYXNzPVxceDIydG9vbCBtb3ZlZG93blxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtc29ydC1kZXNjXFx4MjIgZGF0YS1iaW5kPSdjbGljazogJHJvb3QubW92ZUJsb2NrLmJpbmQoJGVsZW1lbnQsICRpbmRleCwgJHBhcmVudCwgZmFsc2UpJz48L2k+PC9kaXY+ICAgIDwhLS0gL2tvIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyRGVsZXRlIGJsb2NrXFx4MjIgY2xhc3M9XFx4MjJ0b29sIGRlbGV0ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0RlbGV0ZSBibG9jaycpIH0sIGNsaWNrOiAkcm9vdC5yZW1vdmVCbG9jay5iaW5kKCRlbGVtZW50LCAkcmF3RGF0YSwgJHBhcmVudClcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXRyYXNoLW9cXHgyMj48L2k+PC9kaXY+ICAgIDxkaXYgdGl0bGU9XFx4MjJEdXBsaWNhdGUgYmxvY2tcXHgyMiBjbGFzcz1cXHgyMnRvb2wgY2xvbmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdEdXBsaWNhdGUgYmxvY2snKSB9LCBjbGljazogJHJvb3QuZHVwbGljYXRlQmxvY2suYmluZCgkZWxlbWVudCwgJGluZGV4LCAkcGFyZW50KVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtZmlsZXMtb1xceDIyPjwvaT48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkZGF0YS5fbmV4dFZhcmlhbnQgIT0gJ3VuZGVmaW5lZCcgLS0+PGRpdiB0aXRsZT1cXHgyMlN3aXRjaCBibG9jayB2YXJpYW50XFx4MjIgY2xhc3M9XFx4MjJ0b29sIHZhcmlhbnRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTd2l0Y2ggYmxvY2sgdmFyaWFudCcpIH0sIGNsaWNrOiAkZGF0YS5fbmV4dFZhcmlhbnRcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLW1hZ2ljXFx4MjI+PC9pPjwvZGl2PjwhLS0gL2tvIC0tPiAgPC9kaXY+ICA8IS0tIGtvIGJsb2NrOiAkZGF0YSAtLT48IS0tIC9rbyAtLT48L2Rpdj5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYmxvY2tzLXNob3dcIiwgXCI8IS0tIGtvIHRlbXBsYXRlOiB7IG5hbWU6ICdibG9jay1zaG93JywgZm9yZWFjaDogYmxvY2tzIH0gLS0+PCEtLSAva28gLS0+XCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImJsb2Nrcy13eXNpd3lnXCIsIFwiPGRpdiBjbGFzcz1cXHgyMnNvcnRhYmxlLWJsb2Nrcy1lZGl0XFx4MjIgZGF0YS1kcm9wLWNvbnRlbnQ9XFx4MjJEcm9wIGhlcmVcXHgyMiBkYXRhLWVtcHR5LWNvbnRlbnQ9XFx4MjJEcm9wIGhlcmUgYmxvY2tzIGZyb20gdGhlIEJsb2NrcyB0YWJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7ICdkYXRhLWRyb3AtY29udGVudCc6ICRyb290LnQoJ0Ryb3AgaGVyZScpLCAnZGF0YS1lbXB0eS1jb250ZW50JzogJHJvb3QudCgnRHJvcCBoZXJlIGJsb2NrcyBmcm9tIHRoZSAmcXVvdDtCbG9ja3MmcXVvdDsgdGFiJykgfSwgY3NzOiB7ICdlbXB0eSc6IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYmxvY2tzKS5sZW5ndGggPT0gMCB9LCBleHRzb3J0YWJsZTogeyBjb25uZWN0Q2xhc3M6ICdzb3J0YWJsZS1ibG9ja3MtZWRpdCcsIHRlbXBsYXRlOiAnYmxvY2std3lzaXd5ZycsIGRhdGE6IGJsb2NrcywgZHJhZ2dpbmc6ICRyb290LmRyYWdnaW5nLCBiZWZvcmVNb3ZlOiAkcm9vdC5zdGFydE11bHRpcGxlLCBhZnRlck1vdmU6ICRyb290LnN0b3BNdWx0aXBsZSwgb3B0aW9uczogeyBoYW5kbGU6ICcuaGFuZGxlJywgcGxhY2Vob2xkZXI6ICRyb290LnBsYWNlaG9sZGVySGVscGVyIH0gfVxceDIyPjwvZGl2PlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJjdXN0b21zdHlsZVwiLCBcIjxkaXYgY2xhc3M9XFx4MjJjdXN0b21TdHlsZUhlbHBcXHgyMiBkYXRhLWJpbmQ9XFx4MjJodG1sOiAkcm9vdC50KCdDdXN0b21pemVkIGJsb2NrLjx1bD48bGk+SW4gdGhpcyBzdGF0dXMgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIHdpbGwgYmUgc3BlY2lmaWMgdG8gdGhlIGN1cnJlbnQgYmxvY2sgKGluc3RlYWQgb2YgYmVpbmcgZ2xvYmFsIHRvIGFsbCBibG9ja3MgaW4gdGhlIHNhbWUgc2VjdGlvbik8L2xpPjxsaT5BIDxzcGFuIGNsYXNzPSZxdW90O2N1c3RvbVN0eWxlZCZxdW90Oz48c3Bhbj4mcXVvdDtzbWFsbCBjdWJlJnF1b3Q7IDwvc3Bhbj48L3NwYW4+IGljb24gYmVzaWRlIHRoZSBwcm9wZXJ0eSB3aWxsIG1hcmsgdGhlIGN1c3RvbWl6YXRpb24uIEJ5IGNsaWNraW5nIHRoaXMgaWNvbiB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXZlcnRlZCB0byB0aGUgdmFsdWUgZGVmaW5lZCBmb3IgdGhlIHNlY3Rpb24uPC9saT48L3VsPicpXFx4MjI+Q3VzdG9taXplZCBibG9jay48dWw+PGxpPkluIHRoaXMgc3RhdHVzIGNoYW5nZXMgdG8gcHJvcGVydGllcyB3aWxsIGJlIHNwZWNpZmljIHRvIHRoZSBjdXJyZW50IGJsb2NrIChpbnN0ZWFkIG9mIGJlaW5nIGdsb2JhbCB0byBhbGwgYmxvY2tzIGluIHRoZSBzYW1lIHNlY3Rpb24pPC9saT48bGk+QSA8c3BhbiBjbGFzcz1cXHgyMmN1c3RvbVN0eWxlZFxceDIyPjxzcGFuPlxceDIyc21hbGwgY3ViZVxceDIyIDwvc3Bhbj48L3NwYW4+IGljb24gYmVzaWRlIHRoZSBwcm9wZXJ0eSB3aWxsIG1hcmsgdGhlIGN1c3RvbWl6YXRpb24uIEJ5IGNsaWNraW5nIHRoaXMgaWNvbiB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXZlcnRlZCB0byB0aGUgdmFsdWUgZGVmaW5lZCBmb3IgdGhlIHNlY3Rpb24uPC9saT48L3VsPjwvZGl2PlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJlbXB0eVwiLCBcIlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJlcnJvclwiLCBcIls8ZGl2IHN0eWxlPVxceDIyYmFja2dyb3VuZC1jb2xvcjogI2ZmZjBmMFxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6IGtvLnRvSlMoJGRhdGEpXFx4MjI+PC9kaXY+XVwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJpbWctd3lzaXd5Z1wiLCBcIjx0YWJsZSB0YWJmb2N1cz1cXHgyMjBcXHgyMiBjZWxsc3BhY2luZz1cXHgyMjBcXHgyMiBjZWxscGFkZGluZz1cXHgyMjBcXHgyMiBkYXRhLWRyb3AtY29udGVudD1cXHgyMkRyb3AgaGVyZVxceDIyIGRhdGEtYmluZD1cXHgyMnN0eWxlOiBfc3R5bGViaW5kLCBjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0SXRlbShfaXRlbSwgX2RhdGEpOyByZXR1cm4gdHJ1ZTsgfSwgY2xpY2tCdWJibGU6IGZhbHNlLCBmdWRyb3BwYWJsZTogeyBhY3RpdmVDbGFzczogJ3VpLXN0YXRlLWhpZ2hsaWdodCcsIGhvdmVyQ2xhc3M6ICd1aS1zdGF0ZS1kcmFnaG92ZXInIH0sIGRyb3BwYWJsZTogeyBvcHRpb25zOiB7IGFjY2VwdDogJy5pbWFnZScsIGFjdGl2ZUNsYXNzOiAndWktc3RhdGUtaGlnaGxpZ2h0JywgaG92ZXJDbGFzczogJ3VpLXN0YXRlLWRyYWdob3ZlcicgfSwgZGF0YTogX3NyYywgZHJhZ2dlZDogJHJvb3QuZmlsZVRvSW1hZ2UgfSwgY3NzOiB7IHNlbGVjdGVkaXRlbTogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oX2l0ZW0pIH0sIHNjcm9sbEludG9WaWV3OiAkcm9vdC5pc1NlbGVjdGVkSXRlbShfaXRlbSksIGF0dHI6IHsgJ2RhdGEtZHJvcC1jb250ZW50JzogJHJvb3QudCgnRHJvcCBoZXJlJyksIHdpZHRoOiBfd2lkdGgsIGhlaWdodDogX2hlaWdodCwgYWxpZ246IF9hbGlnbiB9XFx4MjIgIGNsYXNzPVxceDIyaW1nLXd5c2l3eWcgc2VsZWN0YWJsZS1pbWdcXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IHRhYmxlO1xceDIyPjx0cj48dGQgY2xhc3M9XFx4MjJ1cGxvYWR6b25lXFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIybW8taW1nc2VsZWN0aW9uaGVscGVyXFx4MjI+PC9kaXY+ICA8ZGl2IGNsYXNzPVxceDIybW8tdXBsb2Fkem9uZVxceDIyPjwvZGl2PiAgPGRpdiBjbGFzcz1cXHgyMmltZy1zaXplXFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogX3NpemVcXHgyMj5zaXplPC9kaXY+ICA8ZGl2IGNsYXNzPVxceDIybWlkdG9vbHNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj4gICAgPCEtLSBrbyBpZjogX3NyYygpICE9ICcnIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyUmVtb3ZlIGltYWdlXFx4MjIgY2xhc3M9XFx4MjJ0b29sIGRlbGV0ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1JlbW92ZSBpbWFnZScpIH0sIGNsaWNrOiBfc3JjLmJpbmQoX3NyYywgJycpLCBjbGlja0J1YmJsZTogZmFsc2VcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXRyYXNoLW9cXHgyMj48L2k+PC9kaXY+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC5lZGl0SW1hZ2UgIT09ICd1bmRlZmluZWQnIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyT3BlbiB0aGUgaW1hZ2UgZWRpdGluZyB0b29sXFx4MjIgY2xhc3M9XFx4MjJ0b29sIGVkaXRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdPcGVuIHRoZSBpbWFnZSBlZGl0aW5nIHRvb2wnKSB9LCBjbGljazogJHJvb3QuZWRpdEltYWdlLmJpbmQoJGVsZW1lbnQsIF9zcmMpLCBjbGlja0J1YmJsZTogZmFsc2VcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXBlbmNpbFxceDIyPjwvaT48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiBfc3JjKCkgPT0gJycgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJVcGxvYWQgYSBuZXcgaW1hZ2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdVcGxvYWQgYSBuZXcgaW1hZ2UnKSB9XFx4MjIgY2xhc3M9XFx4MjJ0b29sIHVwbG9hZFxceDIyIHN0eWxlPVxceDIycG9zaXRpb246IHJlbGF0aXZlOyBvdmVyZmxvdzogaGlkZGVuO1xceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtdXBsb2FkXFx4MjI+PC9pPiAgICAgIDxpbnB1dCBjbGFzcz1cXHgyMmZpbGV1cGxvYWQgbm9maWxlXFx4MjIgdHlwZT1cXHgyMmZpbGVcXHgyMiBuYW1lPVxceDIyZmlsZXNbXVxceDIyIGRhdGEtYmluZD1cXHgyMmZpbGV1cGxvYWQ6IHsgZGF0YTogX3NyYywgb25lcnJvcjogJHJvb3Qubm90aWZpZXIuZXJyb3IsIG9uZmlsZTogJHJvb3QubG9hZE1haWxpbmdJbWFnZSwgY2FudmFzUHJldmlldzogdHJ1ZSB9XFx4MjIgc3R5bGU9XFx4MjJ6LWluZGV4OiAyMDsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG1pbi13aWR0aDogMTAwJTsgbWluLWhlaWdodDogMTAwJTsgZm9udC1zaXplOiA5OTlweDsgdGV4dC1hbGlnbjogcmlnaHQ7IGZpbHRlcjogYWxwaGEob3BhY2l0eT0wKTsgb3BhY2l0eTogMDsgb3V0bGluZTogbm9uZTsgY3Vyc29yOiBpbmhlcml0OyBkaXNwbGF5OiBibG9ja1xceDIyPiAgICA8L2Rpdj4gICAgPCEtLSAva28gLS0+ICA8L2Rpdj4gIDwhLS0ga28gdGVtcGxhdGU6IF90ZW1wbGF0ZSAtLT48IS0tIC9rbyAtLT4gIDwhLS0ga28gaWY6IF9zcmMoKSA9PSAnJyAtLT4gICAgPCEtLSAgICA8aW1nIHN0eWxlPVxceDIyZGlzcGxheTogYmxvY2s7XFx4MjIgY2xhc3M9XFx4MjJpbWdwbGFjZWhvbGRlclxceDIyIHdpZHRoPVxceDIyMjAwXFx4MjIgc3JjPVxceDIyXFx4MjIgYWx0PVxceDIySW5zZXJ0IGFuIGltYWdlIGhlcmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ3eXNpd3lnU3JjOiB7IHNyYzogX3NyYy5wcmVsb2FkZWQsIHBsYWNlaG9sZGVyOiBfcGxhY2Vob2xkZXJzcmMsIHdpZHRoOiBfd2lkdGgsIGhlaWdodDogX2hlaWdodCwgbWV0aG9kOiBfbWV0aG9kIH1cXHgyMiAvPiAgICAtLT4gICAgPHNwYW4gY2xhc3M9XFx4MjJmaWxldXBsb2FkdGV4dFxceDIyIHN0eWxlPVxceDIydGV4dC1hbGlnbjogY2VudGVyOyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgZmxleC1hbGlnbjogY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgcGFkZGluZzogMWVtOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDtcXHgyMj48c3BhbiBjbGFzcz1cXHgyMnRleHRNaWRkbGVcXHgyMiBzdHlsZT1cXHgyMiB0ZXh0LXNoYWRvdzogMXB4IDFweCAwICNGRkZGRkYsIDAgMCAxMHB4ICNGRkZGRkY7IGZvbnQtd2VpZ2h0OiBib2xkO1xceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290LnQoJ0Ryb3AgYW4gaW1hZ2UgaGVyZScpXFx4MjI+RHJvcCBhbiBpbWFnZSBoZXJlPC9zcGFuPjwvc3Bhbj4gIDwhLS0gL2tvIC0tPiAgPCEtLSBrbyBpZjogX3NyYygpICE9ICcnIC0tPiAgPCEtLSAgICA8aW1nIHN0eWxlPVxceDIyZGlzcGxheTogYmxvY2s7XFx4MjIgd2lkdGg9XFx4MjIyMDBcXHgyMiBzcmM9XFx4MjJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJwcmVsb2FkZXI6IF9zcmMsIHd5c2l3eWdTcmM6IHsgc3JjOiBfc3JjLnByZWxvYWRlZCwgcGxhY2Vob2xkZXI6IF9wbGFjZWhvbGRlcnNyYywgd2lkdGg6IF93aWR0aCwgaGVpZ2h0OiBfaGVpZ2h0LCBtZXRob2Q6IF9tZXRob2QgfVxceDIyIC8+ICAgIC0tPiAgPCEtLSAva28gLS0+ICA8IS0tIHB1bHNhbnRlIHBlciBsYSBjYW5jZWxsYXppb25lIC0tPiAgPGRpdiB0aXRsZT1cXHgyMkRyb3AgYW4gaW1hZ2UgaGVyZSBvciBjbGljayB0aGUgdXBsb2FkIGJ1dHRvblxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0Ryb3AgYW4gaW1hZ2UgaGVyZSBvciBjbGljayB0aGUgdXBsb2FkIGJ1dHRvbicpIH0sIHRvb2x0aXBzOiB7fVxceDIyIGNsYXNzPVxceDIyd29ya3pvbmVcXHgyMiBzdHlsZT1cXHgyMnBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuO1xceDIyPiAgICA8IS0tIGtvIGlmOiBfc3JjLnByZWxvYWRlZCAmJiBfc3JjKCkgIT0gX3NyYy5wcmVsb2FkZWQoKSAtLT5QUkVMT0FESU5HLi4uLjwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiBfc3JjKCkgIT0gJycgLS0+ICAgICAgPGlucHV0IGNsYXNzPVxceDIyZmlsZXVwbG9hZCB3aXRoZmlsZVxceDIyIHR5cGU9XFx4MjJmaWxlXFx4MjIgbmFtZT1cXHgyMmZpbGVzW11cXHgyMiBkYXRhLWJpbmQ9XFx4MjJmaWxldXBsb2FkOiB7IGRhdGE6IF9zcmMsIG9uZXJyb3I6ICRyb290Lm5vdGlmaWVyLmVycm9yLCBvbmZpbGU6ICRyb290Lm1haWxpbmdHYWxsZXJ5LnVuc2hpZnQuYmluZCgkcm9vdC5tYWlsaW5nR2FsbGVyeSksIGNhbnZhc1ByZXZpZXc6IHRydWUgfVxceDIyIHN0eWxlPVxceDIyei1pbmRleDogLTIwOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgbWluLXdpZHRoOiAxMDAlOyBtaW4taGVpZ2h0OiAxMDAlOyBmb250LXppZTogOTk5cHg7IHRleHQtYWxpZ246IHJpZ2h0OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9MCk7IG9wYWNpdHk6IDA7IG91dGxpbmU6IG5vbmU7IGN1cnNvcjogaW5oZXJpdDsgZGlzcGxheTogYmxvY2tcXHgyMj4gICAgPCEtLSAva28gLS0+ICAgIDxkaXYgY2xhc3M9XFx4MjJwcm9ncmVzc1xceDIyIHN0eWxlPVxceDIyb3BhY2l0eTogLjU7IHdpZHRoOiA4MCU7IG1hcmdpbi1sZWZ0OiAxMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAzMCU7IGhlaWdodDogMjBweDsgYm9yZGVyOiAycHggc29saWQgYmxhY2s7XFx4MjI+ICAgICAgPGRpdiBjbGFzcz1cXHgyMnByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3VjY2Vzc1xceDIyIHN0eWxlPVxceDIyaGVpZ2h0OiAyMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgXFx4MjI+PC9kaXY+ICAgIDwvZGl2PiAgPC9kaXY+PC90YWJsZT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwibWFpblwiLCBcIjxkaXYgaWQ9XFx4MjJwYWdlXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBub25lO1xceDIyIGRhdGEtYmluZD1cXHgyMnZpc2libGU6IHRydWUsIGNzczogeyB3aXRoVG9vbGJveDogJHJvb3Quc2hvd1Rvb2xib3gsIHdpdGhQcmV2aWV3RnJhbWU6IHNob3dQcmV2aWV3RnJhbWUgfVxceDIyPiAgPGRpdiBpZD1cXHgyMm1haW4tZWRpdC1hcmVhXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6IGZ1bmN0aW9uKG9iaiwgZXZ0KSB7ICRyb290LnNlbGVjdEJsb2NrKG51bGwpOyByZXR1cm4gdHJ1ZTsgfSwgY2xpY2tCdWJibGU6IGZhbHNlXFx4MjI+ICAgIDwhLS0ga28gd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiAnd3lzaXd5ZycsIHRlbXBsYXRlTW9kZUZhbGxiYWNrOiAnc2hvdycgfSAtLT4gICAgPGRpdiBpZD1cXHgyMm1haW4td3lzaXd5Zy1hcmVhXFx4MjIgZGF0YS1iaW5kPVxceDIyd3lzaXd5Z1Njcm9sbGZpeDogdHJ1ZSwgc2Nyb2xsYWJsZTogdHJ1ZSwgZnVkcm9wcGFibGU6IHsgYWN0aXZlOiBkcmFnZ2luZ0ltYWdlIH0sIGNzczogeyBpc2RyYWdnaW5nOiBkcmFnZ2luZywgaXNkcmFnZ2luZ2ltZzogZHJhZ2dpbmdJbWFnZSB9LCBibG9jazogY29udGVudFxceDIyPjwvZGl2PiAgICA8IS0tIC9rbyAtLT4gIDwvZGl2PiAgPGRpdiBpZD1cXHgyMnRvb2xiYXJcXHgyMiBjbGFzcz1cXHgyMm1vXFx4MjIgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC51bmRvICE9ICd1bmRlZmluZWQnIC0tPiAgICA8c3BhbiBkYXRhLWJpbmQ9XFx4MjJidXR0b25zZXQ6IHsgfVxceDIyIGNsYXNzPVxceDIybGVmdEJ1dHRvbnNcXHgyMj4gICAgPGEgdGl0bGU9XFx4MjJVbmRvIGxhc3Qgb3BlcmF0aW9uXFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1VuZG8gbGFzdCBvcGVyYXRpb24nKSB9LCBjbGljazogJHJvb3QudW5kby5leGVjdXRlLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnVuZG8uZW5hYmxlZCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtcmVwbHknIH0sIGxhYmVsOiAkcm9vdC51bmRvLm5hbWUsIHRleHQ6IHRydWUgfVxceDIyPlVORE88L2E+ICAgIDxhIHRpdGxlPVxceDIyUmVkbyBsYXN0IG9wZXJhdGlvblxceDIyIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdSZWRvIGxhc3Qgb3BlcmF0aW9uJykgfSwgY2xpY2s6ICRyb290LnJlZG8uZXhlY3V0ZSwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC5yZWRvLmVuYWJsZWQoKSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLXNoYXJlJyB9LCBsYWJlbDogJHJvb3QucmVkby5uYW1lLCB0ZXh0OiB0cnVlIH1cXHgyMj5SRURPPC9hPiAgICA8L3NwYW4+ICAgIDwhLS0ga28gaWY6ICRyb290LmRlYnVnIC0tPiAgICA8YSBocmVmPVxceDIyamF2YXNjcmlwdDp2b2lkKDApXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LnVuZG9SZXNldCwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC51bmRvLmVuYWJsZWQoKSAmJiAhJHJvb3QucmVkby5lbmFibGVkKCksIGxhYmVsOiAncmVzZXQnLCB0ZXh0OiB0cnVlIH1cXHgyMj5SRVNFVDwvYT4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0gL2tvIC0tPiAgICA8c3Bhbj4gICAgPGlucHV0IGlkPVxceDIyc2hvd0dhbGxlcnlcXHgyMiB0eXBlPVxceDIyY2hlY2tib3hcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjaGVja2VkOiAkcm9vdC5zaG93R2FsbGVyeSwgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd0dhbGxlcnksICAgIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1waWN0dXJlLW8nLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogdHJ1ZSwgbGFiZWw6ICRyb290LnQoJ0dhbGxlcnknKSB9XFx4MjI+PGxhYmVsIHRpdGxlPVxceDIyU2hvdyBpbWFnZSBnYWxsZXJ5XFx4MjIgZm9yPVxceDIyc2hvd0dhbGxlcnlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTaG93IGltYWdlIGdhbGxlcnknKSB9XFx4MjI+c2hvdyBnYWxsZXJ5PC9sYWJlbD48L2lucHV0PiAgICA8L3NwYW4+ICAgIDwhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiAnZWRpdC1uYW1lJyB9IC0tPiMgbWFpbGluZyBuYW1lICM8IS0tIC9rbyAtLT4gICAgPGlucHV0IGlkPVxceDIycHJldmlld0ZyYW1lVG9nZ2xlXFx4MjIgdHlwZT1cXHgyMmNoZWNrYm94XFx4MjIgZGF0YS1iaW5kPVxceDIyY2hlY2tlZDogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZSwgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLXRhYmxldCcsIHNlY29uZGFyeTogbnVsbCB9LCB0ZXh0OiBmYWxzZSwgbGFiZWw6ICRyb290LnQoJ1ByZXZpZXcnKSB9XFx4MjI+PGxhYmVsIHRpdGxlPVxceDIyU2hvdyBsaXZlIHByZXZpZXdcXHgyMiBmb3I9XFx4MjJwcmV2aWV3RnJhbWVUb2dnbGVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTaG93IGxpdmUgcHJldmlldycpIH1cXHgyMj5QUkVWSUVXPC9sYWJlbD48L2lucHV0PiAgICA8IS0tIGtvIGlmOiAkcm9vdC5kZWJ1ZyAtLT4gICAgPGEgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5leHBvcnQsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGxhYmVsOiAnZXhwb3J0JywgdGV4dDogdHJ1ZSB9XFx4MjI+RVhQT1JUPC9hPiAgICA8aW5wdXQgdHlwZT1cXHgyMmNoZWNrYm94XFx4MjIgZGF0YS1iaW5kPVxceDIyY2hlY2tlZDogJHJvb3QuZGVidWdcXHgyMiAvPiBkZWJ1ZyAgICA8YSBocmVmPVxceDIyamF2YXNjcmlwdDp2b2lkKDApXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmxvYWREZWZhdWx0QmxvY2tzLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtdXBsb2FkJyB9LCBsYWJlbDogJ0RlZmF1bHQnLCB0ZXh0OiB0cnVlIH1cXHgyMj5MT0FEIEJMT0NLUzwvYT4gICAgWzxhIGlkPVxceDIyc3Vic2NyaXB0aW9uc0NvdW50XFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dmlld01vZGVsLmxvb3BTdWJzY3JpcHRpb25zQ291bnQoKVxceDIyPnN1YnM8L2E+XSAgICA8IS0tIC9rbyAtLT4gICAgPHNwYW4gZGF0YS1iaW5kPVxceDIydmlzaWJsZTogZmFsc2VcXHgyMj4gICAgPGlucHV0IHR5cGU9XFx4MjJjaGVja2JveFxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnNob3dUb29sYm94XFx4MjIgLz4gdG9vbGJveCAgICA8L3NwYW4+ICAgIDxkaXYgY2xhc3M9XFx4MjJyaWdodEJ1dHRvbnNcXHgyMj4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRyb290LnNhdmUgIT09ICd1bmRlZmluZWQnIC0tPiAgICA8YSB0aXRsZT1cXHgyMlNhdmUgdGVtcGxhdGVcXHgyMiBocmVmPVxceDIyamF2YXNjcmlwdDp2b2lkKDApXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2F2ZSB0ZW1wbGF0ZScpIH0sIGNsaWNrOiAkcm9vdC5zYXZlLmV4ZWN1dGUsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGRpc2FibGVkOiAhJHJvb3Quc2F2ZS5lbmFibGVkKCksIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1jbG91ZC11cGxvYWQnIH0sIGxhYmVsOiAkcm9vdC50KCRyb290LnNhdmUubmFtZSksIHRleHQ6IHRydWUgfVxceDIyPlNBTFZBPC9hPiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRyb290LnRlc3QgIT09ICd1bmRlZmluZWQnIC0tPiAgICA8YSB0aXRsZT1cXHgyMlNob3cgcHJldmlldyBhbmQgc2VuZCB0ZXN0XFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1Nob3cgcHJldmlldyBhbmQgc2VuZCB0ZXN0JykgfSwgY2xpY2s6ICRyb290LnRlc3QuZXhlY3V0ZSwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC50ZXN0LmVuYWJsZWQoKSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLXBhcGVyLXBsYW5lJyB9LCBsYWJlbDogJHJvb3QudCgkcm9vdC50ZXN0Lm5hbWUpLCB0ZXh0OiB0cnVlIH1cXHgyMj5URVNUPC9hPiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRyb290LmRvd25sb2FkICE9PSAndW5kZWZpbmVkJyAtLT4gICAgPGZvcm0gaWQ9XFx4MjJkb3dubG9hZEZvcm1cXHgyMiBhY3Rpb249XFx4MjIjXFx4MjIgbWV0aG9kPVxceDIyUE9TVFxceDIyPiAgICA8aW5wdXQgdHlwZT1cXHgyMmhpZGRlblxceDIyIG5hbWU9XFx4MjJhY3Rpb25cXHgyMiB2YWx1ZT1cXHgyMmRvd25sb2FkXFx4MjIgLz4gICAgPGlucHV0IHR5cGU9XFx4MjJoaWRkZW5cXHgyMiBuYW1lPVxceDIyZmlsZW5hbWVcXHgyMiB2YWx1ZT1cXHgyMmVtYWlsLmh0bWxcXHgyMiBpZD1cXHgyMmRvd25sb2FkSHRtbEZpbGVuYW1lXFx4MjIgLz4gICAgPGlucHV0IHR5cGU9XFx4MjJoaWRkZW5cXHgyMiBuYW1lPVxceDIyaHRtbFxceDIyIGlkPVxceDIyZG93bmxvYWRIdG1sVGV4dGFyZWFcXHgyMiAvPiAgICA8YSB0aXRsZT1cXHgyMkRvd25sb2FkIHRlbXBsYXRlXFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0Rvd25sb2FkIHRlbXBsYXRlJykgfSwgY2xpY2s6ICRyb290LmRvd25sb2FkLmV4ZWN1dGUsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGRpc2FibGVkOiAhJHJvb3QuZG93bmxvYWQuZW5hYmxlZCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtZG93bmxvYWQnIH0sIGxhYmVsOiAkcm9vdC50KCRyb290LmRvd25sb2FkLm5hbWUpLCB0ZXh0OiB0cnVlIH1cXHgyMj5ET1dOTE9BRDwvYT4gICAgPC9mb3JtPiAgICA8IS0tIC9rbyAtLT4gICAgPC9kaXY+ICA8L2Rpdj4gIDwhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiAnZGlhbG9nLXNlbGVjdC1pbWFnZScgfSAtLT4jIGRpYWxvZyBpbWFnZSBzZWxlY3Rpb24gIzwhLS0gL2tvIC0tPiAgPCEtLSBrbyBpZjogJHJvb3Quc2hvd1Rvb2xib3ggLS0+ICA8ZGl2IGlkPVxceDIybWFpbi10b29sYm94XFx4MjIgY2xhc3M9XFx4MjJtb1xceDIyIGRhdGEtYmluZD1cXHgyMnNjcm9sbGFibGU6IHRydWUsIHdpdGhQcm9wZXJ0aWVzOiB7IHRlbXBsYXRlTW9kZTogJ2VkaXQnIH1cXHgyMj4gICAgPGRpdiBkYXRhLWJpbmQ9XFx4MjJ0ZW1wbGF0ZTogeyBuYW1lOiAndG9vbGJveCcgfVxceDIyPjwvZGl2PiAgPC9kaXY+ICA8IS0tIC9rbyAtLT4gIDxkaXYgaWQ9XFx4MjJtYWluLXByZXZpZXdcXHgyMiBjbGFzcz1cXHgyMm1vXFx4MjIgZGF0YS1iaW5kPVxceDIyc2Nyb2xsYWJsZTogdHJ1ZSwgaWY6ICRyb290LnNob3dQcmV2aWV3RnJhbWVcXHgyMj4gICAgPGRpdiBpZD1cXHgyMnByZXZpZXctdG9vbGJhclxceDIyPiAgICAgIDxkaXYgZGF0YS1iaW5kPVxceDIydmlzaWJsZTogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZSwgYnV0dG9uc2V0OiB7IH1cXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IGlubGluZS1ibG9ja1xceDIyPiAgICAgICAgPGlucHV0IGlkPVxceDIycHJldmlld0xhcmdlXFx4MjIgdHlwZT1cXHgyMnJhZGlvXFx4MjIgbmFtZT1cXHgyMnByZXZpZXdNb2RlXFx4MjIgdmFsdWU9XFx4MjJsYXJnZVxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnByZXZpZXdNb2RlLCBidXR0b246IHsgdGV4dDogZmFsc2UsIGxhYmVsOiAnbGFyZ2UnLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtZGVza3RvcCcgfSB9XFx4MjIgLz4gICAgICAgIDxsYWJlbCBmb3I9XFx4MjJwcmV2aWV3TGFyZ2VcXHgyMiB0aXRsZT1cXHgyMkxhcmdlIHNjcmVlblxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0xhcmdlIHNjcmVlbicpIH1cXHgyMj5MYXJnZSBzY3JlZW48L2xhYmVsPiAgICAgICAgPGlucHV0IGlkPVxceDIycHJldmlld0Rlc2t0b3BcXHgyMiB0eXBlPVxceDIycmFkaW9cXHgyMiBuYW1lPVxceDIycHJldmlld01vZGVcXHgyMiB2YWx1ZT1cXHgyMmRlc2t0b3BcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjaGVja2VkOiAkcm9vdC5wcmV2aWV3TW9kZSwgYnV0dG9uOiB7IHRleHQ6IGZhbHNlLCBsYWJlbDogJ2Rlc2t0b3AnLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtdGFibGV0JyB9IH1cXHgyMiAvPiAgICAgICAgPGxhYmVsIGZvcj1cXHgyMnByZXZpZXdEZXNrdG9wXFx4MjIgdGl0bGU9XFx4MjJUYWJsZXRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdUYWJsZXQnKSB9XFx4MjI+VGFibGV0PC9sYWJlbD4gICAgICAgIDxpbnB1dCBpZD1cXHgyMnByZXZpZXdNb2JpbGVcXHgyMiB0eXBlPVxceDIycmFkaW9cXHgyMiBuYW1lPVxceDIycHJldmlld01vZGVcXHgyMiB2YWx1ZT1cXHgyMm1vYmlsZVxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnByZXZpZXdNb2RlLCBidXR0b246IHsgdGV4dDogZmFsc2UsIGxhYmVsOiAnbW9iaWxlJywgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLW1vYmlsZScgfSB9XFx4MjIgLz4gICAgICAgIDxsYWJlbCBmb3I9XFx4MjJwcmV2aWV3TW9iaWxlXFx4MjIgdGl0bGU9XFx4MjJTbWFydHBob25lXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU21hcnRwaG9uZScpIH1cXHgyMj5TbWFydHBob25lPC9sYWJlbD4gICAgICA8L2Rpdj4gICAgPC9kaXY+ICAgIDxkaXYgaWQ9XFx4MjJmcmFtZS1jb250YWluZXJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjc3M6IHsgZGVza3RvcDogJHJvb3QucHJldmlld01vZGUoKSA9PSAnZGVza3RvcCcsIG1vYmlsZTogJHJvb3QucHJldmlld01vZGUoKSA9PSAnbW9iaWxlJywgbGFyZ2U6ICRyb290LnByZXZpZXdNb2RlKCkgPT0gJ2xhcmdlJyB9XFx4MjI+ICAgICAgPGlmcmFtZSBkYXRhLWJpbmQ9XFx4MjJiaW5kSWZyYW1lOiAkZGF0YVxceDIyPjwvaWZyYW1lPiAgICA8L2Rpdj4gIDwvZGl2PiAgPGRpdiBjbGFzcz1cXHgyMm1vXFx4MjIgaWQ9XFx4MjJtby1ib2R5XFx4MjI+PC9kaXY+ICA8IS0tIFRPRE8gUkVNT1ZFIE1FICA8ZGl2IGlkPVxceDIyaW5jb21wYXRpYmxlLWJyb3dzZXJcXHgyMiB0aXRsZT1cXHgyMlVuc3VwcG9ydGVkIGJyb3dzZXJcXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IG5vbmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdVc3VwcG9ydGVkIGJyb3dzZXInKSB9LCBodG1sOiAnPHA+WW91ciBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuPC9wPjxwPlVzZSBhIGRpZmZlcmVudCBicm93c2VyIG9yIHRyeSB1cGRhcmluZyB5b3VyIGJyb3dzZXIuPC9wPjxwPlN1cHBvcnRlZCBicm93c2VyczogPHVsPjxsaT5JbnRlcm5ldCBFeHBsb3JlciAmZ3Q7PSAxMDwvbGk+PGxpPkdvb2dsZSBDaHJvbWUgJmd0Oz0gMzA8L2xpPjxsaT5BcHBsZSBTYWZhcmkgJmd0Oz0gNTwvbGk+PGxpPk1vemlsbGEgRmlyZWZpeCAmZ3Q7PSAyMDwvbGk+PC91bD48L3A+J1xceDIyPiAgICBVbnN1cHBvcnRlZCBicm93c2VyICA8L2Rpdj4gIC0tPiAgPGRpdiBpZD1cXHgyMmluY29tcGF0aWJsZS10ZW1wbGF0ZVxceDIyIHRpdGxlPVxceDIyU2F2ZWQgbW9kZWwgaXMgb2Jzb2xldGVcXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IG5vbmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTYXZlZCBtb2RlbCBpcyBvYnNvbGV0ZScpIH0sIGh0bWw6ICRyb290LnQoJzxwPlRoZSBzYXZlZCBtb2RlbCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYSBwcmV2aW91cywgbm9uIGNvbXBsZXRlbHkgY29tcGF0aWJsZSB2ZXJzaW9uLCBvZiB0aGUgdGVtcGxhdGU8L3A+PHA+U29tZSBjb250ZW50IG9yIHN0eWxlIGluIHRoZSBtb2RlbCA8Yj5DT1VMRCBCRSBMT1NUPC9iPiBpZiB5b3Ugd2lsbCA8Yj5zYXZlPC9iPjwvcD48cD5Db250YWN0IHVzIGZvciBtb3JlIGluZm9ybWF0aW9ucyE8L3A+JylcXHgyMj4gICAgSW5jb21wYXRpYmxlIHRlbXBsYXRlICA8L2Rpdj4gIDxkaXYgaWQ9XFx4MjJmYWtlLWltYWdlLWVkaXRvclxceDIyIHRpdGxlPVxceDIyRmFrZSBpbWFnZSBlZGl0b3JcXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IG5vbmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdGYWtlIGltYWdlIGVkaXRvcicpIH0sIGh0bWw6ICRyb290LnQoJzxwPkZha2UgaW1hZ2UgZWRpdG9yPC9wPicpXFx4MjI+ICAgIDxwPkZha2UgaW1hZ2UgZWRpdG9yPC9wPiAgPC9kaXY+PC9kaXY+PCEtLSBrbyBpZjogJHJvb3QubG9nb1BhdGggLS0+PGRpdiBpZD1cXHgyMmxvYWRpbmdcXHgyMiBjbGFzcz1cXHgyMmxvYWRpbmdcXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IGJsb2NrOyB3aWR0aDogMzAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgaGVpZ2h0OiAzMnB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDowOyBib3R0b206IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyAgbWFyZ2luOiBhdXRvO1xceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgc3R5bGU6ICdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogNXB4OyBsZWZ0OiA2cHg7IHotaW5kZXg6IDE1MDsnfSwgY3NzOiB7IGxvYWRpbmc6IGZhbHNlIH1cXHgyMj4gIDxhIGhyZWY9XFx4MjIvXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyBocmVmOiAkcm9vdC5sb2dvVXJsLCBhbHQ6ICRyb290LmxvZ29BbHQgfVxceDIyPjxpbWcgZGF0YS1iaW5kPVxceDIyYXR0cjogeyBzcmM6ICRyb290LmxvZ29QYXRoIH1cXHgyMiB3aWR0aD1cXHgyMjMyXFx4MjIgaGVpZ2h0PVxceDIyMzJcXHgyMiBhbHQ9XFx4MjJtb3NhaWNvXFx4MjIgYm9yZGVyPVxceDIyMFxceDIyIC8+PC9hPiAgPGRpdiBzdHlsZT1cXHgyMm9wYWNpdHk6IDBcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ2aXNpYmxlOiBmYWxzZVxceDIyPk9wcHBzLi4uICEhPC9kaXY+PC9kaXY+PCEtLSAva28gLS0+PCEtLSBrbyB0ZW1wbGF0ZToge25hbWU6ICdob21lLWljb24nIH0gLS0+IyBob21lLWljb24gIzwhLS0gL2tvIC0tPlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJ0b29sYm94XCIsIFwiPGRpdiBpZD1cXHgyMnRvb2x0YWJzXFx4MjIgY2xhc3M9XFx4MjJ0YWJzX2hvcml6b250YWwgYnV0dG9uX2NvbG9yXFx4MjIgZGF0YS1iaW5kPVxceDIydGFiczogeyBhY3RpdmU6ICRyb290LnNlbGVjdGVkVG9vbCB9XFx4MjI+ICA8dWw+ICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj48YSB0aXRsZT1cXHgyMkJsb2NrcyByZWFkeSB0byBiZSBhZGRlZCB0byB0aGUgdGVtcGxhdGVcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGhyZWY9XFx4MjIjdG9vbGJsb2Nrc1xceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0Jsb2NrcyByZWFkeSB0byBiZSBhZGRlZCB0byB0aGUgdGVtcGxhdGUnKSB9XFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1jdWJlc1xceDIyPjwvaT4gPHNwYW4gZGF0YS1iaW5kPVxceDIyaHRtbDogJHJvb3QudCgnQmxvY2tzJylcXHgyMj5CbG9ja3M8L3NwYW4+PC9hPjwvbGk+ICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj48YSB0aXRsZT1cXHgyMkVkaXQgY29udGVudCBvcHRpb25zXFx4MjIgaHJlZj1cXHgyMiN0b29sY29udGVudHNcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0VkaXQgY29udGVudCBvcHRpb25zJykgfVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtcGVuY2lsXFx4MjI+PC9pPiA8c3BhbiBkYXRhLWJpbmQ9XFx4MjJodG1sOiAkcm9vdC50KCdDb250ZW50JylcXHgyMj5Db250ZW50PC9zcGFuPjwvYT48L2xpPiAgICA8bGkgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+PGEgdGl0bGU9XFx4MjJFZGl0IHN0eWxlIG9wdGlvbnNcXHgyMiBocmVmPVxceDIyI3Rvb2xzdHlsZXNcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0VkaXQgc3R5bGUgb3B0aW9ucycpIH1cXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXBhaW50LWJydXNoXFx4MjI+PC9pPiA8c3BhbiBkYXRhLWJpbmQ9XFx4MjJodG1sOiAkcm9vdC50KCdTdHlsZScpXFx4MjI+U3R5bGU8L3NwYW4+PC9hPjwvbGk+ICA8L3VsPiAgPGRpdiBpZD1cXHgyMnRvb2xibG9ja3NcXHgyMiBkYXRhLWJpbmQ9XFx4MjJzY3JvbGxhYmxlOiB0cnVlXFx4MjI+ICAgIDxkaXYgY2xhc3M9XFx4MjJibG9jay1saXN0XFx4MjIgZGF0YS1iaW5kPVxceDIyZm9yZWFjaDogYmxvY2tEZWZzXFx4MjIgc3R5bGU9XFx4MjJ0ZXh0LWFsaWduOiBjZW50ZXJcXHgyMj4gICAgICA8ZGl2IGNsYXNzPVxceDIyZHJhZ2dhYmxlLWl0ZW1cXHgyMiBkYXRhLWJpbmQ9XFx4MjJ3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6ICdzaG93JyB9XFx4MjI+ICAgICAgICA8ZGl2IGNsYXNzPVxceDIyYmxvY2tcXHgyMiBkYXRhLWJpbmQ9XFx4MjJleHRkcmFnZ2FibGU6IHsgY29ubmVjdENsYXNzOiAnc29ydGFibGUtYmxvY2tzLWVkaXQnLCBkYXRhOiAkZGF0YSwgZHJvcENvbnRhaW5lcjogJyNtYWluLXd5c2l3eWctYXJlYScsIGRyYWdnaW5nOiAkcm9vdC5kcmFnZ2luZywgJ29wdGlvbnMnOiB7IGhhbmRsZTogJy5oYW5kbGUnLCBkaXN0YW5jZTogMTAsICdhcHBlbmRUbyc6ICcjcGFnZScgfSB9LCBjbGljazogJHJvb3QuYWRkQmxvY2tcXHgyMiBzdHlsZT1cXHgyMnBvc2l0aW9uOiByZWxhdGl2ZTtcXHgyMj4gICAgICAgICAgPGRpdiB0aXRsZT1cXHgyMkNsaWNrIG9yIGRyYWcgdG8gYWRkIHRoaXMgYmxvY2sgdG8gdGhlIHRlbXBsYXRlXFx4MjIgY2xhc3M9XFx4MjJoYW5kbGVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdDbGljayBvciBkcmFnIHRvIGFkZCB0aGlzIGJsb2NrIHRvIHRoZSB0ZW1wbGF0ZScpIH0sIHRvb2x0aXBzOiB7fVxceDIyPjwvZGl2PiAgICAgICAgICA8aW1nIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgYWx0OiAkcm9vdC50KCdCbG9jayBfX25hbWVfXycsIHsgbmFtZToga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0eXBlKSB9KSwgc3JjOiAkcm9vdC50ZW1wbGF0ZVBhdGgoJ2VkcmVzLycra28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0eXBlKSsnLnBuZycpIH1cXHgyMiBhbHQ9XFx4MjJCbG9jayBfX25hbWVfX1xceDIyIC8+ICAgICAgICA8L2Rpdj4gICAgICAgIDxhIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBjbGFzcz1cXHgyMmFkZGJsb2NrYnV0dG9uXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmFkZEJsb2NrLCBidXR0b246IHsgbGFiZWw6ICRyb290LnQoJ0FkZCcpIH1cXHgyMj5BZGQ8L2E+ICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgPC9kaXY+ICA8ZGl2IGlkPVxceDIydG9vbGNvbnRlbnRzXFx4MjIgZGF0YS1iaW5kPVxceDIyc2Nyb2xsYWJsZTogdHJ1ZVxceDIyPiAgICA8IS0tIGtvIGlmOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgIT09IG51bGwgLS0+ICAgIDxkaXYgZGF0YS1iaW5kPVxceDIyYmxvY2s6ICRyb290LnNlbGVjdGVkQmxvY2tcXHgyMj48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6ICRyb290LnNlbGVjdGVkQmxvY2soKSA9PSBudWxsIC0tPiAgICA8ZGl2IGNsYXNzPVxceDIybm9TZWxlY3RlZEJsb2NrXFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnQnkgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgY29udGVudCBvcHRpb25zLCBpZiBhbnksIHdpbGwgc2hvdyBoZXJlJylcXHgyMj5CeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBjb250ZW50IG9wdGlvbnMsIGlmIGFueSwgd2lsbCBzaG93IGhlcmU8L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gYmxvY2s6IGNvbnRlbnQgLS0+PCEtLSAva28gLS0+ICA8L2Rpdj4gIDxkaXYgaWQ9XFx4MjJ0b29sc3R5bGVzXFx4MjIgZGF0YS1iaW5kPVxceDIyc2Nyb2xsYWJsZTogdHJ1ZSwgd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiAnc3R5bGVyJyB9XFx4MjI+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC5jb250ZW50KCkudGhlbWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiAkcm9vdC5jb250ZW50KCkudGhlbWUoKS5zY2hlbWUgPT09ICd1bmRlZmluZWQnIHx8ICRyb290LmNvbnRlbnQoKS50aGVtZSgpLnNjaGVtZSgpID09PSAnY3VzdG9tJyAtLT4gICAgICA8IS0tIGtvIGlmOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgIT09IG51bGwgLS0+ICAgICAgPGRpdiBkYXRhLWJpbmQ9XFx4MjJibG9jazogJHJvb3Quc2VsZWN0ZWRCbG9jaywgY3NzOiB7IHdvcmtMb2NhbDogJHJvb3Quc2VsZWN0ZWRCbG9jaygpLmN1c3RvbVN0eWxlLCB3b3JrR2xvYmFsOiB0eXBlb2YgJHJvb3Quc2VsZWN0ZWRCbG9jaygpLmN1c3RvbVN0eWxlID09PSAndW5kZWZpbmVkJyB8fCAhJHJvb3Quc2VsZWN0ZWRCbG9jaygpLmN1c3RvbVN0eWxlKCkgfVxceDIyPjwvZGl2PiAgICAgIDwhLS0gL2tvIC0tPiAgICAgIDwhLS0ga28gaWY6ICRyb290LnNlbGVjdGVkQmxvY2soKSA9PSBudWxsIC0tPiAgICAgIDxkaXYgY2xhc3M9XFx4MjJub1NlbGVjdGVkQmxvY2tcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdCeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBzdHlsZSBvcHRpb25zLCBpZiBhdmFpbGFibGUsIHdpbGwgc2hvdyBoZXJlJylcXHgyMj5CeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBzdHlsZSBvcHRpb25zLCBpZiBhdmFpbGFibGUsIHdpbGwgc2hvdyBoZXJlPC9kaXY+ICAgICAgPCEtLSAva28gLS0+ICAgICAgPGRpdiBjbGFzcz1cXHgyMndvcmtHbG9iYWxDb250ZW50XFx4MjI+ICAgICAgPCEtLSBrbyBibG9jazogY29udGVudCAtLT48IS0tIC9rbyAtLT4gICAgICA8L2Rpdj4gICAgPCEtLSAva28gLS0+ICA8L2Rpdj48L2Rpdj48ZGl2IGlkPVxceDIydG9vbGltYWdlc1xceDIyIGNsYXNzPVxceDIyc2xpZGViYXJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJzY3JvbGxhYmxlOiB0cnVlLCBjc3M6IHsgaGlkZGVuOiAkcm9vdC5zaG93R2FsbGVyeSgpID09PSBmYWxzZSB9XFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIyY2xvc2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3Quc2hvd0dhbGxlcnkuYmluZCgkZWxlbWVudCwgZmFsc2UpO1xceDIyPlg8L2Rpdj4gIDxzcGFuIGNsYXNzPVxceDIycGFuZS10aXRsZVxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290LnQoJ2dhbGxlcnktdGl0bGUnKVxceDIyPkdhbGxlcmllczo8L3NwYW4+ICA8IS0tIGtvIGlmOiAkcm9vdC5zaG93R2FsbGVyeSgpIC0tPiAgPGRpdiBpZD1cXHgyMnRvb2xpbWFnZXN0YWJcXHgyMiBjbGFzcz1cXHgyMnRhYnNfaG9yaXpvbnRhbFxceDIyIGRhdGEtYmluZD1cXHgyMnRhYnM6IHsgYWN0aXZlOiAkcm9vdC5zZWxlY3RlZEltYWdlVGFiIH1cXHgyMj4gICAgPHVsPiAgICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj48YSB0aXRsZT1cXHgyMmdhbGxlcnktbWFpbGluZ1xceDIyIGRhdGEtbG9jYWw9XFx4MjJ0cnVlXFx4MjIgaHJlZj1cXHgyMiN0b29saW1hZ2VzZ2FsbGVyeVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ2dhbGxlcnktbWFpbGluZycpIH0sIHRleHQ6ICRyb290LnQoJ2dhbGxlcnktbWFpbGluZycpXFx4MjI+Z2FsbGVyeS1tYWlsaW5nPC9hPjwvbGk+ICAgICAgPGxpIGRhdGEtYmluZD1cXHgyMnRvb2x0aXBzOiB7fVxceDIyPjxhIHRpdGxlPVxceDIyZ2FsbGVyeS10ZW1wbGF0ZVxceDIyIGRhdGEtbG9jYWw9XFx4MjJ0cnVlXFx4MjIgaHJlZj1cXHgyMiN0b29saW1hZ2VzZ2FsbGVyeXRlbXBsYXRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnZ2FsbGVyeS10ZW1wbGF0ZScpIH0sIHRleHQ6ICRyb290LnQoJ2dhbGxlcnktdGVtcGxhdGUnKVxceDIyPmdhbGxlcnktdGVtcGxhdGU8L2E+PC9saT4gICAgPC91bD4gICAgPGRpdiBpZD1cXHgyMnRvb2xpbWFnZXNnYWxsZXJ5XFx4MjIgY2xhc3M9XFx4MjJnYWxsZXJ5LXBhbmVsXFx4MjI+ICAgICAgPCEtLSBrbyB0ZW1wbGF0ZToge25hbWU6ICdnYWxsZXJ5LXVwbG9hZCcsIGRhdGE6IHsgdHlwZTogJ21haWxpbmcnIH0gfSAtLT4jIG1haWxpbmcgZ2FsbGVyeSBmaWxldXBsb2FkICM8IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PT0gZmFsc2UgLS0+PGEgY2xhc3M9XFx4MjJsb2FkYnV0dG9uXFx4MjIgdGl0bGU9XFx4MjJTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5XFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1Nob3cgaW1hZ2VzIGZyb20gdGhlIGdhbGxlcnknKSB9LCBjbGljazogJHJvb3QubG9hZE1haWxpbmdHYWxsZXJ5LCBidXR0b246IHsgZGlzYWJsZWQ6ICRyb290Lm1haWxpbmdHYWxsZXJ5U3RhdHVzLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtcGljdHVyZS1vJyB9LCBsYWJlbDogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PSAnbG9hZGluZycgPyAkcm9vdC50KCdMb2FkaW5nLi4uJykgOiAkcm9vdC50KCdMb2FkIGdhbGxlcnknKSwgdGV4dDogdHJ1ZSB9XFx4MjI+IyBsb2FkIGdhbGxlcnkgIzwvYT48IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PT0gJ2xvYWRpbmcnIC0tPjxkaXYgY2xhc3M9XFx4MjJnYWxsZXJ5RW1wdHlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdnYWxsZXJ5LW1haWxpbmctbG9hZGluZycpXFx4MjI+TG9hZGluZyBtYWlsaW5nIGdhbGxlcnnigKY8L2Rpdj48IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PT0gMCAtLT48ZGl2IGNsYXNzPVxceDIyZ2FsbGVyeUVtcHR5XFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnZ2FsbGVyeS1tYWlsaW5nLWVtcHR5JylcXHgyMj5UaGUgbWFpbGluZyBnYWxsZXJ5IGlzIGVtcHR5PC9kaXY+PCEtLSAva28gLS0+ICAgIDwhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiAnZ2FsbGVyeS1pbWFnZXMnLCBkYXRhOiB7IGl0ZW1zOiBtYWlsaW5nR2FsbGVyeSwgdHlwZTogJ21haWxpbmcnIH0gfSAtLT4jIG1haWxpbmcgZ2FsbGVyeSAjPCEtLSAva28gLS0+ICAgIDwvZGl2PiAgICA8ZGl2IGlkPVxceDIydG9vbGltYWdlc2dhbGxlcnl0ZW1wbGF0ZVxceDIyIGNsYXNzPVxceDIyZ2FsbGVyeS1wYW5lbFxceDIyPiAgICAgIDwhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiAnZ2FsbGVyeS11cGxvYWQnLCBkYXRhOiB7IHR5cGU6ICd0ZW1wbGF0ZScgfSB9IC0tPiMgbWFpbGluZyB0ZW1wbGF0ZSBmaWxldXBsb2FkICM8IS0tIC9rbyAtLT4gICAgICA8IS0tIGtvIGlmOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMoKSA9PT0gZmFsc2UgLS0+PGEgY2xhc3M9XFx4MjJsb2FkYnV0dG9uXFx4MjIgdGl0bGU9XFx4MjJTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5XFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1Nob3cgaW1hZ2VzIGZyb20gdGhlIGdhbGxlcnknKSB9LCBjbGljazogJHJvb3QubG9hZFRlbXBsYXRlR2FsbGVyeSwgYnV0dG9uOiB7IGRpc2FibGVkOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1waWN0dXJlLW8nIH0sIGxhYmVsOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMoKSA9PSAnbG9hZGluZycgPyAkcm9vdC50KCdMb2FkaW5nLi4uJykgOiAkcm9vdC50KCdMb2FkIGdhbGxlcnknKSwgdGV4dDogdHJ1ZSB9XFx4MjI+IyBsb2FkIGdhbGxlcnkgIzwvYT48IS0tIC9rbyAtLT4gICAgICA8IS0tIGtvIGlmOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMoKSA9PT0gJ2xvYWRpbmcnIC0tPjxkaXYgY2xhc3M9XFx4MjJnYWxsZXJ5RW1wdHlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdnYWxsZXJ5LW1haWxpbmctbG9hZGluZycpXFx4MjI+TG9hZGluZyB0ZW1wbGF0ZSBnYWxsZXJ5Li4uPC9kaXY+PCEtLSAva28gLS0+ICAgICAgPCEtLSBrbyBpZjogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT09IDAgLS0+PGRpdiBjbGFzcz1cXHgyMmdhbGxlcnlFbXB0eVxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290LnQoJ2dhbGxlcnktbWFpbGluZy1lbXB0eScpXFx4MjI+VGhlIHRlbXBsYXRlIGdhbGxlcnkgaXMgZW1wdHk8L2Rpdj48IS0tIC9rbyAtLT4gICAgICA8IS0tIGtvIHRlbXBsYXRlOiB7bmFtZTogJ2dhbGxlcnktaW1hZ2VzJywgZGF0YTogeyBpdGVtczogdGVtcGxhdGVHYWxsZXJ5LCB0eXBlOiAndGVtcGxhdGUnIH0gfSAtLT4jIHRlbXBsYXRlIGdhbGxlcnkgIzwhLS0gL2tvIC0tPiAgICA8L2Rpdj4gIDwvZGl2PiAgPCEtLSAva28gLS0+PC9kaXY+PGRpdiBpZD1cXHgyMnRvb2xkZWJ1Z1xceDIyIGNsYXNzPVxceDIyc2xpZGViYXJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjc3M6IHsgaGlkZGVuOiAkcm9vdC5kZWJ1ZygpID09PSBmYWxzZSB9XFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIyY2xvc2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuZGVidWcuYmluZCgkZWxlbWVudCwgZmFsc2UpO1xceDIyPlg8L2Rpdj4gIDwhLS0ga28gaWY6ICRyb290LmRlYnVnIC0tPiAgQ29udGVudDogIDxwcmUgZGF0YS1iaW5kPSd0ZXh0OiBrby50b0pTT04oY29udGVudCwgbnVsbCwgMiknIHN0eWxlPVxceDIyb3ZlcmZsb3c6IGF1dG87IGhlaWdodDogMjAlXFx4MjI+PC9wcmU+ICBCbG9ja0RlZnM6ICA8cHJlIGRhdGEtYmluZD0ndGV4dDoga28udG9KU09OKGJsb2NrRGVmcywgbnVsbCwgMiknIHN0eWxlPVxceDIyb3ZlcmZsb3c6IGF1dG87IGhlaWdodDogMjAlXFx4MjI+PC9wcmU+ICA8IS0tIC9rbyAtLT4gIDxhIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuZXhwb3J0SFRNTHRvVGV4dGFyZWEuYmluZCgkZWxlbWVudCwgJyNvdXRwdXRodG1sJyk7IGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IHRleHQ6IHRydWUsIGxhYmVsOidHZW5lcmF0ZScgfVxceDIyPk91dHB1dDwvYT4gIDxhIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuZXhwb3J0SlNPTnRvVGV4dGFyZWEuYmluZCgkZWxlbWVudCwgJyNvdXRwdXRodG1sJyk7IGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IHRleHQ6IHRydWUsIGxhYmVsOidFeHBvcnQnIH1cXHgyMj5FeHBvcnQ8L2E+ICA8YSBocmVmPVxceDIyamF2YXNjcmlwdDp2b2lkKDApXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmltcG9ydEpTT05mcm9tVGV4dGFyZWEuYmluZCgkZWxlbWVudCwgJyNvdXRwdXRodG1sJyk7IGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IHRleHQ6IHRydWUsIGxhYmVsOidJbXBvcnQnIH1cXHgyMj5JbXBvcnQ8L2E+ICA8dGV4dGFyZWEgaWQ9XFx4MjJvdXRwdXRodG1sXFx4MjIgcm93cz1cXHgyMjEwXFx4MjIgc3R5bGU9XFx4MjJ3aWR0aDogMTAwJTtcXHgyMj48L3RleHRhcmVhPjwvZGl2PjxkaXYgaWQ9XFx4MjJ0b29sdGhlbWVcXHgyMiBjbGFzcz1cXHgyMnVpLXdpZGdldCBzbGlkZWJhclxceDIyIGRhdGEtYmluZD1cXHgyMmNzczogeyBoaWRkZW46ICRyb290LnNob3dUaGVtZSgpID09PSBmYWxzZSB9XFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIyY2xvc2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3Quc2hvd1RoZW1lLmJpbmQoJGVsZW1lbnQsIGZhbHNlKTtcXHgyMj5YPC9kaXY+ICA8IS0tIGtvIHdpdGhQcm9wZXJ0aWVzOiB7IHRlbXBsYXRlTW9kZTogJ3N0eWxlcicgfSAtLT4gICAgPCEtLSBrbyBpZjogJHJvb3Quc2hvd1RoZW1lIC0tPiAgICAgIDwhLS0ga28gYmxvY2s6ICRyb290LmNvbnRlbnQoKS50aGVtZSAtLT48IS0tIC9rbyAtLT4gICAgPCEtLSAva28gLS0+ICA8IS0tIC9rbyAtLT48L2Rpdj5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiZGlhbG9nLXNlbGVjdC1pbWFnZVwiLCBcIjwhLS0ga28gaWY6ICRyb290LnNob3dEaWFsb2dHYWxsZXJ5KCkgLS0+PCEtLSBzaG91bGQgdXNlIHVpLWRpYWxvZyAtLT48YXNpZGUgaWQ9XFx4MjJkaWFsb2dHYWxsZXJ5XFx4MjIgY2xhc3M9XFx4MjJtb1xceDIyPiAgPGRpdiBjbGFzcz1cXHgyMnRhYnNfaG9yaXpvbnRhbFxceDIyIGRhdGEtYmluZD1cXHgyMnRhYnM6IHsgYWN0aXZlOiAkcm9vdC5zZWxlY3RlZEltYWdlVGFiIH1cXHgyMj4gICAgPGRpdiBjbGFzcz1cXHgyMmNsb3NlXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmNsb3NlRGlhbG9nR2FsbGVyeTtcXHgyMj5YPC9kaXY+ICAgIDx1bD4gICAgICA8bGkgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+PGEgdGl0bGU9XFx4MjJnYWxsZXJ5LW1haWxpbmdcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGhyZWY9XFx4MjIjZGlhbG9nZ2FsbGVyeW1haWxpbmdcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdnYWxsZXJ5LW1haWxpbmcnKSB9LCB0ZXh0OiAkcm9vdC50KCdnYWxsZXJ5LW1haWxpbmcnKVxceDIyPmdhbGxlcnktbWFpbGluZzwvYT48L2xpPiAgICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj48YSB0aXRsZT1cXHgyMmdhbGxlcnktdGVtcGxhdGVcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGhyZWY9XFx4MjIjZGlhbG9nZ2FsbGVyeXRlbXBsYXRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnZ2FsbGVyeS10ZW1wbGF0ZScpIH0sIHRleHQ6ICRyb290LnQoJ2dhbGxlcnktdGVtcGxhdGUnKVxceDIyPmdhbGxlcnktdGVtcGxhdGU8L2E+PC9saT4gICAgPC91bD4gICAgPGRpdiBpZD1cXHgyMmRpYWxvZ2dhbGxlcnltYWlsaW5nXFx4MjIgY2xhc3M9XFx4MjJnYWxsZXJ5LXBhbmVsXFx4MjI+ICAgICAgPCEtLSBrbyB0ZW1wbGF0ZToge25hbWU6ICdnYWxsZXJ5LXVwbG9hZCcsIGRhdGE6IHsgdHlwZTogJ21haWxpbmcnIH0gfSAtLT4jIG1haWxpbmcgZ2FsbGVyeSBmaWxldXBsb2FkICM8IS0tIC9rbyAtLT4gICAgICA8IS0tIGtvIGlmOiAkcm9vdC5tYWlsaW5nR2FsbGVyeVN0YXR1cygpID09PSBmYWxzZSAtLT48YSBjbGFzcz1cXHgyMmxvYWRidXR0b25cXHgyMiB0aXRsZT1cXHgyMlNob3cgaW1hZ2VzIGZyb20gdGhlIGdhbGxlcnlcXHgyMiBocmVmPVxceDIyamF2YXNjcmlwdDp2b2lkKDApXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2hvdyBpbWFnZXMgZnJvbSB0aGUgZ2FsbGVyeScpIH0sIGNsaWNrOiAkcm9vdC5sb2FkTWFpbGluZ0dhbGxlcnksIGJ1dHRvbjogeyBkaXNhYmxlZDogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1waWN0dXJlLW8nIH0sIGxhYmVsOiAkcm9vdC5tYWlsaW5nR2FsbGVyeVN0YXR1cygpID09ICdsb2FkaW5nJyA/ICRyb290LnQoJ0xvYWRpbmcuLi4nKSA6ICRyb290LnQoJ0xvYWQgZ2FsbGVyeScpLCB0ZXh0OiB0cnVlIH1cXHgyMj4jIGxvYWQgZ2FsbGVyeSAjPC9hPjwhLS0gL2tvIC0tPiAgICAgIDwhLS0ga28gaWY6ICRyb290Lm1haWxpbmdHYWxsZXJ5U3RhdHVzKCkgPT09ICdsb2FkaW5nJyAtLT4gICAgICAgIDxkaXYgY2xhc3M9XFx4MjJnYWxsZXJ5RW1wdHlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdnYWxsZXJ5LW1haWxpbmctbG9hZGluZycpXFx4MjI+TG9hZGluZyBtYWlsaW5nIGdhbGxlcnnigKY8L2Rpdj4gICAgICA8IS0tIC9rbyAtLT4gICAgICA8IS0tIGtvIGlmOiAkcm9vdC5tYWlsaW5nR2FsbGVyeVN0YXR1cygpID09PSAwIC0tPiAgICAgICAgPGRpdiBjbGFzcz1cXHgyMmdhbGxlcnlFbXB0eVxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290LnQoJ2dhbGxlcnktbWFpbGluZy1lbXB0eScpXFx4MjI+VGhlIG1haWxpbmcgZ2FsbGVyeSBpcyBlbXB0eTwvZGl2PiAgICAgIDwhLS0gL2tvIC0tPiAgICAgIDxkaXYgY2xhc3M9XFx4MjJkaWFsb2ctZ2FsbGVyeS13cmFwcGVyXFx4MjI+ICAgICAgICA8dWwgZGF0YS1iaW5kPVxceDIyZm9yZWFjaDogbWFpbGluZ0dhbGxlcnlcXHgyMj4gICAgICAgICAgPCEtLSBrbyBpZjogdHlwZW9mIHRodW1ibmFpbFVybCAhPSAndW5kZWZpbmVkJyAtLT4gICAgICAgICAgPGxpIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5zZXRCZ0ltYWdlLmJpbmQoJGVsZW1lbnQsIG5hbWUpO1xceDIyPiAgICAgICAgICAgIDxpbWcgc3R5bGU9XFx4MjJkaXNwbGF5OiBibG9jaztcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHNyYzogdGh1bWJuYWlsVXJsIH1cXHgyMi8+ICAgICAgICAgIDwvbGk+ICAgICAgICAgIDwhLS0gL2tvIC0tPiAgICAgICAgPC91bD4gICAgICA8L2Rpdj4gICAgPC9kaXY+ICAgIDxkaXYgaWQ9XFx4MjJkaWFsb2dnYWxsZXJ5dGVtcGxhdGVcXHgyMiBjbGFzcz1cXHgyMmdhbGxlcnktcGFuZWxcXHgyMj4gICAgICA8IS0tIGtvIHRlbXBsYXRlOiB7bmFtZTogJ2dhbGxlcnktdXBsb2FkJywgZGF0YTogeyB0eXBlOiAndGVtcGxhdGUnIH0gfSAtLT4jIG1haWxpbmcgdGVtcGxhdGUgZmlsZXVwbG9hZCAjPCEtLSAva28gLS0+ICAgICAgPCEtLSBrbyBpZjogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlIC0tPjxhIGNsYXNzPVxceDIybG9hZGJ1dHRvblxceDIyIHRpdGxlPVxceDIyU2hvdyBpbWFnZXMgZnJvbSB0aGUgZ2FsbGVyeVxceDIyIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5JykgfSwgY2xpY2s6ICRyb290LmxvYWRUZW1wbGF0ZUdhbGxlcnksIGJ1dHRvbjogeyBkaXNhYmxlZDogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtcGljdHVyZS1vJyB9LCBsYWJlbDogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT0gJ2xvYWRpbmcnID8gJHJvb3QudCgnTG9hZGluZy4uLicpIDogJHJvb3QudCgnTG9hZCBnYWxsZXJ5JyksIHRleHQ6IHRydWUgfVxceDIyPiMgbG9hZCBnYWxsZXJ5ICM8L2E+PCEtLSAva28gLS0+ICAgICAgPCEtLSBrbyBpZjogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT09ICdsb2FkaW5nJyAtLT4gICAgICAgIDxkaXYgY2xhc3M9XFx4MjJnYWxsZXJ5RW1wdHlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdnYWxsZXJ5LW1haWxpbmctbG9hZGluZycpXFx4MjI+TG9hZGluZyB0ZW1wbGF0ZSBnYWxsZXJ5Li4uPC9kaXY+ICAgICAgPCEtLSAva28gLS0+ICAgICAgPCEtLSBrbyBpZjogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT09IDAgLS0+ICAgICAgICA8ZGl2IGNsYXNzPVxceDIyZ2FsbGVyeUVtcHR5XFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnZ2FsbGVyeS1tYWlsaW5nLWVtcHR5JylcXHgyMj5UaGUgdGVtcGxhdGUgZ2FsbGVyeSBpcyBlbXB0eTwvZGl2PiAgICAgIDwhLS0gL2tvIC0tPiAgICAgIDxkaXYgY2xhc3M9XFx4MjJkaWFsb2ctZ2FsbGVyeS13cmFwcGVyXFx4MjI+ICAgICAgICA8dWwgZGF0YS1iaW5kPVxceDIyZm9yZWFjaDogdGVtcGxhdGVHYWxsZXJ5XFx4MjI+ICAgICAgICAgIDwhLS0ga28gaWY6IHR5cGVvZiB0aHVtYm5haWxVcmwgIT0gJ3VuZGVmaW5lZCcgLS0+ICAgICAgICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3Quc2V0QmdJbWFnZS5iaW5kKCRlbGVtZW50LCBuYW1lKTtcXHgyMj4gICAgICAgICAgICA8aW1nIHN0eWxlPVxceDIyZGlzcGxheTogYmxvY2s7XFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyBzcmM6IHRodW1ibmFpbFVybCB9XFx4MjIvPiAgICAgICAgICA8L2xpPiAgICAgICAgICA8IS0tIC9rbyAtLT4gICAgICAgIDwvdWw+ICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgPC9kaXY+PC9hc2lkZT48IS0tIC9rbyAtLT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiZWRpdC1uYW1lXCIsIFwiPCEtLSBrbyBpZjogJHJvb3QudGl0bGVNb2RlKCkgPT0gJ2VkaXQnIHx8ICRyb290LnRpdGxlTW9kZSgpID09ICdzYXZpbmcnIC0tPjxmb3JtIGNsYXNzPVxceDIybWFpbGluZy1uYW1lXFx4MjIgZGF0YS1iaW5kPVxceDIyc3VibWl0OiBzYXZlRWRpdE1haWxpbmdOYW1lLCBzdWJtaXRCdWJibGU6IGZhbHNlXFx4MjI+ICA8aW5wdXQgdHlwZT1cXHgyMnRleHRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ2YWx1ZTogJHJvb3QubWV0YWRhdGEubmFtZSwgZGlzYWJsZTogJHJvb3QudGl0bGVNb2RlKCkgPT0gJ3NhdmluZycsIGhhc0ZvY3VzOiAkcm9vdC50aXRsZU1vZGUoKSA9PSAnZWRpdCdcXHgyMi8+ICA8YnV0dG9uIHR5cGU9XFx4MjJidXR0b25cXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogY2FuY2VsRWRpdE1haWxpbmdOYW1lLCBjbGlja0J1YmJsZTogZmFsc2UsIGRpc2FibGU6ICRyb290LnRpdGxlTW9kZSgpID09ICdzYXZpbmcnLCAgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLXRpbWVzJywgc2Vjb25kYXJ5OiBudWxsIH0sIHRleHQ6IGZhbHNlLCBsYWJlbDogJHJvb3QudCgnZWRpdC10aXRsZS1jYW5jZWwnKSB9XFx4MjI+Y2FuY2VsPC9idXR0b24+ICA8YnV0dG9uIHR5cGU9XFx4MjJzdWJtaXRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJkaXNhYmxlOiAkcm9vdC50aXRsZU1vZGUoKSA9PSAnc2F2aW5nJywgICAgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLWNoZWNrLWNpcmNsZScsIHNlY29uZGFyeTogbnVsbCB9LCB0ZXh0OiBmYWxzZSwgbGFiZWw6ICRyb290LnQoJ2VkaXQtdGl0bGUtc2F2ZScpIH1cXHgyMj5zYXZlPC9idXR0b24+PC9mb3JtPjwhLS0gL2tvIC0tPjwhLS0ga28gaWY6ICRyb290LnRpdGxlTW9kZSgpID09ICdzaG93JyAtLT48ZGl2IGNsYXNzPVxceDIybWFpbGluZy1uYW1lXFx4MjI+ICA8cCBjbGFzcz1cXHgyMnVpLWJ1dHRvblxceDIyIGRhdGEtYmluZD1cXHgyMmV2ZW50OiB7IGRibGNsaWNrOiBlbmFibGVFZGl0TWFpbGluZ05hbWUgfSwgZGJsY2xpY2tCdWJibGU6IGZhbHNlLCAgICBhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdlZGl0LXRpdGxlLWRvdWJsZS1jbGljaycpIH1cXHgyMj4gICAgPHNwYW4gY2xhc3M9XFx4MjJ1aS1idXR0b24tdGV4dFxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290Lm1haWxpbmdOYW1lXFx4MjI+PC9zcGFuPiAgPC9wPjwvZGl2PjwhLS0gL2tvIC0tPlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJnYWxsZXJ5LWltYWdlc1wiLCBcIjxhc2lkZSBjbGFzcz1cXHgyMmdhbGxlcnktdGh1bWJzIGdhbGxlcnktdGh1bWJzLS1jdXN0b21cXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7J2RhdGEtdHlwZSc6IHR5cGV9XFx4MjI+ICA8ZGl2IGRhdGEtYmluZD1cXHgyMmZvcmVhY2g6IGl0ZW1zXFx4MjI+ICAgIDxkaXYgY2xhc3M9XFx4MjJkcmFnZ2FibGUtaXRlbVxceDIyIGRhdGEtYmluZD1cXHgyMmlmOiB0eXBlb2YgdGh1bWJuYWlsVXJsICE9ICd1bmRlZmluZWQnXFx4MjI+ICAgICAgPGJ1dHRvbiBjbGFzcz1cXHgyMmdhbGxlcnktdGh1bWJzX19yZW1vdmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QucmVtb3ZlSW1hZ2UuYmluZCgkZGF0YSwgJGRhdGEsICRwYXJlbnQudHlwZSlcXHgyMj4gICAgICAgIDxpIGNsYXNzPVxceDIyZmEgZmEtdGltZXNcXHgyMj48L2k+ICAgICAgPC9idXR0b24+ICAgICAgPGRpdiBjbGFzcz1cXHgyMmRyYWdnYWJsZSBpbWFnZVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5hZGRJbWFnZSwgZXh0ZHJhZ2dhYmxlOiB7IGRhdGE6ICRkYXRhLCBkcm9wQ29udGFpbmVyOiAnI21haW4td3lzaXd5Zy1hcmVhJywgZHJhZ2dpbmc6ICRyb290LmRyYWdnaW5nSW1hZ2UsICdvcHRpb25zJzogeyAnYXBwZW5kVG8nOiAnI3BhZ2UnIH0gfSwgc3R5bGU6IHsgYmFja2dyb3VuZEltYWdlOiAndXJsKFxcXFwnJyArIHRodW1ibmFpbFVybCArICdcXFxcJyknIH1cXHgyMj4gICAgICAgIDxpbWcgdGl0bGU9XFx4MjJEcmFnIHRoaXMgaW1hZ2UgYW5kIGRyb3AgaXQgb24gYW55IHRlbXBsYXRlIGltYWdlIHBsYWNlaG9sZGVyXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBibG9jaztcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge30sIGF0dHI6IHsgc3JjOiB0aHVtYm5haWxVcmwsICd0aXRsZSc6ICRyb290LnQoJ0RyYWcgdGhpcyBpbWFnZSBhbmQgZHJvcCBpdCBvbiBhbnkgdGVtcGxhdGUgaW1hZ2UgcGxhY2Vob2xkZXInKSB9XFx4MjIvPiAgICAgIDwvZGl2PiAgICA8L2Rpdj4gIDwvZGl2PjwvYXNpZGU+XCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImdhbGxlcnktdXBsb2FkXCIsIFwiPGRpdiBkYXRhLWRyb3AtY29udGVudD1cXHgyMkRyb3AgaGVyZVxceDIyIGNsYXNzPVxceDIyaW1nLWRyb3B6b25lIHBhbmUgdXBsb2Fkem9uZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgJ2RhdGEtZHJvcC1jb250ZW50JzogJHJvb3QudCgnRHJvcCBoZXJlJykgfSwgZnVkcm9wcGFibGU6IHsgYWN0aXZlQ2xhc3M6ICd1aS1zdGF0ZS1oaWdobGlnaHQnLCBob3ZlckNsYXNzOiAndWktc3RhdGUtZHJhZ2hvdmVyJyB9XFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIybW8tdXBsb2Fkem9uZVxceDIyPiAgICA8IS0tIGtvIGlmOiB0eXBlID09PSAnbWFpbGluZycgLS0+ICAgICAgPGlucHV0IGNsYXNzPVxceDIyZmlsZXVwbG9hZFxceDIyIHR5cGU9XFx4MjJmaWxlXFx4MjIgbXVsdGlwbGUgbmFtZT1cXHgyMmZpbGVzW11cXHgyMiBkYXRhLWJpbmQ9XFx4MjJmaWxldXBsb2FkOiB7IG9uZXJyb3I6ICRyb290Lm5vdGlmaWVyLmVycm9yLCBvbmZpbGU6ICRyb290LmxvYWRNYWlsaW5nSW1hZ2UgfVxceDIyPiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogdHlwZSA9PT0gJ3RlbXBsYXRlJyAtLT4gICAgICA8aW5wdXQgY2xhc3M9XFx4MjJmaWxldXBsb2FkXFx4MjIgdHlwZT1cXHgyMmZpbGVcXHgyMiBtdWx0aXBsZSBuYW1lPVxceDIyZmlsZXNbXVxceDIyIGRhdGEtYmluZD1cXHgyMmZpbGV1cGxvYWQ6IHsgb25lcnJvcjogJHJvb3Qubm90aWZpZXIuZXJyb3IsIG9uZmlsZTogJHJvb3QubG9hZFRlbXBsYXRlSW1hZ2UsIHVwbG9hZFRvVGVtcGxhdGU6IHRydWUgfVxceDIyPiAgICA8IS0tIC9rbyAtLT4gICAgPHNwYW4gZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnQ2xpY2sgb3IgZHJhZyBmaWxlcyBoZXJlJylcXHgyMj5DbGljayBvciBkcmFnIGZpbGVzIGhlcmU8L3NwYW4+ICAgICAgPGRpdiBjbGFzcz1cXHgyMndvcmt6b25lXFx4MjI+ICAgICAgICA8ZGl2IGNsYXNzPVxceDIycHJvZ3Jlc3NcXHgyMj4gICAgICAgICAgPGRpdiBjbGFzcz1cXHgyMnByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3VjY2Vzc1xceDIyPjwvZGl2PiAgICAgICAgPC9kaXY+ICAgICAgPC9kaXY+ICA8L2Rpdj48L2Rpdj5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiaG9tZS1pY29uXCIsIFwiPGRpdiBpZD1cXHgyMmxvYWRpbmdcXHgyMiBjbGFzcz1cXHgyMmxvYWRpbmdcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjc3M6IHsgbG9hZGluZzogZmFsc2UgfVxceDIyPiAgPGEgaHJlZj1cXHgyMi9cXHgyMiBhbHQ9XFx4MjJtb3NhaWMtYmFja2VuZFxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgYWx0OiAkcm9vdC5icmFuZE5hbWUgfVxceDIyPiAgICA8aSBjbGFzcz1cXHgyMmZhIGZhLWhvbWUgZmEtMnhcXHgyMiBhcmlhLWhpZGRlbj1cXHgyMnRydWVcXHgyMj48L2k+ICA8L2E+ICA8ZGl2IHN0eWxlPVxceDIyb3BhY2l0eTogMFxceDIyIGRhdGEtYmluZD1cXHgyMnZpc2libGU6IGZhbHNlXFx4MjI+T3BwcHMuLi4gISE8L2Rpdj48L2Rpdj5cIik7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtib29sZWFufSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy5cbiAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAqICAgICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAgICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICBpZiAoIW9iaklzQXJyKSB7XG4gICAgb2JqVGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IGdldFRhZyhvdGhlcik7XG4gICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG4gIH1cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG9iamVjdCksXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvdGhlciksXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRywgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgdW5kZWZpbmVkLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogc3RyaW5nVG9QYXRoKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEsXG4vLyBmb3IgZGF0YSB2aWV3cyBpbiBFZGdlIDwgMTQsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIHJlc3VsdCxcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XVxuICogIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV1cbiAqICBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqL1xudmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgdmFyIHJlc3VsdCA9IChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpXG4gICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXG4gICAgOiBbXTtcblxuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfVxuICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcHJvcHMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iamVjdDtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIHBpY2sgZnJvbS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9sIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSBuYXRpdmVHZXRTeW1ib2xzID8gb3ZlckFyZyhuYXRpdmVHZXRTeW1ib2xzLCBPYmplY3QpIDogc3R1YkFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9sIHByb3BlcnRpZXNcbiAqIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdCBhcmVcbiAqIG5vdCBvbWl0dGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJvcHNdIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBvbWl0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xudmFyIG9taXQgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBwcm9wcyA9IGFycmF5TWFwKGJhc2VGbGF0dGVuKHByb3BzLCAxKSwgdG9LZXkpO1xuICByZXR1cm4gYmFzZVBpY2sob2JqZWN0LCBiYXNlRGlmZmVyZW5jZShnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcHJvcHMpKTtcbn0pO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9taXQ7XG4iLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvc3BlYWtpbmd1cmwnKTtcbiIsIihmdW5jdGlvbiAocm9vdCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIGNoYXJNYXBcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBjaGFyTWFwID0ge1xuXG4gICAgICAgIC8vIGxhdGluXG4gICAgICAgICfDgCc6ICdBJyxcbiAgICAgICAgJ8OBJzogJ0EnLFxuICAgICAgICAnw4InOiAnQScsXG4gICAgICAgICfDgyc6ICdBJyxcbiAgICAgICAgJ8OEJzogJ0FlJyxcbiAgICAgICAgJ8OFJzogJ0EnLFxuICAgICAgICAnw4YnOiAnQUUnLFxuICAgICAgICAnw4cnOiAnQycsXG4gICAgICAgICfDiCc6ICdFJyxcbiAgICAgICAgJ8OJJzogJ0UnLFxuICAgICAgICAnw4onOiAnRScsXG4gICAgICAgICfDiyc6ICdFJyxcbiAgICAgICAgJ8OMJzogJ0knLFxuICAgICAgICAnw40nOiAnSScsXG4gICAgICAgICfDjic6ICdJJyxcbiAgICAgICAgJ8OPJzogJ0knLFxuICAgICAgICAnw5AnOiAnRCcsXG4gICAgICAgICfDkSc6ICdOJyxcbiAgICAgICAgJ8OSJzogJ08nLFxuICAgICAgICAnw5MnOiAnTycsXG4gICAgICAgICfDlCc6ICdPJyxcbiAgICAgICAgJ8OVJzogJ08nLFxuICAgICAgICAnw5YnOiAnT2UnLFxuICAgICAgICAnxZAnOiAnTycsXG4gICAgICAgICfDmCc6ICdPJyxcbiAgICAgICAgJ8OZJzogJ1UnLFxuICAgICAgICAnw5onOiAnVScsXG4gICAgICAgICfDmyc6ICdVJyxcbiAgICAgICAgJ8OcJzogJ1VlJyxcbiAgICAgICAgJ8WwJzogJ1UnLFxuICAgICAgICAnw50nOiAnWScsXG4gICAgICAgICfDnic6ICdUSCcsXG4gICAgICAgICfDnyc6ICdzcycsXG4gICAgICAgICfDoCc6ICdhJyxcbiAgICAgICAgJ8OhJzogJ2EnLFxuICAgICAgICAnw6InOiAnYScsXG4gICAgICAgICfDoyc6ICdhJyxcbiAgICAgICAgJ8OkJzogJ2FlJyxcbiAgICAgICAgJ8OlJzogJ2EnLFxuICAgICAgICAnw6YnOiAnYWUnLFxuICAgICAgICAnw6cnOiAnYycsXG4gICAgICAgICfDqCc6ICdlJyxcbiAgICAgICAgJ8OpJzogJ2UnLFxuICAgICAgICAnw6onOiAnZScsXG4gICAgICAgICfDqyc6ICdlJyxcbiAgICAgICAgJ8OsJzogJ2knLFxuICAgICAgICAnw60nOiAnaScsXG4gICAgICAgICfDric6ICdpJyxcbiAgICAgICAgJ8OvJzogJ2knLFxuICAgICAgICAnw7AnOiAnZCcsXG4gICAgICAgICfDsSc6ICduJyxcbiAgICAgICAgJ8OyJzogJ28nLFxuICAgICAgICAnw7MnOiAnbycsXG4gICAgICAgICfDtCc6ICdvJyxcbiAgICAgICAgJ8O1JzogJ28nLFxuICAgICAgICAnw7YnOiAnb2UnLFxuICAgICAgICAnxZEnOiAnbycsXG4gICAgICAgICfDuCc6ICdvJyxcbiAgICAgICAgJ8O5JzogJ3UnLFxuICAgICAgICAnw7onOiAndScsXG4gICAgICAgICfDuyc6ICd1JyxcbiAgICAgICAgJ8O8JzogJ3VlJyxcbiAgICAgICAgJ8WxJzogJ3UnLFxuICAgICAgICAnw70nOiAneScsXG4gICAgICAgICfDvic6ICd0aCcsXG4gICAgICAgICfDvyc6ICd5JyxcbiAgICAgICAgJ+G6nic6ICdTUycsXG5cbiAgICAgICAgLy8gbGFuZ3VhZ2Ugc3BlY2lmaWNcblxuICAgICAgICAvLyBBcmFiaWNcbiAgICAgICAgJ9inJzogJ2EnLFxuICAgICAgICAn2KMnOiAnYScsXG4gICAgICAgICfYpSc6ICdpJyxcbiAgICAgICAgJ9iiJzogJ2FhJyxcbiAgICAgICAgJ9ikJzogJ3UnLFxuICAgICAgICAn2KYnOiAnZScsXG4gICAgICAgICfYoSc6ICdhJyxcbiAgICAgICAgJ9ioJzogJ2InLFxuICAgICAgICAn2KonOiAndCcsXG4gICAgICAgICfYqyc6ICd0aCcsXG4gICAgICAgICfYrCc6ICdqJyxcbiAgICAgICAgJ9itJzogJ2gnLFxuICAgICAgICAn2K4nOiAna2gnLFxuICAgICAgICAn2K8nOiAnZCcsXG4gICAgICAgICfYsCc6ICd0aCcsXG4gICAgICAgICfYsSc6ICdyJyxcbiAgICAgICAgJ9iyJzogJ3onLFxuICAgICAgICAn2LMnOiAncycsXG4gICAgICAgICfYtCc6ICdzaCcsXG4gICAgICAgICfYtSc6ICdzJyxcbiAgICAgICAgJ9i2JzogJ2RoJyxcbiAgICAgICAgJ9i3JzogJ3QnLFxuICAgICAgICAn2LgnOiAneicsXG4gICAgICAgICfYuSc6ICdhJyxcbiAgICAgICAgJ9i6JzogJ2doJyxcbiAgICAgICAgJ9mBJzogJ2YnLFxuICAgICAgICAn2YInOiAncScsXG4gICAgICAgICfZgyc6ICdrJyxcbiAgICAgICAgJ9mEJzogJ2wnLFxuICAgICAgICAn2YUnOiAnbScsXG4gICAgICAgICfZhic6ICduJyxcbiAgICAgICAgJ9mHJzogJ2gnLFxuICAgICAgICAn2YgnOiAndycsXG4gICAgICAgICfZiic6ICd5JyxcbiAgICAgICAgJ9mJJzogJ2EnLFxuICAgICAgICAn2KknOiAnaCcsXG4gICAgICAgICfvu7snOiAnbGEnLFxuICAgICAgICAn77u3JzogJ2xhYScsXG4gICAgICAgICfvu7knOiAnbGFpJyxcbiAgICAgICAgJ++7tSc6ICdsYWEnLFxuXG4gICAgICAgIC8vIFBlcnNpYW4gYWRkaXRpb25hbCBjaGFyYWN0ZXJzIHRoYW4gQXJhYmljXG4gICAgICAgICfaryc6ICdnJyxcbiAgICAgICAgJ9qGJzogJ2NoJyxcbiAgICAgICAgJ9m+JzogJ3AnLFxuICAgICAgICAn2pgnOiAnemgnLFxuICAgICAgICAn2qknOiAnaycsXG4gICAgICAgICfbjCc6ICd5JyxcblxuICAgICAgICAvLyBBcmFiaWMgZGlhY3RyaWNzXG4gICAgICAgICfZjic6ICdhJyxcbiAgICAgICAgJ9mLJzogJ2FuJyxcbiAgICAgICAgJ9mQJzogJ2UnLFxuICAgICAgICAn2Y0nOiAnZW4nLFxuICAgICAgICAn2Y8nOiAndScsXG4gICAgICAgICfZjCc6ICdvbicsXG4gICAgICAgICfZkic6ICcnLFxuXG4gICAgICAgIC8vIEFyYWJpYyBudW1iZXJzXG4gICAgICAgICfZoCc6ICcwJyxcbiAgICAgICAgJ9mhJzogJzEnLFxuICAgICAgICAn2aInOiAnMicsXG4gICAgICAgICfZoyc6ICczJyxcbiAgICAgICAgJ9mkJzogJzQnLFxuICAgICAgICAn2aUnOiAnNScsXG4gICAgICAgICfZpic6ICc2JyxcbiAgICAgICAgJ9mnJzogJzcnLFxuICAgICAgICAn2agnOiAnOCcsXG4gICAgICAgICfZqSc6ICc5JyxcblxuICAgICAgICAvLyBQZXJzaWFuIG51bWJlcnNcbiAgICAgICAgJ9uwJzogJzAnLFxuICAgICAgICAn27EnOiAnMScsXG4gICAgICAgICfbsic6ICcyJyxcbiAgICAgICAgJ9uzJzogJzMnLFxuICAgICAgICAn27QnOiAnNCcsXG4gICAgICAgICfbtSc6ICc1JyxcbiAgICAgICAgJ9u2JzogJzYnLFxuICAgICAgICAn27cnOiAnNycsXG4gICAgICAgICfbuCc6ICc4JyxcbiAgICAgICAgJ9u5JzogJzknLFxuXG4gICAgICAgIC8vIEJ1cm1lc2UgY29uc29uYW50c1xuICAgICAgICAn4YCAJzogJ2snLFxuICAgICAgICAn4YCBJzogJ2toJyxcbiAgICAgICAgJ+GAgic6ICdnJyxcbiAgICAgICAgJ+GAgyc6ICdnYScsXG4gICAgICAgICfhgIQnOiAnbmcnLFxuICAgICAgICAn4YCFJzogJ3MnLFxuICAgICAgICAn4YCGJzogJ3NhJyxcbiAgICAgICAgJ+GAhyc6ICd6JyxcbiAgICAgICAgJ+GAheGAuyc6ICd6YScsXG4gICAgICAgICfhgIonOiAnbnknLFxuICAgICAgICAn4YCLJzogJ3QnLFxuICAgICAgICAn4YCMJzogJ3RhJyxcbiAgICAgICAgJ+GAjSc6ICdkJyxcbiAgICAgICAgJ+GAjic6ICdkYScsXG4gICAgICAgICfhgI8nOiAnbmEnLFxuICAgICAgICAn4YCQJzogJ3QnLFxuICAgICAgICAn4YCRJzogJ3RhJyxcbiAgICAgICAgJ+GAkic6ICdkJyxcbiAgICAgICAgJ+GAkyc6ICdkYScsXG4gICAgICAgICfhgJQnOiAnbicsXG4gICAgICAgICfhgJUnOiAncCcsXG4gICAgICAgICfhgJYnOiAncGEnLFxuICAgICAgICAn4YCXJzogJ2InLFxuICAgICAgICAn4YCYJzogJ2JhJyxcbiAgICAgICAgJ+GAmSc6ICdtJyxcbiAgICAgICAgJ+GAmic6ICd5JyxcbiAgICAgICAgJ+GAmyc6ICd5YScsXG4gICAgICAgICfhgJwnOiAnbCcsXG4gICAgICAgICfhgJ0nOiAndycsXG4gICAgICAgICfhgJ4nOiAndGgnLFxuICAgICAgICAn4YCfJzogJ2gnLFxuICAgICAgICAn4YCgJzogJ2xhJyxcbiAgICAgICAgJ+GAoSc6ICdhJyxcbiAgICAgICAgLy8gY29uc29uYW50IGNoYXJhY3RlciBjb21ib3NcbiAgICAgICAgJ+GAvCc6ICd5JyxcbiAgICAgICAgJ+GAuyc6ICd5YScsXG4gICAgICAgICfhgL0nOiAndycsXG4gICAgICAgICfhgLzhgL0nOiAneXcnLFxuICAgICAgICAn4YC74YC9JzogJ3l3YScsXG4gICAgICAgICfhgL4nOiAnaCcsXG4gICAgICAgIC8vIGluZGVwZW5kZW50IHZvd2Vsc1xuICAgICAgICAn4YCnJzogJ2UnLFxuICAgICAgICAn4YGPJzogJy1lJyxcbiAgICAgICAgJ+GAoyc6ICdpJyxcbiAgICAgICAgJ+GApCc6ICctaScsXG4gICAgICAgICfhgIknOiAndScsXG4gICAgICAgICfhgKYnOiAnLXUnLFxuICAgICAgICAn4YCpJzogJ2F3JyxcbiAgICAgICAgJ+GAnuGAvOGAseGArCc6ICdhdycsXG4gICAgICAgICfhgKonOiAnYXcnLFxuICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgICfhgYAnOiAnMCcsXG4gICAgICAgICfhgYEnOiAnMScsXG4gICAgICAgICfhgYInOiAnMicsXG4gICAgICAgICfhgYMnOiAnMycsXG4gICAgICAgICfhgYQnOiAnNCcsXG4gICAgICAgICfhgYUnOiAnNScsXG4gICAgICAgICfhgYYnOiAnNicsXG4gICAgICAgICfhgYcnOiAnNycsXG4gICAgICAgICfhgYgnOiAnOCcsXG4gICAgICAgICfhgYknOiAnOScsXG4gICAgICAgIC8vIHZpcmFtYSBhbmQgdG9uZSBtYXJrcyB3aGljaCBhcmUgc2lsZW50IGluIHRyYW5zbGl0ZXJhdGlvblxuICAgICAgICAn4YC5JzogJycsXG4gICAgICAgICfhgLcnOiAnJyxcbiAgICAgICAgJ+GAuCc6ICcnLFxuXG4gICAgICAgIC8vIEN6ZWNoXG4gICAgICAgICfEjSc6ICdjJyxcbiAgICAgICAgJ8SPJzogJ2QnLFxuICAgICAgICAnxJsnOiAnZScsXG4gICAgICAgICfFiCc6ICduJyxcbiAgICAgICAgJ8WZJzogJ3InLFxuICAgICAgICAnxaEnOiAncycsXG4gICAgICAgICfFpSc6ICd0JyxcbiAgICAgICAgJ8WvJzogJ3UnLFxuICAgICAgICAnxb4nOiAneicsXG4gICAgICAgICfEjCc6ICdDJyxcbiAgICAgICAgJ8SOJzogJ0QnLFxuICAgICAgICAnxJonOiAnRScsXG4gICAgICAgICfFhyc6ICdOJyxcbiAgICAgICAgJ8WYJzogJ1InLFxuICAgICAgICAnxaAnOiAnUycsXG4gICAgICAgICfFpCc6ICdUJyxcbiAgICAgICAgJ8WuJzogJ1UnLFxuICAgICAgICAnxb0nOiAnWicsXG5cbiAgICAgICAgLy8gRGhpdmVoaVxuICAgICAgICAn3oAnOiAnaCcsXG4gICAgICAgICfegSc6ICdzaCcsXG4gICAgICAgICfegic6ICduJyxcbiAgICAgICAgJ96DJzogJ3InLFxuICAgICAgICAn3oQnOiAnYicsXG4gICAgICAgICfehSc6ICdsaCcsXG4gICAgICAgICfehic6ICdrJyxcbiAgICAgICAgJ96HJzogJ2EnLFxuICAgICAgICAn3ognOiAndicsXG4gICAgICAgICfeiSc6ICdtJyxcbiAgICAgICAgJ96KJzogJ2YnLFxuICAgICAgICAn3osnOiAnZGgnLFxuICAgICAgICAn3ownOiAndGgnLFxuICAgICAgICAn3o0nOiAnbCcsXG4gICAgICAgICfejic6ICdnJyxcbiAgICAgICAgJ96PJzogJ2duJyxcbiAgICAgICAgJ96QJzogJ3MnLFxuICAgICAgICAn3pEnOiAnZCcsXG4gICAgICAgICfekic6ICd6JyxcbiAgICAgICAgJ96TJzogJ3QnLFxuICAgICAgICAn3pQnOiAneScsXG4gICAgICAgICfelSc6ICdwJyxcbiAgICAgICAgJ96WJzogJ2onLFxuICAgICAgICAn3pcnOiAnY2gnLFxuICAgICAgICAn3pgnOiAndHQnLFxuICAgICAgICAn3pknOiAnaGgnLFxuICAgICAgICAn3ponOiAna2gnLFxuICAgICAgICAn3psnOiAndGgnLFxuICAgICAgICAn3pwnOiAneicsXG4gICAgICAgICfenSc6ICdzaCcsXG4gICAgICAgICfenic6ICdzJyxcbiAgICAgICAgJ96fJzogJ2QnLFxuICAgICAgICAn3qAnOiAndCcsXG4gICAgICAgICfeoSc6ICd6JyxcbiAgICAgICAgJ96iJzogJ2EnLFxuICAgICAgICAn3qMnOiAnZ2gnLFxuICAgICAgICAn3qQnOiAncScsXG4gICAgICAgICfepSc6ICd3JyxcbiAgICAgICAgJ96mJzogJ2EnLFxuICAgICAgICAn3qcnOiAnYWEnLFxuICAgICAgICAn3qgnOiAnaScsXG4gICAgICAgICfeqSc6ICdlZScsXG4gICAgICAgICfeqic6ICd1JyxcbiAgICAgICAgJ96rJzogJ29vJyxcbiAgICAgICAgJ96sJzogJ2UnLFxuICAgICAgICAn3q0nOiAnZXknLFxuICAgICAgICAn3q4nOiAnbycsXG4gICAgICAgICferyc6ICdvYScsXG4gICAgICAgICfesCc6ICcnLFxuXG4gICAgICAgIC8vIEdlb3JnaWFuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvbWFuaXphdGlvbl9vZl9HZW9yZ2lhblxuICAgICAgICAvLyBOYXRpb25hbCBzeXN0ZW0gKDIwMDIpXG4gICAgICAgICfhg5AnOiAnYScsXG4gICAgICAgICfhg5EnOiAnYicsXG4gICAgICAgICfhg5InOiAnZycsXG4gICAgICAgICfhg5MnOiAnZCcsXG4gICAgICAgICfhg5QnOiAnZScsXG4gICAgICAgICfhg5UnOiAndicsXG4gICAgICAgICfhg5YnOiAneicsXG4gICAgICAgICfhg5cnOiAndCcsXG4gICAgICAgICfhg5gnOiAnaScsXG4gICAgICAgICfhg5knOiAnaycsXG4gICAgICAgICfhg5onOiAnbCcsXG4gICAgICAgICfhg5snOiAnbScsXG4gICAgICAgICfhg5wnOiAnbicsXG4gICAgICAgICfhg50nOiAnbycsXG4gICAgICAgICfhg54nOiAncCcsXG4gICAgICAgICfhg58nOiAnemgnLFxuICAgICAgICAn4YOgJzogJ3InLFxuICAgICAgICAn4YOhJzogJ3MnLFxuICAgICAgICAn4YOiJzogJ3QnLFxuICAgICAgICAn4YOjJzogJ3UnLFxuICAgICAgICAn4YOkJzogJ3AnLFxuICAgICAgICAn4YOlJzogJ2snLFxuICAgICAgICAn4YOmJzogJ2doJyxcbiAgICAgICAgJ+GDpyc6ICdxJyxcbiAgICAgICAgJ+GDqCc6ICdzaCcsXG4gICAgICAgICfhg6knOiAnY2gnLFxuICAgICAgICAn4YOqJzogJ3RzJyxcbiAgICAgICAgJ+GDqyc6ICdkeicsXG4gICAgICAgICfhg6wnOiAndHMnLFxuICAgICAgICAn4YOtJzogJ2NoJyxcbiAgICAgICAgJ+GDric6ICdraCcsXG4gICAgICAgICfhg68nOiAnaicsXG4gICAgICAgICfhg7AnOiAnaCcsXG5cbiAgICAgICAgLy8gR3JlZWtcbiAgICAgICAgJ86xJzogJ2EnLFxuICAgICAgICAnzrInOiAndicsXG4gICAgICAgICfOsyc6ICdnJyxcbiAgICAgICAgJ860JzogJ2QnLFxuICAgICAgICAnzrUnOiAnZScsXG4gICAgICAgICfOtic6ICd6JyxcbiAgICAgICAgJ863JzogJ2knLFxuICAgICAgICAnzrgnOiAndGgnLFxuICAgICAgICAnzrknOiAnaScsXG4gICAgICAgICfOuic6ICdrJyxcbiAgICAgICAgJ867JzogJ2wnLFxuICAgICAgICAnzrwnOiAnbScsXG4gICAgICAgICfOvSc6ICduJyxcbiAgICAgICAgJ86+JzogJ2tzJyxcbiAgICAgICAgJ86/JzogJ28nLFxuICAgICAgICAnz4AnOiAncCcsXG4gICAgICAgICfPgSc6ICdyJyxcbiAgICAgICAgJ8+DJzogJ3MnLFxuICAgICAgICAnz4QnOiAndCcsXG4gICAgICAgICfPhSc6ICd5JyxcbiAgICAgICAgJ8+GJzogJ2YnLFxuICAgICAgICAnz4cnOiAneCcsXG4gICAgICAgICfPiCc6ICdwcycsXG4gICAgICAgICfPiSc6ICdvJyxcbiAgICAgICAgJ86sJzogJ2EnLFxuICAgICAgICAnzq0nOiAnZScsXG4gICAgICAgICfOryc6ICdpJyxcbiAgICAgICAgJ8+MJzogJ28nLFxuICAgICAgICAnz40nOiAneScsXG4gICAgICAgICfOric6ICdpJyxcbiAgICAgICAgJ8+OJzogJ28nLFxuICAgICAgICAnz4InOiAncycsXG4gICAgICAgICfPiic6ICdpJyxcbiAgICAgICAgJ86wJzogJ3knLFxuICAgICAgICAnz4snOiAneScsXG4gICAgICAgICfOkCc6ICdpJyxcbiAgICAgICAgJ86RJzogJ0EnLFxuICAgICAgICAnzpInOiAnQicsXG4gICAgICAgICfOkyc6ICdHJyxcbiAgICAgICAgJ86UJzogJ0QnLFxuICAgICAgICAnzpUnOiAnRScsXG4gICAgICAgICfOlic6ICdaJyxcbiAgICAgICAgJ86XJzogJ0knLFxuICAgICAgICAnzpgnOiAnVEgnLFxuICAgICAgICAnzpknOiAnSScsXG4gICAgICAgICfOmic6ICdLJyxcbiAgICAgICAgJ86bJzogJ0wnLFxuICAgICAgICAnzpwnOiAnTScsXG4gICAgICAgICfOnSc6ICdOJyxcbiAgICAgICAgJ86eJzogJ0tTJyxcbiAgICAgICAgJ86fJzogJ08nLFxuICAgICAgICAnzqAnOiAnUCcsXG4gICAgICAgICfOoSc6ICdSJyxcbiAgICAgICAgJ86jJzogJ1MnLFxuICAgICAgICAnzqQnOiAnVCcsXG4gICAgICAgICfOpSc6ICdZJyxcbiAgICAgICAgJ86mJzogJ0YnLFxuICAgICAgICAnzqcnOiAnWCcsXG4gICAgICAgICfOqCc6ICdQUycsXG4gICAgICAgICfOqSc6ICdPJyxcbiAgICAgICAgJ86GJzogJ0EnLFxuICAgICAgICAnzognOiAnRScsXG4gICAgICAgICfOiic6ICdJJyxcbiAgICAgICAgJ86MJzogJ08nLFxuICAgICAgICAnzo4nOiAnWScsXG4gICAgICAgICfOiSc6ICdJJyxcbiAgICAgICAgJ86PJzogJ08nLFxuICAgICAgICAnzqonOiAnSScsXG4gICAgICAgICfOqyc6ICdZJyxcblxuICAgICAgICAvLyBMYXR2aWFuXG4gICAgICAgICfEgSc6ICdhJyxcbiAgICAgICAgLy8gJ8SNJzogJ2MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ8STJzogJ2UnLFxuICAgICAgICAnxKMnOiAnZycsXG4gICAgICAgICfEqyc6ICdpJyxcbiAgICAgICAgJ8S3JzogJ2snLFxuICAgICAgICAnxLwnOiAnbCcsXG4gICAgICAgICfFhic6ICduJyxcbiAgICAgICAgLy8gJ8WhJzogJ3MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ8WrJzogJ3UnLFxuICAgICAgICAvLyAnxb4nOiAneicsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAnxIAnOiAnQScsXG4gICAgICAgIC8vICfEjCc6ICdDJywgLy8gZHVwbGljYXRlXG4gICAgICAgICfEkic6ICdFJyxcbiAgICAgICAgJ8SiJzogJ0cnLFxuICAgICAgICAnxKonOiAnSScsXG4gICAgICAgICfEtic6ICdrJyxcbiAgICAgICAgJ8S7JzogJ0wnLFxuICAgICAgICAnxYUnOiAnTicsXG4gICAgICAgIC8vICfFoCc6ICdTJywgLy8gZHVwbGljYXRlXG4gICAgICAgICfFqic6ICdVJyxcbiAgICAgICAgLy8gJ8W9JzogJ1onLCAvLyBkdXBsaWNhdGVcblxuICAgICAgICAvLyBNYWNlZG9uaWFuXG4gICAgICAgICfQjCc6ICdLaicsXG4gICAgICAgICfRnCc6ICdraicsXG4gICAgICAgICfQiSc6ICdMaicsXG4gICAgICAgICfRmSc6ICdsaicsXG4gICAgICAgICfQiic6ICdOaicsXG4gICAgICAgICfRmic6ICduaicsXG4gICAgICAgICfQotGBJzogJ1RzJyxcbiAgICAgICAgJ9GC0YEnOiAndHMnLFxuXG4gICAgICAgIC8vIFBvbGlzaFxuICAgICAgICAnxIUnOiAnYScsXG4gICAgICAgICfEhyc6ICdjJyxcbiAgICAgICAgJ8SZJzogJ2UnLFxuICAgICAgICAnxYInOiAnbCcsXG4gICAgICAgICfFhCc6ICduJyxcbiAgICAgICAgLy8gJ8OzJzogJ28nLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ8WbJzogJ3MnLFxuICAgICAgICAnxbonOiAneicsXG4gICAgICAgICfFvCc6ICd6JyxcbiAgICAgICAgJ8SEJzogJ0EnLFxuICAgICAgICAnxIYnOiAnQycsXG4gICAgICAgICfEmCc6ICdFJyxcbiAgICAgICAgJ8WBJzogJ0wnLFxuICAgICAgICAnxYMnOiAnTicsXG4gICAgICAgICfFmic6ICdTJyxcbiAgICAgICAgJ8W5JzogJ1onLFxuICAgICAgICAnxbsnOiAnWicsXG5cbiAgICAgICAgLy8gVWtyYW5pYW5cbiAgICAgICAgJ9CEJzogJ1llJyxcbiAgICAgICAgJ9CGJzogJ0knLFxuICAgICAgICAn0IcnOiAnWWknLFxuICAgICAgICAn0pAnOiAnRycsXG4gICAgICAgICfRlCc6ICd5ZScsXG4gICAgICAgICfRlic6ICdpJyxcbiAgICAgICAgJ9GXJzogJ3lpJyxcbiAgICAgICAgJ9KRJzogJ2cnLFxuXG4gICAgICAgIC8vIFJvbWFuaWFuXG4gICAgICAgICfEgyc6ICdhJyxcbiAgICAgICAgJ8SCJzogJ0EnLFxuICAgICAgICAnyJknOiAncycsXG4gICAgICAgICfImCc6ICdTJyxcbiAgICAgICAgLy8gJ8WfJzogJ3MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ8WeJzogJ1MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ8ibJzogJ3QnLFxuICAgICAgICAnyJonOiAnVCcsXG4gICAgICAgICfFoyc6ICd0JyxcbiAgICAgICAgJ8WiJzogJ1QnLFxuXG4gICAgICAgIC8vIFJ1c3NpYW4gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm9tYW5pemF0aW9uX29mX1J1c3NpYW5cbiAgICAgICAgLy8gSUNBT1xuXG4gICAgICAgICfQsCc6ICdhJyxcbiAgICAgICAgJ9CxJzogJ2InLFxuICAgICAgICAn0LInOiAndicsXG4gICAgICAgICfQsyc6ICdnJyxcbiAgICAgICAgJ9C0JzogJ2QnLFxuICAgICAgICAn0LUnOiAnZScsXG4gICAgICAgICfRkSc6ICd5bycsXG4gICAgICAgICfQtic6ICd6aCcsXG4gICAgICAgICfQtyc6ICd6JyxcbiAgICAgICAgJ9C4JzogJ2knLFxuICAgICAgICAn0LknOiAnaScsXG4gICAgICAgICfQuic6ICdrJyxcbiAgICAgICAgJ9C7JzogJ2wnLFxuICAgICAgICAn0LwnOiAnbScsXG4gICAgICAgICfQvSc6ICduJyxcbiAgICAgICAgJ9C+JzogJ28nLFxuICAgICAgICAn0L8nOiAncCcsXG4gICAgICAgICfRgCc6ICdyJyxcbiAgICAgICAgJ9GBJzogJ3MnLFxuICAgICAgICAn0YInOiAndCcsXG4gICAgICAgICfRgyc6ICd1JyxcbiAgICAgICAgJ9GEJzogJ2YnLFxuICAgICAgICAn0YUnOiAna2gnLFxuICAgICAgICAn0YYnOiAnYycsXG4gICAgICAgICfRhyc6ICdjaCcsXG4gICAgICAgICfRiCc6ICdzaCcsXG4gICAgICAgICfRiSc6ICdzaCcsXG4gICAgICAgICfRiic6ICcnLFxuICAgICAgICAn0YsnOiAneScsXG4gICAgICAgICfRjCc6ICcnLFxuICAgICAgICAn0Y0nOiAnZScsXG4gICAgICAgICfRjic6ICd5dScsXG4gICAgICAgICfRjyc6ICd5YScsXG4gICAgICAgICfQkCc6ICdBJyxcbiAgICAgICAgJ9CRJzogJ0InLFxuICAgICAgICAn0JInOiAnVicsXG4gICAgICAgICfQkyc6ICdHJyxcbiAgICAgICAgJ9CUJzogJ0QnLFxuICAgICAgICAn0JUnOiAnRScsXG4gICAgICAgICfQgSc6ICdZbycsXG4gICAgICAgICfQlic6ICdaaCcsXG4gICAgICAgICfQlyc6ICdaJyxcbiAgICAgICAgJ9CYJzogJ0knLFxuICAgICAgICAn0JknOiAnSScsXG4gICAgICAgICfQmic6ICdLJyxcbiAgICAgICAgJ9CbJzogJ0wnLFxuICAgICAgICAn0JwnOiAnTScsXG4gICAgICAgICfQnSc6ICdOJyxcbiAgICAgICAgJ9CeJzogJ08nLFxuICAgICAgICAn0J8nOiAnUCcsXG4gICAgICAgICfQoCc6ICdSJyxcbiAgICAgICAgJ9ChJzogJ1MnLFxuICAgICAgICAn0KInOiAnVCcsXG4gICAgICAgICfQoyc6ICdVJyxcbiAgICAgICAgJ9CkJzogJ0YnLFxuICAgICAgICAn0KUnOiAnS2gnLFxuICAgICAgICAn0KYnOiAnQycsXG4gICAgICAgICfQpyc6ICdDaCcsXG4gICAgICAgICfQqCc6ICdTaCcsXG4gICAgICAgICfQqSc6ICdTaCcsXG4gICAgICAgICfQqic6ICcnLFxuICAgICAgICAn0KsnOiAnWScsXG4gICAgICAgICfQrCc6ICcnLFxuICAgICAgICAn0K0nOiAnRScsXG4gICAgICAgICfQric6ICdZdScsXG4gICAgICAgICfQryc6ICdZYScsXG5cbiAgICAgICAgLy8gU2VyYmlhblxuICAgICAgICAn0ZInOiAnZGonLFxuICAgICAgICAn0ZgnOiAnaicsXG4gICAgICAgIC8vICfRmSc6ICdsaicsICAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ9GaJzogJ25qJywgLy8gZHVwbGljYXRlXG4gICAgICAgICfRmyc6ICdjJyxcbiAgICAgICAgJ9GfJzogJ2R6JyxcbiAgICAgICAgJ9CCJzogJ0RqJyxcbiAgICAgICAgJ9CIJzogJ2onLFxuICAgICAgICAvLyAn0IknOiAnTGonLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ9CKJzogJ05qJywgLy8gZHVwbGljYXRlXG4gICAgICAgICfQiyc6ICdDJyxcbiAgICAgICAgJ9CPJzogJ0R6JyxcblxuICAgICAgICAvLyBTbG92YWtcbiAgICAgICAgJ8S+JzogJ2wnLFxuICAgICAgICAnxLonOiAnbCcsXG4gICAgICAgICfFlSc6ICdyJyxcbiAgICAgICAgJ8S9JzogJ0wnLFxuICAgICAgICAnxLknOiAnTCcsXG4gICAgICAgICfFlCc6ICdSJyxcblxuICAgICAgICAvLyBUdXJraXNoXG4gICAgICAgICfFnyc6ICdzJyxcbiAgICAgICAgJ8WeJzogJ1MnLFxuICAgICAgICAnxLEnOiAnaScsXG4gICAgICAgICfEsCc6ICdJJyxcbiAgICAgICAgLy8gJ8OnJzogJ2MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ8OHJzogJ0MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ8O8JzogJ3UnLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAvLyAnw5wnOiAnVScsIC8vIGR1cGxpY2F0ZSwgc2VlIGxhbmdDaGFyTWFwXG4gICAgICAgIC8vICfDtic6ICdvJywgLy8gZHVwbGljYXRlLCBzZWUgbGFuZ0NoYXJNYXBcbiAgICAgICAgLy8gJ8OWJzogJ08nLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAnxJ8nOiAnZycsXG4gICAgICAgICfEnic6ICdHJyxcblxuICAgICAgICAvLyBWaWV0bmFtZXNlXG4gICAgICAgICfhuqMnOiAnYScsXG4gICAgICAgICfhuqInOiAnQScsXG4gICAgICAgICfhurMnOiAnYScsXG4gICAgICAgICfhurInOiAnQScsXG4gICAgICAgICfhuqknOiAnYScsXG4gICAgICAgICfhuqgnOiAnQScsXG4gICAgICAgICfEkSc6ICdkJyxcbiAgICAgICAgJ8SQJzogJ0QnLFxuICAgICAgICAn4bq5JzogJ2UnLFxuICAgICAgICAn4bq4JzogJ0UnLFxuICAgICAgICAn4bq9JzogJ2UnLFxuICAgICAgICAn4bq8JzogJ0UnLFxuICAgICAgICAn4bq7JzogJ2UnLFxuICAgICAgICAn4bq6JzogJ0UnLFxuICAgICAgICAn4bq/JzogJ2UnLFxuICAgICAgICAn4bq+JzogJ0UnLFxuICAgICAgICAn4buBJzogJ2UnLFxuICAgICAgICAn4buAJzogJ0UnLFxuICAgICAgICAn4buHJzogJ2UnLFxuICAgICAgICAn4buGJzogJ0UnLFxuICAgICAgICAn4buFJzogJ2UnLFxuICAgICAgICAn4buEJzogJ0UnLFxuICAgICAgICAn4buDJzogJ2UnLFxuICAgICAgICAn4buCJzogJ0UnLFxuICAgICAgICAn4buPJzogJ28nLFxuICAgICAgICAn4buNJzogJ28nLFxuICAgICAgICAn4buMJzogJ28nLFxuICAgICAgICAn4buRJzogJ28nLFxuICAgICAgICAn4buQJzogJ08nLFxuICAgICAgICAn4buTJzogJ28nLFxuICAgICAgICAn4buSJzogJ08nLFxuICAgICAgICAn4buVJzogJ28nLFxuICAgICAgICAn4buUJzogJ08nLFxuICAgICAgICAn4buZJzogJ28nLFxuICAgICAgICAn4buYJzogJ08nLFxuICAgICAgICAn4buXJzogJ28nLFxuICAgICAgICAn4buWJzogJ08nLFxuICAgICAgICAnxqEnOiAnbycsXG4gICAgICAgICfGoCc6ICdPJyxcbiAgICAgICAgJ+G7myc6ICdvJyxcbiAgICAgICAgJ+G7mic6ICdPJyxcbiAgICAgICAgJ+G7nSc6ICdvJyxcbiAgICAgICAgJ+G7nCc6ICdPJyxcbiAgICAgICAgJ+G7oyc6ICdvJyxcbiAgICAgICAgJ+G7oic6ICdPJyxcbiAgICAgICAgJ+G7oSc6ICdvJyxcbiAgICAgICAgJ+G7oCc6ICdPJyxcbiAgICAgICAgJ+G7nic6ICdvJyxcbiAgICAgICAgJ+G7nyc6ICdvJyxcbiAgICAgICAgJ+G7iyc6ICdpJyxcbiAgICAgICAgJ+G7iic6ICdJJyxcbiAgICAgICAgJ8SpJzogJ2knLFxuICAgICAgICAnxKgnOiAnSScsXG4gICAgICAgICfhu4knOiAnaScsXG4gICAgICAgICfhu4gnOiAnaScsXG4gICAgICAgICfhu6cnOiAndScsXG4gICAgICAgICfhu6YnOiAnVScsXG4gICAgICAgICfhu6UnOiAndScsXG4gICAgICAgICfhu6QnOiAnVScsXG4gICAgICAgICfFqSc6ICd1JyxcbiAgICAgICAgJ8WoJzogJ1UnLFxuICAgICAgICAnxrAnOiAndScsXG4gICAgICAgICfGryc6ICdVJyxcbiAgICAgICAgJ+G7qSc6ICd1JyxcbiAgICAgICAgJ+G7qCc6ICdVJyxcbiAgICAgICAgJ+G7qyc6ICd1JyxcbiAgICAgICAgJ+G7qic6ICdVJyxcbiAgICAgICAgJ+G7sSc6ICd1JyxcbiAgICAgICAgJ+G7sCc6ICdVJyxcbiAgICAgICAgJ+G7ryc6ICd1JyxcbiAgICAgICAgJ+G7ric6ICdVJyxcbiAgICAgICAgJ+G7rSc6ICd1JyxcbiAgICAgICAgJ+G7rCc6ICfGsCcsXG4gICAgICAgICfhu7cnOiAneScsXG4gICAgICAgICfhu7YnOiAneScsXG4gICAgICAgICfhu7MnOiAneScsXG4gICAgICAgICfhu7InOiAnWScsXG4gICAgICAgICfhu7UnOiAneScsXG4gICAgICAgICfhu7QnOiAnWScsXG4gICAgICAgICfhu7knOiAneScsXG4gICAgICAgICfhu7gnOiAnWScsXG4gICAgICAgICfhuqEnOiAnYScsXG4gICAgICAgICfhuqAnOiAnQScsXG4gICAgICAgICfhuqUnOiAnYScsXG4gICAgICAgICfhuqQnOiAnQScsXG4gICAgICAgICfhuqcnOiAnYScsXG4gICAgICAgICfhuqYnOiAnQScsXG4gICAgICAgICfhuq0nOiAnYScsXG4gICAgICAgICfhuqwnOiAnQScsXG4gICAgICAgICfhuqsnOiAnYScsXG4gICAgICAgICfhuqonOiAnQScsXG4gICAgICAgIC8vICfEgyc6ICdhJywgLy8gZHVwbGljYXRlXG4gICAgICAgIC8vICfEgic6ICdBJywgLy8gZHVwbGljYXRlXG4gICAgICAgICfhuq8nOiAnYScsXG4gICAgICAgICfhuq4nOiAnQScsXG4gICAgICAgICfhurEnOiAnYScsXG4gICAgICAgICfhurAnOiAnQScsXG4gICAgICAgICfhurcnOiAnYScsXG4gICAgICAgICfhurYnOiAnQScsXG4gICAgICAgICfhurUnOiAnYScsXG4gICAgICAgICfhurQnOiAnQScsXG4gICAgICAgIFwi4pOqXCI6IFwiMFwiLFxuICAgICAgICBcIuKRoFwiOiBcIjFcIixcbiAgICAgICAgXCLikaFcIjogXCIyXCIsXG4gICAgICAgIFwi4pGiXCI6IFwiM1wiLFxuICAgICAgICBcIuKRo1wiOiBcIjRcIixcbiAgICAgICAgXCLikaRcIjogXCI1XCIsXG4gICAgICAgIFwi4pGlXCI6IFwiNlwiLFxuICAgICAgICBcIuKRplwiOiBcIjdcIixcbiAgICAgICAgXCLikadcIjogXCI4XCIsXG4gICAgICAgIFwi4pGoXCI6IFwiOVwiLFxuICAgICAgICBcIuKRqVwiOiBcIjEwXCIsXG4gICAgICAgIFwi4pGqXCI6IFwiMTFcIixcbiAgICAgICAgXCLikatcIjogXCIxMlwiLFxuICAgICAgICBcIuKRrFwiOiBcIjEzXCIsXG4gICAgICAgIFwi4pGtXCI6IFwiMTRcIixcbiAgICAgICAgXCLika5cIjogXCIxNVwiLFxuICAgICAgICBcIuKRr1wiOiBcIjE2XCIsXG4gICAgICAgIFwi4pGwXCI6IFwiMTdcIixcbiAgICAgICAgXCLikbFcIjogXCIxOFwiLFxuICAgICAgICBcIuKRslwiOiBcIjE4XCIsXG4gICAgICAgIFwi4pGzXCI6IFwiMThcIixcblxuICAgICAgICBcIuKTtVwiOiBcIjFcIixcbiAgICAgICAgXCLik7ZcIjogXCIyXCIsXG4gICAgICAgIFwi4pO3XCI6IFwiM1wiLFxuICAgICAgICBcIuKTuFwiOiBcIjRcIixcbiAgICAgICAgXCLik7lcIjogXCI1XCIsXG4gICAgICAgIFwi4pO6XCI6IFwiNlwiLFxuICAgICAgICBcIuKTu1wiOiBcIjdcIixcbiAgICAgICAgXCLik7xcIjogXCI4XCIsXG4gICAgICAgIFwi4pO9XCI6IFwiOVwiLFxuICAgICAgICBcIuKTvlwiOiBcIjEwXCIsXG5cbiAgICAgICAgXCLik79cIjogXCIwXCIsXG4gICAgICAgIFwi4pOrXCI6IFwiMTFcIixcbiAgICAgICAgXCLik6xcIjogXCIxMlwiLFxuICAgICAgICBcIuKTrVwiOiBcIjEzXCIsXG4gICAgICAgIFwi4pOuXCI6IFwiMTRcIixcbiAgICAgICAgXCLik69cIjogXCIxNVwiLFxuICAgICAgICBcIuKTsFwiOiBcIjE2XCIsXG4gICAgICAgIFwi4pOxXCI6IFwiMTdcIixcbiAgICAgICAgXCLik7JcIjogXCIxOFwiLFxuICAgICAgICBcIuKTs1wiOiBcIjE5XCIsXG4gICAgICAgIFwi4pO0XCI6IFwiMjBcIixcblxuICAgICAgICBcIuKStlwiOiBcIkFcIixcbiAgICAgICAgXCLikrdcIjogXCJCXCIsXG4gICAgICAgIFwi4pK4XCI6IFwiQ1wiLFxuICAgICAgICBcIuKSuVwiOiBcIkRcIixcbiAgICAgICAgXCLikrpcIjogXCJFXCIsXG4gICAgICAgIFwi4pK7XCI6IFwiRlwiLFxuICAgICAgICBcIuKSvFwiOiBcIkdcIixcbiAgICAgICAgXCLikr1cIjogXCJIXCIsXG4gICAgICAgIFwi4pK+XCI6IFwiSVwiLFxuICAgICAgICBcIuKSv1wiOiBcIkpcIixcbiAgICAgICAgXCLik4BcIjogXCJLXCIsXG4gICAgICAgIFwi4pOBXCI6IFwiTFwiLFxuICAgICAgICBcIuKTglwiOiBcIk1cIixcbiAgICAgICAgXCLik4NcIjogXCJOXCIsXG4gICAgICAgIFwi4pOEXCI6IFwiT1wiLFxuICAgICAgICBcIuKThVwiOiBcIlBcIixcbiAgICAgICAgXCLik4ZcIjogXCJRXCIsXG4gICAgICAgIFwi4pOHXCI6IFwiUlwiLFxuICAgICAgICBcIuKTiFwiOiBcIlNcIixcbiAgICAgICAgXCLik4lcIjogXCJUXCIsXG4gICAgICAgIFwi4pOKXCI6IFwiVVwiLFxuICAgICAgICBcIuKTi1wiOiBcIlZcIixcbiAgICAgICAgXCLik4xcIjogXCJXXCIsXG4gICAgICAgIFwi4pONXCI6IFwiWFwiLFxuICAgICAgICBcIuKTjlwiOiBcIllcIixcbiAgICAgICAgXCLik49cIjogXCJaXCIsXG5cbiAgICAgICAgXCLik5BcIjogXCJhXCIsXG4gICAgICAgIFwi4pORXCI6IFwiYlwiLFxuICAgICAgICBcIuKTklwiOiBcImNcIixcbiAgICAgICAgXCLik5NcIjogXCJkXCIsXG4gICAgICAgIFwi4pOUXCI6IFwiZVwiLFxuICAgICAgICBcIuKTlVwiOiBcImZcIixcbiAgICAgICAgXCLik5ZcIjogXCJnXCIsXG4gICAgICAgIFwi4pOXXCI6IFwiaFwiLFxuICAgICAgICBcIuKTmFwiOiBcImlcIixcbiAgICAgICAgXCLik5lcIjogXCJqXCIsXG4gICAgICAgIFwi4pOaXCI6IFwia1wiLFxuICAgICAgICBcIuKTm1wiOiBcImxcIixcbiAgICAgICAgXCLik5xcIjogXCJtXCIsXG4gICAgICAgIFwi4pOdXCI6IFwiblwiLFxuICAgICAgICBcIuKTnlwiOiBcIm9cIixcbiAgICAgICAgXCLik59cIjogXCJwXCIsXG4gICAgICAgIFwi4pOgXCI6IFwicVwiLFxuICAgICAgICBcIuKToVwiOiBcInJcIixcbiAgICAgICAgXCLik6JcIjogXCJzXCIsXG4gICAgICAgIFwi4pOjXCI6IFwidFwiLFxuICAgICAgICBcIuKTpFwiOiBcInVcIixcbiAgICAgICAgXCLik6ZcIjogXCJ2XCIsXG4gICAgICAgIFwi4pOlXCI6IFwid1wiLFxuICAgICAgICBcIuKTp1wiOiBcInhcIixcbiAgICAgICAgXCLik6hcIjogXCJ5XCIsXG4gICAgICAgIFwi4pOpXCI6IFwielwiLFxuXG4gICAgICAgIC8vIHN5bWJvbHNcbiAgICAgICAgJ+KAnCc6ICdcIicsXG4gICAgICAgICfigJ0nOiAnXCInLFxuICAgICAgICAn4oCYJzogXCInXCIsXG4gICAgICAgICfigJknOiBcIidcIixcbiAgICAgICAgJ+KIgic6ICdkJyxcbiAgICAgICAgJ8aSJzogJ2YnLFxuICAgICAgICAn4oSiJzogJyhUTSknLFxuICAgICAgICAnwqknOiAnKEMpJyxcbiAgICAgICAgJ8WTJzogJ29lJyxcbiAgICAgICAgJ8WSJzogJ09FJyxcbiAgICAgICAgJ8KuJzogJyhSKScsXG4gICAgICAgICfigKAnOiAnKycsXG4gICAgICAgICfihKAnOiAnKFNNKScsXG4gICAgICAgICfigKYnOiAnLi4uJyxcbiAgICAgICAgJ8uaJzogJ28nLFxuICAgICAgICAnwronOiAnbycsXG4gICAgICAgICfCqic6ICdhJyxcbiAgICAgICAgJ+KAoic6ICcqJyxcbiAgICAgICAgJ+GBiic6ICcsJyxcbiAgICAgICAgJ+GBiyc6ICcuJyxcblxuICAgICAgICAvLyBjdXJyZW5jeVxuICAgICAgICAnJCc6ICdVU0QnLFxuICAgICAgICAn4oKsJzogJ0VVUicsXG4gICAgICAgICfigqInOiAnQlJOJyxcbiAgICAgICAgJ+KCoyc6ICdGUkYnLFxuICAgICAgICAnwqMnOiAnR0JQJyxcbiAgICAgICAgJ+KCpCc6ICdJVEwnLFxuICAgICAgICAn4oKmJzogJ05HTicsXG4gICAgICAgICfigqcnOiAnRVNQJyxcbiAgICAgICAgJ+KCqSc6ICdLUlcnLFxuICAgICAgICAn4oKqJzogJ0lMUycsXG4gICAgICAgICfigqsnOiAnVk5EJyxcbiAgICAgICAgJ+KCrSc6ICdMQUsnLFxuICAgICAgICAn4oKuJzogJ01OVCcsXG4gICAgICAgICfigq8nOiAnR1JEJyxcbiAgICAgICAgJ+KCsSc6ICdBUlMnLFxuICAgICAgICAn4oKyJzogJ1BZRycsXG4gICAgICAgICfigrMnOiAnQVJBJyxcbiAgICAgICAgJ+KCtCc6ICdVQUgnLFxuICAgICAgICAn4oK1JzogJ0dIUycsXG4gICAgICAgICfCoic6ICdjZW50JyxcbiAgICAgICAgJ8KlJzogJ0NOWScsXG4gICAgICAgICflhYMnOiAnQ05ZJyxcbiAgICAgICAgJ+WGhic6ICdZRU4nLFxuICAgICAgICAn77e8JzogJ0lSUicsXG4gICAgICAgICfigqAnOiAnRVdFJyxcbiAgICAgICAgJ+C4vyc6ICdUSEInLFxuICAgICAgICAn4oKoJzogJ0lOUicsXG4gICAgICAgICfigrknOiAnSU5SJyxcbiAgICAgICAgJ+KCsCc6ICdQRicsXG4gICAgICAgICfigronOiAnVFJZJyxcbiAgICAgICAgJ9iLJzogJ0FGTicsXG4gICAgICAgICfigrwnOiAnQVpOJyxcbiAgICAgICAgJ9C70LInOiAnQkdOJyxcbiAgICAgICAgJ+Gfmyc6ICdLSFInLFxuICAgICAgICAn4oKhJzogJ0NSQycsXG4gICAgICAgICfigrgnOiAnS1pUJyxcbiAgICAgICAgJ9C00LXQvSc6ICdNS0QnLFxuICAgICAgICAnesWCJzogJ1BMTicsXG4gICAgICAgICfigr0nOiAnUlVCJyxcbiAgICAgICAgJ+KCvic6ICdHRUwnXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3BlY2lhbCBsb29rIGFoZWFkIGNoYXJhY3RlciBhcnJheVxuICAgICAqIFRoZXNlIGNoYXJhY3RlcnMgZm9ybSB3aXRoIGNvbnNvbmFudHMgdG8gYmVjb21lICdzaW5nbGUnL2NvbnNvbmFudCBjb21ib1xuICAgICAqIEB0eXBlIFtBcnJheV1cbiAgICAgKi9cbiAgICB2YXIgbG9va0FoZWFkQ2hhckFycmF5ID0gW1xuICAgICAgICAvLyBidXJtZXNlXG4gICAgICAgICfhgLonLFxuXG4gICAgICAgIC8vIERoaXZlaGlcbiAgICAgICAgJ96wJ1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBkaWF0cmljTWFwIGZvciBsYW5ndWFnZXMgd2hlcmUgdHJhbnNsaXRlcmF0aW9uIGNoYW5nZXMgZW50aXJlbHkgYXMgbW9yZSBkaWF0cmljcyBhcmUgYWRkZWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBkaWF0cmljTWFwID0ge1xuICAgICAgICAvLyBCdXJtZXNlXG4gICAgICAgIC8vIGRlcGVuZGVudCB2b3dlbHNcbiAgICAgICAgJ+GArCc6ICdhJyxcbiAgICAgICAgJ+GAqyc6ICdhJyxcbiAgICAgICAgJ+GAsSc6ICdlJyxcbiAgICAgICAgJ+GAsic6ICdlJyxcbiAgICAgICAgJ+GArSc6ICdpJyxcbiAgICAgICAgJ+GAric6ICdpJyxcbiAgICAgICAgJ+GAreGAryc6ICdvJyxcbiAgICAgICAgJ+GAryc6ICd1JyxcbiAgICAgICAgJ+GAsCc6ICd1JyxcbiAgICAgICAgJ+GAseGAq+GAhOGAuic6ICdhdW5nJyxcbiAgICAgICAgJ+GAseGArCc6ICdhdycsXG4gICAgICAgICfhgLHhgKzhgLonOiAnYXcnLFxuICAgICAgICAn4YCx4YCrJzogJ2F3JyxcbiAgICAgICAgJ+GAseGAq+GAuic6ICdhdycsXG4gICAgICAgICfhgLonOiAn4YC6JywgLy8gdGhpcyBpcyBzcGVjaWFsIGNhc2UgYnV0IHRoZSBjaGFyYWN0ZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gbGF0aW4gaW4gdGhlIGNvZGVcbiAgICAgICAgJ+GAgOGAuic6ICdldCcsXG4gICAgICAgICfhgK3hgK/hgIDhgLonOiAnYWlrJyxcbiAgICAgICAgJ+GAseGArOGAgOGAuic6ICdhdWsnLFxuICAgICAgICAn4YCE4YC6JzogJ2luJyxcbiAgICAgICAgJ+GAreGAr+GAhOGAuic6ICdhaW5nJyxcbiAgICAgICAgJ+GAseGArOGAhOGAuic6ICdhdW5nJyxcbiAgICAgICAgJ+GAheGAuic6ICdpdCcsXG4gICAgICAgICfhgIrhgLonOiAnaScsXG4gICAgICAgICfhgJDhgLonOiAnYXQnLFxuICAgICAgICAn4YCt4YCQ4YC6JzogJ2VpaycsXG4gICAgICAgICfhgK/hgJDhgLonOiAnb2snLFxuICAgICAgICAn4YC94YCQ4YC6JzogJ3V0JyxcbiAgICAgICAgJ+GAseGAkOGAuic6ICdpdCcsXG4gICAgICAgICfhgJLhgLonOiAnZCcsXG4gICAgICAgICfhgK3hgK/hgJLhgLonOiAnb2snLFxuICAgICAgICAn4YCv4YCS4YC6JzogJ2FpdCcsXG4gICAgICAgICfhgJThgLonOiAnYW4nLFxuICAgICAgICAn4YCs4YCU4YC6JzogJ2FuJyxcbiAgICAgICAgJ+GAreGAlOGAuic6ICdlaW4nLFxuICAgICAgICAn4YCv4YCU4YC6JzogJ29uJyxcbiAgICAgICAgJ+GAveGAlOGAuic6ICd1bicsXG4gICAgICAgICfhgJXhgLonOiAnYXQnLFxuICAgICAgICAn4YCt4YCV4YC6JzogJ2VpaycsXG4gICAgICAgICfhgK/hgJXhgLonOiAnb2snLFxuICAgICAgICAn4YC94YCV4YC6JzogJ3V0JyxcbiAgICAgICAgJ+GAlOGAuuGAr+GAleGAuic6ICdudWInLFxuICAgICAgICAn4YCZ4YC6JzogJ2FuJyxcbiAgICAgICAgJ+GAreGAmeGAuic6ICdlaW4nLFxuICAgICAgICAn4YCv4YCZ4YC6JzogJ29uJyxcbiAgICAgICAgJ+GAveGAmeGAuic6ICd1bicsXG4gICAgICAgICfhgJrhgLonOiAnZScsXG4gICAgICAgICfhgK3hgK/hgJzhgLonOiAnb2wnLFxuICAgICAgICAn4YCJ4YC6JzogJ2luJyxcbiAgICAgICAgJ+GAtic6ICdhbicsXG4gICAgICAgICfhgK3hgLYnOiAnZWluJyxcbiAgICAgICAgJ+GAr+GAtic6ICdvbicsXG5cbiAgICAgICAgLy8gRGhpdmVoaVxuICAgICAgICAn3qbeh96wJzogJ2FoJyxcbiAgICAgICAgJ96m3oHesCc6ICdhaCdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbGFuZ0NoYXJNYXAgbGFuZ3VhZ2Ugc3BlY2lmaWMgY2hhcmFjdGVycyB0cmFuc2xhdGlvbnNcbiAgICAgKiBAdHlwZSAgIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGxhbmdDaGFyTWFwID0ge1xuICAgICAgICAnZW4nOiB7fSwgLy8gZGVmYXVsdCBsYW5ndWFnZVxuXG4gICAgICAgICdheic6IHsgLy8gQXplcmJhaWphbmlcbiAgICAgICAgICAgICfDpyc6ICdjJyxcbiAgICAgICAgICAgICfJmSc6ICdlJyxcbiAgICAgICAgICAgICfEnyc6ICdnJyxcbiAgICAgICAgICAgICfEsSc6ICdpJyxcbiAgICAgICAgICAgICfDtic6ICdvJyxcbiAgICAgICAgICAgICfFnyc6ICdzJyxcbiAgICAgICAgICAgICfDvCc6ICd1JyxcbiAgICAgICAgICAgICfDhyc6ICdDJyxcbiAgICAgICAgICAgICfGjyc6ICdFJyxcbiAgICAgICAgICAgICfEnic6ICdHJyxcbiAgICAgICAgICAgICfEsCc6ICdJJyxcbiAgICAgICAgICAgICfDlic6ICdPJyxcbiAgICAgICAgICAgICfFnic6ICdTJyxcbiAgICAgICAgICAgICfDnCc6ICdVJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdjcyc6IHsgLy8gQ3plY2hcbiAgICAgICAgICAgICfEjSc6ICdjJyxcbiAgICAgICAgICAgICfEjyc6ICdkJyxcbiAgICAgICAgICAgICfEmyc6ICdlJyxcbiAgICAgICAgICAgICfFiCc6ICduJyxcbiAgICAgICAgICAgICfFmSc6ICdyJyxcbiAgICAgICAgICAgICfFoSc6ICdzJyxcbiAgICAgICAgICAgICfFpSc6ICd0JyxcbiAgICAgICAgICAgICfFryc6ICd1JyxcbiAgICAgICAgICAgICfFvic6ICd6JyxcbiAgICAgICAgICAgICfEjCc6ICdDJyxcbiAgICAgICAgICAgICfEjic6ICdEJyxcbiAgICAgICAgICAgICfEmic6ICdFJyxcbiAgICAgICAgICAgICfFhyc6ICdOJyxcbiAgICAgICAgICAgICfFmCc6ICdSJyxcbiAgICAgICAgICAgICfFoCc6ICdTJyxcbiAgICAgICAgICAgICfFpCc6ICdUJyxcbiAgICAgICAgICAgICfFric6ICdVJyxcbiAgICAgICAgICAgICfFvSc6ICdaJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdmaSc6IHsgLy8gRmlubmlzaFxuICAgICAgICAgICAgLy8gJ8OlJzogJ2EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgIC8vICfDhSc6ICdBJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgICAnw6QnOiAnYScsIC8vIG9rXG4gICAgICAgICAgICAnw4QnOiAnQScsIC8vIG9rXG4gICAgICAgICAgICAnw7YnOiAnbycsIC8vIG9rXG4gICAgICAgICAgICAnw5YnOiAnTycgLy8gb2tcbiAgICAgICAgfSxcblxuICAgICAgICAnaHUnOiB7IC8vIEh1bmdhcmlhblxuICAgICAgICAgICAgJ8OkJzogJ2EnLCAvLyBva1xuICAgICAgICAgICAgJ8OEJzogJ0EnLCAvLyBva1xuICAgICAgICAgICAgLy8gJ8OhJzogJ2EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgIC8vICfDgSc6ICdBJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgICAnw7YnOiAnbycsIC8vIG9rXG4gICAgICAgICAgICAnw5YnOiAnTycsIC8vIG9rXG4gICAgICAgICAgICAvLyAnxZEnOiAnbycsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgICAgLy8gJ8WQJzogJ08nLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgICfDvCc6ICd1JyxcbiAgICAgICAgICAgICfDnCc6ICdVJyxcbiAgICAgICAgICAgICfFsSc6ICd1JyxcbiAgICAgICAgICAgICfFsCc6ICdVJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdsdCc6IHsgLy8gTGl0aHVhbmlhblxuICAgICAgICAgICAgJ8SFJzogJ2EnLFxuICAgICAgICAgICAgJ8SNJzogJ2MnLFxuICAgICAgICAgICAgJ8SZJzogJ2UnLFxuICAgICAgICAgICAgJ8SXJzogJ2UnLFxuICAgICAgICAgICAgJ8SvJzogJ2knLFxuICAgICAgICAgICAgJ8WhJzogJ3MnLFxuICAgICAgICAgICAgJ8WzJzogJ3UnLFxuICAgICAgICAgICAgJ8WrJzogJ3UnLFxuICAgICAgICAgICAgJ8W+JzogJ3onLFxuICAgICAgICAgICAgJ8SEJzogJ0EnLFxuICAgICAgICAgICAgJ8SMJzogJ0MnLFxuICAgICAgICAgICAgJ8SYJzogJ0UnLFxuICAgICAgICAgICAgJ8SWJzogJ0UnLFxuICAgICAgICAgICAgJ8SuJzogJ0knLFxuICAgICAgICAgICAgJ8WgJzogJ1MnLFxuICAgICAgICAgICAgJ8WyJzogJ1UnLFxuICAgICAgICAgICAgJ8WqJzogJ1UnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2x2JzogeyAvLyBMYXR2aWFuXG4gICAgICAgICAgICAnxIEnOiAnYScsXG4gICAgICAgICAgICAnxI0nOiAnYycsXG4gICAgICAgICAgICAnxJMnOiAnZScsXG4gICAgICAgICAgICAnxKMnOiAnZycsXG4gICAgICAgICAgICAnxKsnOiAnaScsXG4gICAgICAgICAgICAnxLcnOiAnaycsXG4gICAgICAgICAgICAnxLwnOiAnbCcsXG4gICAgICAgICAgICAnxYYnOiAnbicsXG4gICAgICAgICAgICAnxaEnOiAncycsXG4gICAgICAgICAgICAnxasnOiAndScsXG4gICAgICAgICAgICAnxb4nOiAneicsXG4gICAgICAgICAgICAnxIAnOiAnQScsXG4gICAgICAgICAgICAnxIwnOiAnQycsXG4gICAgICAgICAgICAnxJInOiAnRScsXG4gICAgICAgICAgICAnxKInOiAnRycsXG4gICAgICAgICAgICAnxKonOiAnaScsXG4gICAgICAgICAgICAnxLYnOiAnaycsXG4gICAgICAgICAgICAnxLsnOiAnTCcsXG4gICAgICAgICAgICAnxYUnOiAnTicsXG4gICAgICAgICAgICAnxaAnOiAnUycsXG4gICAgICAgICAgICAnxaonOiAndScsXG4gICAgICAgICAgICAnxb0nOiAnWidcbiAgICAgICAgfSxcblxuICAgICAgICAncGwnOiB7IC8vIFBvbGlzaFxuICAgICAgICAgICAgJ8SFJzogJ2EnLFxuICAgICAgICAgICAgJ8SHJzogJ2MnLFxuICAgICAgICAgICAgJ8SZJzogJ2UnLFxuICAgICAgICAgICAgJ8WCJzogJ2wnLFxuICAgICAgICAgICAgJ8WEJzogJ24nLFxuICAgICAgICAgICAgJ8OzJzogJ28nLFxuICAgICAgICAgICAgJ8WbJzogJ3MnLFxuICAgICAgICAgICAgJ8W6JzogJ3onLFxuICAgICAgICAgICAgJ8W8JzogJ3onLFxuICAgICAgICAgICAgJ8SEJzogJ0EnLFxuICAgICAgICAgICAgJ8SGJzogJ0MnLFxuICAgICAgICAgICAgJ8SYJzogJ2UnLFxuICAgICAgICAgICAgJ8WBJzogJ0wnLFxuICAgICAgICAgICAgJ8WDJzogJ04nLFxuICAgICAgICAgICAgJ8OTJzogJ08nLFxuICAgICAgICAgICAgJ8WaJzogJ1MnLFxuICAgICAgICAgICAgJ8W5JzogJ1onLFxuICAgICAgICAgICAgJ8W7JzogJ1onXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3N2JzogeyAvLyBTd2VkaXNoXG4gICAgICAgICAgICAvLyAnw6UnOiAnYScsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgICAgLy8gJ8OFJzogJ0EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgICfDpCc6ICdhJywgLy8gb2tcbiAgICAgICAgICAgICfDhCc6ICdBJywgLy8gb2tcbiAgICAgICAgICAgICfDtic6ICdvJywgLy8gb2tcbiAgICAgICAgICAgICfDlic6ICdPJyAvLyBva1xuICAgICAgICB9LFxuXG4gICAgICAgICdzayc6IHsgLy8gU2xvdmFrXG4gICAgICAgICAgICAnw6QnOiAnYScsXG4gICAgICAgICAgICAnw4QnOiAnQSdcbiAgICAgICAgfSxcblxuICAgICAgICAnc3InOiB7IC8vIFNlcmJpYW5cbiAgICAgICAgICAgICfRmSc6ICdsaicsXG4gICAgICAgICAgICAn0ZonOiAnbmonLFxuICAgICAgICAgICAgJ9CJJzogJ0xqJyxcbiAgICAgICAgICAgICfQiic6ICdOaicsXG4gICAgICAgICAgICAnxJEnOiAnZGonLFxuICAgICAgICAgICAgJ8SQJzogJ0RqJ1xuICAgICAgICB9LFxuXG4gICAgICAgICd0cic6IHsgLy8gVHVya2lzaFxuICAgICAgICAgICAgJ8OcJzogJ1UnLFxuICAgICAgICAgICAgJ8OWJzogJ08nLFxuICAgICAgICAgICAgJ8O8JzogJ3UnLFxuICAgICAgICAgICAgJ8O2JzogJ28nXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3ltYm9sTWFwIGxhbmd1YWdlIHNwZWNpZmljIHN5bWJvbCB0cmFuc2xhdGlvbnNcbiAgICAgKiB0cmFuc2xhdGlvbnMgbXVzdCBiZSB0cmFuc2xpdGVyYXRlZCBhbHJlYWR5XG4gICAgICogQHR5cGUgICB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBzeW1ib2xNYXAgPSB7XG4gICAgICAgICdhcic6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdsYS1uaWhheWEnLFxuICAgICAgICAgICAgJ+KZpSc6ICdob2InLFxuICAgICAgICAgICAgJyYnOiAnd2EnLFxuICAgICAgICAgICAgJ3wnOiAnYXcnLFxuICAgICAgICAgICAgJzwnOiAnYXFhbC1tZW4nLFxuICAgICAgICAgICAgJz4nOiAnYWtiYXItbWVuJyxcbiAgICAgICAgICAgICfiiJEnOiAnbWFqbW91JyxcbiAgICAgICAgICAgICfCpCc6ICdvbWxhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdheic6IHt9LFxuXG4gICAgICAgICdjYSc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdpbmZpbml0JyxcbiAgICAgICAgICAgICfimaUnOiAnYW1vcicsXG4gICAgICAgICAgICAnJic6ICdpJyxcbiAgICAgICAgICAgICd8JzogJ28nLFxuICAgICAgICAgICAgJzwnOiAnbWVueXMgcXVlJyxcbiAgICAgICAgICAgICc+JzogJ21lcyBxdWUnLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW1hIGRlbHMnLFxuICAgICAgICAgICAgJ8KkJzogJ21vbmVkYSdcbiAgICAgICAgfSxcblxuICAgICAgICAnY3MnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnbmVrb25lY25vJyxcbiAgICAgICAgICAgICfimaUnOiAnbGFza2EnLFxuICAgICAgICAgICAgJyYnOiAnYScsXG4gICAgICAgICAgICAnfCc6ICduZWJvJyxcbiAgICAgICAgICAgICc8JzogJ21lbnNpIG5leicsXG4gICAgICAgICAgICAnPic6ICd2ZXRzaSBuZXonLFxuICAgICAgICAgICAgJ+KIkSc6ICdzb3VjZXQnLFxuICAgICAgICAgICAgJ8KkJzogJ21lbmEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2RlJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ3VuZW5kbGljaCcsXG4gICAgICAgICAgICAn4pmlJzogJ0xpZWJlJyxcbiAgICAgICAgICAgICcmJzogJ3VuZCcsXG4gICAgICAgICAgICAnfCc6ICdvZGVyJyxcbiAgICAgICAgICAgICc8JzogJ2tsZWluZXIgYWxzJyxcbiAgICAgICAgICAgICc+JzogJ2dyb2Vzc2VyIGFscycsXG4gICAgICAgICAgICAn4oiRJzogJ1N1bW1lIHZvbicsXG4gICAgICAgICAgICAnwqQnOiAnV2FlaHJ1bmcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2R2Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2tvbHVudWxhYScsXG4gICAgICAgICAgICAn4pmlJzogJ2xvYWJpJyxcbiAgICAgICAgICAgICcmJzogJ2FhaScsXG4gICAgICAgICAgICAnfCc6ICdub29uZWUnLFxuICAgICAgICAgICAgJzwnOiAnYWggdnVyZSBrdWRhJyxcbiAgICAgICAgICAgICc+JzogJ2FoIHZ1cmUgYm9kdScsXG4gICAgICAgICAgICAn4oiRJzogJ2p1bXVsYScsXG4gICAgICAgICAgICAnwqQnOiAnZmFpc2FhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdlbic6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdpbmZpbml0eScsXG4gICAgICAgICAgICAn4pmlJzogJ2xvdmUnLFxuICAgICAgICAgICAgJyYnOiAnYW5kJyxcbiAgICAgICAgICAgICd8JzogJ29yJyxcbiAgICAgICAgICAgICc8JzogJ2xlc3MgdGhhbicsXG4gICAgICAgICAgICAnPic6ICdncmVhdGVyIHRoYW4nLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW0nLFxuICAgICAgICAgICAgJ8KkJzogJ2N1cnJlbmN5J1xuICAgICAgICB9LFxuXG4gICAgICAgICdlcyc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdpbmZpbml0bycsXG4gICAgICAgICAgICAn4pmlJzogJ2Ftb3InLFxuICAgICAgICAgICAgJyYnOiAneScsXG4gICAgICAgICAgICAnfCc6ICd1JyxcbiAgICAgICAgICAgICc8JzogJ21lbm9zIHF1ZScsXG4gICAgICAgICAgICAnPic6ICdtYXMgcXVlJyxcbiAgICAgICAgICAgICfiiJEnOiAnc3VtYSBkZSBsb3MnLFxuICAgICAgICAgICAgJ8KkJzogJ21vbmVkYSdcbiAgICAgICAgfSxcblxuICAgICAgICAnZmEnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnYmktbmFoYXlhdCcsXG4gICAgICAgICAgICAn4pmlJzogJ2VzaGdoJyxcbiAgICAgICAgICAgICcmJzogJ3ZhJyxcbiAgICAgICAgICAgICd8JzogJ3lhJyxcbiAgICAgICAgICAgICc8JzogJ2thbXRhci1heicsXG4gICAgICAgICAgICAnPic6ICdiaXNodGFyLWF6JyxcbiAgICAgICAgICAgICfiiJEnOiAnbWFqbW9vZScsXG4gICAgICAgICAgICAnwqQnOiAndmFoZWQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2ZpJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2FhcmV0dG9teXlzJyxcbiAgICAgICAgICAgICfimaUnOiAncmFra2F1cycsXG4gICAgICAgICAgICAnJic6ICdqYScsXG4gICAgICAgICAgICAnfCc6ICd0YWknLFxuICAgICAgICAgICAgJzwnOiAncGllbmVtcGkga3VpbicsXG4gICAgICAgICAgICAnPic6ICdzdXVyZW1waSBrdWluJyxcbiAgICAgICAgICAgICfiiJEnOiAnc3VtbWEnLFxuICAgICAgICAgICAgJ8KkJzogJ3ZhbHV1dHRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdmcic6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdpbmZpbmltZW50JyxcbiAgICAgICAgICAgICfimaUnOiAnQW1vdXInLFxuICAgICAgICAgICAgJyYnOiAnZXQnLFxuICAgICAgICAgICAgJ3wnOiAnb3UnLFxuICAgICAgICAgICAgJzwnOiAnbW9pbnMgcXVlJyxcbiAgICAgICAgICAgICc+JzogJ3N1cGVyaWV1cmUgYScsXG4gICAgICAgICAgICAn4oiRJzogJ3NvbW1lIGRlcycsXG4gICAgICAgICAgICAnwqQnOiAnbW9ubmFpZSdcbiAgICAgICAgfSxcblxuICAgICAgICAnZ2UnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAndXNhc3J1bG9iYScsXG4gICAgICAgICAgICAn4pmlJzogJ3NpcXZhcnVsaScsXG4gICAgICAgICAgICAnJic6ICdkYScsXG4gICAgICAgICAgICAnfCc6ICdhbicsXG4gICAgICAgICAgICAnPCc6ICduYWtsZWJpJyxcbiAgICAgICAgICAgICc+JzogJ21ldGknLFxuICAgICAgICAgICAgJ+KIkSc6ICdqYW1pJyxcbiAgICAgICAgICAgICfCpCc6ICd2YWx1dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2dyJzoge30sXG5cbiAgICAgICAgJ2h1Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ3ZlZ3RlbGVuJyxcbiAgICAgICAgICAgICfimaUnOiAnc3plcmVsZW0nLFxuICAgICAgICAgICAgJyYnOiAnZXMnLFxuICAgICAgICAgICAgJ3wnOiAndmFneScsXG4gICAgICAgICAgICAnPCc6ICdraXNlYmIgbWludCcsXG4gICAgICAgICAgICAnPic6ICduYWd5b2JiIG1pbnQnLFxuICAgICAgICAgICAgJ+KIkSc6ICdzenVtbWEnLFxuICAgICAgICAgICAgJ8KkJzogJ3BlbnpuZW0nXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2l0Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2luZmluaXRvJyxcbiAgICAgICAgICAgICfimaUnOiAnYW1vcmUnLFxuICAgICAgICAgICAgJyYnOiAnZScsXG4gICAgICAgICAgICAnfCc6ICdvJyxcbiAgICAgICAgICAgICc8JzogJ21pbm9yZSBkaScsXG4gICAgICAgICAgICAnPic6ICdtYWdnaW9yZSBkaScsXG4gICAgICAgICAgICAn4oiRJzogJ3NvbW1hJyxcbiAgICAgICAgICAgICfCpCc6ICdtb25ldGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2x0Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2JlZ2FseWJlJyxcbiAgICAgICAgICAgICfimaUnOiAnbWVpbGUnLFxuICAgICAgICAgICAgJyYnOiAnaXInLFxuICAgICAgICAgICAgJ3wnOiAnYXInLFxuICAgICAgICAgICAgJzwnOiAnbWF6aWF1IG5laScsXG4gICAgICAgICAgICAnPic6ICdkYXVnaWF1IG5laScsXG4gICAgICAgICAgICAn4oiRJzogJ3N1bWEnLFxuICAgICAgICAgICAgJ8KkJzogJ3ZhbGl1dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2x2Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2JlemdhbGliYScsXG4gICAgICAgICAgICAn4pmlJzogJ21pbGVzdGliYScsXG4gICAgICAgICAgICAnJic6ICd1bicsXG4gICAgICAgICAgICAnfCc6ICd2YWknLFxuICAgICAgICAgICAgJzwnOiAnbWF6YWsgbmVrYScsXG4gICAgICAgICAgICAnPic6ICdsaWVsYWtzIG5la2EnLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW1tYScsXG4gICAgICAgICAgICAnwqQnOiAndmFsdXRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdteSc6IHtcbiAgICAgICAgICAgICfiiIYnOiAna3dhaGtoeWFldCcsXG4gICAgICAgICAgICAn4oieJzogJ2FzYW9uYXNtZScsXG4gICAgICAgICAgICAn4pmlJzogJ2FraHlhaXQnLFxuICAgICAgICAgICAgJyYnOiAnbmhpbicsXG4gICAgICAgICAgICAnfCc6ICd0aG8nLFxuICAgICAgICAgICAgJzwnOiAnbmdldGhhdycsXG4gICAgICAgICAgICAnPic6ICdreWl0aGF3JyxcbiAgICAgICAgICAgICfiiJEnOiAncGF1bmdsZCcsXG4gICAgICAgICAgICAnwqQnOiAnbmd3ZWt5ZSdcbiAgICAgICAgfSxcblxuICAgICAgICAnbWsnOiB7fSxcblxuICAgICAgICAnbmwnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnb25laW5kaWcnLFxuICAgICAgICAgICAgJ+KZpSc6ICdsaWVmZGUnLFxuICAgICAgICAgICAgJyYnOiAnZW4nLFxuICAgICAgICAgICAgJ3wnOiAnb2YnLFxuICAgICAgICAgICAgJzwnOiAna2xlaW5lciBkYW4nLFxuICAgICAgICAgICAgJz4nOiAnZ3JvdGVyIGRhbicsXG4gICAgICAgICAgICAn4oiRJzogJ3NvbScsXG4gICAgICAgICAgICAnwqQnOiAndmFsdXRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdwbCc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICduaWVza29uY3pvbm9zYycsXG4gICAgICAgICAgICAn4pmlJzogJ21pbG9zYycsXG4gICAgICAgICAgICAnJic6ICdpJyxcbiAgICAgICAgICAgICd8JzogJ2x1YicsXG4gICAgICAgICAgICAnPCc6ICdtbmllanN6ZSBuaXonLFxuICAgICAgICAgICAgJz4nOiAnd2lla3N6ZSBuaXonLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW1hJyxcbiAgICAgICAgICAgICfCpCc6ICd3YWx1dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3B0Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2luZmluaXRvJyxcbiAgICAgICAgICAgICfimaUnOiAnYW1vcicsXG4gICAgICAgICAgICAnJic6ICdlJyxcbiAgICAgICAgICAgICd8JzogJ291JyxcbiAgICAgICAgICAgICc8JzogJ21lbm9yIHF1ZScsXG4gICAgICAgICAgICAnPic6ICdtYWlvciBxdWUnLFxuICAgICAgICAgICAgJ+KIkSc6ICdzb21hJyxcbiAgICAgICAgICAgICfCpCc6ICdtb2VkYSdcbiAgICAgICAgfSxcblxuICAgICAgICAncm8nOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnaW5maW5pdCcsXG4gICAgICAgICAgICAn4pmlJzogJ2RyYWdvc3RlJyxcbiAgICAgICAgICAgICcmJzogJ3NpJyxcbiAgICAgICAgICAgICd8JzogJ3NhdScsXG4gICAgICAgICAgICAnPCc6ICdtYWkgbWljIGNhJyxcbiAgICAgICAgICAgICc+JzogJ21haSBtYXJlIGNhJyxcbiAgICAgICAgICAgICfiiJEnOiAnc3VtYScsXG4gICAgICAgICAgICAnwqQnOiAndmFsdXRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdydSc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdiZXNrb25lY2hubycsXG4gICAgICAgICAgICAn4pmlJzogJ2x1Ym92JyxcbiAgICAgICAgICAgICcmJzogJ2knLFxuICAgICAgICAgICAgJ3wnOiAnaWxpJyxcbiAgICAgICAgICAgICc8JzogJ21lbnNoZScsXG4gICAgICAgICAgICAnPic6ICdib2xzaGUnLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW1tYScsXG4gICAgICAgICAgICAnwqQnOiAndmFsanV0YSdcbiAgICAgICAgfSxcblxuICAgICAgICAnc2snOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnbmVrb25lY25vJyxcbiAgICAgICAgICAgICfimaUnOiAnbGFza2EnLFxuICAgICAgICAgICAgJyYnOiAnYScsXG4gICAgICAgICAgICAnfCc6ICdhbGVibycsXG4gICAgICAgICAgICAnPCc6ICdtZW5laiBha28nLFxuICAgICAgICAgICAgJz4nOiAndmlhYyBha28nLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdWNldCcsXG4gICAgICAgICAgICAnwqQnOiAnbWVuYSdcbiAgICAgICAgfSxcblxuICAgICAgICAnc3InOiB7fSxcblxuICAgICAgICAndHInOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnc29uc3V6bHVrJyxcbiAgICAgICAgICAgICfimaUnOiAnYXNrJyxcbiAgICAgICAgICAgICcmJzogJ3ZlJyxcbiAgICAgICAgICAgICd8JzogJ3ZleWEnLFxuICAgICAgICAgICAgJzwnOiAna3VjdWt0dXInLFxuICAgICAgICAgICAgJz4nOiAnYnV5dWt0dXInLFxuICAgICAgICAgICAgJ+KIkSc6ICd0b3BsYW0nLFxuICAgICAgICAgICAgJ8KkJzogJ3BhcmEgYmlyaW1pJ1xuICAgICAgICB9LFxuXG4gICAgICAgICd1ayc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdiZXpraW5lY2huaXN0JyxcbiAgICAgICAgICAgICfimaUnOiAnbHVib3YnLFxuICAgICAgICAgICAgJyYnOiAnaScsXG4gICAgICAgICAgICAnfCc6ICdhYm8nLFxuICAgICAgICAgICAgJzwnOiAnbWVuc2hlJyxcbiAgICAgICAgICAgICc+JzogJ2JpbHNoZScsXG4gICAgICAgICAgICAn4oiRJzogJ3N1bWEnLFxuICAgICAgICAgICAgJ8KkJzogJ3ZhbGp1dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3ZuJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ3ZvIGN1YycsXG4gICAgICAgICAgICAn4pmlJzogJ3lldScsXG4gICAgICAgICAgICAnJic6ICd2YScsXG4gICAgICAgICAgICAnfCc6ICdob2FjJyxcbiAgICAgICAgICAgICc8JzogJ25obyBob24nLFxuICAgICAgICAgICAgJz4nOiAnbG9uIGhvbicsXG4gICAgICAgICAgICAn4oiRJzogJ3RvbmcnLFxuICAgICAgICAgICAgJ8KkJzogJ3RpZW4gdGUnXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVyaWNDaGFycyA9IFsnOycsICc/JywgJzonLCAnQCcsICcmJywgJz0nLCAnKycsICckJywgJywnLCAnLyddLmpvaW4oJycpO1xuXG4gICAgdmFyIHVyaWNOb1NsYXNoQ2hhcnMgPSBbJzsnLCAnPycsICc6JywgJ0AnLCAnJicsICc9JywgJysnLCAnJCcsICcsJ10uam9pbignJyk7XG5cbiAgICB2YXIgbWFya0NoYXJzID0gWycuJywgJyEnLCAnficsICcqJywgXCInXCIsICcoJywgJyknXS5qb2luKCcnKTtcblxuICAgIC8qKlxuICAgICAqIGdldFNsdWdcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlucHV0IGlucHV0IHN0cmluZ1xuICAgICAqIEBwYXJhbSAge29iamVjdHxzdHJpbmd9IG9wdHMgY29uZmlnIG9iamVjdCBvciBzZXBhcmF0b3Igc3RyaW5nL2NoYXJcbiAgICAgKiBAYXBpICAgIHB1YmxpY1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIHNsdWdnaWZpZWQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGdldFNsdWcgPSBmdW5jdGlvbiBnZXRTbHVnKGlucHV0LCBvcHRzKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLSc7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGRpYXRyaWNTdHJpbmcgPSAnJztcbiAgICAgICAgdmFyIGNvbnZlcnRTeW1ib2xzID0gdHJ1ZTtcbiAgICAgICAgdmFyIGN1c3RvbVJlcGxhY2VtZW50cyA9IHt9O1xuICAgICAgICB2YXIgbWFpbnRhaW5DYXNlO1xuICAgICAgICB2YXIgdGl0bGVDYXNlO1xuICAgICAgICB2YXIgdHJ1bmNhdGU7XG4gICAgICAgIHZhciB1cmljRmxhZztcbiAgICAgICAgdmFyIHVyaWNOb1NsYXNoRmxhZztcbiAgICAgICAgdmFyIG1hcmtGbGFnO1xuICAgICAgICB2YXIgc3ltYm9sO1xuICAgICAgICB2YXIgbGFuZ0NoYXI7XG4gICAgICAgIHZhciBsdWNreTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBjaDtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIHZhciBsYXN0Q2hhcldhc1N5bWJvbDtcbiAgICAgICAgdmFyIGxhc3RDaGFyV2FzRGlhdHJpYztcbiAgICAgICAgdmFyIGFsbG93ZWRDaGFycyA9ICcnO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBvcHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ltYm9sID0gc3ltYm9sTWFwLmVuO1xuICAgICAgICBsYW5nQ2hhciA9IGxhbmdDaGFyTWFwLmVuO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG1haW50YWluQ2FzZSA9IG9wdHMubWFpbnRhaW5DYXNlIHx8IGZhbHNlO1xuICAgICAgICAgICAgY3VzdG9tUmVwbGFjZW1lbnRzID0gKG9wdHMuY3VzdG9tICYmIHR5cGVvZiBvcHRzLmN1c3RvbSA9PT0gJ29iamVjdCcpID8gb3B0cy5jdXN0b20gOiBjdXN0b21SZXBsYWNlbWVudHM7XG4gICAgICAgICAgICB0cnVuY2F0ZSA9ICgrb3B0cy50cnVuY2F0ZSA+IDEgJiYgb3B0cy50cnVuY2F0ZSkgfHwgZmFsc2U7XG4gICAgICAgICAgICB1cmljRmxhZyA9IG9wdHMudXJpYyB8fCBmYWxzZTtcbiAgICAgICAgICAgIHVyaWNOb1NsYXNoRmxhZyA9IG9wdHMudXJpY05vU2xhc2ggfHwgZmFsc2U7XG4gICAgICAgICAgICBtYXJrRmxhZyA9IG9wdHMubWFyayB8fCBmYWxzZTtcbiAgICAgICAgICAgIGNvbnZlcnRTeW1ib2xzID0gKG9wdHMuc3ltYm9scyA9PT0gZmFsc2UgfHwgb3B0cy5sYW5nID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBvcHRzLnNlcGFyYXRvciB8fCBzZXBhcmF0b3I7XG5cbiAgICAgICAgICAgIGlmICh1cmljRmxhZykge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRDaGFycyArPSB1cmljQ2hhcnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1cmljTm9TbGFzaEZsYWcpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hhcnMgKz0gdXJpY05vU2xhc2hDaGFycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hcmtGbGFnKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZENoYXJzICs9IG1hcmtDaGFycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ltYm9sID0gKG9wdHMubGFuZyAmJiBzeW1ib2xNYXBbb3B0cy5sYW5nXSAmJiBjb252ZXJ0U3ltYm9scykgP1xuICAgICAgICAgICAgICAgIHN5bWJvbE1hcFtvcHRzLmxhbmddIDogKGNvbnZlcnRTeW1ib2xzID8gc3ltYm9sTWFwLmVuIDoge30pO1xuXG4gICAgICAgICAgICBsYW5nQ2hhciA9IChvcHRzLmxhbmcgJiYgbGFuZ0NoYXJNYXBbb3B0cy5sYW5nXSkgP1xuICAgICAgICAgICAgICAgIGxhbmdDaGFyTWFwW29wdHMubGFuZ10gOlxuICAgICAgICAgICAgICAgIG9wdHMubGFuZyA9PT0gZmFsc2UgfHwgb3B0cy5sYW5nID09PSB0cnVlID8ge30gOiBsYW5nQ2hhck1hcC5lbjtcblxuICAgICAgICAgICAgLy8gaWYgdGl0bGVDYXNlIGNvbmZpZyBpcyBhbiBBcnJheSwgcmV3cml0ZSB0byBvYmplY3QgZm9ybWF0XG4gICAgICAgICAgICBpZiAob3B0cy50aXRsZUNhc2UgJiYgdHlwZW9mIG9wdHMudGl0bGVDYXNlLmxlbmd0aCA9PT0gJ251bWJlcicgJiYgQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0cy50aXRsZUNhc2UpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy50aXRsZUNhc2UuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXBsYWNlbWVudHNbdiArICcnXSA9IHYgKyAnJztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRpdGxlQ2FzZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlQ2FzZSA9ICEhb3B0cy50aXRsZUNhc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGN1c3RvbSBjb25maWcgaXMgYW4gQXJyYXksIHJld3JpdGUgdG8gb2JqZWN0IGZvcm1hdFxuICAgICAgICAgICAgaWYgKG9wdHMuY3VzdG9tICYmIHR5cGVvZiBvcHRzLmN1c3RvbS5sZW5ndGggPT09ICdudW1iZXInICYmIEFycmF5LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdHMuY3VzdG9tKSkge1xuICAgICAgICAgICAgICAgIG9wdHMuY3VzdG9tLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tUmVwbGFjZW1lbnRzW3YgKyAnJ10gPSB2ICsgJyc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGN1c3RvbSByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGN1c3RvbVJlcGxhY2VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHZhciByO1xuXG4gICAgICAgICAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgZXNjYXBlQ2hhcnModikgKyAnXFxcXGInLCAnZ2knKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByID0gbmV3IFJlZ0V4cChlc2NhcGVDaGFycyh2KSwgJ2dpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKHIsIGN1c3RvbVJlcGxhY2VtZW50c1t2XSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYWRkIGFsbCBjdXN0b20gcmVwbGFjZW1lbnQgdG8gYWxsb3dlZCBjaGFybGlzdFxuICAgICAgICAgICAgZm9yIChjaCBpbiBjdXN0b21SZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hhcnMgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhbGxvd2VkQ2hhcnMgKz0gc2VwYXJhdG9yO1xuXG4gICAgICAgIC8vIGVzY2FwZSBhbGwgbmVjZXNzYXJ5IGNoYXJzXG4gICAgICAgIGFsbG93ZWRDaGFycyA9IGVzY2FwZUNoYXJzKGFsbG93ZWRDaGFycyk7XG5cbiAgICAgICAgLy8gdHJpbSB3aGl0ZXNwYWNlc1xuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLyheXFxzK3xcXHMrJCkvZywgJycpO1xuXG4gICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgIGxhc3RDaGFyV2FzRGlhdHJpYyA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpbnB1dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gaW5wdXRbaV07XG5cbiAgICAgICAgICAgIGlmIChpc1JlcGxhY2VkQ3VzdG9tQ2hhcihjaCwgY3VzdG9tUmVwbGFjZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNvbnZlcnQgYSBhbHJlYWR5IGNvbnZlcnRlZCBjaGFyXG4gICAgICAgICAgICAgICAgbGFzdENoYXJXYXNTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFuZ0NoYXJbY2hdKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBsYW5ndWFnZSBzcGVjaWZpYyBkaWFjdHJpY3MgY2hhcnMgY29udmVyc2lvblxuICAgICAgICAgICAgICAgIGNoID0gbGFzdENoYXJXYXNTeW1ib2wgJiYgbGFuZ0NoYXJbY2hdLm1hdGNoKC9bQS1aYS16MC05XS8pID8gJyAnICsgbGFuZ0NoYXJbY2hdIDogbGFuZ0NoYXJbY2hdO1xuXG4gICAgICAgICAgICAgICAgbGFzdENoYXJXYXNTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggaW4gY2hhck1hcCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSB0cmFuc2xpdGVyYXRpb24gY2hhbmdlcyBlbnRpcmVseSB3aGVuIHNvbWUgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBhZGRlZFxuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGwgJiYgbG9va0FoZWFkQ2hhckFycmF5LmluZGV4T2YoaW5wdXRbaSArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYXRyaWNTdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q2hhcldhc0RpYXRyaWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddICsgY2hhck1hcFtjaF07XG4gICAgICAgICAgICAgICAgICAgIGRpYXRyaWNTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGRpYWN0cmljcyBjaGFyc1xuICAgICAgICAgICAgICAgICAgICBjaCA9IGxhc3RDaGFyV2FzU3ltYm9sICYmIGNoYXJNYXBbY2hdLm1hdGNoKC9bQS1aYS16MC05XS8pID8gJyAnICsgY2hhck1hcFtjaF0gOiBjaGFyTWFwW2NoXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc1N5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxhc3RDaGFyV2FzRGlhdHJpYyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCBpbiBkaWF0cmljTWFwKSB7XG4gICAgICAgICAgICAgICAgZGlhdHJpY1N0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBjaCA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBzdHJpbmcsIHB1dCB0aGUgd2hvbGUgbWVhbmluZ2Z1bCB3b3JkXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gZGlhdHJpY01hcFtkaWF0cmljU3RyaW5nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdENoYXJXYXNEaWF0cmljID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBzeW1ib2wgY2hhcnNcbiAgICAgICAgICAgICAgICBzeW1ib2xbY2hdICYmICEodXJpY0ZsYWcgJiYgdXJpY0NoYXJzXG4gICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKGNoKSAhPT0gLTEpICYmICEodXJpY05vU2xhc2hGbGFnICYmIHVyaWNOb1NsYXNoQ2hhcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gLmluZGV4T2YoY2gpICE9PSAtMSkgJiYgIShtYXJrRmxhZyAmJiBtYXJrQ2hhcnNcbiAgICAgICAgICAgICAgICAgICAgLmluZGV4T2YoY2gpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBjaCA9IGxhc3RDaGFyV2FzU3ltYm9sIHx8IHJlc3VsdC5zdWJzdHIoLTEpLm1hdGNoKC9bQS1aYS16MC05XS8pID8gc2VwYXJhdG9yICsgc3ltYm9sW2NoXSA6IHN5bWJvbFtjaF07XG4gICAgICAgICAgICAgICAgY2ggKz0gaW5wdXRbaSArIDFdICE9PSB2b2lkIDAgJiYgaW5wdXRbaSArIDFdLm1hdGNoKC9bQS1aYS16MC05XS8pID8gc2VwYXJhdG9yIDogJyc7XG5cbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hhcldhc0RpYXRyaWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddICsgY2g7XG4gICAgICAgICAgICAgICAgICAgIGRpYXRyaWNTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJXYXNEaWF0cmljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q2hhcldhc1N5bWJvbCAmJiAoL1tBLVphLXowLTldLy50ZXN0KGNoKSB8fCByZXN1bHQuc3Vic3RyKC0xKS5tYXRjaCgvQS1aYS16MC05XS8pKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGxhdGluIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgIGNoID0gJyAnICsgY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBhbGxvd2VkIGNoYXJzXG4gICAgICAgICAgICByZXN1bHQgKz0gY2gucmVwbGFjZShuZXcgUmVnRXhwKCdbXlxcXFx3XFxcXHMnICsgYWxsb3dlZENoYXJzICsgJ18tXScsICdnJyksIHNlcGFyYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGl0bGVDYXNlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvKFxcdykoXFxTKikvZywgZnVuY3Rpb24gKF8sIGksIHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IGkudG9VcHBlckNhc2UoKSArIChyICE9PSBudWxsID8gciA6ICcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5rZXlzKGN1c3RvbVJlcGxhY2VtZW50cykuaW5kZXhPZihqLnRvTG93ZXJDYXNlKCkpIDwgMCkgPyBqIDogai50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbGltaW5hdGUgZHVwbGljYXRlIHNlcGFyYXRvcnNcbiAgICAgICAgLy8gYWRkIHNlcGFyYXRvclxuICAgICAgICAvLyB0cmltIHNlcGFyYXRvcnMgZnJvbSBzdGFydCBhbmQgZW5kXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXHMrL2csIHNlcGFyYXRvcilcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwnICsgc2VwYXJhdG9yICsgJysnLCAnZycpLCBzZXBhcmF0b3IpXG4gICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKCcoXlxcXFwnICsgc2VwYXJhdG9yICsgJyt8XFxcXCcgKyBzZXBhcmF0b3IgKyAnKyQpJywgJ2cnKSwgJycpO1xuXG4gICAgICAgIGlmICh0cnVuY2F0ZSAmJiByZXN1bHQubGVuZ3RoID4gdHJ1bmNhdGUpIHtcbiAgICAgICAgICAgIGx1Y2t5ID0gcmVzdWx0LmNoYXJBdCh0cnVuY2F0ZSkgPT09IHNlcGFyYXRvcjtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCB0cnVuY2F0ZSk7XG5cbiAgICAgICAgICAgIGlmICghbHVja3kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYWludGFpbkNhc2UgJiYgIXRpdGxlQ2FzZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVTbHVnIGN1cnJpZWQob3B0cykoaW5wdXQpXG4gICAgICogQHBhcmFtICAge29iamVjdHxzdHJpbmd9IG9wdHMgY29uZmlnIG9iamVjdCBvciBpbnB1dCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuICB7RnVuY3Rpb259IGZ1bmN0aW9uIGdldFNsdWdXaXRoQ29uZmlnKClcbiAgICAgKiovXG4gICAgdmFyIGNyZWF0ZVNsdWcgPSBmdW5jdGlvbiBjcmVhdGVTbHVnKG9wdHMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0U2x1Z1dpdGhDb25maWdcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gaW5wdXQgc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9IHNsdWcgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0U2x1Z1dpdGhDb25maWcoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTbHVnKGlucHV0LCBvcHRzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZXNjYXBlIENoYXJzXG4gICAgICogQHBhcmFtICAge3N0cmluZ30gaW5wdXQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGVzY2FwZUNoYXJzID0gZnVuY3Rpb24gZXNjYXBlQ2hhcnMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1stXFxcXF4kKis/LigpfFtcXF17fVxcL10vZywgJ1xcXFwkJicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGUgY2hhciBpcyBhbiBhbHJlYWR5IGNvbnZlcnRlZCBjaGFyIGZyb20gY3VzdG9tIGxpc3RcbiAgICAgKiBAcGFyYW0gICB7Y2hhcn0gY2ggY2hhcmFjdGVyIHRvIGNoZWNrXG4gICAgICogQHBhcmFtICAge29iamVjdH0gY3VzdG9tUmVwbGFjZW1lbnRzIGN1c3RvbSB0cmFuc2xhdGlvbiBtYXBcbiAgICAgKi9cbiAgICB2YXIgaXNSZXBsYWNlZEN1c3RvbUNoYXIgPSBmdW5jdGlvbiAoY2gsIGN1c3RvbVJlcGxhY2VtZW50cykge1xuICAgICAgICBmb3IgKHZhciBjIGluIGN1c3RvbVJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgaWYgKGN1c3RvbVJlcGxhY2VtZW50c1tjXSA9PT0gY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblxuICAgICAgICAvLyBleHBvcnQgZnVuY3Rpb25zIGZvciB1c2UgaW4gTm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldFNsdWc7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLmNyZWF0ZVNsdWcgPSBjcmVhdGVTbHVnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuXG4gICAgICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBmb3IgdXNlIGluIEFNRFxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTbHVnO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGRvbid0IG92ZXJ3cml0ZSBnbG9iYWwgaWYgZXhpc3RzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm9vdC5nZXRTbHVnIHx8IHJvb3QuY3JlYXRlU2x1Zykge1xuICAgICAgICAgICAgICAgIHRocm93ICdzcGVha2luZ3VybDogZ2xvYmFscyBleGlzdHMgLyhnZXRTbHVnfGNyZWF0ZVNsdWcpLyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QuZ2V0U2x1ZyA9IGdldFNsdWc7XG4gICAgICAgICAgICAgICAgcm9vdC5jcmVhdGVTbHVnID0gY3JlYXRlU2x1ZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG59KSh0aGlzKTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0J5dGVMZW5ndGg7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gcmVxdWlyZSgnLi91dGlsL2Fzc2VydFN0cmluZycpO1xuXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnRTdHJpbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbmZ1bmN0aW9uIGlzQnl0ZUxlbmd0aChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW4gPSB2b2lkIDA7XG4gIHZhciBtYXggPSB2b2lkIDA7XG4gIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBtaW4gPSBvcHRpb25zLm1pbiB8fCAwO1xuICAgIG1heCA9IG9wdGlvbnMubWF4O1xuICB9IGVsc2Uge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpc0J5dGVMZW5ndGgoc3RyLCBtaW4gWywgbWF4XSlcbiAgICBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgbWF4ID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBsZW4gPSBlbmNvZGVVUkkoc3RyKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGggLSAxO1xuICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VtYWlsO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IHJlcXVpcmUoJy4vdXRpbC9hc3NlcnRTdHJpbmcnKTtcblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzZXJ0U3RyaW5nKTtcblxudmFyIF9tZXJnZSA9IHJlcXVpcmUoJy4vdXRpbC9tZXJnZScpO1xuXG52YXIgX21lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlKTtcblxudmFyIF9pc0J5dGVMZW5ndGggPSByZXF1aXJlKCcuL2lzQnl0ZUxlbmd0aCcpO1xuXG52YXIgX2lzQnl0ZUxlbmd0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0J5dGVMZW5ndGgpO1xuXG52YXIgX2lzRlFETiA9IHJlcXVpcmUoJy4vaXNGUUROJyk7XG5cbnZhciBfaXNGUUROMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRlFETik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2VtYWlsX29wdGlvbnMgPSB7XG4gIGFsbG93X2Rpc3BsYXlfbmFtZTogZmFsc2UsXG4gIHJlcXVpcmVfZGlzcGxheV9uYW1lOiBmYWxzZSxcbiAgYWxsb3dfdXRmOF9sb2NhbF9wYXJ0OiB0cnVlLFxuICByZXF1aXJlX3RsZDogdHJ1ZVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xudmFyIGRpc3BsYXlOYW1lID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1thLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLFxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcc10qPCguKyk+JC9pO1xudmFyIGVtYWlsVXNlclBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl0rJC9pO1xudmFyIHF1b3RlZEVtYWlsVXNlciA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl0pKSokL2k7XG52YXIgZW1haWxVc2VyVXRmOFBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rJC9pO1xudmFyIHF1b3RlZEVtYWlsVXNlclV0ZjggPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZVxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkqJC9pO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuZnVuY3Rpb24gaXNFbWFpbChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlMi5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2VtYWlsX29wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lIHx8IG9wdGlvbnMuYWxsb3dfZGlzcGxheV9uYW1lKSB7XG4gICAgdmFyIGRpc3BsYXlfZW1haWwgPSBzdHIubWF0Y2goZGlzcGxheU5hbWUpO1xuICAgIGlmIChkaXNwbGF5X2VtYWlsKSB7XG4gICAgICBzdHIgPSBkaXNwbGF5X2VtYWlsWzFdO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnQCcpO1xuICB2YXIgZG9tYWluID0gcGFydHMucG9wKCk7XG4gIHZhciB1c2VyID0gcGFydHMuam9pbignQCcpO1xuXG4gIHZhciBsb3dlcl9kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxvd2VyX2RvbWFpbiA9PT0gJ2dtYWlsLmNvbScgfHwgbG93ZXJfZG9tYWluID09PSAnZ29vZ2xlbWFpbC5jb20nKSB7XG4gICAgdXNlciA9IHVzZXIucmVwbGFjZSgvXFwuL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzQnl0ZUxlbmd0aDIuZGVmYXVsdCkodXNlciwgeyBtYXg6IDY0IH0pIHx8ICEoMCwgX2lzQnl0ZUxlbmd0aDIuZGVmYXVsdCkoZG9tYWluLCB7IG1heDogMjU0IH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzRlFETjIuZGVmYXVsdCkoZG9tYWluLCB7IHJlcXVpcmVfdGxkOiBvcHRpb25zLnJlcXVpcmVfdGxkIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHVzZXJbMF0gPT09ICdcIicpIHtcbiAgICB1c2VyID0gdXNlci5zbGljZSgxLCB1c2VyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IHF1b3RlZEVtYWlsVXNlclV0ZjgudGVzdCh1c2VyKSA6IHF1b3RlZEVtYWlsVXNlci50ZXN0KHVzZXIpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm4gPSBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IGVtYWlsVXNlclV0ZjhQYXJ0IDogZW1haWxVc2VyUGFydDtcblxuICB2YXIgdXNlcl9wYXJ0cyA9IHVzZXIuc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1c2VyX3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwYXR0ZXJuLnRlc3QodXNlcl9wYXJ0c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRkRRTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSByZXF1aXJlKCcuL3V0aWwvYXNzZXJ0U3RyaW5nJyk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydFN0cmluZyk7XG5cbnZhciBfbWVyZ2UgPSByZXF1aXJlKCcuL3V0aWwvbWVyZ2UnKTtcblxudmFyIF9tZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXJnZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2ZxZG5fb3B0aW9ucyA9IHtcbiAgcmVxdWlyZV90bGQ6IHRydWUsXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcbiAgYWxsb3dfdHJhaWxpbmdfZG90OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNGRFFOKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZnFkbl9vcHRpb25zKTtcblxuICAvKiBSZW1vdmUgdGhlIG9wdGlvbmFsIHRyYWlsaW5nIGRvdCBiZWZvcmUgY2hlY2tpbmcgdmFsaWRpdHkgKi9cbiAgaWYgKG9wdGlvbnMuYWxsb3dfdHJhaWxpbmdfZG90ICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpO1xuICBpZiAob3B0aW9ucy5yZXF1aXJlX3RsZCkge1xuICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcbiAgICBpZiAoIXBhcnRzLmxlbmd0aCB8fCAhL14oW2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9fHhuW2EtejAtOS1dezIsfSkkL2kudGVzdCh0bGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGRpc2FsbG93IHNwYWNlc1xuICAgIGlmICgvW1xcc1xcdTIwMDItXFx1MjAwQlxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZcXHVEQjQwXFx1REMyMF0vLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBwYXJ0LCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChvcHRpb25zLmFsbG93X3VuZGVyc2NvcmVzKSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKC9fL2csICcnKTtcbiAgICB9XG4gICAgaWYgKCEvXlthLXpcXHUwMGExLVxcdWZmZmYwLTktXSskL2kudGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBkaXNhbGxvdyBmdWxsLXdpZHRoIGNoYXJzXG4gICAgaWYgKC9bXFx1ZmYwMS1cXHVmZjVlXS8udGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFydFswXSA9PT0gJy0nIHx8IHBhcnRbcGFydC5sZW5ndGggLSAxXSA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0U3RyaW5nO1xuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKGlucHV0KSB7XG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG5cbiAgaWYgKCFpc1N0cmluZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgbGlicmFyeSAodmFsaWRhdG9yLmpzKSB2YWxpZGF0ZXMgc3RyaW5ncyBvbmx5Jyk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1lcmdlO1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZGVmYXVsdHMgPSBhcmd1bWVudHNbMV07XG5cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZ2V0U2x1ZyA9IHJlcXVpcmUoJ3NwZWFraW5ndXJsJylcblxuLy8gdGFrZSBjYXJlIG9mIHNsdWdnaW5nIGV2ZXJ5dGhpbmcgQlVUIHRoZSBmaWxlIGV4dGVuc2lvblxuLy8ga2VlcGluZyB0aGlzIGZpbGUgYXMgbWluaW1hbCBhcyBwb3NzaWJsZSAtPiB1c2VkIGluIGZyb250LWVuZCAoZWRpdG9yKVxudmFyIGV4dFJlZyAgPSAvXFwuWzAtOWEtel0rJC9cblxuZnVuY3Rpb24gc2x1Z0ZpbGVuYW1lKG5hbWUpIHtcbiAgdmFyIGZpbGVOYW1lICAgICAgPSBuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXG4gIC8vIEl0IHNlZW1zIHRoYXQgc29tZSBmaWxlcyBjYW1lIGhlcmUgd2l0aG91dCBleHRlbnNpb24gT19PJ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZGVub3VnaC9tb3NhaWNvL2lzc3Vlcy83MVxuICAvLyBIYXZlbid0IGJlZW4gYWJsZSB0byByZXByb2R1Y2UgYnV0IHNlY3VyZSBpdFxuICB2YXIgaGFzRXh0ZW5zaW9uICA9IGV4dFJlZy50ZXN0KCBmaWxlTmFtZSApXG4gIGlmICggIWhhc0V4dGVuc2lvbiApIHtcbiAgICBjb25zb2xlLmxvZygnW1NMVUdGSUxFTkFNRV0gaW1wb3NzaWJsZSB0byBzbHVnJywgbmFtZSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgZXh0ICAgICAgICAgICA9IGV4dFJlZy5leGVjKGZpbGVOYW1lKVswXVxuICBmaWxlTmFtZSAgICAgICAgICA9IGZpbGVOYW1lLnJlcGxhY2UoZXh0LCAnJylcbiAgZmlsZU5hbWUgICAgICAgICAgPSBnZXRTbHVnKCBmaWxlTmFtZS50cmltKCkgKSArIGV4dFxuICByZXR1cm4gZmlsZU5hbWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzbHVnRmlsZW5hbWVcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cbi8qIGdsb2JhbCBYTUxIdHRwUmVxdWVzdDogZmFsc2UgKi9cblxudmFyIHVybCAgICAgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcblxudmFyIHRlbXBsYXRlTG9hZGVyID0gcmVxdWlyZSgnLi90ZW1wbGF0ZS1sb2FkZXIuanMnKTtcblxucmVxdWlyZShcIi4va28tYmluZGluZ3MuanNcIik7XG52YXIgcGVyZm9ybWFuY2VBd2FyZUNhbGxlciA9IHJlcXVpcmUoXCIuL3RpbWVkLWNhbGwuanNcIikudGltZWRDYWxsO1xuXG52YXIgYWRkVW5kb1N0YWNrRXh0ZW5zaW9uTWFrZXIgPSByZXF1aXJlKFwiLi91bmRvbWFuYWdlci91bmRvbWFpbi5qc1wiKTtcbnZhciBjb2xvclBsdWdpbiA9IHJlcXVpcmUoXCIuL2V4dC9jb2xvci5qc1wiKTtcbnZhciBpbmxpbmVyUGx1Z2luID0gcmVxdWlyZShcIi4vZXh0L2lubGluZXIuanNcIik7XG5cbnZhciBsb2NhbFN0b3JhZ2VMb2FkZXIgPSByZXF1aXJlKFwiLi9leHQvbG9jYWxzdG9yYWdlLmpzXCIpO1xuXG5pZiAodHlwZW9mIGtvID09ICd1bmRlZmluZWQnKSB0aHJvdyBcIkNhbm5vdCBmaW5kIGtub2Nrb3V0LmpzIGxpYnJhcnkhXCI7XG5pZiAodHlwZW9mICQgPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IGZpbmQganF1ZXJ5IGxpYnJhcnkhXCI7XG5cbmlmIChmYWxzZSkge1xuXG5mdW5jdGlvbiBfY2Fub25pY2FsaXplKHVybCkge1xuICB2YXIgZGl2ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8YT48L2E+XCI7XG4gIGRpdi5maXJzdENoaWxkLmhyZWYgPSB1cmw7IC8vIEVuc3VyZXMgdGhhdCB0aGUgaHJlZiBpcyBwcm9wZXJseSBlc2NhcGVkXG4gIGRpdi5pbm5lckhUTUwgPSBkaXYuaW5uZXJIVE1MOyAvLyBSdW4gdGhlIGN1cnJlbnQgaW5uZXJIVE1MIGJhY2sgdGhyb3VnaCB0aGUgcGFyc2VyXG4gIHJldHVybiBkaXYuZmlyc3RDaGlsZC5ocmVmO1xufVxuXG5mdW5jdGlvbiBfYXBwZW5kVXJsUGFyYW1ldGVycyhiYXNlVXJsLCBwYXJhbWV0ZXJzKSB7XG4gIHZhciBwYXJhbVNlcGFyYXRvciA9IGJhc2VVcmwuaW5kZXhPZignPycpID09IC0xID8gJz8nIDogJyYnO1xuICB2YXIgcmVzID0gYmFzZVVybDtcbiAgZm9yICh2YXIgcGFyYW0gaW4gcGFyYW1ldGVycykgaWYgKHBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgcmVzICs9IHBhcmFtU2VwYXJhdG9yICsgcGFyYW0gKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgcGFyYW1TZXBhcmF0b3IgPSAnJic7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIGFwcGx5QmluZGluZ09wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCBrbykge1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLmNvbnZlcnRlZFVybCA9IGZ1bmN0aW9uKHNyYywgbWV0aG9kLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHF1ZXJ5UGFyYW1TZXBhcmF0b3I7XG4gICAgdmFyIGltZ1Byb2Nlc3NvckJhY2tlbmQgPSBvcHRpb25zLmltZ1Byb2Nlc3NvckJhY2tlbmQgPyBvcHRpb25zLmltZ1Byb2Nlc3NvckJhY2tlbmQgOiAnLi91cGxvYWQnO1xuICAgIHZhciBiYWNrRW5kTWF0Y2ggPSBpbWdQcm9jZXNzb3JCYWNrZW5kLm1hdGNoKC9eKGh0dHBzPzpcXC9cXC9bXlxcL10qXFwvKS4qJC8pO1xuICAgIHZhciBzcmNNYXRjaCA9IHNyYy5tYXRjaCgvXihodHRwcz86XFwvXFwvW15cXC9dKlxcLykuKiQvKTtcbiAgICBpZiAoYmFja0VuZE1hdGNoID09PSBudWxsIHx8IChzcmNNYXRjaCAhPT0gbnVsbCAmJiBiYWNrRW5kTWF0Y2hbMV0gPT0gc3JjTWF0Y2hbMV0pKSB7XG4gICAgICBxdWVyeVBhcmFtU2VwYXJhdG9yID0gaW1nUHJvY2Vzc29yQmFja2VuZC5pbmRleE9mKCc/JykgPT0gLTEgPyAnPycgOiAnJic7XG4gICAgICByZXR1cm4gX2FwcGVuZFVybFBhcmFtZXRlcnMoaW1nUHJvY2Vzc29yQmFja2VuZCwgeyBzcmM6IHNyYywgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogd2lkdGggKyBcIixcIiArIGhlaWdodCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJDYW5ub3QgYXBwbHkgYmFja2VuZCBpbWFnZSByZXNpemluZyB0byBub24tbG9jYWwgcmVzb3VyY2VzIFwiLCBzcmMsIG1ldGhvZCwgd2lkdGgsIGhlaWdodCwgYmFja0VuZE1hdGNoLCBzcmNNYXRjaCk7XG4gICAgICB2YXIgcGFyYW1zID0geyBtZXRob2Q6IG1ldGhvZCwgd2lkdGg6IHdpZHRoIH07XG4gICAgICBpZiAoaGVpZ2h0ICE9PSBudWxsKSBwYXJhbXNbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgcmV0dXJuIF9hcHBlbmRVcmxQYXJhbWV0ZXJzKHNyYywgcGFyYW1zKTtcbiAgICB9XG4gIH07XG5cbiAga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMucGxhY2Vob2xkZXJVcmwgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB0ZXh0KSB7XG4gICAgdmFyIGltZ1Byb2Nlc3NvckJhY2tlbmQgPSBvcHRpb25zLmltZ1Byb2Nlc3NvckJhY2tlbmQgPyBvcHRpb25zLmltZ1Byb2Nlc3NvckJhY2tlbmQgOiAnLi91cGxvYWQnO1xuICAgIHJldHVybiBfYXBwZW5kVXJsUGFyYW1ldGVycyhpbWdQcm9jZXNzb3JCYWNrZW5kLCB7IG1ldGhvZDogJ3BsYWNlaG9sZGVyJywgcGFyYW1zOiB3aWR0aCArIFwiLFwiICsgaGVpZ2h0IH0pO1xuICB9O1xuXG4gIC8vIHB1c2hlcyBjdXN0b20gdGlueW1jZSBjb25maWd1cmF0aW9ucyBmcm9tIG9wdGlvbnMgdG8gdGhlIGJpbmRpbmdcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW55bWNlQ29uZmlnKVxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnN0YW5kYXJkT3B0aW9ucyA9IG9wdGlvbnMudGlueW1jZUNvbmZpZztcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW55bWNlQ29uZmlnRnVsbClcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5mdWxsT3B0aW9ucyA9IG9wdGlvbnMudGlueW1jZUNvbmZpZ0Z1bGw7XG59O1xuXG59XG5cbnZhciBzdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRlbXBsYXRlRmlsZSwgdGVtcGxhdGVNZXRhZGF0YSwganNvcmpzb24sIGN1c3RvbUV4dGVuc2lvbnMpIHtcblxuICB0ZW1wbGF0ZUxvYWRlci5maXhQYWdlRXZlbnRzKCk7XG5cbiAgdmFyIGZpbGVVcGxvYWRNZXNzYWdlc0V4dGVuc2lvbiA9IGZ1bmN0aW9uKHZtKSB7XG4gICAgdmFyIGZpbGV1cGxvYWRDb25maWcgPSB7XG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICB1bmtub3duRXJyb3I6IHZtLnQoJ1Vua25vd24gZXJyb3InKSxcbiAgICAgICAgdXBsb2FkZWRCeXRlczogdm0udCgnVXBsb2FkZWQgYnl0ZXMgZXhjZWVkIGZpbGUgc2l6ZScpLFxuICAgICAgICBtYXhOdW1iZXJPZkZpbGVzOiB2bS50KCdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcpLFxuICAgICAgICBhY2NlcHRGaWxlVHlwZXM6IHZtLnQoJ0ZpbGUgdHlwZSBub3QgYWxsb3dlZCcpLFxuICAgICAgICBtYXhGaWxlU2l6ZTogdm0udCgnRmlsZSBpcyB0b28gbGFyZ2UnKSxcbiAgICAgICAgbWluRmlsZVNpemU6IHZtLnQoJ0ZpbGUgaXMgdG9vIHNtYWxsJyksXG4gICAgICAgIHBvc3RfbWF4X3NpemU6IHZtLnQoJ1RoZSB1cGxvYWRlZCBmaWxlIGV4Y2VlZHMgdGhlIHBvc3RfbWF4X3NpemUgZGlyZWN0aXZlIGluIHBocC5pbmknKSxcbiAgICAgICAgbWF4X2ZpbGVfc2l6ZTogdm0udCgnRmlsZSBpcyB0b28gYmlnJyksXG4gICAgICAgIG1pbl9maWxlX3NpemU6IHZtLnQoJ0ZpbGUgaXMgdG9vIHNtYWxsJyksXG4gICAgICAgIGFjY2VwdF9maWxlX3R5cGVzOiB2bS50KCdGaWxldHlwZSBub3QgYWxsb3dlZCcpLFxuICAgICAgICBtYXhfbnVtYmVyX29mX2ZpbGVzOiB2bS50KCdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcpLFxuICAgICAgICBtYXhfd2lkdGg6IHZtLnQoJ0ltYWdlIGV4Y2VlZHMgbWF4aW11bSB3aWR0aCcpLFxuICAgICAgICBtaW5fd2lkdGg6IHZtLnQoJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSB3aWR0aCcpLFxuICAgICAgICBtYXhfaGVpZ2h0OiB2bS50KCdJbWFnZSBleGNlZWRzIG1heGltdW0gaGVpZ2h0JyksXG4gICAgICAgIG1pbl9oZWlnaHQ6IHZtLnQoJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSBoZWlnaHQnKSxcbiAgICAgICAgYWJvcnQ6IHZtLnQoJ0ZpbGUgdXBsb2FkIGFib3J0ZWQnKSxcbiAgICAgICAgaW1hZ2VfcmVzaXplOiB2bS50KCdGYWlsZWQgdG8gcmVzaXplIGltYWdlJyksXG4gICAgICAgIGdlbmVyaWM6IHZtLnQoJ1VuZXhwZWN0ZWQgdXBsb2FkIGVycm9yJylcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIGZpbGVVcGxvYWQgb3B0aW9ucy5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbGV1cGxvYWRDb25maWcpXG4gICAgICBmaWxldXBsb2FkQ29uZmlnID0gJC5leHRlbmQodHJ1ZSwgZmlsZXVwbG9hZENvbmZpZywgb3B0aW9ucy5maWxldXBsb2FkQ29uZmlnKTtcblxuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1snZmlsZXVwbG9hZCddLmV4dGVuZE9wdGlvbnMgPSBmaWxldXBsb2FkQ29uZmlnO1xuXG4gIH07XG5cbiAgdmFyIHNpbXBsZVRyYW5zbGF0aW9uUGx1Z2luID0gZnVuY3Rpb24odm0pIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmluZ3MpIHtcbiAgICAgIHZtLnQgPSBmdW5jdGlvbihrZXksIG9ialBhcmFtKSB7XG4gICAgICAgIHZhciByZXMgPSBvcHRpb25zLnN0cmluZ3Nba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJNaXNzaW5nIHRyYW5zbGF0aW9uIHN0cmluZyBmb3JcIixrZXksXCI6IHVzaW5nIGRlZmF1bHQgc3RyaW5nXCIpO1xuICAgICAgICAgIHJlcyA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm0udHQocmVzLCBvYmpQYXJhbSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBzaW1wbGVUcmFuc2xhdGlvblBsdWdpbiBtdXN0IGJlIGJlZm9yZSB0aGUgdW5kb1N0YWNrIHRvIHRyYW5zbGF0ZSB1bmRvL3JlZG8gbGFiZWxzXG4gIHZhciBleHRlbnNpb25zID0gW3NpbXBsZVRyYW5zbGF0aW9uUGx1Z2luLCBhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlcihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSwgY29sb3JQbHVnaW4sIGlubGluZXJQbHVnaW5dO1xuICBpZiAodHlwZW9mIGN1c3RvbUV4dGVuc2lvbnMgIT09ICd1bmRlZmluZWQnKVxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY3VzdG9tRXh0ZW5zaW9ucy5sZW5ndGg7IGsrKykgZXh0ZW5zaW9ucy5wdXNoKGN1c3RvbUV4dGVuc2lvbnNba10pO1xuICBleHRlbnNpb25zLnB1c2goZmlsZVVwbG9hZE1lc3NhZ2VzRXh0ZW5zaW9uKTtcblxuICB2YXIgZ2FsbGVyeVVybCA9IG9wdGlvbnMuZmlsZXVwbG9hZENvbmZpZyA/IG9wdGlvbnMuZmlsZXVwbG9hZENvbmZpZy51cmwgOiAnL3VwbG9hZC8nO1xuICBhcHBseUJpbmRpbmdPcHRpb25zKG9wdGlvbnMsIGtvKTtcblxuICAvLyBUT0RPIHdoYXQgYWJvdXQgYXBwZW5kaW5nIHRvIGFub3RoZXIgZWxlbWVudD9cbiAgJChcIjwhLS0ga28gdGVtcGxhdGU6ICdtYWluJyAtLT48IS0tIC9rbyAtLT5cIikuYXBwZW5kVG8oZ2xvYmFsLmRvY3VtZW50LmJvZHkpO1xuXG4gIC8vIHRlbXBsYXRlRmlsZSBtYXkgb3ZlcnJpZGUgdGhlIHRlbXBsYXRlIHBhdGggaW4gdGVtcGxhdGVNZXRhZGF0YVxuICBpZiAodHlwZW9mIHRlbXBsYXRlRmlsZSA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGVtcGxhdGVNZXRhZGF0YSAhPSAndW5kZWZpbmVkJykge1xuICAgIHRlbXBsYXRlRmlsZSA9IHRlbXBsYXRlTWV0YWRhdGEudGVtcGxhdGU7XG4gIH1cbiAgLy8gVE9ETyBjYW5vbmljYWxpemUgdGVtcGxhdGVGaWxlIHRvIGFic29sdXRlIG9yIHJlbGF0aXZlIGRlcGVuZGluZyBvbiBcInJlbGF0aXZlVXJsc0V4Y2VwdGlvblwiIHBsdWdpblxuXG4gIHRlbXBsYXRlTG9hZGVyLmxvYWQocGVyZm9ybWFuY2VBd2FyZUNhbGxlciwgdGVtcGxhdGVGaWxlLCB0ZW1wbGF0ZU1ldGFkYXRhLCBqc29yanNvbiwgZXh0ZW5zaW9ucywgZ2FsbGVyeVVybCk7XG5cbn07XG5cbmlmIChmYWxzZSkge1xuXG52YXIgaW5pdEZyb21Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbihvcHRpb25zLCBoYXNoX2tleSwgY3VzdG9tRXh0ZW5zaW9ucykge1xuICB0cnkge1xuICAgIHZhciBsc0RhdGEgPSBsb2NhbFN0b3JhZ2VMb2FkZXIoaGFzaF9rZXksIG9wdGlvbnMuZW1haWxQcm9jZXNzb3JCYWNrZW5kKTtcbiAgICB2YXIgZXh0ZW5zaW9ucyA9IHR5cGVvZiBjdXN0b21FeHRlbnNpb25zICE9PSAndW5kZWZpbmVkJyA/IGN1c3RvbUV4dGVuc2lvbnMgOiBbXTtcbiAgICBleHRlbnNpb25zLnB1c2gobHNEYXRhLmV4dGVuc2lvbik7XG4gICAgdmFyIHRlbXBsYXRlID0gX2Nhbm9uaWNhbGl6ZShsc0RhdGEubWV0YWRhdGEudGVtcGxhdGUpO1xuICAgIHN0YXJ0KG9wdGlvbnMsIHRlbXBsYXRlLCBsc0RhdGEubWV0YWRhdGEsIGxzRGF0YS5tb2RlbCwgZXh0ZW5zaW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVE9ETyBub3QgZm91bmQgXCIsIGhhc2hfa2V5LCBlKTtcbiAgfVxufTtcblxudmFyIGluaXQgPSBmdW5jdGlvbihvcHRpb25zLCBjdXN0b21FeHRlbnNpb25zKSB7XG5cbiAgdmFyIGhhc2ggPSBnbG9iYWwubG9jYXRpb24uaGFzaCA/IGdsb2JhbC5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiI1wiKVsxXSA6IHVuZGVmaW5lZDtcblxuICAvLyBMb2FkaW5nIGZyb20gY29uZmlndXJlZCB0ZW1wbGF0ZSBvciBjb25maWd1cmVkIG1ldGFkYXRhXG4gIGlmIChvcHRpb25zICYmIChvcHRpb25zLnRlbXBsYXRlIHx8IG9wdGlvbnMuZGF0YSkpIHtcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2Uob3B0aW9ucy5kYXRhKTtcbiAgICAgIHN0YXJ0KG9wdGlvbnMsIHVuZGVmaW5lZCwgZGF0YS5tZXRhZGF0YSwgZGF0YS5jb250ZW50LCBjdXN0b21FeHRlbnNpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQob3B0aW9ucywgb3B0aW9ucy50ZW1wbGF0ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGN1c3RvbUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvLyBMb2FkaW5nIGZyb20gTG9jYWxTdG9yYWdlIChpZiB1cmwgaGFzaCBoYXMgYSA3Y2hhcnMga2V5KVxuICB9IGVsc2UgaWYgKGhhc2ggJiYgaGFzaC5sZW5ndGggPT0gNykge1xuICAgIGluaXRGcm9tTG9jYWxTdG9yYWdlKG9wdGlvbnMsIGhhc2gsIGN1c3RvbUV4dGVuc2lvbnMpO1xuICAgIC8vIExvYWRpbmcgZnJvbSB0ZW1wbGF0ZSB1cmwgYXMgaGFzaCAoaWYgaGFzaCBpcyBub3QgYSB2YWxpZCBsb2NhbHN0b3JhZ2Uga2V5KVxuICB9IGVsc2UgaWYgKGhhc2gpIHtcbiAgICBzdGFydChvcHRpb25zLCBfY2Fub25pY2FsaXplKGhhc2gpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY3VzdG9tRXh0ZW5zaW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxufVxuXG5pZiAodHJ1ZSkge1xuXG4vLy8vLy9cbi8vIENVU1RPTSBNT1NBSUNPIFNQRUNJRklDXG4vLy8vLy9cblxuLy8gZG9uJ3QgcmVwbGFjZSBtb3NhaWNvIGNvZGUgZm9yIGJldHRlciBtZXJnaW5nXG5cbi8vIEtlZXAgYW4gZW1wdHkgZnVuY3Rpb24gZm9yIG5vdCBicmVha2luZyBzdGFydCBmdW5jdGlvblxuLy8gRXZlbiBpZiBhcHBseUJpbmRpbmdPcHRpb25zIGNhbiBiZSBzdXJjaGFyZ2VkLFxuLy8gaXQncyBiZXR0ZXIgdG8gcmVtb3ZlIHRoaXMgbm90IG5lY2Vzc2FyeSBwaWVjZSBvZiBjb2RlXG52YXIgYXBwbHlCaW5kaW5nT3B0aW9ucyA9ICQubm9vcFxuXG4vLyBGTE9XOlxuLy8gPT4gaW5pdFxuLy8gPT4gc3RhcnRcbi8vIGluIC4vdGVtcGxhdGUtbG9hZGVyLmpzXG4vLyA9PiB0ZW1wbGF0ZUxvYWRlcjogQWpheCBkYXRhc1xuLy8gPT4gdGVtcGxhdGVDb21waWxlcjpcbi8vICAgIC0+IEluaXRpYWxpemUgdmlld21vZGVsICguL3ZpZXdtb2RlbC5qcylcbi8vICAgIC0+IEFkZCBzZXJ2ZXIgZGF0YXNcbi8vICAgIC0+IGFwcGx5IHBsdWdpbnMgKHNlcnZlci1zdG9yYWdlLCBzZXRFZGl0b3JJY29uICsgbW9zYWljbyBkZWZpbmVkKVxuXG52YXIgY3VzdG9tRXh0ID0gcmVxdWlyZSgnLi9leHQvY3VzdG9tLWV4dGVuc2lvbnMnKVxuXG52YXIgaW5pdCA9IGZ1bmN0aW9uKG9wdHMsIGN1c3RvbUV4dGVuc2lvbnMpIHtcbiAgY29uc29sZS5pbmZvKCdDVVNUT00gTU9TQUlDTyDigJMgaW5pdCcpXG4gIGNvbnNvbGUubG9nKG9wdHMpXG4gIHZhciBoYXNEYXRhcyA9IG9wdHMgJiYgb3B0cy5tZXRhZGF0YSAmJiBvcHRzLmRhdGFcbiAgLy8gZWRpdG9yLmphZGUgc2NyaXB0IG5lZWQgYSByZXR1cm4gdmFsdWVcbiAgaWYgKCFoYXNEYXRhcykgcmV0dXJuIGZhbHNlO1xuXG4gIGN1c3RvbUV4dC5leHRlbmRWaWV3TW9kZWwob3B0cywgY3VzdG9tRXh0ZW5zaW9ucylcbiAgY3VzdG9tRXh0LmV4dGVuZEtub2Nrb3V0KG9wdHMpXG5cbiAgc3RhcnQob3B0cywgdm9pZCgwKSwgb3B0cy5tZXRhZGF0YSwgb3B0cy5kYXRhLCBjdXN0b21FeHRlbnNpb25zKVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0NvbXBhdGlibGU6IHRlbXBsYXRlTG9hZGVyLmlzQ29tcGF0aWJsZSxcbiAgaW5pdDogaW5pdCxcbiAgc3RhcnQ6IHN0YXJ0XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuLy8gQHNlZSBhbHNvIHNjcmlwdC10ZW1wbGF0ZS5qcyBwdXNoVGVtcGxhdGVcbnZhciBhZGRTY3JpcHRUZW1wbGF0ZSA9IGZ1bmN0aW9uKGRvYywgdGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZU1hcmt1cCkge1xuICB2YXIgc2NyaXB0VGFnID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHRUYWcuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvaHRtbCcpO1xuICBzY3JpcHRUYWcuc2V0QXR0cmlidXRlKCdpZCcsIHRlbXBsYXRlTmFtZSk7XG4gIHNjcmlwdFRhZy50ZXh0ID0gdGVtcGxhdGVNYXJrdXA7XG4gIGRvYy5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gIHJldHVybiBzY3JpcHRUYWc7XG4gIC8vICQoJzxzY3JpcHQgdHlwZT1cInRleHQvaHRtbFwiPjwvc2MnICsgJ3JpcHQ+JykudGV4dCh0ZW1wbGF0ZU1hcmt1cCkuYXR0cignaWQnLCB0ZW1wbGF0ZU5hbWUpLmFwcGVuZFRvKCQoJ2JvZHknKSk7XG59O1xuXG4vLyB1c2VkIGZvciBsaXZlIHByZXZpZXcgaW4gaWZyYW1lLlxua28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUgPSB7XG4gIC8vIHRwbCB3aWxsIGJlIG92ZXJyaWRlbiB3aXRoIHRoZSBzdHJ1Y3R1cmUgcGFyc2VkIGJ5IHRoZSBpbnB1dCB0ZW1wbGF0ZS5cbiAgdHBsOiBcIjwhRE9DVFlQRSBodG1sPlxcclxcbjxodG1sPlxcclxcbjxoZWFkPlxcclxcbjwvaGVhZD5cXHJcXG48Ym9keT48ZGl2IGRhdGEtYmluZD1cXFwiYmxvY2s6IGNvbnRlbnRcXFwiPjwvZGl2PjwvYm9keT5cXHJcXG48L2h0bWw+XFxyXFxuXCIsXG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBiaW5kSWZyYW1lKGxvY2FsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaWZyYW1lID0gZWxlbWVudC5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGlmcmFtZS5vcGVuKCk7XG4gICAgICAgIGlmcmFtZS53cml0ZShrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGwpO1xuICAgICAgICBpZnJhbWUuY2xvc2UoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpZnJhbWVkb2MgPSBpZnJhbWUuYm9keTtcbiAgICAgICAgICBpZiAoaWZyYW1lZG9jKSB7XG4gICAgICAgICAgICAvLyBzY3JpcHRzIGhhdmUgdG8gYmUgZHVwbGljYXRlZCAobWF5YmUgdGhpcyBpcyBub3QgbmVlZGVkIGFueW1vcmUgc2luY2UgdXNpbmcgc3RyaW5nLXRlbXBsYXRlcylcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZXMgPSBlbGVtZW50LmNvbnRlbnRXaW5kb3cucGFyZW50LmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCd0eXBlJykgPT0gJ3RleHQvaHRtbCcgJiYgdGVtcGxhdGVzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICAgICAgICAgIGFkZFNjcmlwdFRlbXBsYXRlKGlmcmFtZSwgdGVtcGxhdGVzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSwgdGVtcGxhdGVzW2ldLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGh0bWwgPSBpZnJhbWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJIVE1MXCIpO1xuXG4gICAgICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBrby5jbGVhbk5vZGUoaHRtbFswXSB8fCBpZnJhbWVkb2MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3ModmFsdWVBY2Nlc3NvcigpLCBodG1sWzBdIHx8IGlmcmFtZWRvYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm8gaWZyYW1lZG9jXCIsIGxvY2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yIHJlYWRpbmcgaWZyYW1lLmJvZHlcIiwgZSwgbG9jYWwpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciByZWFkaW5nIGlmcmFtZSBjb250ZW50RG9jdW1lbnRcIiwgZSwgbG9jYWwpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgICAvLyBpZ25vcmVkXG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRJZnJhbWUoXCJmaXJzdCBjYWxsXCIpO1xuICAgIC8vIG9sZGVyIGJyb3dzZXJzIG5lZWRlZCB0aGlzXG4gICAgLy8ga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgJ2xvYWQnLCBiaW5kSWZyYW1lKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgZ2xvYmFsOmZhbHNlICovXG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3dpdGhQcm9wZXJ0aWVzJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgLy8gTWFrZSBhIG1vZGlmaWVkIGJpbmRpbmcgY29udGV4dCwgd2l0aCBhIGV4dHJhIHByb3BlcnRpZXMsIGFuZCBhcHBseSBpdCB0byBkZXNjZW5kYW50IGVsZW1lbnRzXG4gICAgdmFyIGNoaWxkQmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dC5jcmVhdGVDaGlsZENvbnRleHQoXG4gICAgICBiaW5kaW5nQ29udGV4dC4kcmF3RGF0YSxcbiAgICAgIG51bGwsIC8vIE9wdGlvbmFsbHksIHBhc3MgYSBzdHJpbmcgaGVyZSBhcyBhbiBhbGlhcyBmb3IgdGhlIGRhdGEgaXRlbSBpbiBkZXNjZW5kYW50IGNvbnRleHRzXG4gICAgICBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgIGtvLnV0aWxzLmV4dGVuZChjb250ZXh0LCB2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgfVxuICAgICk7XG4gICAga28uYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMoY2hpbGRCaW5kaW5nQ29udGV4dCwgZWxlbWVudCk7XG5cbiAgICAvLyBBbHNvIHRlbGwgS08gKm5vdCogdG8gYmluZCB0aGUgZGVzY2VuZGFudHMgaXRzZWxmLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGJvdW5kIHR3aWNlXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3dpdGhQcm9wZXJ0aWVzJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2xvZyddID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGNvbnNvbGUubG9nKFwibG9nXCIsIHZhbHVlQWNjZXNzb3IoKSk7XG4gIH1cbn07XG5cblxua28uYmluZGluZ0hhbmRsZXJzWydibG9jayddID0ge1xuXG4gIHRlbXBsYXRlRXhpc3RzOiBmdW5jdGlvbihpZCkge1xuICAgIHZhciBlbCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKGVsKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBfY2hvb3NlVGVtcGxhdGU6IGZ1bmN0aW9uKGlzQXJyYXksIHByZWZpeCwgYWN0aW9uLCBmYWxsYmFjaykge1xuICAgIHZhciBpZCA9IHByZWZpeCArICctJyArIGFjdGlvbjtcbiAgICBpZiAoa28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLnRlbXBsYXRlRXhpc3RzKGlkKSkgcmV0dXJuIGlkO1xuICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IG51bGwpIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX2Nob29zZVRlbXBsYXRlKGlzQXJyYXksIHByZWZpeCwgZmFsbGJhY2spO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGZhbGxCYWNrSWQgPSBpc0FycmF5ID8gJ2FycmF5JyA6ICdvYmplY3QtJyArIGFjdGlvbjtcbiAgICAgIGlmIChrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10udGVtcGxhdGVFeGlzdHMoZmFsbEJhY2tJZCkpIHJldHVybiBmYWxsQmFja0lkO1xuICAgICAgZWxzZSB0aHJvdyBcImNhbm5vdCBmaW5kIHRlbXBsYXRlIGZvciBcIiArIGlkICsgXCIvXCIgKyBmYWxsQmFja0lkO1xuICAgIH1cbiAgfSxcblxuICAvLyBjb21wdXRlIGRpc3BsYXlNb2RlIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZU1vZGUgc2V0IHVzaW5nIFwid2l0aFByb3BlcnRpZXNcIiBiaW5kaW5nLlxuICBfZGlzcGxheU1vZGU6IGZ1bmN0aW9uKHVud3JhcHBlZCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgcHJlZml4ID0gdHlwZW9mIHVud3JhcHBlZC50eXBlICE9ICd1bmRlZmluZWQnID8ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh1bndyYXBwZWQudHlwZSkgOiAnbm90YWJsb2NrLScgKyB0eXBlb2YodW53cmFwcGVkKTtcbiAgICB2YXIgaXNBcnJheSA9IHR5cGVvZiB1bndyYXBwZWQuc3BsaWNlICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgdGVtcGxhdGVNb2RlID0gYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID8gYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlIDogJ3Nob3cnO1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX2Nob29zZVRlbXBsYXRlKGlzQXJyYXksIHByZWZpeCwgdGVtcGxhdGVNb2RlLCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGVGYWxsYmFjayk7XG4gIH0sXG5cbiAgX21ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3I6IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLFxuICAgICAgICB1bndyYXBwZWRWYWx1ZSA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKHZhbHVlKTsgLy8gVW53cmFwIHdpdGhvdXQgc2V0dGluZyBhIGRlcGVuZGVuY3kgaGVyZVxuXG4gICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZS5kYXRhIGlzIHRoZSBhcnJheSwgcHJlc2VydmUgYWxsIHJlbGV2YW50IG9wdGlvbnMgYW5kIHVud3JhcCBhZ2FpbiB2YWx1ZSBzbyB3ZSBnZXQgdXBkYXRlc1xuICAgICAgdmFyIG1vZGVsVmFsdWU7XG4gICAgICB2YXIgdGVtcGxhdGU7XG5cbiAgICAgIGlmICgoIXVud3JhcHBlZFZhbHVlKSB8fCAodHlwZW9mIHVud3JhcHBlZFZhbHVlLmRhdGEgIT0gJ29iamVjdCcgJiYgdHlwZW9mIHVud3JhcHBlZFZhbHVlLmRhdGEgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgbW9kZWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWxWYWx1ZSA9IHVud3JhcHBlZFZhbHVlLmRhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgdW53cmFwcGVkVmFsdWUudGVtcGxhdGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVQYXJhbSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodW53cmFwcGVkVmFsdWUudGVtcGxhdGUpO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZU1vZGUgPSBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPyBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgOiAnc2hvdyc7XG4gICAgICAgICAgdGVtcGxhdGUgPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX2Nob29zZVRlbXBsYXRlKGZhbHNlLCB0ZW1wbGF0ZVBhcmFtLCB0ZW1wbGF0ZU1vZGUsIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZUZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdW53cmFwcGVkTW9kZWxWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobW9kZWxWYWx1ZSk7XG4gICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHVud3JhcHBlZE1vZGVsVmFsdWUpKSBjb25zb2xlLmxvZyhcImRvdWJsZU9ic2VydmFibGVcIiwgdW53cmFwcGVkTW9kZWxWYWx1ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTk9URSBJRTggdXNlZCB0byBicmVhayBoZXJlLCBidXQgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBhbnltb3JlLCBzbyBtYXliZSB0aGlzIGlzIG5vdCBuZWVkZWQuXG4gICAgICAgIGlmIChtb2RlbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9ICdlbXB0eSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0ga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLl9kaXNwbGF5TW9kZSh1bndyYXBwZWRNb2RlbFZhbHVlLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSwgdW53cmFwcGVkTW9kZWxWYWx1ZSwgYmluZGluZ0NvbnRleHRbJyRkYXRhJ10sIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbmFtZSc6IHRlbXBsYXRlLFxuICAgICAgICAnZGF0YSc6IG1vZGVsVmFsdWUsXG4gICAgICAgICd0ZW1wbGF0ZUVuZ2luZSc6IGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLmluc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG4gIH0sXG5cbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWVBY2Nlc3NvcigpID09PSAndW5kZWZpbmVkJykgY29uc29sZS5sb2coXCJmb3VuZCBhIG51bGwgYmxvY2s6IGNoZWNrIGVuZGluZyBjb21tYXMgaW4gYXJyYXlzIGRlZnMgaW4gSUVcIik7XG4gICAgdmFyIG5ld1ZhbHVlQWNjZXNzb3IgPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX21ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciwgYmluZGluZ0NvbnRleHQpO1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3RlbXBsYXRlJ11bJ2luaXQnXShlbGVtZW50LCBuZXdWYWx1ZUFjY2Vzc29yKTtcbiAgfSxcbiAgJ3VwZGF0ZSc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIG5ld1ZhbHVlQWNjZXNzb3IgPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX21ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciwgYmluZGluZ0NvbnRleHQpO1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3RlbXBsYXRlJ11bJ3VwZGF0ZSddKGVsZW1lbnQsIG5ld1ZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfVxufTtcbmtvLmV4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzWydibG9jayddID0gZmFsc2U7IC8vIENhbid0IHJld3JpdGUgY29udHJvbCBmbG93IGJpbmRpbmdzXG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWydibG9jayddID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gc2NyaXB0IHRlbXBsYXRlIGlzIHRoZSBvbmUgcHJvdmlkZWQgYnkgS08gYW5kIGRlYWxzIHdpdGggdGVtcGFsdGVzIGRlZmluZWQgYXMgPHNjcmlwdCB0eXBlPXRleHQvaHRtbC5cbi8vIHN0cmluZyB0ZW1wbGF0ZSBkZWZpbmVzIHRoZW0gaW4gbWVtb3J5IGFuZCBhdm9pZHMgcG9sbHV0aW5nIHRoZSBIVE1MOiBzZWVtcyB0byB3b3JrIGJldHRlciBpbiBNb3NhaWNvLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3RyaW5nLXRlbXBsYXRlLmpzJyk7XG4vLyBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2NyaXB0LXRlbXBsYXRlLmpzJyk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG5yZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2V2b2wtY29sb3JwaWNrZXIvanMvZXZvbC5jb2xvcnBpY2tlci5taW4uanNcIik7XG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGtvanF1aSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wydrb2pxdWknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvanF1aSddIDogbnVsbCk7XG5cblxudmFyIENvbG9yUGlja2VyID0gZnVuY3Rpb24oKSB7XG4gIGtvanF1aS5CaW5kaW5nSGFuZGxlci5jYWxsKHRoaXMsICdjb2xvcnBpY2tlcicpO1xufTtcbkNvbG9yUGlja2VyLnByb3RvdHlwZSA9IGtvanF1aS51dGlscy5jcmVhdGVPYmplY3Qoa29qcXVpLkJpbmRpbmdIYW5kbGVyLnByb3RvdHlwZSk7XG5Db2xvclBpY2tlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xvclBpY2tlcjtcblxuQ29sb3JQaWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuICB2YXIgdmEgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gIHZhciB2YWx1ZSA9IHZhLmNvbG9yO1xuXG4gIC8vIEluIG9yZGVyIHRvIGhhdmUgYSBjb3JyZWN0IGRlcGVuZGVuY3kgdHJhY2tpbmcgaW4gXCJpZlN1YnNcIiB3ZSBoYXZlIHRvIGVuc3VyZSB3ZSB1c2UgYSBzaW5nbGUgY29tcHV0ZXIgZm9yIGVhY2ggZWRpdGFibGVcbiAgLy8gcHJvcGVydHkuIEdpdmVuIHRoaXMgYmluZGluZyBuZWVkcyAyIG9mIHRoZW0sIHdlIGNyZWF0ZSBhIGNvbXB1dGVkIHNvIHRvIFwicHJveHlcIiB0aGUgZGVwZW5kZW5jaWVzLlxuICB2YXIgbmV3RE8gPSBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogdmFsdWUsXG4gICAgd3JpdGU6IHZhbHVlLFxuICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuICB9KTtcbiAgdmFyIG5ld1ZBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ld0RPO1xuICB9O1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy52YWx1ZS5pbml0KGVsZW1lbnQsIG5ld1ZBLCBhbGxCaW5kaW5ncyk7XG5cbiAgdmFyIGNoYW5nZVByb3BhZ2F0b3IgPSBmdW5jdGlvbihldmVudCwgY29sb3IpIHtcbiAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAndW5kZWZpbmVkJykgbmV3RE8oY29sb3IpO1xuICB9O1xuICAkKGVsZW1lbnQpLm9uKCdjaGFuZ2UuY29sb3InLCBjaGFuZ2VQcm9wYWdhdG9yKTtcblxuICBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0ID0ge1xuICAgICAgICBjb2xvcjoga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShuZXdETyksXG4gICAgICAgIHNob3dPbjogJ2J1dHRvbidcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHZhKVxuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbG9yJyAmJiB2YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgb3B0W3Byb3BdID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YVtwcm9wXSk7XG4gICAgICAkKGVsZW1lbnQpLmNvbG9ycGlja2VyKG9wdCk7XG4gICAgfSxcbiAgICBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnRcbiAgfSk7XG5cbiAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAkKGVsZW1lbnQpLm9mZignY2hhbmdlLmNvbG9yJywgY2hhbmdlUHJvcGFnYXRvcik7XG4gICAgJChlbGVtZW50KS5jb2xvcnBpY2tlcignZGVzdHJveScpO1xuICB9KTtcblxufTtcbmtvanF1aS51dGlscy5yZWdpc3RlcihDb2xvclBpY2tlcik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xuXG4vKiBodHRwczovL2dpdGh1Yi5jb20va25vY2tvdXQva25vY2tvdXQvaXNzdWVzLzExNzEgKi9cbmtvLmJpbmRpbmdIYW5kbGVycy5jc3NUZXh0ID0ge1xuICAndXBkYXRlJzogZnVuY3Rpb24obm9kZSwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICB2YXIgdGV4dCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICB0cnkge1xuICAgICAgbm9kZS5pbm5lclRleHQgPSB0ZXh0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghbm9kZS5zdHlsZVNoZWV0KSBub2RlLmlubmVySFRNTCA9IFwiYXt9XCI7XG4gICAgICBub2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgfVxuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcblxuLyoga25vY2tvdXQgZHJvcHBhYmxlLCB3aXRoIHNpbXBsaWZpZWQgVU1EICovXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgZmFjdG9yeShrbywgJCk7XG59KShmdW5jdGlvbihrbywgJCkge1xuICB2YXIgSVRFTUtFWSA9IFwia29fc29ydEl0ZW1cIixcbiAgICBJTkRFWEtFWSA9IFwia29fc291cmNlSW5kZXhcIixcbiAgICBMSVNUS0VZID0gXCJrb19zb3J0TGlzdFwiLFxuICAgIFBBUkVOVEtFWSA9IFwia29fcGFyZW50TGlzdFwiLFxuICAgIERSQUdLRVkgPSBcImtvX2RyYWdJdGVtXCIsXG4gICAgdW53cmFwID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSxcbiAgICBkYXRhR2V0ID0ga28udXRpbHMuZG9tRGF0YS5nZXQsXG4gICAgZGF0YVNldCA9IGtvLnV0aWxzLmRvbURhdGEuc2V0O1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy5kcm9wcGFibGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KSxcbiAgICAgICAgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfHwge30sXG4gICAgICAgIGRyb3BwYWJsZSA9IHt9LFxuICAgICAgICBkcm9wQWN0dWFsO1xuXG4gICAgICAkLmV4dGVuZCh0cnVlLCBkcm9wcGFibGUsIGtvLmJpbmRpbmdIYW5kbGVycy5kcm9wcGFibGUpO1xuICAgICAgaWYgKHZhbHVlLmRhdGEpIHtcbiAgICAgICAgaWYgKHZhbHVlLm9wdGlvbnMgJiYgZHJvcHBhYmxlLm9wdGlvbnMpIHtcbiAgICAgICAgICBrby51dGlscy5leHRlbmQoZHJvcHBhYmxlLm9wdGlvbnMsIHZhbHVlLm9wdGlvbnMpO1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZS5vcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGtvLnV0aWxzLmV4dGVuZChkcm9wcGFibGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyb3BwYWJsZS5kYXRhID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGRyb3BBY3R1YWwgPSBkcm9wcGFibGUub3B0aW9ucy5kcm9wO1xuXG4gICAgICAkZWxlbWVudC5kcm9wcGFibGUoa28udXRpbHMuZXh0ZW5kKGRyb3BwYWJsZS5vcHRpb25zLCB7XG4gICAgICAgIGRyb3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG4gICAgICAgICAgdmFyIGVsID0gdWkuZHJhZ2dhYmxlWzBdLFxuICAgICAgICAgICAgaXRlbSA9IGRhdGFHZXQoZWwsIElURU1LRVkpIHx8IGRhdGFHZXQoZWwsIERSQUdLRVkpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uY2xvbmUpIHtcbiAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyb3BwYWJsZS5kcmFnZ2VkKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSBkcm9wcGFibGUuZHJhZ2dlZC5jYWxsKHRoaXMsIGl0ZW0sIGV2ZW50LCB1aSkgfHwgaXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyb3BwYWJsZS5kYXRhKSB7XG4gICAgICAgICAgICAgIGRyb3BwYWJsZS5kYXRhKGl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRyb3BBY3R1YWwpIHtcbiAgICAgICAgICAgIGRyb3BBY3R1YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvL2hhbmRsZSBlbmFibGluZy9kaXNhYmxpbmdcbiAgICAgIGlmIChkcm9wcGFibGUuaXNFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga28uY29tcHV0ZWQoe1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGVsZW1lbnQuZHJvcHBhYmxlKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZHJvcHBhYmxlLmlzRW5hYmxlZCkgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpIHtcblxuICAgIH0sXG4gICAgdGFyZ2V0SW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJNb3ZlOiBudWxsLFxuICAgIGJlZm9yZU1vdmU6IG51bGwsXG4gICAgb3B0aW9uczoge31cbiAgfTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbi8qIHV0aWxpdHkgZm9yIHRvZ2V0aGVyanMgKi9cbmtvLmJpbmRpbmdIYW5kbGVycy5mb2N1c2FibGUgPSB7XG4gICdmb2N1cyc6IGZ1bmN0aW9uKCkge30sXG4gICdibHVyJzogZnVuY3Rpb24oKSB7fSxcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICQoZWxlbWVudCkub2ZmKFwiZm9jdXNpblwiLCBrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmZvY3VzKTtcbiAgICAgICQoZWxlbWVudCkub2ZmKFwiZm9jdXNvdXRcIiwga28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZS5ibHVyKTtcbiAgICB9KTtcblxuICAgICQoZWxlbWVudCkub24oXCJmb2N1c2luXCIsIGtvLmJpbmRpbmdIYW5kbGVycy5mb2N1c2FibGUuZm9jdXMpO1xuICAgICQoZWxlbWVudCkub24oXCJmb2N1c291dFwiLCBrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmJsdXIpO1xuXG4gIH1cbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlID0ge1xuICAnc2Nyb2xsJzogZnVuY3Rpb24oKSB7fSxcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICQoZWxlbWVudCkub2ZmKFwic2Nyb2xsXCIsIGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlLnNjcm9sbCk7XG4gICAgfSk7XG5cbiAgICAkKGVsZW1lbnQpLm9uKFwic2Nyb2xsXCIsIGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlLnNjcm9sbCk7XG5cbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG5cbmtvLmV4dGVuZGVycy5wYWdpbmcgPSBmdW5jdGlvbih0YXJnZXQsIHBhZ2VTaXplKSB7XG4gIHZhciBfcGFnZVNpemUgPSBrby5vYnNlcnZhYmxlKHBhZ2VTaXplIHx8IDEwKSxcbiAgICAvLyBkZWZhdWx0IHBhZ2VTaXplIHRvIDEwXG4gICAgX2N1cnJlbnRQYWdlID0ga28ub2JzZXJ2YWJsZSgxKTsgLy8gZGVmYXVsdCBjdXJyZW50IHBhZ2UgdG8gMVxuICB0YXJnZXQucGFnZVNpemUgPSBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogX3BhZ2VTaXplLFxuICAgIHdyaXRlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID4gMCkge1xuICAgICAgICBfcGFnZVNpemUobmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3BhZ2VTaXplKDEwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRhcmdldC5jdXJyZW50UGFnZSA9IGtvLmNvbXB1dGVkKHtcbiAgICByZWFkOiBfY3VycmVudFBhZ2UsXG4gICAgd3JpdGU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPiB0YXJnZXQucGFnZUNvdW50KCkpIHtcbiAgICAgICAgX2N1cnJlbnRQYWdlKHRhcmdldC5wYWdlQ291bnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlIDw9IDApIHtcbiAgICAgICAgX2N1cnJlbnRQYWdlKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2N1cnJlbnRQYWdlKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRhcmdldC5wYWdlQ291bnQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRhcmdldCgpLmxlbmd0aCAvIHRhcmdldC5wYWdlU2l6ZSgpKSB8fCAxO1xuICB9KTtcblxuICB0YXJnZXQuY3VycmVudFBhZ2VEYXRhID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhZ2VTaXplID0gX3BhZ2VTaXplKCksXG4gICAgICBwYWdlSW5kZXggPSBfY3VycmVudFBhZ2UoKSxcbiAgICAgIHN0YXJ0SW5kZXggPSBwYWdlU2l6ZSAqIChwYWdlSW5kZXggLSAxKSxcbiAgICAgIGVuZEluZGV4ID0gcGFnZVNpemUgKiBwYWdlSW5kZXg7XG5cbiAgICByZXR1cm4gdGFyZ2V0KCkuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICB9KTtcblxuICB0YXJnZXQubW92ZUZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGFyZ2V0LmN1cnJlbnRQYWdlKDEpO1xuICB9O1xuICB0YXJnZXQubW92ZVByZXZpb3VzID0gZnVuY3Rpb24oKSB7XG4gICAgdGFyZ2V0LmN1cnJlbnRQYWdlKHRhcmdldC5jdXJyZW50UGFnZSgpIC0gMSk7XG4gIH07XG4gIHRhcmdldC5tb3ZlTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRhcmdldC5jdXJyZW50UGFnZSh0YXJnZXQuY3VycmVudFBhZ2UoKSArIDEpO1xuICB9O1xuICB0YXJnZXQubW92ZUxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICB0YXJnZXQuY3VycmVudFBhZ2UodGFyZ2V0LnBhZ2VDb3VudCgpKTtcbiAgfTtcblxuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgZ2xvYmFsOiB0cnVlICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIHNvcnRhYmxlID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddWyd1aSddWydzb3J0YWJsZSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J11bJ3VpJ11bJ3NvcnRhYmxlJ10gOiBudWxsKTtcbnZhciBkcmFnZ2FibGUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J11bJ3VpJ11bJ2RyYWdnYWJsZSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J11bJ3VpJ11bJ2RyYWdnYWJsZSddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xucmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9rbm9ja291dC1zb3J0YWJsZS9idWlsZC9rbm9ja291dC1zb3J0YWJsZS5taW4uanNcIik7XG5cbmlmICh0eXBlb2Ygc29ydGFibGUgPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IGZpbmQganF1ZXJ5LXVpIHNvcnRhYmxlIHdpZGdldCBkZXBlbmRlbmN5IVwiO1xuaWYgKHR5cGVvZiBkcmFnZ2FibGUgPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IGZpbmQganF1ZXJ5LXVpIHNvcnRhYmxlIHdpZGdldCBkZXBlbmRlbmN5IVwiO1xuXG52YXIgaXNEcmFnZ2luZ0hlbHBlciA9IGZ1bmN0aW9uKHdyaXRhYmxlLCBlKSB7XG4gIGlmICh3cml0YWJsZSgpKSB7XG4gICAgaWYgKGUudHlwZSA9PSB3cml0YWJsZSgpICsgJ3N0b3AnKSB3cml0YWJsZShmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUudHlwZSA9PSAnZHJhZ3N0YXJ0JyB8fCBlLnR5cGUgPT0gJ3NvcnRzdGFydCcpIHdyaXRhYmxlKGUudHlwZS5zdWJzdHJpbmcoMCwgNCkpO1xuICB9XG59O1xuXG52YXIgbWFrZUV4dGVuZGVkVmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBtb2RlbFZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLFxuICAgICAgdW53cmFwcGVkVmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTsgLy8gVW53cmFwIHdpdGhvdXQgc2V0dGluZyBhIGRlcGVuZGVuY3kgaGVyZVxuXG4gICAga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTtcblxuICAgIGlmIChtb2RlbFZhbHVlLm9wdGlvbnMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG1vZGVsVmFsdWUub3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBvcmlnU3RhcnQgPSBtb2RlbFZhbHVlLm9wdGlvbnMuc3RhcnQ7XG4gICAgbW9kZWxWYWx1ZS5vcHRpb25zLnN0YXJ0ID0gZnVuY3Rpb24oZSwgdWkpIHtcbiAgICAgIGlmICh0eXBlb2YgbW9kZWxWYWx1ZS5kcmFnZ2luZyAhPSAndW5kZWZpbmVkJyAmJiBrby5pc1dyaXRhYmxlT2JzZXJ2YWJsZShtb2RlbFZhbHVlLmRyYWdnaW5nKSkgaXNEcmFnZ2luZ0hlbHBlcihtb2RlbFZhbHVlLmRyYWdnaW5nLCBlKTtcbiAgICAgIGlmICh0eXBlb2YgbW9kZWxWYWx1ZS5kcm9wQ29udGFpbmVyICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1vZGVsVmFsdWUuc2Nyb2xsSW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGZvbyA9ICQobW9kZWxWYWx1ZS5kcm9wQ29udGFpbmVyKS5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAkKG1vZGVsVmFsdWUuZHJvcENvbnRhaW5lcikuc2Nyb2xsVG9wKGZvbyArIG1vZGVsVmFsdWUuYWRkaW5nKTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcmlnU3RhcnQgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBvcmlnU3RhcnQoZSwgdWkpO1xuICAgIH07XG4gICAgdmFyIG9yaWdTdG9wID0gbW9kZWxWYWx1ZS5vcHRpb25zLnN0b3A7XG4gICAgbW9kZWxWYWx1ZS5vcHRpb25zLnN0b3AgPSBmdW5jdGlvbihlLCB1aSkge1xuICAgICAgaWYgKHR5cGVvZiBtb2RlbFZhbHVlLmRyYWdnaW5nICE9ICd1bmRlZmluZWQnICYmIGtvLmlzV3JpdGFibGVPYnNlcnZhYmxlKG1vZGVsVmFsdWUuZHJhZ2dpbmcpKSBpc0RyYWdnaW5nSGVscGVyKG1vZGVsVmFsdWUuZHJhZ2dpbmcsIGUpO1xuICAgICAgaWYgKHR5cGVvZiBtb2RlbFZhbHVlLmRyb3BDb250YWluZXIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZ2xvYmFsLmNsZWFySW50ZXJ2YWwobW9kZWxWYWx1ZS5zY3JvbGxJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9yaWdTdG9wICE9ICd1bmRlZmluZWQnKSByZXR1cm4gb3JpZ1N0b3AoZSwgdWkpO1xuICAgIH07XG4gICAgdmFyIG9yaWdEcmFnID0gbW9kZWxWYWx1ZS5vcHRpb25zLmRyYWc7XG4gICAgbW9kZWxWYWx1ZS5vcHRpb25zLmRyYWcgPSBmdW5jdGlvbihlLCB1aSkge1xuICAgICAgaWYgKHR5cGVvZiBtb2RlbFZhbHVlLmRyb3BDb250YWluZXIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHRvcCA9IGUucGFnZVkgLSAkKG1vZGVsVmFsdWUuZHJvcENvbnRhaW5lcikub2Zmc2V0KCkudG9wO1xuICAgICAgICB2YXIgYm90dG9tID0gdG9wIC0gJChtb2RlbFZhbHVlLmRyb3BDb250YWluZXIpLmhlaWdodCgpO1xuICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsaW5nIHNwZWVkIGRlcGVuZGluZyBvbiBkaXN0YW5jZSBmcm9tIGJvcmRlci5cbiAgICAgICAgaWYgKHRvcCA8IC0yMCkge1xuICAgICAgICAgIG1vZGVsVmFsdWUuYWRkaW5nID0gLTIwO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiPDw8XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICBtb2RlbFZhbHVlLmFkZGluZyA9IC0xMDtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIjw8XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IDEwKSB7XG4gICAgICAgICAgbW9kZWxWYWx1ZS5hZGRpbmcgPSAtNTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIjxcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tID4gMjApIHtcbiAgICAgICAgICBtb2RlbFZhbHVlLmFkZGluZyA9IDIwO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiPj4+XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbSA+IDApIHtcbiAgICAgICAgICBtb2RlbFZhbHVlLmFkZGluZyA9IDEwO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiPj5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tID4gLTEwKSB7XG4gICAgICAgICAgbW9kZWxWYWx1ZS5hZGRpbmcgPSA1O1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiPlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbFZhbHVlLmFkZGluZyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ0RyYWcgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBvcmlnRHJhZyhlLCB1aSk7XG4gICAgfTtcblxuICAgIHJldHVybiBtb2RlbFZhbHVlO1xuICB9O1xufTtcblxua28uYmluZGluZ0hhbmRsZXJzLmV4dHNvcnRhYmxlID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZS5pbml0KGVsZW1lbnQsIG1ha2VFeHRlbmRlZFZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpIHtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlLnVwZGF0ZShlbGVtZW50LCBtYWtlRXh0ZW5kZWRWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgfVxufTtcblxua28uYmluZGluZ0hhbmRsZXJzLmV4dGRyYWdnYWJsZSA9IHtcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLmluaXQoZWxlbWVudCwgbWFrZUV4dGVuZGVkVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLnVwZGF0ZShlbGVtZW50LCBtYWtlRXh0ZW5kZWRWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlLCBJbWFnZTogZmFsc2UgKi9cblxuLy8gVGhpcyBtb2R1bGUgZGVwZW5kcyBvbiB0aG9zZSBmaWxlcywgYnV0IGl0IGRvZXNuJ3QgaGF2ZSBhIGRpcmVjdCBkZXBlbmRlbmN5LCBzbyB3ZSBkb24ndCByZXF1aXJlIHRoZW0gaGVyZS5cblxuLy9yZXF1aXJlKFwiYmx1ZWltcC1jYW52YXMtdG8tYmxvYlwiKTtcbi8vcmVxdWlyZShcImpxdWVyeS1maWxlLXVwbG9hZC9qcy9qcXVlcnkuaWZyYW1lLXRyYW5zcG9ydC5qc1wiKTtcbi8vcmVxdWlyZShcImpxdWVyeS1maWxlLXVwbG9hZC9qcy9qcXVlcnkuZmlsZXVwbG9hZC5qc1wiKTtcbi8vcmVxdWlyZShcImpxdWVyeS1maWxlLXVwbG9hZC9qcy9qcXVlcnkuZmlsZXVwbG9hZC1wcm9jZXNzLmpzXCIpO1xuLy9yZXF1aXJlKFwianF1ZXJ5LWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5maWxldXBsb2FkLWltYWdlLmpzXCIpO1xuLy9yZXF1aXJlKFwianF1ZXJ5LWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5maWxldXBsb2FkLXZhbGlkYXRlLmpzXCIpO1xuXG52YXIgJCAgICAgICA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gICAgICA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuLy8gZXhwZXJpbWVudGFsIGltYWdlIHByZWxvYWRpbmcuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ByZWxvYWRlciddID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUucHJlbG9hZGVkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YWx1ZS5wcmVsb2FkZWQgPSBrby5vYnNlcnZhYmxlKFwiXCIpO1xuXG4gICAgICB2YXIgcHJlbG9hZGVyID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IHZhbHVlLnByZWxvYWRlZCgpKSB7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YWx1ZS5wcmVsb2FkZWQobmV3VmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhbHVlLnByZWxvYWRlZChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IG5ld1ZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZS5wcmVsb2FkZWQobmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFsdWUuc3Vic2NyaWJlKHByZWxvYWRlcik7XG4gICAgICBwcmVsb2FkZXIodmFsdWUoKSk7XG4gICAgfVxuICB9XG59O1xuXG5pZiAoZmFsc2UpIHtcblxuLy8gVE9ETyB3ZSBkb24ndCB1c2UgYWR2YXR0ciBhbmQgYWR2c3R5bGUsIG1heWJlIHdlIHNob3VsZCBzaW1wbHkgcmVtb3ZlIHRoaXMgY29kZS5cbmtvLmJpbmRpbmdIYW5kbGVyc1snYWR2YXR0ciddID0ge1xuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkgfHwge30pO1xuICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godmFsdWUsIGZ1bmN0aW9uKGF0dHJOYW1lLCBhdHRyVmFsdWVBY2Nlc3Nvcikge1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcblxuICAgICAgaWYgKGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZShhdHRyVmFsdWVBY2Nlc3NvcikpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gYXR0clZhbHVlQWNjZXNzb3IoKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9IGF0dHJWYWx1ZSkge1xuICAgICAgICAgIGF0dHJWYWx1ZUFjY2Vzc29yKGF0dHJWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFkdkF0dHIgZm91bmQgYSB2YWx1ZSBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdFwiLCBhdHRyTmFtZSwgb2xkVmFsdWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gICd1cGRhdGUnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSB8fCB7fTtcbiAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihhdHRyTmFtZSwgYXR0clZhbHVlKSB7XG4gICAgICBhdHRyVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGF0dHJWYWx1ZSk7XG4gICAgICAvLyBUbyBjb3ZlciBjYXNlcyBsaWtlIFwiYXR0cjogeyBjaGVja2VkOnNvbWVQcm9wIH1cIiwgd2Ugd2FudCB0byByZW1vdmUgdGhlIGF0dHJpYnV0ZSBlbnRpcmVseVxuICAgICAgLy8gd2hlbiBzb21lUHJvcCBpcyBhIFwibm8gdmFsdWVcIi1saWtlIHZhbHVlIChzdHJpY3RseSBudWxsLCBmYWxzZSwgb3IgdW5kZWZpbmVkKVxuICAgICAgLy8gKGJlY2F1c2UgdGhlIGFic2VuY2Ugb2YgdGhlIFwiY2hlY2tlZFwiIGF0dHIgaXMgaG93IHRvIG1hcmsgYW4gZWxlbWVudCBhcyBub3QgY2hlY2tlZCwgZXRjLilcbiAgICAgIHZhciB0b1JlbW92ZSA9IChhdHRyVmFsdWUgPT09IGZhbHNlKSB8fCAoYXR0clZhbHVlID09PSBudWxsKSB8fCAoYXR0clZhbHVlID09PSB1bmRlZmluZWQpO1xuICAgICAgaWYgKHRvUmVtb3ZlKSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICBlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfSk7XG4gIH1cbn07XG5rby5iaW5kaW5nSGFuZGxlcnNbJ2FkdnN0eWxlJ10gPSB7XG4gICdpbml0JzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSB8fCB7fSk7XG4gICAga28udXRpbHMub2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oc3R5bGVOYW1lLCBzdHlsZVZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZhciBzdHlsZVZhbHVlO1xuICAgICAgaWYgKHN0eWxlTmFtZS5tYXRjaCgvUHgkLykpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVOYW1lLnN1YnN0cigwLCBzdHlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChzdHlsZVZhbHVlLm1hdGNoKC9weCQvKSkge1xuICAgICAgICAgIHN0eWxlVmFsdWUgPSBzdHlsZVZhbHVlLnJlcGxhY2UoL3B4JC8sICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFkdlN0eWxlIGJpbmRpbmcgZm91bmQgYW4gdW5leHBlY3RlZCBkZWZhdWx0IHZhbHVlXCIsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChrby5pc1dyaXRlYWJsZU9ic2VydmFibGUoc3R5bGVWYWx1ZUFjY2Vzc29yKSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBzdHlsZVZhbHVlQWNjZXNzb3IoKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9IHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICBzdHlsZVZhbHVlQWNjZXNzb3Ioc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFkdlN0eWxlIGZvdW5kIGEgdmFsdWUgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcIiwgc3R5bGVOYW1lLCBvbGRWYWx1ZSwgc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gICd1cGRhdGUnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgdmFyIHZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkgfHwge30pO1xuICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgc3R5bGVWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoc3R5bGVWYWx1ZSk7XG5cbiAgICAgIGlmIChzdHlsZVZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBzdHlsZVZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBzdHlsZVZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBzdHlsZVZhbHVlID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlTmFtZS5tYXRjaCgvUHgkLykpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVOYW1lLnN1YnN0cigwLCBzdHlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBzdHlsZVZhbHVlICsgXCJweFwiO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH0pO1xuICB9XG59O1xuXG59XG5cbi8vIFV0aWxpdHkgdG8gbG9nIGluaXppYWxpemF0aW9uIGFuZCBkaXNwb3NhbCBvZiBET00gZWxlbWVudHMuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2RvbWxvZyddID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgY29uc29sZS5sb2coXCJpbml0aWFsaXplZFwiLCBlbGVtZW50KTtcbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS5sb2coXCJkaXNwb3NlZFwiLCBlbGVtZW50KTtcbiAgICB9KTtcbiAgfVxufTtcblxua28uYmluZGluZ0hhbmRsZXJzWydmdWRyb3BwYWJsZSddID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgdmFyIG9wdCA9IHZhbHVlQWNjZXNzb3IoKSB8fCB7fTtcbiAgICB2YXIgdGltZW91dHNPYmogPSB7fTtcblxuICAgIHZhciBvdmVyID0gZnVuY3Rpb24odGltZW91dHMsIGRyb3Bab25lVGltZW91dCwgZWxlbWVudCwgY2xhc3NOYW1lLCBvYnNlcnZhYmxlLCBldmVudCkge1xuXG4gICAgICBpZiAoIXRpbWVvdXRzW2Ryb3Bab25lVGltZW91dF0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSAmJiAhb2JzZXJ2YWJsZSgpKSB7XG4gICAgICAgICAgb2JzZXJ2YWJsZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLmNsZWFyVGltZW91dCh0aW1lb3V0c1tkcm9wWm9uZVRpbWVvdXRdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZW91dHNbZHJvcFpvbmVUaW1lb3V0XSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrby5pc1dyaXRlYWJsZU9ic2VydmFibGUob2JzZXJ2YWJsZSkgJiYgb2JzZXJ2YWJsZSgpKSB7XG4gICAgICAgICAgb2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChldmVudC50eXBlID09ICdkcmFnbGVhdmUnKSBzdG9wKCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gVXNpbmcgMTAwIGl0IGRvZW5zJ3Qgd29yayBmaW5lIG9uIExpbnV4IChjaG9tZS9maXJlZm94KSwgdXNpbmcgMjAwIHN0aWxsIHNob3dzIGlzc3VlcyBvbiBzbG93IExpbnV4IGJveGVzXG4gICAgICAgIHRpbWVvdXRzW2Ryb3Bab25lVGltZW91dF0gPSBnbG9iYWwuc2V0VGltZW91dChzdG9wLCA1MDApO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGlmIChvcHQuYWN0aXZlIHx8IG9wdC5hY3RpdmVDbGFzcykge1xuICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZ2xvYmFsLCAnZHJhZ292ZXInLCBvdmVyLmJpbmQodW5kZWZpbmVkLCB0aW1lb3V0c09iaiwgJ2FjdGl2ZVRpbWVvdXQnLCBlbGVtZW50LCBvcHQuYWN0aXZlQ2xhc3MsIG9wdC5hY3RpdmUpKTtcbiAgICB9XG4gICAgaWYgKG9wdC5ob3ZlckNsYXNzKSB7XG4gICAgICAvLyBkcmFnZW50ZXIgYW5kIGRyYWdsZWF2ZSBhcmUgbm90IHJlcXVpcmVkIGJ1dCB0aGV5IHNwZWVkdXAgZmVlZGJhY2sgd2hlbiB1c2VkLlxuICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgJ2RyYWdvdmVyIGRyYWdlbnRlciBkcmFnbGVhdmUnLCBvdmVyLmJpbmQodW5kZWZpbmVkLCB0aW1lb3V0c09iaiwgJ2hvdmVyVGltZW91dCcsIGVsZW1lbnQsIG9wdC5ob3ZlckNsYXNzLCB1bmRlZmluZWQpKTtcbiAgICB9XG4gIH1cbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snZmlsZXVwbG9hZCddID0ge1xuICBleHRlbmRPcHRpb25zOiB7fSxcbiAgLy8gcmVtb3RlRmlsZVByZXByb2Nlc3NvciBtZXRob2QgaGFzIGJlZW4gc2V0IGluIGFwcC5qc1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgLy8gVE9ETyBkb21ub2RlZGlzcG9zYWwgZG9lc24ndCB3b3JrIHdoZW4gdGhlIHVwbG9hZCBpcyBkb25lIGJ5IFwiY2xpY2tpbmdcIlxuICAgIC8vIFByb2JhYmx5IGpxdWVyeS1maWxldXBsb2FkIG1vdmVzIHRoZSBET00gc29tZXdoZXJlIGVsc2Ugc28gdGhhdCBLTyBkb2Vzbid0XG4gICAgLy8gZGV0ZWN0IHRoZSByZW1vdmFsIGFueW1vcmUuXG4gICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICQoZWxlbWVudCkuZmlsZXVwbG9hZCgnZGVzdHJveScpO1xuICAgIH0pO1xuXG4gICAgLy8gaWYgd2UgbGVhdmUgdGhlIHRpdGxlIHRoZSBuYXRpdmUgY29udHJvbCB3aWxsIHNob3cgdXMgYSB0b29sdGlwIHdlIGRvbid0IHdhbnQuXG4gICAgLy8gSW4gV2ViS2l0IHRoZSByaWdodCB3YXkgdG8gcmVtb3ZlIGl0IGlzIGxlYXZpbmcgYSBcIndoaXRlc3BhY2VcIi5cbiAgICAvLyBJbiBHZWNrbyB3ZSBoYXZlIHRvIHNldCBpdCBlbXB0eS5cbiAgICBpZiAoZ2xvYmFsLndlYmtpdFVSTClcbiAgICAgICQoZWxlbWVudCkuYXR0cigndGl0bGUnLCAnICcpO1xuICAgIGVsc2VcbiAgICAgICQoZWxlbWVudCkuYXR0cigndGl0bGUnLCAnJyk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2YWx1ZUFjY2Vzc29yKCkgfHwge307XG5cbiAgICB2YXIgJGZ1ID0gJChlbGVtZW50KTtcbiAgICB2YXIgJHBhcmVudCA9ICRmdS5wYXJlbnRzKCcudXBsb2Fkem9uZScpO1xuXG4gICAgdmFyIGRhdGFWYWx1ZSA9IG9wdGlvbnMuZGF0YTtcbiAgICBvcHRpb25zLmRhdGEgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2FudmFzUHJldmlldyA9IG9wdGlvbnMuY2FudmFzUHJldmlldztcblxuICAgIC8vIFRPRE8gcmVtb3ZlIGhhcmRjb2RlZCB1cmxcbiAgICBrby51dGlscy5leHRlbmQob3B0aW9ucywge1xuICAgICAgdXJsOiAnL3VwbG9hZC8nLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGRyb3Bab25lOiAkcGFyZW50LmZpbmQoJy5tby11cGxvYWR6b25lJylbMF0sXG4gICAgICBhdXRvVXBsb2FkOiB0cnVlLFxuICAgICAgYWNjZXB0RmlsZVR5cGVzOiAvKFxcLnxcXC8pKGdpZnxqcGU/Z3xwbmcpJC9pLFxuICAgICAgbWF4RmlsZVNpemU6IDEwMjQgKiAxMDI0LFxuICAgICAgLy8gRW5hYmxlIGltYWdlIHJlc2l6aW5nLCBleGNlcHQgZm9yIEFuZHJvaWQgYW5kIE9wZXJhLFxuICAgICAgLy8gd2hpY2ggYWN0dWFsbHkgc3VwcG9ydCBpbWFnZSByZXNpemluZywgYnV0IGZhaWwgdG9cbiAgICAgIC8vIHNlbmQgQmxvYiBvYmplY3RzIHZpYSBYSFIgcmVxdWVzdHM6XG4gICAgICBkaXNhYmxlSW1hZ2VSZXNpemU6IC9BbmRyb2lkKD8hLipDaHJvbWUpfE9wZXJhLy50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgIHByZXZpZXdNYXhXaWR0aDogMjAwLFxuICAgICAgcHJldmlld01heEhlaWdodDogMjAwLFxuICAgICAgcHJldmlld0Nyb3A6IGZhbHNlLFxuICAgICAgcmVwbGFjZUZpbGVJbnB1dDogZmFsc2UsIC8vIHJlcGxhY2VGaWxlSW5wdXQgdHJ1ZSBicmVha3MgYWZ0ZXIgdXBsb2FkaW5nIHVzaW5nIFwiaW5wdXRcIiAodXNpbmcgbW91c2UgY2xpYyBpbnN0ZWFkIG9mIGRyb3BwaW5nKVxuXG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICAvLyBjbGllbnQgc2lkZVxuICAgICAgICB1bmtub3duRXJyb3I6ICdVbmtub3duIGVycm9yJyxcbiAgICAgICAgdXBsb2FkZWRCeXRlczogJ1VwbG9hZGVkIGJ5dGVzIGV4Y2VlZCBmaWxlIHNpemUnLFxuICAgICAgICBtYXhOdW1iZXJPZkZpbGVzOiAnTWF4aW11bSBudW1iZXIgb2YgZmlsZXMgZXhjZWVkZWQnLFxuICAgICAgICBhY2NlcHRGaWxlVHlwZXM6ICdGaWxlIHR5cGUgbm90IGFsbG93ZWQnLFxuICAgICAgICBtYXhGaWxlU2l6ZTogJ0ZpbGUgaXMgdG9vIGxhcmdlJyxcbiAgICAgICAgbWluRmlsZVNpemU6ICdGaWxlIGlzIHRvbyBzbWFsbCcsXG4gICAgICAgIC8vIHNlcnZlciBzaWRlXG4gICAgICAgIHBvc3RfbWF4X3NpemU6ICdUaGUgdXBsb2FkZWQgZmlsZSBleGNlZWRzIHRoZSBwb3N0X21heF9zaXplIGRpcmVjdGl2ZSBpbiBwaHAuaW5pJyxcbiAgICAgICAgbWF4X2ZpbGVfc2l6ZTogJ0ZpbGUgaXMgdG9vIGJpZycsXG4gICAgICAgIG1pbl9maWxlX3NpemU6ICdGaWxlIGlzIHRvbyBzbWFsbCcsXG4gICAgICAgIGFjY2VwdF9maWxlX3R5cGVzOiAnRmlsZXR5cGUgbm90IGFsbG93ZWQnLFxuICAgICAgICBtYXhfbnVtYmVyX29mX2ZpbGVzOiAnTWF4aW11bSBudW1iZXIgb2YgZmlsZXMgZXhjZWVkZWQnLFxuICAgICAgICBtYXhfd2lkdGg6ICdJbWFnZSBleGNlZWRzIG1heGltdW0gd2lkdGgnLFxuICAgICAgICBtaW5fd2lkdGg6ICdJbWFnZSByZXF1aXJlcyBhIG1pbmltdW0gd2lkdGgnLFxuICAgICAgICBtYXhfaGVpZ2h0OiAnSW1hZ2UgZXhjZWVkcyBtYXhpbXVtIGhlaWdodCcsXG4gICAgICAgIG1pbl9oZWlnaHQ6ICdJbWFnZSByZXF1aXJlcyBhIG1pbmltdW0gaGVpZ2h0JyxcbiAgICAgICAgYWJvcnQ6ICdGaWxlIHVwbG9hZCBhYm9ydGVkJyxcbiAgICAgICAgaW1hZ2VfcmVzaXplOiAnRmFpbGVkIHRvIHJlc2l6ZSBpbWFnZScsXG4gICAgICAgIGdlbmVyaWM6ICdVbmV4cGVjdGVkIHVwbG9hZCBlcnJvcidcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGV4dGVuZE9wdGlvbnMgaXMgc2V0dGVkIGluIGFwcC5qcyNzdGFydFxuICAgIGtvLnV0aWxzLmV4dGVuZChvcHRpb25zLCBrby5iaW5kaW5nSGFuZGxlcnNbJ2ZpbGV1cGxvYWQnXS5leHRlbmRPcHRpb25zKTtcblxuICAgIHZhciB3b3JraW5nID0gMDtcbiAgICB2YXIgZmlyc3RXb3JrZWQgPSAnJztcblxuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS13b3JraW5nID09PSAwKSB7XG4gICAgICAgIGlmIChkYXRhVmFsdWUpIHtcbiAgICAgICAgICBkYXRhVmFsdWUoZmlyc3RXb3JrZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0V29ya2VkID0gJyc7XG4gICAgICAgIGlmIChjYW52YXNQcmV2aWV3KSB7XG4gICAgICAgICAgJHBhcmVudC5maW5kKCdpbWcnKS5zaG93KCk7XG4gICAgICAgICAgJHBhcmVudC5maW5kKCdjYW52YXMnKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKFwidXBsb2FkaW5nXCIpO1xuICAgICAgICAkcGFyZW50LmZpbmQoJy5wcm9ncmVzcy1iYXInKS5jc3MoJ3dpZHRoJywgMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2xhdGVkTWVzc2FnZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tZXNzYWdlcyA9PSAnb2JqZWN0JyAmJiBvcHRpb25zLm1lc3NhZ2VzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goL14oW14gXSspKC4qKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2VzW21hdGNoWzFdXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2VzW21hdGNoWzFdXSArIG1hdGNoWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIC8vIFxuICAgIGlmIChvcHRpb25zLnVwbG9hZFRvVGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMudXJsID0ga28uYmluZGluZ0hhbmRsZXJzWydmaWxldXBsb2FkJ10uZXh0ZW5kT3B0aW9ucy51cmwudGVtcGxhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudXJsID0ga28uYmluZGluZ0hhbmRsZXJzWydmaWxldXBsb2FkJ10uZXh0ZW5kT3B0aW9ucy51cmwubWFpbGluZztcbiAgICB9XG5cbiAgICAkZnUuZmlsZXVwbG9hZChvcHRpb25zKTtcblxuICAgIHZhciBldmVudHMgPSBbJ2ZpbGV1cGxvYWRhZGQnLCAnZmlsZXVwbG9hZHByb2Nlc3NhbHdheXMnLCAnZmlsZXVwbG9hZHByb2dyZXNzYWxsJywgJ2ZpbGV1cGxvYWRkb25lJywgJ2ZpbGV1cGxvYWRmYWlsJ107XG4gICAgdmFyIGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKGUsIGRhdGEpIHtcbiAgICAgIGlmIChlLnR5cGUgPT0gJ2ZpbGV1cGxvYWRhZGQnKSB7XG4gICAgICAgIHdvcmtpbmcrKztcbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gJ2ZpbGV1cGxvYWRmYWlsJykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImZpbGV1cGxvYWRmYWlsXCIsIGUsIGRhdGEpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmVycm9yKSB7XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3JUaHJvd24gPT09ICcnICYmIGRhdGEudGV4dFN0YXR1cyA9PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uZXJyb3IodHJhbnNsYXRlZE1lc3NhZ2UoJ2dlbmVyaWMnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25lcnJvcih0cmFuc2xhdGVkTWVzc2FnZSgnZ2VuZXJpYyAoJyArIGRhdGEuZXJyb3JUaHJvd24gKyAnKScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSA9PSAnZmlsZXVwbG9hZGRvbmUnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5yZXN1bHQuZmlsZXNbMF0udXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChvcHRpb25zLm9uZmlsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnJlc3VsdC5maWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBkYXRhLnJlc3VsdC5maWxlc1tpXSA9IGtvLmJpbmRpbmdIYW5kbGVyc1snZmlsZXVwbG9hZCddLnJlbW90ZUZpbGVQcmVwcm9jZXNzb3IoZGF0YS5yZXN1bHQuZmlsZXNbaV0pO1xuICAgICAgICAgICAgICBvcHRpb25zLm9uZmlsZShkYXRhLnJlc3VsdC5maWxlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpcnN0V29ya2VkID09PSAnJykgZmlyc3RXb3JrZWQgPSBkYXRhLnJlc3VsdC5maWxlc1swXS51cmw7XG5cbiAgICAgICAgICBpZiAoY2FudmFzUHJldmlldykge1xuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGNsZWFudXA7XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGNsZWFudXA7XG4gICAgICAgICAgICBpbWcuc3JjID0gZGF0YS5yZXN1bHQuZmlsZXNbMF0udXJsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLnJlc3VsdC5maWxlc1swXS5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInJlbW90ZSBlcnJvclwiLCBlLCBkYXRhKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uZXJyb3IodHJhbnNsYXRlZE1lc3NhZ2UoZGF0YS5yZXN1bHQuZmlsZXNbMF0uZXJyb3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5leHBlY3RlZCBlcnJvclwiLCBlLCBkYXRhKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uZXJyb3IodHJhbnNsYXRlZE1lc3NhZ2UoJ2dlbmVyaWMgKFVuZXhwZWN0ZWQgRXJyb3IgcmV0cmlldmluZyB1cGxvYWRlZCBmaWxlKScpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS50eXBlID09ICdmaWxldXBsb2FkcHJvY2Vzc2Fsd2F5cycpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZGF0YS5pbmRleCxcbiAgICAgICAgICBmaWxlID0gZGF0YS5maWxlc1tpbmRleF07XG4gICAgICAgIGlmIChmaWxlLnByZXZpZXcgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY2FudmFzIHdlIGhhZCBtdWx0aXBsZSB1cGxvYWRlZCBmaWxlc1xuICAgICAgICAgIGlmICgkcGFyZW50LmZpbmQoJ2NhbnZhcycpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGNhbnZhc1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgdmFyIGVsID0gJChmaWxlLnByZXZpZXcpLmNzcygnd2lkdGgnLCAnMTAwJScpOyAvLyAuY3NzKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpLmNzcygnbGVmdCcsICcwJyk7XG4gICAgICAgICAgICAgICRwYXJlbnQuZmluZCgnaW1nJykuaGlkZSgpO1xuICAgICAgICAgICAgICAkcGFyZW50LnByZXBlbmQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHBhcmVudC5hZGRDbGFzcyhcInVwbG9hZGluZ1wiKTtcbiAgICAgICAgICAgICRwYXJlbnQuZmluZCgnLnByb2dyZXNzLWJhcicpLmNzcygnd2lkdGgnLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICAgICAgICAvLyBGaWxlIHR5cGUgbm90IGFsbG93ZWRcbiAgICAgICAgICAvLyBGaWxlIGlzIHRvbyBsYXJnZVxuICAgICAgICAgIGlmIChvcHRpb25zLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25lcnJvcih0cmFuc2xhdGVkTWVzc2FnZShmaWxlLmVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSA9PSAnZmlsZXVwbG9hZHByb2dyZXNzYWxsJykge1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBwYXJzZUludChkYXRhLmxvYWRlZCAvIGRhdGEudG90YWwgKiAxMDAsIDEwKTtcbiAgICAgICAgJHBhcmVudC5maW5kKCcucHJvZ3Jlc3MtYmFyJykuY3NzKCd3aWR0aCcsIHByb2dyZXNzICsgJyUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSBldmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBldmVudE5hbWUgPSBldmVudHNbaV07XG4gICAgICAkZnUub24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAoISQuc3VwcG9ydC5maWxlSW5wdXQpIHtcbiAgICAgICRmdS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLnBhcmVudCgpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snaWZTdWJzJ10gPSB7XG4gIC8vIGNsb25lTm9kZXMgZnJvbSBrby51dGlscy5jbG9uZU5vZGVzIChtaXNzaW5nIGluIG1pbmltaXplZCBLTylcbiAgY2xvbmVOb2RlczogZnVuY3Rpb24obm9kZXNBcnJheSwgc2hvdWxkQ2xlYW5Ob2Rlcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbm9kZXNBcnJheS5sZW5ndGgsIG5ld05vZGVzQXJyYXkgPSBbXTsgaSA8IGo7IGkrKykge1xuICAgICAgdmFyIGNsb25lZE5vZGUgPSBub2Rlc0FycmF5W2ldLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIG5ld05vZGVzQXJyYXkucHVzaChzaG91bGRDbGVhbk5vZGVzID8ga28uY2xlYW5Ob2RlKGNsb25lZE5vZGUpIDogY2xvbmVkTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2Rlc0FycmF5O1xuICB9LFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGRpZERpc3BsYXlPbkxhc3RVcGRhdGUsXG4gICAgICBzYXZlZE5vZGVzLFxuICAgICAgdmFsdWVBY2MgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZUFjYy5kYXRhLnN1YnNDb3VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGtvLmV4dGVuZGVyc1snc3Vic2NyaXB0aW9uc0NvdW50J10odmFsdWVBY2MuZGF0YSk7XG4gICAgICAvLyBOT1RFIEkgY2FuJ3Qgc2ltcGx5IGxpc3RlbiBvbiBcInRocmVzaG9sZHNcIiBiZWNhdXNlIG11bHRpcGxlIGJpbmRpbmdzIHRvIHRoZSBzYW1lIG9ic2VydmFibGUgY291bGQgdXNlIGRpZmZlcmVudCB0aHJlc2hvbGRzLlxuICAgIH1cbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKS5kYXRhLnN1YnNDb3VudCksXG4gICAgICAgIGlzRmlyc3RSZW5kZXIgPSAhc2F2ZWROb2RlcyxcbiAgICAgICAgc2hvdWxkRGlzcGxheSwgbmVlZHNSZWZyZXNoLCBndXR0ZXI7XG5cbiAgICAgIGd1dHRlciA9IC0odHlwZW9mIHZhbHVlQWNjZXNzb3IoKS5ndXR0ZXIgIT09ICd1bmRlZmluZWQnID8gdmFsdWVBY2Nlc3NvcigpLmd1dHRlciA6IDEpO1xuICAgICAgc2hvdWxkRGlzcGxheSA9IGRhdGFWYWx1ZSArIChkaWREaXNwbGF5T25MYXN0VXBkYXRlID8gZ3V0dGVyIDogMCkgPj0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjYy50aHJlc2hvbGQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUFjY2Vzc29yKCkubm90ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZUFjY2Vzc29yKCkubm90KSB7XG4gICAgICAgIHNob3VsZERpc3BsYXkgPSAhc2hvdWxkRGlzcGxheTtcbiAgICAgIH1cbiAgICAgIG5lZWRzUmVmcmVzaCA9IGlzRmlyc3RSZW5kZXIgfHwgKHNob3VsZERpc3BsYXkgIT09IGRpZERpc3BsYXlPbkxhc3RVcGRhdGUpO1xuXG4gICAgICBpZiAobmVlZHNSZWZyZXNoKSB7XG4gICAgICAgIC8vIFNhdmUgYSBjb3B5IG9mIHRoZSBpbm5lciBub2RlcyBvbiB0aGUgaW5pdGlhbCB1cGRhdGUsIGJ1dCBvbmx5IGlmIHdlIGhhdmUgZGVwZW5kZW5jaWVzLlxuICAgICAgICBpZiAoaXNGaXJzdFJlbmRlciAmJiBrby5jb21wdXRlZENvbnRleHQuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKSkge1xuICAgICAgICAgIHNhdmVkTm9kZXMgPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2lmU3VicyddLmNsb25lTm9kZXMoa28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMoZWxlbWVudCksIHRydWUgLyogc2hvdWxkQ2xlYW5Ob2RlcyAqLyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZERpc3BsYXkpIHtcbiAgICAgICAgICBpZiAoIWlzRmlyc3RSZW5kZXIpIHtcbiAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5zZXREb21Ob2RlQ2hpbGRyZW4oZWxlbWVudCwga28uYmluZGluZ0hhbmRsZXJzWydpZlN1YnMnXS5jbG9uZU5vZGVzKHNhdmVkTm9kZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga28uYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMoYmluZGluZ0NvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGUoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBkaWREaXNwbGF5T25MYXN0VXBkYXRlID0gc2hvdWxkRGlzcGxheTtcbiAgICAgIH1cbiAgICB9LCBudWxsLCB7XG4gICAgICBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgJ2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzJzogdHJ1ZVxuICAgIH07XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWydpZlN1YnMnXSA9IHRydWU7XG5cbi8vIGtvLmlzV3JpdGFibGVPYnNlcnZhYmxlICh3aXRob3V0IFwiZVwiKSBoYXMgYmVlbiBpbnRyb2R1Y2VkIGluIDMuMi4wLCB0aGF0IGlzIGFsc28gb3VyIG1pbiByZXF1aXJlbWVudC5cbi8vIG1pbmltaXplZCBrbm9ja291dCBcIm9iZnVzY2F0ZVwiIHRoZSBiZWZvcmVTdWJzY3JpcHRpb25BZGQgYW5kIGFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlIG1ldGhvZHMgdGhhdCB3ZSBoYWNrIGhlcmUuXG4vLyBzbyB3ZSBoYXZlIHRvIGV4cGxpY2l0bHkga25vdyB0aGF0LlxuLy8gTm90ZTogd2UgdXNlZCB0byB1c2Uga28uREVCVUcgdG8gZGV0ZWN0IHRoZSBkZWJ1ZyB2ZXJzaW9uIG9mIEtPLCBidXQgdGhpcyB3YXMgcmVtb3ZlZCBpbiBLTyAzLjQuMCssIFxuLy8gICAgICAgc28gd2Ugc3dpdGNoZWQgdG8ga28uc3Vic2NyaXB0aW9uIGZ1bmN0aW9uIHRoYXQgb25seSBleGlzdHMgaW4gREVCVUcgdmVyc2lvbnMuXG52YXIgYmVmb3JlU3Vic2NyaXB0aW9uUHJvcDtcbnZhciBhZnRlclN1YnNjcmlwdGlvblByb3A7XG5pZiAodHlwZW9mIGtvLnN1YnNjcmlwdGlvbiA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBrby5pc1dyaXRhYmxlT2JzZXJ2YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmVmb3JlU3Vic2NyaXB0aW9uUHJvcCA9ICdiZWZvcmVTdWJzY3JpcHRpb25BZGQnO1xuICBhZnRlclN1YnNjcmlwdGlvblByb3AgPSAnYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUnO1xufSBlbHNlIGlmIChrby52ZXJzaW9uID09IFwiMy4yLjBcIikge1xuICBiZWZvcmVTdWJzY3JpcHRpb25Qcm9wID0gJ3ZhJztcbiAgYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wID0gJ25iJztcbn0gZWxzZSBpZiAoa28udmVyc2lvbiA9PSBcIjMuMy4wXCIpIHtcbiAgYmVmb3JlU3Vic2NyaXB0aW9uUHJvcCA9ICdqYSc7XG4gIGFmdGVyU3Vic2NyaXB0aW9uUHJvcCA9ICd1YSc7XG59IGVsc2UgaWYgKGtvLnZlcnNpb24gPT0gXCIzLjQuMFwiKSB7XG4gIGJlZm9yZVN1YnNjcmlwdGlvblByb3AgPSAnc2EnO1xuICBhZnRlclN1YnNjcmlwdGlvblByb3AgPSAnSWEnO1xufSBlbHNlIGlmIChrby52ZXJzaW9uID09IFwiMy40LjFcIikge1xuICBiZWZvcmVTdWJzY3JpcHRpb25Qcm9wID0gJ3NhJztcbiAgYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wID0gJ0lhJztcbn1cbmVsc2UgdGhyb3cgXCJVbnN1cHBvcnRlZCBtaW5pbWl6ZWQgS25vY2tvdXQgdmVyc2lvbiBcIiArIGtvLnZlcnNpb24gKyBcIiAoc3VwcG9ydGVkIERFQlVHIG9yIG1pbmltaXplZCAzLjIuMCAuLi4gMy40LjEpXCI7XG5cbi8vIGludGVybmFsbHkgdXNlZCBieSBpZnN1YnMgYmluZGluZy5cbi8vIFdBUk5JTkcgdGhpcyBicmVhayB3aGVuIHVzZWQgd2l0aCBwdXJlQ29tcHV0ZWQgb3IgZGVmZXJyZWRFdmFsdWF0ZWRcbmtvLmV4dGVuZGVyc1snc3Vic2NyaXB0aW9uc0NvdW50J10gPSBmdW5jdGlvbih0YXJnZXQsIGwxLCBsMikge1xuICBpZiAodHlwZW9mIHRhcmdldC5zdWJzQ291bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGFyZ2V0LnN1YnNDb3VudCA9IGtvLm9ic2VydmFibGUodGFyZ2V0LmdldFN1YnNjcmlwdGlvbnNDb3VudCgpKS5leHRlbmQoe1xuICAgICAgbm90aWZ5OiAnYWx3YXlzJ1xuICAgIH0pO1xuICAgIHZhciB1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24gPSB0YXJnZXRbYmVmb3JlU3Vic2NyaXB0aW9uUHJvcF07XG4gICAgdmFyIHVuZGVybHlpbmdBZnRlclN1YnNjcmlwdGlvblJlbW92ZUZ1bmN0aW9uID0gdGFyZ2V0W2FmdGVyU3Vic2NyaXB0aW9uUHJvcF07XG4gICAgdGFyZ2V0W2JlZm9yZVN1YnNjcmlwdGlvblByb3BdID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmICh1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24pIHVuZGVybHlpbmdCZWZvcmVTdWJzY3JpcHRpb25BZGRGdW5jdGlvbi5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgdmFyIGMgPSB0YXJnZXQuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkgKyAxO1xuICAgICAgaWYgKHR5cGVvZiBsMSA9PT0gJ3VuZGVmaW5lZCcgfHwgYyA9PSBsMSB8fCB0eXBlb2YgbDIgPT09ICd1bmRlZmluZWQnIHx8IGMgPT0gbDIpIHRhcmdldC5zdWJzQ291bnQoYyk7XG4gICAgfTtcbiAgICB0YXJnZXRbYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAodW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24pIHVuZGVybHlpbmdBZnRlclN1YnNjcmlwdGlvblJlbW92ZUZ1bmN0aW9uLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICB2YXIgYyA9IHRhcmdldC5nZXRTdWJzY3JpcHRpb25zQ291bnQoKTtcbiAgICAgIGlmICh0eXBlb2YgbDEgPT09ICd1bmRlZmluZWQnIHx8IGMgPT0gbDEgfHwgdHlwZW9mIGwyID09PSAndW5kZWZpbmVkJyB8fCBjID09IGwyKSB0YXJnZXQuc3Vic0NvdW50KGMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXCJhbHJlYWR5IGFwcGxpZWQgc3Vic2NyaXB0aW9uQ291bnQgdG8gb2JzZXJ2YWJsZVwiKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gT3ZlcnJpZGVzIG5hdGl2ZSBqUXVlcnkgc3Bpbm5lciB0byBhdm9pZCB2YWxpZGF0aW9uIG9mIHRoZSBcInN0ZXBcIi5cbi8vIFdlIHdhbnRzIHRvIHVzZSB0aGUgc3RlcCBidXQgYWxzbyB3YW50cyB0byBsZWF2ZSB0aGUgdXNlciB0aGUgYWJpbGl0eSB0byBzZWxlY3Qgc3BlY2lmaWMgdmFsdWVzLlxuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIgc3Bpbm5lciA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXVsndWknXVsnc3Bpbm5lciddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J11bJ3VpJ11bJ3NwaW5uZXInXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuaWYgKHR5cGVvZiBzcGlubmVyID09ICd1bmRlZmluZWQnKSB0aHJvdyBcIkNhbm5vdCBmaW5kIGpxdWVyeS11aSBzcGlubmVyIHdpZGdldCBkZXBlbmRlbmN5IVwiO1xuXG4kLndpZGdldChcInVpLnNwaW5uZXJcIiwgc3Bpbm5lciwge1xuICBfYWRqdXN0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGFkaiA9IHRoaXMuX3N1cGVyKHZhbHVlKTtcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgLy8gZml4IHByZWNpc2lvbiBmcm9tIGJhZCBKUyBmbG9hdGluZyBwb2ludCBtYXRoXG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKCkpKTtcblxuICAgIC8vIGNsYW1wIHRoZSB2YWx1ZVxuICAgIGlmIChvcHRpb25zLm1heCAhPT0gbnVsbCAmJiB2YWx1ZSA+IG9wdGlvbnMubWF4KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5tYXg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1pbiAhPT0gbnVsbCAmJiB2YWx1ZSA8IG9wdGlvbnMubWluKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5taW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBPdmVycmlkZXMgbmF0aXZlIGpRdWVyeSB0YWJzIHRvIG1ha2UgdGFicyB3b3JraW5nIGFsc28gd2hlbiB1c2luZyBhIGJhc2UgdGFnXG4vLyBpbiBvcmRlciB0byBhdm9pZCBjb25mbGljdHMgeW91IGhhdmUgdG8gYWRkIGEgZGF0YS1sb2NhbD1cInRydWVcIiBhdHRyaWJ1dGUgdG8geW91ciB0YWIgbGlua3MuXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgdGFicyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXVsndWknXVsndGFicyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J11bJ3VpJ11bJ3RhYnMnXSA6IG51bGwpO1xuXG5pZiAodHlwZW9mIHRhYnMgPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IGZpbmQganF1ZXJ5LXVpIHRhYnMgd2lkZ2V0IGRlcGVuZGVuY3khXCI7XG5cbiQud2lkZ2V0KFwidWkudGFic1wiLCB0YWJzLCB7XG4gIF9pc0xvY2FsOiBmdW5jdGlvbiggYW5jaG9yICkge1xuICAgIGlmIChhbmNob3IuZ2V0QXR0cmlidXRlKCdkYXRhLWxvY2FsJykgPT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgIGVsc2UgcmV0dXJuIHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuICB9XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgZ2xvYmFsOiBmYWxzZSAqL1xuXG5mdW5jdGlvbiBwdXNoVGVtcGxhdGUodGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZVRleHQpIHtcbiAgdmFyIHNjcmlwdFRhZyA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0VGFnLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2h0bWwnKTtcbiAgc2NyaXB0VGFnLnNldEF0dHJpYnV0ZSgnaWQnLCB0ZW1wbGF0ZU5hbWUpO1xuICBzY3JpcHRUYWcudGV4dCA9IHRlbXBsYXRlVGV4dDtcbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGVtcGxhdGUodGVtcGxhdGVOYW1lKSB7XG4gIHZhciBlbCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZU5hbWUpO1xuICBpZiAoZWwpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xufVxuXG5mdW5jdGlvbiBpbml0KCkge31cblxuZnVuY3Rpb24gZ2V0VGVtcGxhdGVDb250ZW50KGlkKSB7XG4gIHZhciBlbCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gIGlmIChlbCkgcmV0dXJuIGVsLmlubmVySFRNTDtcbiAgZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogaW5pdCxcbiAgYWRkVGVtcGxhdGU6IHB1c2hUZW1wbGF0ZSxcbiAgcmVtb3ZlVGVtcGxhdGU6IHJlbW92ZVRlbXBsYXRlLFxuICBnZXRUZW1wbGF0ZUNvbnRlbnQ6IGdldFRlbXBsYXRlQ29udGVudFxufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciB0aW55bWNlID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3RpbnltY2UnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ3RpbnltY2UnXSA6IG51bGwpO1xuXG52YXIgdGltZW91dDtcblxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC52aXNpYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEBzZWUgRmxvYXRQYW5lbC5qcyBmdW5jdGlvbiByZXBvc2l0aW9uUGFuZWwocGFuZWwpXG4gICAgLy8gRmlyc3QgY29uZGl0aW9uIGdyb3VwIGlzIGZvciBUaW55bWNlIDQuMC80LjFcbiAgICAvLyBTZWNvbmQgY29uZGl0aW9uIGdyb3VwIGlzIGZvciBUaW55bWNlIDQuMi80LjMgd2hlcmUgXCIuX3Byb3BlcnR5XCIgYXJlIG5vdyBhdmFpbGFibGUgYXMgXCIuc3RhdGUuZ2V0KCdwcm9wZXJ0eScpXCIuXG4gICAgaWYgKCh0eXBlb2YgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuX3Zpc2libGUgIT09ICd1bmRlZmluZWQnICYmIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLl92aXNpYmxlICYmIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLl9maXhlZCkgfHxcbiAgICAgICAgKHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5zdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuc3RhdGUuZ2V0KCd2aXNpYmxlJykgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuc3RhdGUuZ2V0KCdmaXhlZCcpKSkge1xuICAgICAgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuZml4ZWQoZmFsc2UpO1xuICAgIH1cblxuICAgIHRpbnltY2UuYWN0aXZlRWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgLy8gRG9uJ3QgZm9yY2UgdGlueW1jZSB0byBiZSB2aXNpYmxlIG9uIHNjcm9sbHNcbiAgICAvLyBJZiBzZXR0ZWQsIFRoaXMgd2lsbCBzaG93IHRoZSB0aW55bWNlIGNvbnRyb2xzIGV2ZW50IHdoZW4gbm9uZSBhcmUgc2VsZWN0ZWRcbiAgICAvLyB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC52aXNpYmxlKHRydWUpO1xuICAgIGlmICh0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5sYXlvdXRSZWN0KCkueSA8PSA0MClcbiAgICAgIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLm1vdmVCeSgwLCA0MCAtIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLmxheW91dFJlY3QoKS55KTtcblxuICB9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1Njcm9sbGZpeCA9IHtcbiAgJ3Njcm9sbCc6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRpbWVvdXQpIGdsb2JhbC5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0KHJlbmRlciwgNTApO1xuICB9LFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJChlbGVtZW50KS5vZmYoXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTY3JvbGxmaXguc2Nyb2xsKTtcbiAgICB9KTtcblxuICAgICQoZWxlbWVudCkub24oXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTY3JvbGxmaXguc2Nyb2xsKTtcblxuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxudmFyIF9zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uKCRlbGVtZW50LCBhbGlnblRvcCwgc2Nyb2xsUGFyZW50LCBtb3ZlQnkpIHtcbiAgdmFyIGN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCk7XG4gIHZhciBuZXdTY3JvbGxUb3AgPSBjdXJyZW50U2Nyb2xsVG9wIC0gbW92ZUJ5IC0gKGFsaWduVG9wID8gMjAgOiAtMjApO1xuICAvLyBpZnJhbWUgc2Nyb2xscyB0aGUgd2luZG93IGFuZCBhbmltYXRpb24gaXMgbm90IHN1cHBvcnRlZFxuICB2YXIgYW5pbWF0ZSA9IHR5cGVvZiBzY3JvbGxQYXJlbnRbMF0ubm9kZVR5cGUgIT09ICd1bmRlZmluZWQnO1xuICBpZiAoYW5pbWF0ZSkge1xuICAgIHZhciBhY3Rpb24gPSB7XG4gICAgICAnc2Nyb2xsVG9wJzogXCJcIiArIE1hdGgucm91bmQobmV3U2Nyb2xsVG9wKSArIFwicHhcIlxuICAgIH07XG4gICAgdmFyIHRpbWUgPSBNYXRoLnJvdW5kKE1hdGguYWJzKG5ld1Njcm9sbFRvcCAtIGN1cnJlbnRTY3JvbGxUb3ApKTtcbiAgICBzY3JvbGxQYXJlbnQuc3RvcCgpLmFuaW1hdGUoYWN0aW9uLCB0aW1lKTtcbiAgfSBlbHNlIHtcbiAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKG5ld1Njcm9sbFRvcCk7XG4gIH1cbiAgLy8gbmF0aXZlIHNjcm9sbEludG9WaWV3IGlzIG5vdCB3ZWxsIHN1cHBvcnRlZCBhbmQgZG9lc24ndCB3b3JrIGZpbmUuXG4gIC8vIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoYWxpZ25Ub3ApO1xufTtcblxua28uYmluZGluZ0hhbmRsZXJzLnNjcm9sbEludG9WaWV3ID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgaWYgKCFzZWxlY3RlZCkgcmV0dXJuO1xuICAgIHRyeSB7XG5cbiAgICAgIHdoaWxlIChlbGVtZW50Lm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgIC8vIGVsZW1lbnQgaXMgYSBjb21tZW50LCBtb3ZlIHRvIHRoZSBuZXh0IHNpYmxpbmcuLi5cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAgICB2YXIgc2Nyb2xsUGFyZW50ID0gJChlbGVtZW50KS5zY3JvbGxQYXJlbnQoKTtcblxuICAgICAgICB2YXIgcGFyZW50VG9wO1xuICAgICAgICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNjcm9sbFBhcmVudFswXS5ub2RlVHlwZSA9PSA5KSB7XG4gICAgICAgICAgLy8gc2Nyb2xscGFyZW50IGlzIGRvY3VtZW50LCByZXBsYWNpbmcgd2l0aCBib2R5Li4uXG4gICAgICAgICAgc2Nyb2xsUGFyZW50ID0gJChzY3JvbGxQYXJlbnRbMF0uZGVmYXVsdFZpZXcpO1xuICAgICAgICAgIHBhcmVudFRvcCA9IDA7XG4gICAgICAgICAgcmVsYXRpdmVPZmZzZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvcCA9IHNjcm9sbFBhcmVudC5vZmZzZXQoKS50b3A7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50SGVpZ2h0ID0gc2Nyb2xsUGFyZW50LmhlaWdodCgpO1xuICAgICAgICB2YXIgcGFyZW50U2Nyb2xsID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xuICAgICAgICB2YXIgcGFyZW50Qm90dG9tID0gcGFyZW50VG9wICsgcGFyZW50SGVpZ2h0O1xuXG4gICAgICAgIC8vIHNjcm9sbFBhcmVudCBpcyB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIHZhciBlbFRvcCA9ICRlbGVtZW50Lm9mZnNldCgpLnRvcDtcbiAgICAgICAgLy8gd2hlbiB3ZSBhcmUgaW4gXCJpZnJhbWVcIiB3aXRoIHNjcm9sbGJhciBldmVyeXRoaWpuZyBjaGFuZ2VzLlxuICAgICAgICBpZiAocmVsYXRpdmVPZmZzZXQpIGVsVG9wID0gZWxUb3AgLSBwYXJlbnRTY3JvbGw7XG4gICAgICAgIHZhciBlbEhlaWdodCA9ICRlbGVtZW50LmhlaWdodCgpO1xuICAgICAgICB2YXIgZWxCb3R0b20gPSBlbFRvcCArIGVsSGVpZ2h0O1xuICAgICAgICBpZiAoZWxUb3AgPiBwYXJlbnRUb3AgJiYgZWxUb3AgKyBlbEhlaWdodCA8IHBhcmVudEJvdHRvbSkge1xuICAgICAgICAgIC8vIGJvdGggYm9yZGVycyBhcmUgdmlzaWJsZSA9PiBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgfSBlbHNlIGlmIChlbEhlaWdodCA8IHBhcmVudEhlaWdodCkge1xuICAgICAgICAgIC8vIGlmIHRoZSBibG9jayBpcyBzbWFsbGVyIHRoYW4gdGhlIHZpZXdQb3J0XG4gICAgICAgICAgaWYgKGVsVG9wIDwgcGFyZW50VG9wKSBfc2Nyb2xsSW50b1ZpZXcoZWxlbWVudCwgdHJ1ZSwgc2Nyb2xsUGFyZW50LCBwYXJlbnRUb3AgLSBlbFRvcCk7XG4gICAgICAgICAgLy8gLT4gaWYgdGhlIHVwcGVyIGJvcmRlciBpcyBoaWdoZXIgdGhhbiB0aGUgdG9wLCB0aGVuIEkgbW92ZSBpdCB0byB0aGUgdG9wLlxuICAgICAgICAgIGlmIChlbEJvdHRvbSA+IHBhcmVudEJvdHRvbSkgX3Njcm9sbEludG9WaWV3KGVsZW1lbnQsIGZhbHNlLCBzY3JvbGxQYXJlbnQsIHBhcmVudEJvdHRvbSAtIGVsQm90dG9tKTtcbiAgICAgICAgICAvLyAtPiBpZiB0aGUgYm90dG9tIGJvcmRlciBpcyBsb3dlciB0aGFuIHRoZSBib3R0b20gdGhlbiBJIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgYmxvY2sgaXMgbGFyZ2VyIHRoYW4gdGhlIHZpZXdQb3J0IHdlIGRvIHRoZSBvcHBvc2l0ZSFcbiAgICAgICAgICAvLyAtPiBpZiB0aGUgdXBwZXIgYm9yZGVyIGlzIGhpZ2hlciB0aGFuIHRoZSB0b3AgYW5kIHRoZSBsb3dlciBpcyBoaWdoZXIgdGhhbiB0aGUgYm90dG9tIEkgbW92ZSB0aGUgbG93ZXIgaXQgdG8gdGhlIGJvdHRvbS5cbiAgICAgICAgICBpZiAoZWxUb3AgPCBwYXJlbnRUb3AgJiYgZWxCb3R0b20gPCBwYXJlbnRCb3R0b20pIF9zY3JvbGxJbnRvVmlldyhlbGVtZW50LCBmYWxzZSwgc2Nyb2xsUGFyZW50LCBwYXJlbnRCb3R0b20gLSBlbEJvdHRvbSk7XG4gICAgICAgICAgLy8gLT4gaWYgdGhlIGJvdHRvbSBib3JkZXIgaWwgbG93ZXIgdGhhbiBib3R0b20gYW5kIHRoZSB1cHBlciBpcyBsb3dlciB0aGFuIHRoZSB0b3AgSSBtb3ZlIHRoZSB1cHBlciBib3JkZXIgdG8gdGhlIHZpZXdwb3J0IHRvcFxuICAgICAgICAgIGlmIChlbFRvcCA+IHBhcmVudFRvcCAmJiBlbEJvdHRvbSA+IHBhcmVudEJvdHRvbSkgX3Njcm9sbEludG9WaWV3KGVsZW1lbnQsIHRydWUsIHNjcm9sbFBhcmVudCwgcGFyZW50VG9wIC0gZWxUb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWxlbWVudC5zY3JvbGxJbnRvVmlldyh0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlRPRE8gZXhjZXB0aW9uIHNjcm9sbGluZyBpbnRvIHZpZXdcIiwgZSk7XG4gICAgfVxuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snc2Nyb2xsSW50b1ZpZXcnXSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIG9yaWdUZW1wbGF0ZVN5c3RlbSA9IHJlcXVpcmUoXCIuL3NjcmlwdC10ZW1wbGF0ZS5qc1wiKTtcblxudmFyIHRlbXBsYXRlcyA9IHt9O1xuXG4vL2RlZmluZSBhIHRlbXBsYXRlIHNvdXJjZSB0aGF0IHNpbXBseSB0cmVhdHMgdGhlIHRlbXBsYXRlIG5hbWUgYXMgaXRzIGNvbnRlbnRcbmtvLnRlbXBsYXRlU291cmNlcy5zdHJpbmdUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRlbXBsYXRlTmFtZSwgdGVtcGxhdGUpIHtcbiAgdGhpcy50ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZU5hbWU7XG4gIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgdGhpcy5fZGF0YSA9IHt9O1xufTtcblxua28udXRpbHMuZXh0ZW5kKGtvLnRlbXBsYXRlU291cmNlcy5zdHJpbmdUZW1wbGF0ZS5wcm90b3R5cGUsIHtcbiAgZGF0YTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZGF0YVwiLCBrZXksIHZhbHVlLCB0aGlzLnRlbXBsYXRlTmFtZSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhW2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YVtrZXldID0gdmFsdWU7XG4gIH0sXG4gIHRleHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJ0ZXh0XCIsIHZhbHVlLCB0aGlzLnRlbXBsYXRlTmFtZSlcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGU7XG4gICAgfVxuICAgIHRoaXMudGVtcGxhdGUgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblxuLy9tb2RpZnkgYW4gZXhpc3RpbmcgdGVtcGxhdGVFbmdpbmUgdG8gd29yayB3aXRoIHN0cmluZyB0ZW1wbGF0ZXNcbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1RlbXBsYXRlRW5naW5lKHRlbXBsYXRlRW5naW5lKSB7XG4gIHZhciBvcmlnID0gdGVtcGxhdGVFbmdpbmUubWFrZVRlbXBsYXRlU291cmNlO1xuICB0ZW1wbGF0ZUVuZ2luZS5tYWtlVGVtcGxhdGVTb3VyY2UgPSBmdW5jdGlvbih0ZW1wbGF0ZU5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBrby50ZW1wbGF0ZVNvdXJjZXMuc3RyaW5nVGVtcGxhdGUodGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZXNbdGVtcGxhdGVOYW1lXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcmlnKHRlbXBsYXRlTmFtZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdGVtcGxhdGVFbmdpbmU7XG59XG5cbmZ1bmN0aW9uIHB1c2hUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUsIHRlbXBsYXRlVGV4dCkge1xuICB0ZW1wbGF0ZXNbdGVtcGxhdGVOYW1lXSA9IHRlbXBsYXRlVGV4dDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGVtcGxhdGUodGVtcGxhdGVOYW1lKSB7XG4gIGlmICh0eXBlb2YgdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0gPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgb3JpZ1RlbXBsYXRlU3lzdGVtLnJlbW92ZVRlbXBsYXRlKHRlbXBsYXRlTmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAga28uc2V0VGVtcGxhdGVFbmdpbmUoY3JlYXRlU3RyaW5nVGVtcGxhdGVFbmdpbmUobmV3IGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lKCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGVtcGxhdGVDb250ZW50KGlkKSB7XG4gIGlmICh0eXBlb2YgdGVtcGxhdGVzW2lkXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVzW2lkXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb3JpZ1RlbXBsYXRlU3lzdGVtLmdldFRlbXBsYXRlQ29udGVudChpZCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6IGluaXQsXG4gIGFkZFRlbXBsYXRlOiBwdXNoVGVtcGxhdGUsXG4gIHJlbW92ZVRlbXBsYXRlOiByZW1vdmVUZW1wbGF0ZSxcbiAgZ2V0VGVtcGxhdGVDb250ZW50OiBnZXRUZW1wbGF0ZUNvbnRlbnRcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGtvanF1aSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wydrb2pxdWknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvanF1aSddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG52YXIgZXh0ZW5kVmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IsIG9iaikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAga28udXRpbHMuZXh0ZW5kKG9iaiwgdmFsdWVBY2Nlc3NvcigpKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xufTtcblxudmFyIG9wdGlvbnMgPSB7XG4gIHNob3c6IHtcbiAgICBkZWxheTogNTAwXG4gIH0sXG4gIHRyYWNrOiB0cnVlLFxuICBpdGVtczogJ1t0aXRsZV1bdGl0bGUhPVwiXCJdW3RpdGxlIT1cIiBcIl0nXG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnMudG9vbHRpcHMgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mICQuZm4udG9vbHRpcCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGtvLmJpbmRpbmdIYW5kbGVycy50b29sdGlwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gcG9zaXRpb246IHsgbXk6IFwibGVmdCsxNSB0b3ArMTVcIiwgYXQ6IFwiY2VudGVyKzMwIGNlbnRlciszMFwiIH1cbiAgICAgIC8vIE5PVEUgdGl0bGUgd2l0aCBcIlwiIGFuZCBcIiBcIiBpcyBuZWVkZWQgdG8gYXZvaWQgZGVmYXVsdCB0b29sdGlwcyBpbiBuYXRpdmUgZmlsZSB1cGxvYWQgY29udHJvbHNcbiAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMudG9vbHRpcC5pbml0KGVsZW1lbnQsIGV4dGVuZFZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3Nvciwgb3B0aW9ucyksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiAkLmZuLnRvb2x0aXAgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBrby5iaW5kaW5nSGFuZGxlcnMudG9vbHRpcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMudG9vbHRpcC51cGRhdGUoZWxlbWVudCwgZXh0ZW5kVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yLCBvcHRpb25zKSwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCk7XG4gICAgfVxuICB9LFxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG4vLyBlcXVhbHMgdG8gXCJ2YWx1ZVwiIGJpbmRpbmcgYnV0IGFwcGx5IFwiaW52YWxpZFwiIGNsYXNzIGlmIFwicGF0dGVyblwiIGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCB2YWx1ZSBtYXRjaGVzIHRoZSBydWxlXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZhbGlkYXRlZFZhbHVlJ10gPSB7XG5cdGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG5cdFx0dmFyIG5ld1ZhbHVlQWNjZXNzb3IgPSB2YWx1ZUFjY2Vzc29yO1xuXHRcdGlmICh0eXBlb2YgZWxlbWVudC5wYXR0ZXJuICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dmFyIHJlID0gbmV3IFJlZ0V4cCgnXig/OicgKyBlbGVtZW50LnBhdHRlcm4gKyAnKSQnKTtcblx0XHRcdHZhciBjb21wdXRlZCA9IGtvLmNvbXB1dGVkKHtcblx0XHRcdFx0cmVhZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHJlcyA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcblx0XHRcdFx0XHQvLyBUT0RPIHN1cHBvcnQgZm9yIGVsZW1lbnQucmVxdWlyZWQgP1xuXHRcdFx0XHRcdHZhciB2YWxpZCA9IHJlcyA9PT0gbnVsbCB8fCByZXMgPT09ICcnIHx8IHJlLnRlc3QocmVzKTtcblx0XHRcdFx0XHQvLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBjbGFzc0xpc3QudG9nZ2xlKCdpbnZhbGlkJywgc3RhdGUpXG5cdFx0XHRcdFx0aWYgKHZhbGlkKSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2ludmFsaWQnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpbnZhbGlkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyaXRlOiBrby5pc1dyaXRlYWJsZU9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSAmJiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZvaWRsYWJzL21vc2FpY28vaXNzdWVzLzEwM1xuXHRcdFx0XHRcdGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShlbGVtZW50LCB2YWx1ZSk7XG5cdFx0XHRcdFx0dmFyIHVwZFZhbHVlID0ga28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudCk7XG5cdFx0XHRcdFx0dmFsdWVBY2Nlc3NvcigpKHVwZFZhbHVlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG5cdFx0XHR9KTtcblx0XHRcdG5ld1ZhbHVlQWNjZXNzb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbXB1dGVkO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0a28uYmluZGluZ0hhbmRsZXJzWyd2YWx1ZSddLmluaXQoZWxlbWVudCwgbmV3VmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpO1xuXHR9XG59O1xua28uZXhwcmVzc2lvblJld3JpdGluZy5fdHdvV2F5QmluZGluZ3NbJ3ZhbGlkYXRlZFZhbHVlJ10gPSB0cnVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWxzIGdsb2JhbDpmYWxzZSAqL1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1sndW5pcXVlSWQnXSA9IHtcbiAgY3VycmVudEluZGV4OiAwLFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgZGF0YSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSB8fCB7fTtcbiAgICBpZiAoZGF0YS5pZCgpID09PSAnJykge1xuICAgICAgdmFyIGlkLCBlbCwgcHJlZml4O1xuICAgICAgLy8gVE9ETyB3ZSBuZWVkIGEgYmV0dGVyIHByZWZpeFxuICAgICAgcHJlZml4ID0gJ2tvXycgKyAodHlwZW9mIGRhdGEudHlwZSAhPT0gJ3VuZGVmaW5lZCcgPyBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEudHlwZSkgOiAnYmxvY2snKTtcbiAgICAgIC8vIHdoZW4gbG9hZGluZyBhbiBleGlzaW5nIG1vZGVsLCBJRHMgY291bGQgYmUgYWxyZWFkeSBhc3NpZ25lZC5cbiAgICAgIGRvIHtcbiAgICAgICAgaWQgPSBwcmVmaXggKyAnXycgKyAoKytrby5iaW5kaW5nSGFuZGxlcnNbJ3VuaXF1ZUlkJ10uY3VycmVudEluZGV4KTtcbiAgICAgICAgZWwgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAvLyB3aGVuIGxvYWRpbmcgYW4gZXhpc3RpbmcgbW9kZWwgbXkgXCJjdXJyZW50SW5kZXhcIiBpcyBlbXB0eS5cbiAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBleGlzdGluZyBibG9ja3MsIHNvIEkgbXVzdCBiZSBzdXJlIEkgZG9uJ3QgcmV1c2UgdGhlaXIgSURzLlxuICAgICAgICAgIC8vIFdlIHVzZSBkaWZmZXJlbnQgcHJlZml4ZXMgKHBlciBibG9jayB0eXBlKSBzbyB0aGF0IGEgaGlkZGVuIGJsb2NrIFxuICAgICAgICAgIC8vIChmb3Igd2hpY2ggd2UgaGF2ZSBubyBpZCBpbiB0aGUgcGFnZSwgZS5nOiBwcmVoZWFkZXIgaW4gdmVyc2FmaXgtMSlcbiAgICAgICAgICAvLyB3aWxsIGJyZWFrIGV2ZXJ0aGluZyBvbmNlIHdlIHJldXNlIGl0cyBuYW1lLlxuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChlbCk7XG4gICAgICBkYXRhLmlkKGlkKTtcbiAgICB9XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd1bmlxdWVJZCddID0gdHJ1ZTtcblxua28uYmluZGluZ0hhbmRsZXJzWyd2aXJ0dWFsQXR0ciddID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAga28uYmluZGluZ0hhbmRsZXJzWydhdHRyJ10udXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3ZpcnR1YWxBdHRyJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZpcnR1YWxBdHRyU3R5bGUnXSA9IHtcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgIC8vIEluIFwicHJldmlld1wiIHdlIGFsc28gc2V0IFwicmVwbGFjZWRzdHlsZVwiIHNvIHRvIGhhdmUgYW4gYXR0cmlidXRlIHRvIGJlIHVzZWQgYnkgSUUgKElFIGJyZWFrcyB0aGUgU1RZTEUpIHRvIGRvIHRoZSBleHBvcnQuXG4gICAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgICAgdmFyIGF0dHJzID0gW1wic3R5bGVcIl07XG4gICAgICBpZiAoaXNOb3RXeXNpd3lnTW9kZSkgYXR0cnMucHVzaChcInJlcGxhY2Vkc3R5bGVcIik7XG4gICAgICB2YXIgYXR0clZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gKGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHx8IChhdHRyVmFsdWUgPT09IG51bGwpIHx8IChhdHRyVmFsdWUgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0b1JlbW92ZSlcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3ZpcnR1YWxBdHRyU3R5bGUnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1sndmlydHVhbFN0eWxlJ10gPSB7XG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICBrby5iaW5kaW5nSGFuZGxlcnNbJ3N0eWxlJ10udXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddID0gdHJ1ZTtcblxuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZpcnR1YWxIdG1sJ10gPSB7XG4gIGluaXQ6IGtvLmJpbmRpbmdIYW5kbGVyc1snaHRtbCddLmluaXQsXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSA4KSB7XG4gICAgICB2YXIgaHRtbCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcblxuICAgICAga28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZShlbGVtZW50KTtcbiAgICAgIGlmICgoaHRtbCAhPT0gbnVsbCkgJiYgKGh0bWwgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGh0bWwgPSBodG1sLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkTm9kZXMgPSBrby51dGlscy5wYXJzZUh0bWxGcmFnbWVudChodG1sKTtcbiAgICAgICAgaWYgKHBhcnNlZE5vZGVzKSB7XG4gICAgICAgICAgdmFyIGVuZENvbW1lbnROb2RlID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHBhcnNlZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgIGVuZENvbW1lbnROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBhcnNlZE5vZGVzW2ldLCBlbmRDb21tZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBwbGFpbiBub2RlXG4gICAgICBrby5iaW5kaW5nSGFuZGxlcnNbJ2h0bWwnXS51cGRhdGUoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcik7XG4gICAgfVxuXG4gICAgLy8gQ29udGVudCBmb3IgdmlydHVhbEhUTUwgbXVzdCBub3QgYmUgcGFyc2VkIGJ5IEtPLCBpdCBpcyBzaW1wbGUgY29udGVudC5cbiAgICByZXR1cm4ge1xuICAgICAgY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWVcbiAgICB9O1xuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1sndmlydHVhbEh0bWwnXSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgdGlueW1jZSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd0aW55bWNlJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd0aW55bWNlJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuL2V2ZW50YWJsZS5qc1wiKTtcblxua28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdPckh0bWwgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuXG4gICAgaWYgKGlzTm90V3lzaXd5Z01vZGUpXG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd2aXJ0dWFsSHRtbCddLmluaXQoKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuaW5pdChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICBpZiAoaXNOb3RXeXNpd3lnTW9kZSlcbiAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3ZpcnR1YWxIdG1sJ10udXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuICAgIC8vZWxzZSBcbiAgICAvLyAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnVwZGF0ZShlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3d5c2l3eWdPckh0bWwnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnSHJlZiA9IHtcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICB2YXIgdiA9IHZhbHVlQWNjZXNzb3IoKTtcblxuICAgICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiWFhYXCIsIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSwgaXNOb3RXeXNpd3lnTW9kZSwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKTtcbiAgICAgIGlmIChpc05vdFd5c2l3eWdNb2RlKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCAnX25ldycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLypqc2hpbnQgc2NyaXB0dXJsOnRydWUqL1xuICAgICAgICAvLyAyMDE1MDIyNjogcmVtb3ZlZCBocmVmIHRvIHdvcmsgYXJvdW5kIEZGIGlzc3VlcyB3aXRoIDxhIGhyZWY9XCJcIj48ZGl2IGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIj4uLjwvZGl2PjwvYT5cbiAgICAgICAgLy8gZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnamF2YXNjcmlwdDp2b2lkKDApJyk7XG4gICAgICAgIC8vIDIwMTUwMzA5OiBvbiBJRSwgYW4gZWRpdGFibGUgPGEgaHJlZj1cIlwiIGRhdGEtZWRpdGFibGU9XCJcIj4gcHJldmVudCB0aW55bWNlIHRvb2xiYXIgdG8gYmUgc2hvd24uXG4gICAgICAgIC8vICAgICAgICAgICBzbyBJIGNoYW5nZSBiZWhhdmlvdXIgYmFzZWQgb24gdGhlIHVzZSBvZiBcInd5c2l3eWdPckh0bWxcIlxuICAgICAgICAvLyBAc2VlOiBodHRwOi8vd3d3LnRpbnltY2UuY29tL2RldmVsb3AvYnVndHJhY2tlcl92aWV3LnBocD9pZD03NDMyXG4gICAgICAgIHZhciBhbGxiaW5kaW5ncyA9IGFsbEJpbmRpbmdzQWNjZXNzb3IoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGxiaW5kaW5ncy53eXNpd3lnT3JIdG1sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgJ2phdmFzY3JpcHQ6dm9pZCgwKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkaHJlZicsICcjJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgICAgLy8gTk9URSB0aGlzIHVud3JhcCBpcyBuZWVkZWQgYWxzbyBpbiBcInd5c2l3eWdcIiBtb2RlLCBvdGhlcndpc2UgZGVwZW5kZW5jeSB0cmFja2luZyBkaWVzLlxuICAgICAgdmFyIGF0dHJWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgIGlmIChpc05vdFd5c2l3eWdNb2RlKSB7XG4gICAgICAgIGlmICgoYXR0clZhbHVlID09PSBmYWxzZSkgfHwgKGF0dHJWYWx1ZSA9PT0gbnVsbCkgfHwgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBhdHRyVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snd3lzaXd5Z0hyZWYnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjID0ge1xuICBjb252ZXJ0ZWRVcmw6IGZ1bmN0aW9uKHNyYywgbWV0aG9kLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHF1ZXJ5UGFyYW1TZXBhcmF0b3IgPSBzcmMuaW5kZXhPZignPycpID09IC0xID8gJz8nIDogJyYnO1xuICAgIHZhciByZXMgPSBzcmMgKyBxdWVyeVBhcmFtU2VwYXJhdG9yICsgXCJtZXRob2Q9XCIgKyBtZXRob2QgKyBcIiZ3aWR0aD1cIiArIHdpZHRoICsgKGhlaWdodCAhPT0gbnVsbCA/IFwiJmhlaWdodD1cIiArIGhlaWdodCA6ICcnKTtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICBwbGFjZWhvbGRlclVybDogZnVuY3Rpb24ocGx3aWR0aCwgcGxoZWlnaHQsIHBsdGV4dCkge1xuICAgIHZhciBwbGFjZWhvbGRlcnNyYyA9IFwiJ2h0dHA6Ly9sb3JlbXBpeGVsLmNvbS9nLycrXCIgKyBwbHdpZHRoICsgXCIrJy8nK1wiICsgcGxoZWlnaHQgKyBcIisnL2Fic3RyYWN0LycrZW5jb2RlVVJJQ29tcG9uZW50KFwiICsgcGx0ZXh0ICsgXCIpXCI7XG4gICAgLy8gaHR0cDovL3BsYWNlaG9sZC5pdC8yMDB4MTUwLnBuZy9jY2NjY2MvMzMzMzMzJnRleHQ9cGxhY2Vob2xkLml0I3N0aGFzaC5uQTNyMjZ2Ui5kcHVmXG4gICAgLy8gcGxhY2Vob2xkZXJzcmMgPSBcIidodHRwOi8vcGxhY2Vob2xkLml0LycrXCIrd2lkdGgrXCIrJ3gnK1wiK2hlaWdodCtcIisnLnBuZy9jY2NjY2MvMzMzMzMzJnRleHQ9JytcIitzaXplO1xuICAgIC8vIHBsYWNlaG9sZGVyc3JjID0gXCInXCIrY29udmVydGVyVXRpbHMuYWRkU2xhc2hlcyhkZWZhdWx0VmFsdWUpK1wiJ1wiO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgdmFyIGF0dHJWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUuc3JjKTtcbiAgICB2YXIgcGxhY2Vob2xkZXJWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUucGxhY2Vob2xkZXIpO1xuICAgIHZhciB3aWR0aCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUud2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlLmhlaWdodCk7XG4gICAgaWYgKChhdHRyVmFsdWUgPT09IGZhbHNlKSB8fCAoYXR0clZhbHVlID09PSBudWxsKSB8fCAoYXR0clZhbHVlID09PSB1bmRlZmluZWQpIHx8IChhdHRyVmFsdWUgPT09ICcnKSkge1xuICAgICAgaWYgKHR5cGVvZiBwbGFjZWhvbGRlclZhbHVlID09ICdvYmplY3QnICYmIHBsYWNlaG9sZGVyVmFsdWUgIT09IG51bGwpIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYy5wbGFjZWhvbGRlclVybChwbGFjZWhvbGRlclZhbHVlLndpZHRoLCBwbGFjZWhvbGRlclZhbHVlLmhlaWdodCwgcGxhY2Vob2xkZXJWYWx1ZS50ZXh0KSk7XG4gICAgICBlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1ldGhvZCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUubWV0aG9kKTtcbiAgICAgIGlmICghbWV0aG9kKSBtZXRob2QgPSB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/ICdjb3ZlcicgOiAncmVzaXplJztcbiAgICAgIHZhciBzcmMgPSBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYy5jb252ZXJ0ZWRVcmwoYXR0clZhbHVlLnRvU3RyaW5nKCksIG1ldGhvZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2lkdGggIT09IG51bGwpIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgpO1xuICAgIGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcbiAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgJiYgaGVpZ2h0ICE9PSBudWxsKSBlbGVtZW50LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgIGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG4gIH1cbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnSWQgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgIGlmICghaXNOb3RXeXNpd3lnTW9kZSlcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciBpc05vdFd5c2l3eWdNb2RlID0gKHR5cGVvZiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPT0gJ3VuZGVmaW5lZCcgfHwgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlICE9ICd3eXNpd3lnJyk7XG4gICAgaWYgKCFpc05vdFd5c2l3eWdNb2RlKVxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpKTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3d5c2l3eWdJZCddID0gdHJ1ZTtcblxuLy8gdXNlZCBvbiBlZGl0YWJsZSBcIml0ZW1cIiBzbyB0byBiaW5kIGNsaWNrcyBvbmx5IGluIHd5c2l3eWcgbW9kZS5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnQ2xpY2sgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgIGlmICghaXNOb3RXeXNpd3lnTW9kZSlcbiAgICAgIGtvLmJpbmRpbmdIYW5kbGVycy5jbGljay5pbml0KGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snd3lzaXd5Z0NsaWNrJ10gPSB0cnVlO1xuXG4vLyB1c2VkIG9uIGVkaXRhYmxlIFwiaXRlbVwiIHNvIHRvIGJpbmQgY3NzIG9ubHkgaW4gd3lzaXd5ZyBtb2RlLlxua28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdDc3MgPSB7XG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciBpc05vdFd5c2l3eWdNb2RlID0gKHR5cGVvZiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPT0gJ3VuZGVmaW5lZCcgfHwgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlICE9ICd3eXNpd3lnJyk7XG4gICAgaWYgKCFpc05vdFd5c2l3eWdNb2RlKVxuICAgICAga28uYmluZGluZ0hhbmRsZXJzLmNzcy51cGRhdGUoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd3eXNpd3lnQ3NzJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0ltZyA9IHtcbiAgbWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3NvcjogZnVuY3Rpb24odmFsdWVBY2Nlc3NvciwgYmluZGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlICE9ICd1bmRlZmluZWQnICYmIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAnd3lzaXd5ZycpO1xuXG4gICAgICB2YXIgbW9kZWxWYWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSxcbiAgICAgICAgdW53cmFwcGVkVmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTsgLy8gVW53cmFwIHdpdGhvdXQgc2V0dGluZyBhIGRlcGVuZGVuY3kgaGVyZVxuXG4gICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZS5kYXRhIGlzIHRoZSBhcnJheSwgcHJlc2VydmUgYWxsIHJlbGV2YW50IG9wdGlvbnMgYW5kIHVud3JhcCBhZ2FpbiB2YWx1ZSBzbyB3ZSBnZXQgdXBkYXRlc1xuICAgICAga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ25hbWUnOiBpc1d5c2l3eWdNb2RlID8gdW53cmFwcGVkVmFsdWVbJ19lZGl0VGVtcGxhdGUnXSA6IHVud3JhcHBlZFZhbHVlWydfdGVtcGxhdGUnXSxcbiAgICAgICAgJ3RlbXBsYXRlRW5naW5lJzoga28ubmF0aXZlVGVtcGxhdGVFbmdpbmUuaW5zdGFuY2VcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3RlbXBsYXRlJ11bJ2luaXQnXShlbGVtZW50LCBrby5iaW5kaW5nSGFuZGxlcnNbJ3d5c2l3eWdJbWcnXS5tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IsIGJpbmRpbmdDb250ZXh0KSk7XG4gIH0sXG4gICd1cGRhdGUnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGJpbmRpbmdDb250ZXh0ID0gYmluZGluZ0NvbnRleHRbJ2V4dGVuZCddKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVyc1sndGVtcGxhdGUnXVsndXBkYXRlJ10oZWxlbWVudCwga28uYmluZGluZ0hhbmRsZXJzWyd3eXNpd3lnSW1nJ10ubWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yLCBiaW5kaW5nQ29udGV4dCksIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3d5c2l3eWdJbWcnXSA9IHRydWU7XG5cbi8vIE5PVEU6IHRoZXJlIGFyZSBpc3N1ZXMgd2l0aCB0aGUgXCJyYXdcIiBmb3JtYXQgYW5kIHRyYXNoIGxlZnQgYXJvdW5kIGJ5IHRpbnltY2Ugd29ya2Fyb3VuZHMgZm9yIGNvbnRlbnRlZGl0YWJsZSBpc3N1ZXMuXG4vLyBzZXR0aW5nIFwiZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlXCIgZGlzYWJsZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgYWRkaW5nIGEgd3JhcHBlciA8cD4gd2hlbiBuZWVkZWQgYW5kIHRoaXMgc2VlbXMgdG8gZml4IG1hbnkgaXNzdWVzIGluIElFLlxuLy8gYWxzbywgbWF5YmUgd2Ugc2hvdWxkIHVzZSB0aGUgXCJyYXdcIiBvbmx5IGZvciB0aGUgXCJiZWZvcmUgU2V0Q29udGVudFwiIGFuZCBpbnN0ZWFkIHJlYWQgdGhlIFwibm9uLXJhd1wiIGNvbnRlbnQgKHRoZSByYXcgY29udGVudCBzb21ldGltZXMgaGF2ZSBkYXRhLSBhdHRyaWJ1dGVzIGFuZCB0b28gbWFueSBlbmRpbmcgPGJyPiBpbiB0aGUgY29kZSlcbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnID0ge1xuICBjdXJyZW50SW5kZXg6IDAsXG4gIHN0YW5kYXJkT3B0aW9uczoge30sXG4gIGZ1bGxPcHRpb25zOiB7XG4gICAgdG9vbGJhcjE6ICdib2xkIGl0YWxpYyBmb3JlY29sb3IgYmFja2NvbG9yIGhyIHN0eWxlc2VsZWN0IHJlbW92ZWZvcm1hdCB8IGxpbmsgdW5saW5rIHwgcGFzdGV0ZXh0IGNvZGUnLFxuICAgIC8vdG9vbGJhcjE6IFwiYm9sZCBpdGFsaWMgfCBmb3JlY29sb3IgYmFja2NvbG9yIHwgbGluayB1bmxpbmsgfCBociB8IHBhc3RldGV4dCBjb2RlXCIsIC8vIHwgbmV3c2xldHRlcl9wcm9maWxlIG5ld3NsZXR0ZXJfb3B0bGluayBuZXdzbGV0dGVyX3Vuc3Vic2NyaWJlIG5ld3NsZXR0ZXJfc2hvd2xpbmtcIjtcbiAgICAvL3Rvb2xiYXIyOiBcImZvcm1hdHNlbGVjdCBmb250c2VsZWN0IGZvbnRzaXplc2VsZWN0IHwgYWxpZ25sZWZ0IGFsaWduY2VudGVyIGFsaWducmlnaHQgYWxpZ25qdXN0aWZ5IHwgYnVsbGlzdCBudW1saXN0XCIsXG4gICAgcGx1Z2luczogW1wibGluayBociBwYXN0ZSBsaXN0cyB0ZXh0Y29sb3IgY29kZVwiXSxcbiAgICAvLyB2YWxpZF9lbGVtZW50czogJ3N0cm9uZy9iLGVtL2ksKlsqXScsXG4gICAgLy8gZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHM6ICdzdHJvbmcvYixlbS9pLCpbKl0nLFxuICAgIC8vIFJlbW92ZWQ6IGltYWdlIGZ1bGxzY3JlZW4gY29udGV4dG1lbnUgXG4gICAgLy8gZG93bmxvYWQgY3VzdG9tOlxuICAgIC8vIGpxdWVyeSB2ZXJzaW9uIGNvbiBsZWdhY3lvdXRwdXQsIGFuY2hvciwgY29kZSwgaW1wb3J0Y3NzLCBsaW5rLCBwYXN0ZSwgdGV4dGNvbG9yLCBociwgbGlzdHNcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIC8vIFRPRE8gdWdseSwgYnV0IHdvcmtzLi4uXG4gICAga28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZS5pbml0KGVsZW1lbnQpO1xuXG4gICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgIHRpbnltY2UucmVtb3ZlKCcjJyArIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICB9KTtcblxuICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKTtcblxuICAgIGlmICgha28uaXNPYnNlcnZhYmxlKHZhbHVlKSkgdGhyb3cgXCJXeXNpd3lnIGJpbmRpbmcgY2FsbGVkIHdpdGggbm9uIG9ic2VydmFibGVcIjtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gOCkgdGhyb3cgXCJXeXNpd3lnIGJpbmRpbmcgY2FsbGVkIG9uIHZpcnR1YWwgbm9kZSwgaWdub3JpbmcuLi4uXCIgKyBlbGVtZW50LmlubmVySFRNTDtcblxuICAgIHZhciBzZWxlY3RvcklkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgaWYgKCFzZWxlY3RvcklkKSB7XG4gICAgICBzZWxlY3RvcklkID0gJ3d5c2l3eWdfJyArICgrK2tvLmJpbmRpbmdIYW5kbGVyc1snd3lzaXd5ZyddLmN1cnJlbnRJbmRleCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBzZWxlY3RvcklkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbEVkaXRvciA9IGVsZW1lbnQudGFnTmFtZSA9PSAnRElWJyB8fCBlbGVtZW50LnRhZ05hbWUgPT0gJ1REJztcbiAgICB2YXIgaXNTdWJzY3JpYmVyQ2hhbmdlID0gZmFsc2U7XG4gICAgdmFyIHRoaXNFZGl0b3I7XG4gICAgdmFyIGlzRWRpdG9yQ2hhbmdlID0gZmFsc2U7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHNlbGVjdG9yOiAnIycgKyBzZWxlY3RvcklkLFxuICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgLy8gbWF5YmUgbm90IG5lZWRlZCwgYnV0IHdvbid0IGh1cnQuXG4gICAgICBoaWRkZW5faW5wdXQ6IGZhbHNlLFxuICAgICAgcGx1Z2luczogW1wicGFzdGVcIl0sXG4gICAgICB0b29sYmFyMTogXCJib2xkIGl0YWxpY1wiLFxuICAgICAgdG9vbGJhcjI6IFwiXCIsXG4gICAgICAvLyB3ZSBoYXZlIHRvIGRpc2FibGUgcHJldmlld19zdHlsZXMgb3RoZXJ3aXNlIHRpbnltY2UgcHVzaCBpbmxpbmUgZXZlcnkgc3R5bGUgaGUgdGhpbmdzIHdpbGwgYmUgYXBwbGllZCBhbmQgdGhpcyBtYWtlcyB0aGUgc3R5bGUgbWVudSB0byBpbmhlcml0IGNvbG9yL2ZvbnQtZmFtaWx5IGFuZCBtb3JlLlxuICAgICAgcHJldmlld19zdHlsZXM6IGZhbHNlLFxuICAgICAgcGFzdGVfYXNfdGV4dDogdHJ1ZSxcbiAgICAgIGxhbmd1YWdlOiAnZW4nLFxuICAgICAgc2NoZW1hOiBcImh0bWw1XCIsXG4gICAgICBleHRlbmRlZF92YWxpZF9lbGVtZW50czogJ3N0cm9uZy9iLGVtL2ksKlsqXScsXG4gICAgICBtZW51YmFyOiBmYWxzZSxcbiAgICAgIHNraW46ICdncmF5LWZsYXQnLFxuICAgICAgc2V0dXA6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAvLyBUT0RPIGNoYW5nZSBzb21ldGltZXMgZG9lc24ndCB0cmlnZ2VyICh3ZSBoYXZlIHRvIGRvY3VtZW50IHdoZW4pXG4gICAgICAgIC8vIGxpc3RlbmluZyBvbiBrZXl1cCB3b3VsZCBpbmNyZWFzZSBjb3JyZWN0bmVzcyBidXQgd2Ugd291bGQgbmVlZCBhIHJhdGVMaW1pdCB0byBhdm9pZCBmbG9vZGluZy5cbiAgICAgICAgZWRpdG9yLm9uKCdjaGFuZ2UgcmVkbyB1bmRvJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFpc1N1YnNjcmliZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlzRWRpdG9yQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHdlIGZhaWxlZCB3aXRoIG90aGVyIHdheXMgdG8gZG8gdGhpczpcbiAgICAgICAgICAgIC8vIHZhbHVlKCQoZWxlbWVudCkuaHRtbCgpKTtcbiAgICAgICAgICAgIC8vIHZhbHVlKGVsZW1lbnQuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgIHZhbHVlKGVkaXRvci5nZXRDb250ZW50KHtcbiAgICAgICAgICAgICAgZm9ybWF0OiAncmF3J1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaXNFZGl0b3JDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDbGlja2luZyBvbiB0aGUgZWxlbWVudCBvbiBmb2N1cyBjaGFuZ2UgYWxsb3cgdGhlIFwiY2xpY1wiIGNvZGUgdG8gYmUgdHJpZ2dlcmVkIGFuZCBwcm9wYWdhdGUgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgLy8gTm90IGVsZWdhbnQsIG1heWJlIHdlIGhhdmUgYmV0dGVyIG9wdGlvbnMuXG4gICAgICAgIGVkaXRvci5vbignZm9jdXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBVc2VkIGJ5IHNjcm9sbGZpeC5qcyAobWF5YmUgdGhpcyBpcyBub3QgbmVlZGVkIGJ5IG5ldyBzY3JvbGxmaXguanMpXG4gICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgICAgZWRpdG9yLmdldEVsZW1lbnQoKS5jbGljaygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBOT1RFOiB0aGlzIGZpeGVzIGlzc3VlIHdpdGggXCJsZWFkaW5nIHNwYWNlc1wiIGluIGRlZmF1bHQgY29udGVudCB0aGF0IHdlcmUgbG9zdCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgIGVkaXRvci5vbignQmVmb3JlU2V0Q29udGVudCcsIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICBpZiAoYXJncy5pbml0aWFsKSBhcmdzLmZvcm1hdCA9ICdyYXcnO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiBOT1RFOiBkaXNhYmxpbmcgXCJFTlRFUlwiIGluIHRpbnkgZWRpdG9yLCBub3QgYSBnb29kIHRoaW5nIGJ1dCBtYXkgYmUgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGNvbnRlbnRlZGl0YWJsZSBpc3N1ZXNcbiAgICAgICAgaWYgKCFmdWxsRWRpdG9yKSB7XG4gICAgICAgICAgLy8gc2Ugbm9uIGFiYmlhbW8gaWwgXCJmdWxsIEVkaXRvclwiLCBkaXNhYmlsaXRpYW1vIGwnaW52aW8uICh2YXJpIGJ1ZylcbiAgICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAgICAgdGhpc0VkaXRvciA9IGVkaXRvcjtcblxuICAgICAgfVxuICAgIH07XG5cbiAgICBrby51dGlscy5leHRlbmQob3B0aW9ucywga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuc3RhbmRhcmRPcHRpb25zKTtcbiAgICBpZiAoZnVsbEVkaXRvcikga28udXRpbHMuZXh0ZW5kKG9wdGlvbnMsIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLmZ1bGxPcHRpb25zKTtcblxuICAgIC8vIHdlIGhhdmUgdG8gcHV0IGluaXRpYWxpemF0aW9uIGluIGEgc2V0dGltZW91dCwgb3RoZXJ3aXNlIHN3aXRjaGluZyBmcm9tIFwiMVwiIHRvIFwiMlwiIGNvbHVtbnMgYmxvY2tzXG4gICAgLy8gd2lsbCBzdGFydCB0aGUgbmV3IGVkaXRvcnMgYmVmb3JlIGRpc3Bvc2luZyB0aGUgb2xkIG9uZXMgYW5kIElEcyBnZXQgdGVtcG9yYXJpbHkgZHVwbGljYXRlZC5cbiAgICAvLyB1c2luZyBzZXRUaW1lb3V0IHRoZSBkaXNwb3NlL2NyZWF0ZSBvcmRlciBpcyBjb3JyZWN0IG9uIGV2ZXJ5IGJyb3dzZXIgdGVzdGVkLlxuICAgIGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGlueW1jZS5pbml0KG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGVudCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgIGlmICghaXNFZGl0b3JDaGFuZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpc1N1YnNjcmliZXJDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIC8vIHdlIGZhaWxlZCBzZXR0aW5nIGNvbnRlbnRzIGluIG90aGVyIHdheXMuLi5cbiAgICAgICAgICAvLyAkKGVsZW1lbnQpLmh0bWwoY29udGVudCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzRWRpdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpc0VkaXRvci5zZXRDb250ZW50KGNvbnRlbnQsIHtcbiAgICAgICAgICAgICAgZm9ybWF0OiAncmF3J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLnNldEh0bWwoZWxlbWVudCwgY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIGV4Y2VwdGlvbiBzZXR0aW5nIGNvbnRlbnQgdG8gZWRpdGFibGUgZWxlbWVudFwiLCB0eXBlb2YgdGhpc0VkaXRvciwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNTdWJzY3JpYmVyQ2hhbmdlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgbnVsbCwge1xuICAgICAgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG4gICAgfSk7XG5cbiAgICAvLyBkbyBub3QgcGFyc2UgaHRtbCBjb250ZW50IGZvciBLTyBiaW5kaW5ncyEhXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlXG4gICAgfTtcblxuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuLy8gcmV0dXJucyAwIGlmIGVxdWFsICgwLjAueCByZWxlYXNlKSwgMSB3aXRoIGJhY2t3YXJkIGNvbXBhdGlibGUgYWRkaXRpb25zICgwLnguMCByZWxlYXNlKSwgMiBvbiBsb3N0IGRhdGEgb3IgaW5jb21wYXRpYmxlIGRhdGEgKHguMC4wIHJlbGVhc2UpXG52YXIgY2hlY2tNb2RlbCA9IGZ1bmN0aW9uKHJlZmVyZW5jZSwgYmxvY2tEZWZzLCBtb2RlbCwgb3JpZ1ByZWZpeCwgcmV2ZXJzZSkge1xuICB2YXIgYmxvY2tEZWZzT2JqLCBpLCBwcmVmaXg7XG4gIHZhciB2YWxpZCA9IDA7XG4gIGlmICh0eXBlb2YgcmV2ZXJzZSA9PSAndW5kZWZpbmVkJykgcmV2ZXJzZSA9IGZhbHNlO1xuICBpZiAodHlwZW9mIGJsb2NrRGVmcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGJsb2NrRGVmcy5zcGxpY2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGJsb2NrRGVmc09iaiA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0RlZnMubGVuZ3RoOyBpKyspIGJsb2NrRGVmc09ialtibG9ja0RlZnNbaV0udHlwZV0gPSBibG9ja0RlZnNbaV07XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tEZWZzT2JqID0gYmxvY2tEZWZzO1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gcmVmZXJlbmNlKVxuICAgIGlmIChyZWZlcmVuY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHByZWZpeCA9IHR5cGVvZiBvcmlnUHJlZml4ICE9PSAndW5kZWZpbmVkJyA/IG9yaWdQcmVmaXggKyBcIi5cIiArIHByb3AgOiBwcm9wO1xuICAgICAgaWYgKCFtb2RlbC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk4gUHJvcGVydHkgXCIsIHByZWZpeCwgXCJmb3VuZCBpbiBtb2RlbCBpcyBub3QgZGVmaW5lZCBieSB0ZW1wbGF0ZTogcmVtb3ZpbmcgaXQhXCIpO1xuICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgIGRlbGV0ZSByZWZlcmVuY2VbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJJTkZPIFByb3BlcnR5IFwiLCBwcmVmaXgsIFwibWlzc2luZyBpbiBtb2RlbCwgY2xvbmluZyBmcm9tIHJlZmVyZW5jZSFcIik7XG4gICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMSk7XG4gICAgICAgICAgbW9kZWxbcHJvcF0gPSByZWZlcmVuY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsW3Byb3BdICE9IHR5cGVvZiByZWZlcmVuY2VbcHJvcF0pIHtcbiAgICAgICAgLy8gc2Ugc29ubyBkaSB0aXBvIGRpdmVyc28gYWxsb3JhIHByb3ZvIGEgdmVkZXJlIHNlIGwnYWx0cm8sIGNvbnZlcnRpdG8gZGkgdGlwbyBtYW50aWVuZSB1biB2YWxvcmUgZXF1aXZhbGVudGUuXG4gICAgICAgIGlmIChtb2RlbFtwcm9wXSAhPT0gbnVsbCAmJiByZWZlcmVuY2VbcHJvcF0gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGVsW3Byb3BdID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoU3RyaW5nKHJlZmVyZW5jZVtwcm9wXSkgIT0gcmVmZXJlbmNlW3Byb3BdKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBEaWZmZXJlbnQgdHlwZSAxIFwiLCBwcmVmaXgsIHR5cGVvZiBtb2RlbFtwcm9wXSwgdHlwZW9mIHJlZmVyZW5jZVtwcm9wXSwgbW9kZWxbcHJvcF0sIHJlZmVyZW5jZVtwcm9wXSk7XG4gICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsW3Byb3BdID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKHJlZmVyZW5jZVtwcm9wXSkgIT0gcmVmZXJlbmNlW3Byb3BdKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBEaWZmZXJlbnQgdHlwZSAyIFwiLCBwcmVmaXgsIHR5cGVvZiBtb2RlbFtwcm9wXSwgdHlwZW9mIHJlZmVyZW5jZVtwcm9wXSwgbW9kZWxbcHJvcF0sIHJlZmVyZW5jZVtwcm9wXSk7XG4gICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gRGlmZmVyZW50IHR5cGUgMyBcIiwgcHJlZml4LCB0eXBlb2YgbW9kZWxbcHJvcF0sIHR5cGVvZiByZWZlcmVuY2VbcHJvcF0sIG1vZGVsW3Byb3BdLCByZWZlcmVuY2VbcHJvcF0pO1xuICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWZlcmVuY2VbcHJvcF0gPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZVtwcm9wXSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlW3Byb3BdLnNwbGljZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VbcHJvcF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpZiAobW9kZWxbcHJvcF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbmVlZHMgc29ydGluZz9cbiAgICAgICAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vZGVsW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1vZGVsW3Byb3BdW2ldLnR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCByZWZlcmVuY2VbcHJvcF0ubGVuZ3RoICYmIHJlZmVyZW5jZVtwcm9wXVtqXS50eXBlICE9PSBtb2RlbFtwcm9wXVtpXS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpZ25vcmluZyBcIiwgcHJlZml4LCByZWZlcmVuY2VbcHJvcF1bal0udHlwZSwgXCIgYmxvY2sgdHlwZSBpbiByZWZlcmVuY2Ugbm90IGZvdW5kIGluIG1vZGVsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSByZWZlcmVuY2VbcHJvcF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOIGNhbm5vdCBmaW5kIFwiLCBwcmVmaXgsIG1vZGVsW3Byb3BdW2ldLnR5cGUsIFwiIGJsb2NrIGluIHJlZmVyZW5jZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnNlIGNvbmRpdGlvbiBzbyB0byBza2lwIFwiZGVlcCB0cmF2ZXJzaW5nXCIgb24gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgY2hlY2tNb2RlbChyZWZlcmVuY2VbcHJvcF1bal0sIHVuZGVmaW5lZCwgbW9kZWxbcHJvcF1baV0sIHByZWZpeCArIFwiW1wiICsgaSArIFwiLlwiICsgbW9kZWxbcHJvcF1baV0udHlwZSArIFwiXVwiKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBhcnJheSB3ZSBjaGVjayBibG9ja0RlZnNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVmZXJlbmNlW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZVtwcm9wXVtpXS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gZm91bmQgYW4gb2JqZWN0IHdpdGggbm8gdHlwZVwiLCBwcmVmaXgsIHJlZmVyZW5jZVtwcm9wXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYmxvY2tEZWZzT2JqLmhhc093blByb3BlcnR5KHJlZmVyZW5jZVtwcm9wXVtpXS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUT0RPIHRoZSBtb2RlbCB1c2VzIGEgYmxvY2sgdHlwZSBub3QgZGVmaW5lZCBieSB0aGUgdGVtcGxhdGUuIFJFTU9WSU5HIElUISFcIiwgcHJlZml4LCByZWZlcmVuY2VbcHJvcF1baV0pO1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VbcHJvcF0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgY2hlY2tNb2RlbChibG9ja0RlZnNPYmpbcmVmZXJlbmNlW3Byb3BdW2ldLnR5cGVdLCBibG9ja0RlZnNPYmosIHJlZmVyZW5jZVtwcm9wXVtpXSwgcHJlZml4ICsgXCJbXCIgKyBpICsgXCIuXCIgKyByZWZlcmVuY2VbcHJvcF1baV0udHlwZSArIFwiXVwiKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RlbFtwcm9wXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTiBOdWxsIG9iamVjdCBpbiBtb2RlbCBcIiwgcHJlZml4LCBcImluc3RlYWQgb2ZcIiwgcmVmZXJlbmNlW3Byb3BdLCBcImRlbGV0aW5nIGl0XCIpO1xuICAgICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWZlcmVuY2VbcHJvcF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJTkZPIE51bGwgb2JqZWN0IGluIG1vZGVsIFwiLCBwcmVmaXgsIFwiaW5zdGVhZCBvZlwiLCByZWZlcmVuY2VbcHJvcF0sIFwiY2xvbmluZyBpdCBmcm9tIHRoZSByZWZlcmVuY2VcIik7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMSk7XG4gICAgICAgICAgICAgICAgbW9kZWxbcHJvcF0gPSByZWZlcmVuY2VbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIGNoZWNrTW9kZWwocmVmZXJlbmNlW3Byb3BdLCBibG9ja0RlZnNPYmosIG1vZGVsW3Byb3BdLCBwcmVmaXgsIHJldmVyc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxbcHJvcF0gIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gTnVsbCBpbiByZWZlcmVuY2UgYnV0IG5vdCBudWxsIGluIG1vZGVsXCIsIHByZWZpeCwgbW9kZWxbcHJvcF0pO1xuICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWZlcmVuY2VbcHJvcF0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiByZWZlcmVuY2VbcHJvcF0gIT09ICdib29sZWFuJyAmJiB0eXBlb2YgcmVmZXJlbmNlW3Byb3BdICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gdW5zdXBwb3J0ZWQgdHlwZVwiLCBwcmVmaXgsIHR5cGVvZiByZWZlcmVuY2VbcHJvcF0pO1xuICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgIH1cblxuICAgIH1cbiAgaWYgKCFyZXZlcnNlKSB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCBjaGVja01vZGVsKG1vZGVsLCBibG9ja0RlZnMsIHJlZmVyZW5jZSwgdHlwZW9mIG9yaWdQcmVmaXggIT09ICd1bmRlZmluZWQnID8gb3JpZ1ByZWZpeCArIFwiIVJcIiA6IFwiIVJcIiwgdHJ1ZSkpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrTW9kZWw7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFBhcnNlcyBDU1MgZGVjbGFyYXRpb25zIGFuZCBzdXBwb3J0cyB0aGUgcHJvcGVydHkgbGFuZ3VhZ2UgKC1rby0qKSBmb3VuZCBiZXR3ZWVuIHRoZW0uXG4vLyBDcmVhdGUgS08gYmluZGluZ3MgYnV0IGRvZXNuJ3QgZGVwZW5kIG9uIEtPLlxuLy8gTmVlZHMgYSBiaW5kaW5nUHJvdmlkZXIuXG5cbnZhciBjb252ZXJ0ZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xudmFyIGNzc1BhcnNlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9tZW5zY2gvbGliL3BhcnNlci5qc1wiKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgZG9tdXRpbHMgPSByZXF1aXJlKFwiLi9kb211dGlscy5qc1wiKTtcblxudmFyIF9kZWNsYXJhdGlvblZhbHVlTG9va3VwID0gZnVuY3Rpb24oZGVjbGFyYXRpb25zLCBwcm9wZXJ0eW5hbWUsIHRlbXBsYXRlVXJsQ29udmVydGVyKSB7XG4gIGZvciAodmFyIGkgPSBkZWNsYXJhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoZGVjbGFyYXRpb25zW2ldLnR5cGUgPT0gJ3Byb3BlcnR5JyAmJiBkZWNsYXJhdGlvbnNbaV0ubmFtZSA9PSBwcm9wZXJ0eW5hbWUpIHtcbiAgICAgIHJldHVybiBfZGVjbGFyYXRpb25WYWx1ZVVybFByZWZpeGVyKGRlY2xhcmF0aW9uc1tpXS52YWx1ZSwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBfcHJvcFRvQ2FtZWxDYXNlID0gZnVuY3Rpb24ocHJvcE5hbWUpIHtcbiAgcmV0dXJuIHByb3BOYW1lLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uKG1hdGNoLCBjb250ZW50cywgb2Zmc2V0LCBzKSB7XG4gICAgcmV0dXJuIGNvbnRlbnRzLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufTtcblxudmFyIF9kZWNsYXJhdGlvblZhbHVlVXJsUHJlZml4ZXIgPSBmdW5jdGlvbih2YWx1ZSwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpIHtcbiAgaWYgKHZhbHVlLm1hdGNoKC91cmxcXCguKlxcKS8pKSB7XG4gICAgdmFyIHJlcGxhY2VkID0gdmFsdWUucmVwbGFjZSgvKHVybFxcKCkoW15cXCldKikoXFwpKS9nLCBmdW5jdGlvbihtYXRjaGVkLCBwcmVmaXgsIHVybCwgcG9zdGZpeCkge1xuICAgICAgdmFyIHRyaW1tZWQgPSB1cmwudHJpbSgpO1xuICAgICAgdmFyIGFwaWNlID0gdXJsLnRyaW0oKS5jaGFyQXQoMCk7XG4gICAgICBpZiAoYXBpY2UgPT0gJ1xcJycgfHwgYXBpY2UgPT0gJ1wiJykge1xuICAgICAgICB0cmltbWVkID0gdHJpbW1lZC5zdWJzdHIoMSwgdHJpbW1lZC5sZW5ndGggLSAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwaWNlID0gJyc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3VXJsID0gdGVtcGxhdGVVcmxDb252ZXJ0ZXIodHJpbW1lZCk7XG4gICAgICBpZiAobmV3VXJsICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBhcGljZSArIG5ld1VybCArIGFwaWNlICsgcG9zdGZpeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXBsYWNlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbnZhciBlbGFib3JhdGVEZWNsYXJhdGlvbnMgPSBmdW5jdGlvbihzdHlsZSwgZGVjbGFyYXRpb25zLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgYmluZGluZ1Byb3ZpZGVyLCBlbGVtZW50LCBiYXNpY0JpbmRpbmdzLCByZW1vdmVEaXNwbGF5Tm9uZSkge1xuICB2YXIgbmV3QmluZGluZ3MgPSB0eXBlb2YgYmFzaWNCaW5kaW5ncyA9PSAnb2JqZWN0JyAmJiBiYXNpY0JpbmRpbmdzICE9PSBudWxsID8gYmFzaWNCaW5kaW5ncyA6IHt9O1xuICB2YXIgbmV3U3R5bGUgPSBudWxsO1xuICB2YXIgc2tpcExpbmVzID0gMDtcbiAgaWYgKHR5cGVvZiBkZWNsYXJhdGlvbnMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgc3R5bGVTaGVldCA9IGNzc1BhcnNlKFwiI3tcXG5cIiArIHN0eWxlICsgXCJ9XCIsIHtcbiAgICAgIGNvbW1lbnRzOiB0cnVlLFxuICAgICAgcG9zaXRpb246IHRydWVcbiAgICB9KTtcbiAgICBkZWNsYXJhdGlvbnMgPSBzdHlsZVNoZWV0LnN0eWxlc2hlZXQucnVsZXNbMF0uZGVjbGFyYXRpb25zO1xuICAgIHNraXBMaW5lcyA9IDE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IGRlY2xhcmF0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBpZiAoZGVjbGFyYXRpb25zW2ldLnR5cGUgPT0gJ3Byb3BlcnR5Jykge1xuICAgICAgaWYgKHJlbW92ZURpc3BsYXlOb25lID09PSB0cnVlICYmIGRlY2xhcmF0aW9uc1tpXS5uYW1lID09ICdkaXNwbGF5JyAmJiBkZWNsYXJhdGlvbnNbaV0udmFsdWUgPT0gJ25vbmUnKSB7XG4gICAgICAgIGlmIChuZXdTdHlsZSA9PT0gbnVsbCkgbmV3U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLnN0YXJ0LCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uZW5kLCBza2lwTGluZXMsIDAsIDAsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWNsID0gZGVjbGFyYXRpb25zW2ldLm5hbWUubWF0Y2goL14ta28tKGJpbmQtfGF0dHItKT8oW2EtejAtOS1dKj8pKC1pZnwtaWZub3QpPyQvKTtcbiAgICAgICAgaWYgKGRlY2wgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyByaW1vemlvbmUgZGVsbG8gc3RpbGUgLWtvLSBkYWxsJ2F0dHJpYnV0byBzdHlsZS5cbiAgICAgICAgICBpZiAobmV3U3R5bGUgPT09IG51bGwgJiYgdHlwZW9mIHN0eWxlICE9ICd1bmRlZmluZWQnKSBuZXdTdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgICAgdmFyIGlzQXR0ciA9IGRlY2xbMV0gPT0gJ2F0dHItJztcbiAgICAgICAgICB2YXIgaXNCaW5kID0gZGVjbFsxXSA9PSAnYmluZC0nO1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IGRlY2xbMl07XG5cbiAgICAgICAgICB2YXIgaXNJZiA9IGRlY2xbM10gPT0gJy1pZicgfHwgZGVjbFszXSA9PSAnLWlmbm90JztcbiAgICAgICAgICB2YXIgY29uZERlY2w7XG4gICAgICAgICAgdmFyIGJpbmRWYWx1ZTtcbiAgICAgICAgICB2YXIgcHJvcERlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgIGlmIChpc0lmKSB7XG4gICAgICAgICAgICBjb25kRGVjbCA9IGRlY2xhcmF0aW9uc1tpXS5uYW1lLnN1YnN0cigwLCBkZWNsYXJhdGlvbnNbaV0ubmFtZS5sZW5ndGggLSBkZWNsWzNdLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uZWREZWNsYXJhdGlvbiA9IF9kZWNsYXJhdGlvblZhbHVlTG9va3VwKGRlY2xhcmF0aW9ucywgY29uZERlY2wsIHRlbXBsYXRlVXJsQ29udmVydGVyKTtcbiAgICAgICAgICAgIGlmIChjb25kaXRpb25lZERlY2xhcmF0aW9uID09PSBudWxsKSB0aHJvdyBcIlVuYWJsZSB0byBmaW5kIGRlY2xhcmF0aW9uIFwiICsgY29uZERlY2wgKyBcIiBmb3IgXCIgKyBkZWNsYXJhdGlvbnNbaV0ubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoKGlzQXR0ciB8fCBpc0JpbmQpICYmICh0eXBlb2YgZWxlbWVudCA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc3R5bGUgIT0gJ3VuZGVmaW5lZCcpKSB0aHJvdyBcIkF0dHJpYnV0ZXMgYW5kIGJpbmQgZGVjbGFyYXRpb25zIGFyZSBvbmx5IGFsbG93ZWQgaW4gaW5saW5lIHN0eWxlcyFcIjtcblxuICAgICAgICAgICAgdmFyIG5lZWREZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGJpbmRUeXBlO1xuICAgICAgICAgICAgaWYgKGlzQXR0cikge1xuICAgICAgICAgICAgICBwcm9wRGVmYXVsdFZhbHVlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgbmVlZERlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBiaW5kVHlwZSA9ICd2aXJ0dWFsQXR0cic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0JpbmQpIHtcbiAgICAgICAgICAgICAgbmVlZERlZmF1bHRWYWx1ZSA9IHR5cGVvZiBzdHlsZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICAgIGlmIChuZWVkRGVmYXVsdFZhbHVlKSBwcm9wRGVmYXVsdFZhbHVlID0gX2RlY2xhcmF0aW9uVmFsdWVMb29rdXAoZGVjbGFyYXRpb25zLCBwcm9wTmFtZSwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgICBiaW5kVHlwZSA9ICd2aXJ0dWFsU3R5bGUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmluZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgcHJvcERlZmF1bHRWYWx1ZSA9IGRvbXV0aWxzLmdldElubmVyVGV4dChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmVlZERlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wRGVmYXVsdFZhbHVlID0gZG9tdXRpbHMuZ2V0SW5uZXJIdG1sKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZWVkRGVmYXVsdFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lZWREZWZhdWx0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVlZERlZmF1bHRWYWx1ZSAmJiBwcm9wRGVmYXVsdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgZmluZCBkZWZhdWx0IHZhbHVlIGZvclwiLCBkZWNsYXJhdGlvbnNbaV0ubmFtZSwgZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgZmluZCBkZWZhdWx0IHZhbHVlIGZvciBcIiArIGRlY2xhcmF0aW9uc1tpXS5uYW1lICsgXCI6IFwiICsgZGVjbGFyYXRpb25zW2ldLnZhbHVlICsgXCIgaW4gXCIgKyBlbGVtZW50ICsgXCIgKFwiICsgdHlwZW9mIHN0eWxlICsgXCIvXCIgKyBwcm9wTmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJpbmREZWZhdWx0VmFsdWUgPSBwcm9wRGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgYmluZE5hbWUgPSAhaXNCaW5kICYmICFpc0F0dHIgPyBfcHJvcFRvQ2FtZWxDYXNlKHByb3BOYW1lKSA6IChwcm9wTmFtZS5pbmRleE9mKCctJykgIT0gLTEgPyAnXFwnJytwcm9wTmFtZSsnXFwnJyA6IHByb3BOYW1lKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYmluZFZhbHVlID0gY29udmVydGVyVXRpbHMuZXhwcmVzc2lvbkJpbmRpbmcoZGVjbGFyYXRpb25zW2ldLnZhbHVlLCBiaW5kaW5nUHJvdmlkZXIsIGJpbmREZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kZWwgZW5zdXJlIHBhdGggZmFpbGVkXCIsIGUuc3RhY2ssIFwibmFtZVwiLCBkZWNsYXJhdGlvbnNbaV0ubmFtZSwgXCJ2YWx1ZVwiLCBkZWNsYXJhdGlvbnNbaV0udmFsdWUsIFwiZGVmYXVsdFwiLCBwcm9wRGVmYXVsdFZhbHVlLCBcImVsZW1lbnRcIiwgZWxlbWVudCk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChiaW5kVHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgbmV3QmluZGluZ3NbYmluZFR5cGVdID09ICd1bmRlZmluZWQnKSBuZXdCaW5kaW5nc1tiaW5kVHlwZV0gPSB7fTtcblxuXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBIUkVGc1xuICAgICAgICAgICAgaWYgKGJpbmRUeXBlID09ICd2aXJ0dWFsQXR0cicgJiYgYmluZE5hbWUgPT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgIGJpbmRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgYmluZE5hbWUgPSAnd3lzaXd5Z0hyZWYnO1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIHJlbW92ZSBpdCwgb3RoZXJ3aXNlIHdlIGVuZHMgdXAgd2l0aCAyIHJ1bGVzIHdyaXRpbmcgaXQuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPSAndW5kZWZpbmVkJyAmJiBlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIFwiaHJlZlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPIGV2YWx1YXRlIHRoZSB1c2Ugb2YgXCItdGhlblwiIChhbmQgLWVsc2UpIHBvc3RmaXhlcyB0byBjb21wbGV0ZSB0aGUgLWlmIGluc3RlYWQgb2YgcmVsYXlpbmdcbiAgICAgICAgICAgIC8vIG9uIHRoZSBzYW1lIGJhc2ljIHNpbnRheCAob3IgbWF5YmUgaXQgaXMgYmV0dGVyIHRvIHN1cHBvcnQgdGVybmFyeSBvcGVyYXRvciBDT05EID8gVEhFTiA6IEVMU0UpLlxuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uQ29uZGl0aW9uID0gX2RlY2xhcmF0aW9uVmFsdWVMb29rdXAoZGVjbGFyYXRpb25zLCBkZWNsYXJhdGlvbnNbaV0ubmFtZSArICctaWYnLCB0ZW1wbGF0ZVVybENvbnZlcnRlcik7XG4gICAgICAgICAgICB2YXIgbm90ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25Db25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGVjbGFyYXRpb25Db25kaXRpb24gPSBfZGVjbGFyYXRpb25WYWx1ZUxvb2t1cChkZWNsYXJhdGlvbnMsIGRlY2xhcmF0aW9uc1tpXS5uYW1lICsgJy1pZm5vdCcsIHRlbXBsYXRlVXJsQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgbm90ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChfZGVjbGFyYXRpb25WYWx1ZUxvb2t1cChkZWNsYXJhdGlvbnMsIGRlY2xhcmF0aW9uc1tpXS5uYW1lICsgJy1pZm5vdCcsIHRlbXBsYXRlVXJsQ29udmVydGVyKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBlcnJvcjogY2Fubm90IHVzZSBib3RoIC1pZiBhbmQgLWlmbm90IHByb3BlcnR5IGNvbmRpdGlvbnNcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uQ29uZGl0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdDb25kID0gY29udmVydGVyVXRpbHMuY29uZGl0aW9uQmluZGluZyhkZWNsYXJhdGlvbkNvbmRpdGlvbiwgYmluZGluZ1Byb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBiaW5kVmFsdWUgPSAobm90ID8gJyEnIDogJycpICsgXCIoXCIgKyBiaW5kaW5nQ29uZCArIFwiKSA/IFwiICsgYmluZFZhbHVlICsgXCIgOiBudWxsXCI7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGRlYWwgd2l0aCAta28gc3R5bGUgYmluZGluZyBjb25kaXRpb25cIiwgZGVjbGFyYXRpb25Db25kaXRpb24sIGRlY2xhcmF0aW9uc1tpXS5uYW1lKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChiaW5kVHlwZSAhPT0gbnVsbCkgbmV3QmluZGluZ3NbYmluZFR5cGVdW2JpbmROYW1lXSA9IGJpbmRWYWx1ZTtcbiAgICAgICAgICAgIGVsc2UgbmV3QmluZGluZ3NbYmluZE5hbWVdID0gYmluZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhcnNpbmcgQHN1cHBvcnRzIDpwcmV2aWV3XG4gICAgICAgICAgaWYgKG5ld1N0eWxlICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIGlmIFwiZWxlbWVudFwiIGlzIGRlZmluZWQgdGhlbiB3ZSBhcmUgcGFyc2luZyBhbiBcImlubGluZVwiIHN0eWxlIGFuZCB3ZSB3YW50IHRvIHJlbW92ZSBpdC5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ICE9ICd1bmRlZmluZWQnICYmIGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uc3RhcnQsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5lbmQsIHNraXBMaW5lcywgMCwgMCwgJycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBhcmUgcGFyc2luZyBhIGZ1bGwgc3R5bGVzaGVldC4uIGxldCdzIHJld3JpdGUgdGhlIGZ1bGwgXCJwcm9wOiB2YWx1ZVwiIHdpdGhvdXQgY2FyaW5nIGFib3V0IHRoZSBvcmlnaW5hbCBzeW50YXguXG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VkV2l0aCA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIFwiaWZcIiB3ZSBzaW1wbHkgaGF2ZSB0byByZW1vdmUgaXQsIG90aGVyd2lzZSB3ZSByZXBsYWNlIHRoZSBpbnB1dCBjb2RlIHdpdGggXCJwcm9wOiB2YWx1ZVwiIGdlbmVyYXRpbmcgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoIWlzSWYpIHJlcGxhY2VkV2l0aCA9IHByb3BOYW1lICsgJzogPCEtLSBrbyB0ZXh0OiAnICsgYmluZFZhbHVlICsgJyAtLT4nICsgcHJvcERlZmF1bHRWYWx1ZSArICc8IS0tIC9rbyAtLT4nO1xuICAgICAgICAgICAgICAgIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5zdGFydCwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLmVuZCwgc2tpcExpbmVzLCAwLCAwLCByZXBsYWNlZFdpdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlJlbW92ZSBzdHlsZSBmYWlsZWRcIiwgZSwgXCJuYW1lXCIsIGRlY2xhcmF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwcmVmaXhpbmcgdXJsc1xuICAgICAgICAgIHZhciByZXBsYWNlZFZhbHVlID0gX2RlY2xhcmF0aW9uVmFsdWVVcmxQcmVmaXhlcihkZWNsYXJhdGlvbnNbaV0udmFsdWUsIHRlbXBsYXRlVXJsQ29udmVydGVyKTtcbiAgICAgICAgICBpZiAocmVwbGFjZWRWYWx1ZSAhPSBkZWNsYXJhdGlvbnNbaV0udmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdHlsZSA9PT0gbnVsbCAmJiB0eXBlb2Ygc3R5bGUgIT09ICd1bmRlZmluZWQnKSBuZXdTdHlsZSA9IHN0eWxlO1xuICAgICAgICAgICAgaWYgKG5ld1N0eWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLnN0YXJ0LCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uZW5kLCBza2lwTGluZXMsIDAsIDAsIGRlY2xhcmF0aW9uc1tpXS5uYW1lICsgXCI6IFwiICsgcmVwbGFjZWRWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlbW92ZSBzdHlsZSBmYWlsZWQgcmVwbGFjaW5nIHVybFwiLCBlLCBcIm5hbWVcIiwgZGVjbGFyYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3R5bGUgaGFuZGxpbmcgYnkgY29uY2F0ZW5hdGVkIFwic3R5bGUgYXR0cmlidXRlXCIgKHdvcnNlIHBlcmZvcm1hbmNlIGJ1dCBtb3JlIHN0YWJsZSB0aGFuIGRpcmVjdCBzdHlsZSBoYW5kbGluZylcbiAgICAgICAgICB2YXIgYmluZE5hbWUyID0gX3Byb3BUb0NhbWVsQ2FzZShkZWNsYXJhdGlvbnNbaV0ubmFtZSk7XG4gICAgICAgICAgdmFyIGJpbmQgPSAndmlydHVhbEF0dHJTdHlsZSc7XG4gICAgICAgICAgdmFyIGJpbmRWYWwyID0gdHlwZW9mIG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXSAhPT0gJ3VuZGVmaW5lZCcgPyBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ11bYmluZE5hbWUyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBkaXN0ID0gJyAnO1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3QmluZGluZ3NbYmluZF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG5ld0JpbmRpbmdzW2JpbmRdID0gXCInJ1wiO1xuICAgICAgICAgICAgZGlzdCA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgYmluZFZhbDIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBuZXdCaW5kaW5nc1tiaW5kXSA9IFwiJ1wiICsgZGVjbGFyYXRpb25zW2ldLm5hbWUgKyBcIjogJysoXCIgKyBiaW5kVmFsMiArIFwiKSsnO1wiICsgZGlzdCArIFwiJytcIiArIG5ld0JpbmRpbmdzW2JpbmRdO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXVtiaW5kTmFtZTJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdCaW5kaW5nc1tiaW5kXSA9IFwiJ1wiICsgZGVjbGFyYXRpb25zW2ldLm5hbWUgKyBcIjogXCIgKyBjb252ZXJ0ZXJVdGlscy5hZGRTbGFzaGVzKHJlcGxhY2VkVmFsdWUpICsgXCI7XCIgKyBkaXN0ICsgXCInK1wiICsgbmV3QmluZGluZ3NbYmluZF07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ICE9ICd1bmRlZmluZWQnICYmIGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXSlcbiAgICAgIGlmIChuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ10uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVbmV4cGVjdGVkIHZpcnR1YWxTdHlsZSBiaW5kaW5nIGFmdGVyIGNvbnZlcnNpb24gdG8gdmlydHVhbEF0dHIuc3R5bGVcIiwgcHJvcCwgbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddW3Byb3BdLCBzdHlsZSk7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCB2aXJ0dWFsU3R5bGUgYmluZGluZyBhZnRlciBjb252ZXJzaW9uIHRvIHZpcnR1YWxBdHRyLnN0eWxlIGZvciBcIiArIHByb3A7XG4gICAgICB9XG4gICAgZGVsZXRlIG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXTtcblxuICAgIHZhciBjdXJyZW50QmluZGluZ3MgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcpO1xuICAgIHZhciBkYXRhQmluZCA9IChjdXJyZW50QmluZGluZ3MgIT09IG51bGwgPyBjdXJyZW50QmluZGluZ3MgKyBcIiwgXCIgOiBcIlwiKSArIF9iaW5kaW5nU2VyaWFsaXplcihuZXdCaW5kaW5ncyk7XG4gICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnLCBkYXRhQmluZCk7XG4gIH1cblxuICAvLyBUT0RPIGEgZnVuY3Rpb24gd2hvc2UgcmV0dXJuIHR5cGUgZGVwZW5kcyBvbiB0aGUgaW5wdXQgcGFyYW1ldGVycyBpcyB2ZXJ5IHVnbHkuLiBwbGVhc2UgRklYIE1FLlxuICBpZiAodHlwZW9mIHN0eWxlID09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gY2xlYW4gdmlydHVhbFN0eWxlIGlmIGVtcHR5XG4gICAgdmFyIGhhc1ZpcnR1YWxTdHlsZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHByb3AxIGluIG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXSlcbiAgICAgIGlmIChuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ10uaGFzT3duUHJvcGVydHkocHJvcDEpKSB7XG4gICAgICAgIGhhc1ZpcnR1YWxTdHlsZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGlmICghaGFzVmlydHVhbFN0eWxlKSBkZWxldGUgbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddO1xuICAgIGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGFuZCBhZGQgYmFjayB2aXJ0dWFsQXR0clN0eWxlIHNvIGl0IGdldHMgYXBwZW5kZWQgQkVGT1JFIHZpcnR1YWxBdHRyU3R5bGUgKF9iaW5kaW5nU2VyaWFsaXplciByZXZlcnNlIHRoZW0uLi4pXG4gICAgICBpZiAodHlwZW9mIG5ld0JpbmRpbmdzWyd2aXJ0dWFsQXR0clN0eWxlJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB2cyA9IG5ld0JpbmRpbmdzWyd2aXJ0dWFsQXR0clN0eWxlJ107XG4gICAgICAgIGRlbGV0ZSBuZXdCaW5kaW5nc1sndmlydHVhbEF0dHJTdHlsZSddO1xuICAgICAgICBuZXdCaW5kaW5nc1sndmlydHVhbEF0dHJTdHlsZSddID0gdnM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybnMgbmV3IHNlcmlhbGl6ZWQgYmluZGluZ3NcbiAgICByZXR1cm4gX2JpbmRpbmdTZXJpYWxpemVyKG5ld0JpbmRpbmdzKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn07XG5cbnZhciBfYmluZGluZ1NlcmlhbGl6ZXIgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBwcm9wIGluIHZhbClcbiAgICBpZiAodmFsLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbFtwcm9wXSA9PSAnb2JqZWN0JykgcmVzLnB1c2gocHJvcCArIFwiOiBcIiArIFwieyBcIiArIF9iaW5kaW5nU2VyaWFsaXplcih2YWxbcHJvcF0pICsgXCIgfVwiKTtcbiAgICAgIGVsc2UgcmVzLnB1c2gocHJvcCArIFwiOiBcIiArIHZhbFtwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gcmVzLnJldmVyc2UoKS5qb2luKCcsICcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGFib3JhdGVEZWNsYXJhdGlvbnM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZGVhbHMgd2l0aCBDaGVlcmlvL2pRdWVyeSBpc3N1ZXMuXG4vLyBNb3N0IG9mIHRoaXMgY291bGQgYmUgZG9uZSB3aXRob3V0IGpRdWVyeSwgdG9vLCBidXQgalF1ZXJ5IGlzIGVhc2llciB0byBiZSBtb2NrZWQgd2l0aCBDaGVlcmlvXG4vLyBPdGhlcndpc2Ugd2Ugd291bGQgbmVlZCBqc0RvbSB0byBydW4gdGhlIGNvbXBpbGVyIGluIHRoZSBzZXJ2ZXIgKHdpdGhvdXQgYSByZWFsIGJyb3dzZXIpXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcblxuZnVuY3Rpb24gX2V4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoc291cmNlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgb2JqRXh0ZW5kID0gZnVuY3Rpb24ob2JqLCBleHRlbmRlcikge1xuICBpZiAodHlwZW9mICQuZXh0ZW5kID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwgb2JqLCBleHRlbmRlcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9leHRlbmQob2JqLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGV4dGVuZGVyKSkpO1xuICB9XG59O1xuXG52YXIgZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gIHZhciByZXMgPSAkKGVsZW1lbnQpLmF0dHIoYXR0cmlidXRlKTtcbiAgaWYgKHR5cGVvZiByZXMgPT0gJ3VuZGVmaW5lZCcpIHJlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG4gIC8vIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xufTtcblxudmFyIHNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgJChlbGVtZW50KS5hdHRyKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAvLyBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn07XG5cbnZhciByZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgJChlbGVtZW50KS5yZW1vdmVBdHRyKGF0dHJpYnV0ZSk7XG4gIC8vIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59O1xuXG52YXIgZ2V0SW5uZXJUZXh0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gJChlbGVtZW50KS50ZXh0KCk7XG4gIC8vIGlmICh0eXBlb2YgZWxlbWVudC5pbm5lclRleHQgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBlbGVtZW50LmlubmVyVGV4dDtcbiAgLy8gZWxzZSByZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudDtcbn07XG5cbnZhciBnZXRJbm5lckh0bWwgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiAkKGVsZW1lbnQpLmh0bWwoKTtcbiAgLy8gcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xufTtcblxudmFyIGdldExvd2VyVGFnTmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgLy8gc29tZXRpbWVzIGNoZWVyaW8gZG9lc24ndCBoYXZlIHRhZ05hbWUgYnV0IFwibmFtZVwiLlxuICAvLyBCcm93c2VycyBoYXZlIFwibmFtZVwiIHdpdGggZW1wdHkgc3RyaW5nXG4gIC8vIFNvbWV0aW1lcyBjaGVlcmlvIGhhcyB0YWdOYW1lIGJ1dCBubyBwcm9wIGZ1bmN0aW9uLlxuICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnJyAmJiB0eXBlb2YgZWxlbWVudC5uYW1lID09ICdzdHJpbmcnKSByZXR1cm4gZWxlbWVudC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChlbGVtZW50LnRhZ05hbWUgIT09ICcnKSByZXR1cm4gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAkKGVsZW1lbnQpLnByb3AoXCJ0YWdOYW1lXCIpLnRvTG93ZXJDYXNlKCk7XG4gIC8vIHJldHVybiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBzZXRDb250ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY29udGVudCkge1xuICAkKGVsZW1lbnQpLmh0bWwoY29udGVudCk7XG4gIC8vIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudDtcbn07XG5cbnZhciByZXBsYWNlSHRtbCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGh0bWwpIHtcbiAgJChlbGVtZW50KS5yZXBsYWNlV2l0aChodG1sKTtcbiAgLy8gZWxlbWVudC5vdXRlckhUTUwgPSBodG1sO1xufTtcblxudmFyIHJlbW92ZUVsZW1lbnRzID0gZnVuY3Rpb24oJGVsZW1lbnRzLCB0cnlEZXRhY2gpIHtcbiAgaWYgKHRyeURldGFjaCAmJiB0eXBlb2YgJGVsZW1lbnRzLmRldGFjaCAhPT0gJ3VuZGVmaW5lZCcpICRlbGVtZW50cy5kZXRhY2goKTtcbiAgLy8gTk9URTogd2UgZG9uJ3QgbmVlZCBhbiBlbHNlLCBhcyBkZXRhY2ggaXMgc2ltcGx5IGFuIG9wdGltaXphdGlvblxuICAkZWxlbWVudHMucmVtb3ZlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG4gIHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlLFxuICByZW1vdmVBdHRyaWJ1dGU6IHJlbW92ZUF0dHJpYnV0ZSxcbiAgZ2V0SW5uZXJUZXh0OiBnZXRJbm5lclRleHQsXG4gIGdldElubmVySHRtbDogZ2V0SW5uZXJIdG1sLFxuICBnZXRMb3dlclRhZ05hbWU6IGdldExvd2VyVGFnTmFtZSxcbiAgc2V0Q29udGVudDogc2V0Q29udGVudCxcbiAgcmVwbGFjZUh0bWw6IHJlcGxhY2VIdG1sLFxuICByZW1vdmVFbGVtZW50czogcmVtb3ZlRWxlbWVudHMsXG4gIG9iakV4dGVuZDogb2JqRXh0ZW5kXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIGVsYWJvcmF0ZURlY2xhcmF0aW9ucyA9IHJlcXVpcmUoXCIuL2RlY2xhcmF0aW9ucy5qc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnZhciBtb2RlbERlZiA9IHJlcXVpcmUoJy4vbW9kZWwuanMnKTtcblxudmFyIF9nZXRPcHRpb25zT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgb3B0aW9uc0NvdXBsZXMgPSBvcHRpb25zLnNwbGl0KCd8Jyk7XG4gIHZhciBvcHRzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uc0NvdXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3B0ID0gb3B0aW9uc0NvdXBsZXNbaV0uc3BsaXQoJz0nKTtcbiAgICBvcHRzW29wdFswXV0gPSBvcHQubGVuZ3RoID4gMSA/IG9wdFsxXSA6IG9wdFswXTtcbiAgfVxuICByZXR1cm4gb3B0cztcbn07XG5cbi8vIFRPRE8gdGhpcyBzaG91bGQgbm90IGhhdmUgaGFyZGNvZGVkIHJ1bGVzICh3ZSBub3cgaGF2ZSBhIHdheSB0byBkZWNsYXJlIHRoZW0gaW4gdGhlIHRlbXBsYXRlIGRlZmluaXRpb24pXG4vLyBDYXRlZ29yeSBcInN0eWxlXCIgaXMgdXNlZCBieSBlZGl0VHlwZSBcInN0eWxlclwiXG4vLyBDYXRlb2dyeSBcImNvbnRlbnRcIiBpcyB1c2VkIGJ5IGVkaXRUeXBlIFwiZWRpdFwiXG4vLyBUT0RPIG1heWJlIHdlIHNob3VsZCB1c2UgYSBjb21tb24gc3RyaW5nIGhlcmUsIGFuZCByZWx5IG9ubHkgb24gdGhlIG9yaWdpbmFsIGNhdGVnb3J5LlxudmFyIF9maWx0ZXJQcm9wcyA9IGZ1bmN0aW9uKG1vZGVsLCBlZGl0VHlwZSwgbGV2ZWwpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBwcm9wIGluIG1vZGVsKVxuICAgIGlmICghcHJvcC5tYXRjaCgvXmN1c3RvbVN0eWxlJC8pICYmICFwcm9wLm1hdGNoKC9eXy8pICYmIG1vZGVsLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICB2YXIgaXNTdHlsZVByb3AgPSBtb2RlbFtwcm9wXSAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWxbcHJvcF0uX2NhdGVnb3J5ICE9ICd1bmRlZmluZWQnICYmIG1vZGVsW3Byb3BdLl9jYXRlZ29yeSA9PSAnc3R5bGUnO1xuICAgICAgaWYgKHByb3AgPT0gJ2lkJyB8fCBwcm9wID09ICd0eXBlJyB8fCBwcm9wLm1hdGNoKC9CbG9ja3MkLykpIHt9IGVsc2UgaWYgKGVkaXRUeXBlID09ICdzdHlsZXInKSB7XG4gICAgICAgIGlmIChpc1N0eWxlUHJvcCB8fCBsZXZlbCA+IDApIHJlcy5wdXNoKHByb3ApO1xuICAgICAgfSBlbHNlIGlmIChlZGl0VHlwZSA9PSAnZWRpdCcpIHtcbiAgICAgICAgLy8gRWRpdGluZyBmb3IgcHJvcGVydGllcyBpbiB0aGUgXCJjb250ZW50XCIgY2F0ZWdvcnkgYnV0IG5vdCBkZWZpbmVkIGluIHRoZSBjb250ZXh0IG9mIGEgYmxvY2tcbiAgICAgICAgdmFyIGlzQ29udGVudFByb3AgPSBtb2RlbFtwcm9wXSAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWxbcHJvcF0uX2NhdGVnb3J5ICE9ICd1bmRlZmluZWQnICYmIG1vZGVsW3Byb3BdLl9jYXRlZ29yeSA9PSAnY29udGVudCcgJiZcbiAgICAgICAgICAodHlwZW9mIG1vZGVsW3Byb3BdLl9jb250ZXh0ID09ICd1bmRlZmluZWQnIHx8IG1vZGVsW3Byb3BdLl9jb250ZXh0ICE9ICdibG9jaycpO1xuICAgICAgICBpZiAoaXNDb250ZW50UHJvcCkgcmVzLnB1c2gocHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlZGl0VHlwZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgX3Byb3BJbnB1dCA9IGZ1bmN0aW9uKG1vZGVsLCBwcm9wLCBwcm9wQWNjZXNzb3IsIGVkaXRUeXBlLCB3aWRnZXRzKSB7XG4gIHZhciBodG1sID0gXCJcIjtcbiAgdmFyIHdpZGdldDtcbiAgaWYgKG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fd2lkZ2V0ICE9ICd1bmRlZmluZWQnKSB3aWRnZXQgPSBtb2RlbC5fd2lkZ2V0O1xuXG4gIGlmICh0eXBlb2Ygd2lkZ2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgXCJVbmtub3duIGRhdGEgdHlwZSBmb3IgXCIgKyBwcm9wO1xuICB9XG5cbiAgLy8gRm9yIGNvbnRlbnQgZWRpdG9ycyB3ZSBkZWFsIHdpdGggZm9jdXNpbmcgKGNsaWNraW5nIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRhaW5lciBESVYpLlxuICB2YXIgb25mb2N1c2JpbmRpbmcgPSAnZm9jdXNhYmxlOiB0cnVlJztcbiAgaWYgKGVkaXRUeXBlID09ICdlZGl0Jykge1xuICAgIG9uZm9jdXNiaW5kaW5nICs9ICcsIGV2ZW50OiB7IGZvY3VzOiBmdW5jdGlvbih1aSwgZXZlbnQpIHsgJCgkZWxlbWVudCkuY2xpY2soKTsgfSB9ICc7XG4gIH1cblxuICBodG1sICs9ICc8bGFiZWwgY2xhc3M9XCJkYXRhLScgKyB3aWRnZXQgKyAnXCInICsgKHdpZGdldCA9PSAnYm9vbGVhbicgPyAnIGRhdGEtYmluZD1cImV2ZW50OiB7IG1vdXNlZG93bjogZnVuY3Rpb24odWksIGV2dCkgeyBpZiAoZXZ0LmJ1dHRvbiA9PSAwKSB7IHZhciBpbnB1dCA9ICQoJGVsZW1lbnQpLmZpbmQoXFwnaW5wdXRcXCcpOyB2YXIgY2ggPSBpbnB1dC5wcm9wKFxcJ2NoZWNrZWRcXCcpOyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBpbnB1dC5jbGljaygpOyBpbnB1dC5wcm9wKFxcJ2NoZWNrZWRcXCcsICFjaCk7IGlucHV0LnRyaWdnZXIoXFwnY2hhbmdlXFwnKTsgfSwgMCk7IH0gfSB9LCBjbGljazogZnVuY3Rpb24odWksIGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgfSwgY2xpY2tCdWJibGU6IGZhbHNlXCInIDogJycpICsgJz4nO1xuXG4gIGlmICh0eXBlb2Ygd2lkZ2V0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpZGdldHNbd2lkZ2V0XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgdyA9IHdpZGdldHNbd2lkZ2V0XTtcbiAgICB2YXIgcGFyYW1ldGVycyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygdy5wYXJhbWV0ZXJzICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGZvciAodmFyIHAgaW4gdy5wYXJhbWV0ZXJzKVxuICAgICAgICBpZiAody5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHApICYmIHR5cGVvZiBtb2RlbFsnXycrcF0gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgIHBhcmFtZXRlcnNbcF0gPSBtb2RlbFsnXycrcF07XG4gICAgaHRtbCArPSB3Lmh0bWwocHJvcEFjY2Vzc29yLCBvbmZvY3VzYmluZGluZywgcGFyYW1ldGVycyk7XG4gIH0gZWxzZSBpZiAod2lkZ2V0ID09ICdib29sZWFuJykge1xuICAgIGh0bWwgKz0gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIm5vdGhpbmdcIiBkYXRhLWJpbmQ9XCJjaGVja2VkOiAnICsgcHJvcEFjY2Vzc29yICsgJywgJyArIG9uZm9jdXNiaW5kaW5nICsgJ1wiIC8+JztcbiAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cImNoZWNrYm94LXJlcGxhY2VyXCIgPjwvc3Bhbj4nOyAvKiBkYXRhLWJpbmQ9XCJjc3M6IHsgY2hlY2tlZDogJytwcm9wQWNjZXNzb3IrJyB9XCIgKi9cbiAgfSBlbHNlIGlmICh3aWRnZXQgPT0gJ2NvbG9yJykge1xuICAgIGh0bWwgKz0gJzxpbnB1dCBzaXplPVwiN1wiIHR5cGU9XCJ0ZXh0XCIgZGF0YS1iaW5kPVwiY29sb3JwaWNrZXI6IHsgY29sb3I6ICcgKyBwcm9wQWNjZXNzb3IgKyAnLCBzdHJpbmdzOiAkcm9vdC50KFxcJ1RoZW1lIENvbG9ycyxTdGFuZGFyZCBDb2xvcnMsV2ViIENvbG9ycyxUaGVtZSBDb2xvcnMsQmFjayB0byBQYWxldHRlLEhpc3RvcnksTm8gaGlzdG9yeSB5ZXQuXFwnKSB9LCAnICsgJywgJyArIG9uZm9jdXNiaW5kaW5nICsgJ1wiIC8+JztcbiAgfSBlbHNlIGlmICh3aWRnZXQgPT0gJ3NlbGVjdCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZGVsLl9vcHRpb25zICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgb3B0cyA9IF9nZXRPcHRpb25zT2JqZWN0KG1vZGVsLl9vcHRpb25zKTtcbiAgICAgIC8vIHZhciBvcHRzID0gbW9kZWwuX29wdGlvbnM7XG4gICAgICBodG1sICs9ICc8c2VsZWN0IGRhdGEtYmluZD1cInZhbHVlOiAnICsgcHJvcEFjY2Vzc29yICsgJywgJyArIG9uZm9jdXNiaW5kaW5nICsgJ1wiPic7XG4gICAgICBmb3IgKHZhciBvcHQgaW4gb3B0cylcbiAgICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgb3B0ICsgJ1wiIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyhvcHRzW29wdF0pICsgJ1xcJylcIj4nICsgb3B0c1tvcHRdICsgJzwvb3B0aW9uPic7XG4gICAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzwvc2VsZWN0Pic7XG4gICAgfVxuICB9IGVsc2UgaWYgKHdpZGdldCA9PSAnZm9udCcpIHtcbiAgICBodG1sICs9ICc8c2VsZWN0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1iaW5kPVwidmFsdWU6ICcgKyBwcm9wQWNjZXNzb3IgKyAnLCAnICsgb25mb2N1c2JpbmRpbmcgKyAnXCI+JztcbiAgICBodG1sICs9ICc8b3B0Z3JvdXAgbGFiZWw9XCJTYW5zLVNlcmlmIEZvbnRzXCI+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWZcIj5BcmlhbDwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIlxcJ0NvbWljIFNhbnMgTVNcXCcsY3Vyc2l2ZSxzYW5zLXNlcmlmXCI+Q29taWMgU2FucyBNUzwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIkltcGFjdCxDaGFyY29hbCxzYW5zLXNlcmlmXCI+SW1wYWN0PC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiXFwnVHJlYnVjaGV0IE1TXFwnLEhlbHZldGljYSxzYW5zLXNlcmlmXCI+VHJlYnVjaGV0IE1TPC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZlwiPlZlcmRhbmE8L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzwvb3B0Z3JvdXA+JztcbiAgICBodG1sICs9ICc8b3B0Z3JvdXAgbGFiZWw9XCJTZXJpZiBGb250c1wiPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIkdlb3JnaWEsc2VyaWZcIj5HZW9yZ2lhPC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiXFwnVGltZXMgTmV3IFJvbWFuXFwnLFRpbWVzLHNlcmlmXCI+VGltZXMgTmV3IFJvbWFuPC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8L29wdGdyb3VwPic7XG4gICAgaHRtbCArPSAnPG9wdGdyb3VwIGxhYmVsPVwiTW9ub3NwYWNlIEZvbnRzXCI+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiXFwnQ291cmllciBOZXdcXCcsQ291cmllcixtb25vc3BhY2VcIj5Db3VyaWVyIE5ldzwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPC9vcHRncm91cD4nO1xuICAgIGh0bWwgKz0gJzwvc2VsZWN0Pic7XG4gIH0gZWxzZSBpZiAod2lkZ2V0ID09ICd1cmwnKSB7XG4gICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInVpLXRleHRidXR0b25cIj4nO1xuICAgIC8vIDxhIGNsYXNzPVwidWktc3Bpbm5lci1idXR0b24gdWktc3Bpbm5lci1kb3duIHVpLWNvcm5lci1iciB1aS1idXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktYnV0dG9uLXRleHQtb25seVwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiYnV0dG9uXCI+PHNwYW4gY2xhc3M9XCJ1aS1idXR0b24tdGV4dFwiPjxzcGFuIGNsYXNzPVwidWktaWNvbiBmYSBmYS1mdyBjYXJldC1kb3duXCI+4pa8PC9zcGFuPjwvc3Bhbj48L2E+XG4gICAgaHRtbCArPSAnPGlucHV0IGNsYXNzPVwidWktdGV4dGJ1dHRvbi1pbnB1dFwiIHNpemU9XCI3XCIgdHlwZT1cInVybFwiIHBhdHRlcm49XCIobWFpbHRvOi4rQC4rfGh0dHBzPzovLy4rXFxcXC4uK3xcXFxcWy4qXFxcXF0uKilcIiB2YWx1ZT1cIm5vdGhpbmdcIiBkYXRhLWJpbmQ9XCJjc3M6IHsgd2l0aEJ1dHRvbjogdHlwZW9mICRyb290LmxpbmtEaWFsb2cgIT09IFxcJ3VuZGVmaW5lZFxcJyB9LCB2YWxpZGF0ZWRWYWx1ZTogJyArIHByb3BBY2Nlc3NvciArICcsICcgKyBvbmZvY3VzYmluZGluZyArICdcIiAvPic7XG4gICAgaHRtbCArPSAnPGEgY2xhc3M9XCJ1aS10ZXh0YnV0dG9uLWJ1dHRvblwiIGRhdGEtYmluZD1cInZpc2libGU6IHR5cGVvZiAkcm9vdC5saW5rRGlhbG9nICE9PSBcXCd1bmRlZmluZWRcXCcsIGNsaWNrOiB0eXBlb2YgJHJvb3QubGlua0RpYWxvZyAhPT0gXFwndW5kZWZpbmVkXFwnID8gJHJvb3QubGlua0RpYWxvZy5iaW5kKCRlbGVtZW50LnByZXZpb3VzU2libGluZykgOiBmYWxzZSwgYnV0dG9uOiB7IGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhIGZhLWZ3IGZhLWVsbGlwc2lzLWhcXCcgfSwgbGFiZWw6IFxcJ09wemlvbmlcXCcsIHRleHQ6IGZhbHNlIH1cIj5PcHppb25pPC9hPic7XG4gICAgaHRtbCArPSAnPC9kaXY+JztcbiAgfSBlbHNlIGlmICh3aWRnZXQgPT0gJ2ludGVnZXInKSB7XG4gICAgLy8gYXQgdGhpcyB0aW1lIHRoZSBcInN0ZXBcIiBkZXBlbmRzIG9uIG1heCBiZWluZyBncmVhdGVyIHRoYW4gMTAwLlxuICAgIC8vIG1heWJlIHdlIHNob3VsZCBleHBvc2UgXCJzdGVwXCIgYXMgYSBjb25maWd1cmF0aW9uLCB0b29cbiAgICB2YXIgbWluID0gMDtcbiAgICB2YXIgbWF4ID0gMTAwMDtcbiAgICBpZiAobW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl9tYXggIT09ICd1bmRlZmluZWQnKSBtYXggPSBtb2RlbC5fbWF4O1xuICAgIGlmIChtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX21pbiAhPT0gJ3VuZGVmaW5lZCcpIG1pbiA9IG1vZGVsLl9taW47XG4gICAgdmFyIHN0ZXAgPSAobWF4IC0gbWluKSA+PSAxMDAgPyAxMCA6IDE7XG4gICAgdmFyIHBhZ2UgPSBzdGVwICogNTtcbiAgICBodG1sICs9ICc8aW5wdXQgY2xhc3M9XCJudW1iZXItc3Bpbm5lclwiIHNpemU9XCI3XCIgc3RlcD1cIicgKyBzdGVwICsgJ1wiIHR5cGU9XCJudW1iZXJcIiB2YWx1ZT1cIi0xXCIgZGF0YS1iaW5kPVwic3Bpbm5lcjogeyBtaW46ICcgKyBtaW4gKyAnLCBtYXg6ICcgKyBtYXggKyAnLCBwYWdlOiAnICsgcGFnZSArICcsIHZhbHVlOiAnICsgcHJvcEFjY2Vzc29yICsgJyB9LCB2YWx1ZVVwZGF0ZTogW1xcJ2NoYW5nZVxcJywgXFwnc3BpblxcJ10nICsgJywgJyArIG9uZm9jdXNiaW5kaW5nICsgJ1wiIC8+JztcbiAgfSBlbHNlIHtcbiAgICBodG1sICs9ICc8aW5wdXQgc2l6ZT1cIjdcIiB0eXBlPVwidGV4dFwiIHZhbHVlPVwibm90aGluZ1wiIGRhdGEtYmluZD1cInZhbHVlOiAnICsgcHJvcEFjY2Vzc29yICsgJywgJyArIG9uZm9jdXNiaW5kaW5nICsgJ1wiIC8+JztcbiAgfVxuXG4gIGh0bWwgKz0gJzwvbGFiZWw+JztcblxuICByZXR1cm4gaHRtbDtcbn07XG5cbnZhciBfZ2V0R2xvYmFsU3R5bGVQcm9wID0gZnVuY3Rpb24oZ2xvYmFsU3R5bGVzLCBtb2RlbCwgcHJvcCwgcGF0aCkge1xuICB2YXIgZ2xvYmFsU3R5bGVQcm9wO1xuICBpZiAodHlwZW9mIG1vZGVsICE9PSAnb2JqZWN0JyB8fCBtb2RlbCA9PT0gbnVsbCB8fCB0eXBlb2YgbW9kZWwuX3dpZGdldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHByb3AgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXRoICE9PSAndW5kZWZpbmVkJyAmJiBwYXRoLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGdsb2JhbFN0eWxlcyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZ2xvYmFsU3R5bGVzW3BhdGhdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWxTdHlsZVByb3AgPSBnbG9iYWxTdHlsZXNbcGF0aF07XG4gICAgfVxuICB9XG4gIHJldHVybiBnbG9iYWxTdHlsZVByb3A7XG59O1xuXG52YXIgX3Byb3BFZGl0b3IgPSBmdW5jdGlvbih3aXRoQmluZGluZ1Byb3ZpZGVyLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbW9kZWwsIHRoZW1lTW9kZWwsIHBhdGgsIHByb3AsIGVkaXRUeXBlLCBsZXZlbCwgYmFzZVRocmVzaG9sZCwgZ2xvYmFsU3R5bGVzLCBnbG9iYWxTdHlsZVByb3AsIHRyYWNrVXNhZ2UsIHJvb3RQcmV2aWV3QmluZGluZywgcHJldmlld0JhY2tncm91bmQpIHtcbiAgaWYgKHR5cGVvZiBsZXZlbCA9PSAndW5kZWZpbmVkJykgbGV2ZWwgPSAwO1xuXG4gIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZGVsID09ICdvYmplY3QnICYmIG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fdXNlY291bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5sb2coXCJUT0RPIEVESVRPUiBpZ25vcmluZ1wiLCBwYXRoLCBcInByb3BlcnR5IGJlY2F1c2UgaXQgaXMgbm90IHVzZWQgYnkgdGhlIHRlbXBsYXRlXCIsIFwicHJvcDpcIiwgcHJvcCwgXCJ0eXBlOlwiLCBlZGl0VHlwZSwgXCJsZXZlbDpcIiwgbGV2ZWwsIHdpdGhCaW5kaW5nUHJvdmlkZXIuX3RlbXBsYXRlTmFtZSk7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICB2YXIgcHJvcEFjY2Vzc29yID0gdHlwZW9mIGdsb2JhbFN0eWxlUHJvcCAhPSAndW5kZWZpbmVkJyA/IHByb3AgKyAnLl9kZWZhdWx0Q29tcHV0ZWQnIDogcHJvcDtcblxuICB2YXIgaHRtbCA9IFwiXCI7XG4gIHZhciB0aXRsZTtcbiAgdmFyIGlmU3Vic1Byb3AgPSBwcm9wQWNjZXNzb3I7XG4gIHZhciBpZlN1YnNHdXR0ZXIgPSAxO1xuICAvLyB0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wICE9ICd1bmRlZmluZWQnID8gMSA6IDI7XG4gIHZhciBpZlN1YnNUaHJlc2hvbGQgPSAxO1xuXG4gIC8vIFRoZSB2aXNpYmlsaXR5IGhhbmRsaW5nIGlzIGEgUElUQVxuICAvLyBcbiAgLy8gSGVyZSBhcmUgc29tZSBcImVkZ2UgY2FzZXNcIiB0byB0ZXN0IHdoZW5ldmVyIHdlIGNoYW5nZSBzb21ldGhpbmcgaGVyZTpcbiAgLy8gTE0gc29jaWFsIGZvb3RlcjogcmVtb3Zpbmcgc2hhcmVWaXNpYmlsZSBtdXN0IGJlIHJlZmxlY3RlZCBpbiB0aGUgYm9vbGVhbnMgc3ViLWNoZWNrc1xuICAvLyBGTFVJRCBzb2NpYWwgYmxvY2s6IG11bHRpcGxlIGNsaWNrcyBvbiB0aGUgXCJ3YW5kXCIgc2hvdWxkIG5vdCBtYWtlIHRoZSBlZGl0b3IgaW52aXNpYmxlXG4gIC8vIEJJUyBoZXJvTWVudSAtIEJ5IGNoYW5naW5nIHRoZSBtZW51IHZpc2liaWxpdHkgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZCBpbiBzdHlsZSBlZGl0b3JzIGZvciB0aGUgbWVudSBsaW5rc1xuICAvLyBGTFVJRCBhbG1vc3QgZXZlcnkgYmxvY2sgd2l0aCBhIGNvbG9yIHZhcmlhbnQgc29tZXRpbWVzIGtlZXBzIHNob3dpbmcgc3R5bGUgZWRpdG9yIGZvciB0aGUgaGlkZGVuIHZhcmlhbnQuXG4gIGlmICh0eXBlb2YgbW9kZWwgPT0gJ29iamVjdCcgJiYgbW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl93aWRnZXQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBEbyBub3RoaW5nIGhlcmVcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFN0eWxlUHJvcCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWZTdWJzR3V0dGVyICs9IDE7XG4gICAgfVxuICB9XG5cbiAgLy8gTk9URSBiYXNlVGhyZXNob2xkIGlzIGFkZGVkIG9ubHkgd2hlbiBnbG9iYWxTdHlsZSBpcyBub3QgZGVmaW5lZCBiZWNhdXNlIHdoZW4gd2UgaGF2ZSBnbG9iYWxTdHlsZVxuICAvLyB3ZSdyZSBnb2luZyB0byBiaW5kIHRoZSBjb21wdXRlZCB2YWx1ZXMgYW5kIG5vdCB0aGUgb3JpZ2luYWwgYW5kIHRoaXMgd2F5IHdlIGRvbid0IGFkZCBvdXJzZXJmIHRvIHRoZSBkZXBlbmRlbmN5IFxuICAvLyB0cmFja2luZyAoc3Vic2NyaXB0aW9uQ291bnQpXG4gIC8vIE5PVEUgYmFzZVRocmVzaG9sZCBpcyBhbiBcImV4cHJlc3Npb25cIiBhbmQgbm90IGEgZml4ZWQgbnVtYmVyLCBzbyB0aGlzIGlzIGEgY29uY2F0ZW5hdGlvblxuICBpZiAodHlwZW9mIGdsb2JhbFN0eWxlUHJvcCA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYmFzZVRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIGlmU3Vic1RocmVzaG9sZCArPSBiYXNlVGhyZXNob2xkO1xuXG4gIGlmICh0eXBlb2YgcHJvcCAhPSAndW5kZWZpbmVkJyAmJiAhIXRyYWNrVXNhZ2UpIHtcbiAgICBodG1sICs9ICc8IS0tIGtvIGlmU3ViczogeyBkYXRhOiAnICsgaWZTdWJzUHJvcCArICcsIHRocmVzaG9sZDogJyArIGlmU3Vic1RocmVzaG9sZCArICcsIGd1dHRlcjogJyArIGlmU3Vic0d1dHRlciArICcgfSAtLT4nO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9ICd1bmRlZmluZWQnICYmIChtb2RlbCA9PT0gbnVsbCB8fCB0eXBlb2YgbW9kZWwuX25hbWUgPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgLy8gVE9ETyB0aHJvdyBleGNlcHRpb24/XG4gICAgY29uc29sZS5sb2coXCJUT0RPIFdBUk4gTWlzc2luZyBsYWJlbCBmb3IgcHJvcGVydHkgXCIsIHByb3ApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcCA9PSAndW5kZWZpbmVkJyAmJiBtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX25hbWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmxvZyhcIlRPRE8gV0FSTiBNaXNzaW5nIGxhYmVsIGZvciBvYmplY3QgXCIsIG1vZGVsLnR5cGUgLyosIG1vZGVsICovICk7XG4gIH1cblxuICBpZiAodHlwZW9mIG1vZGVsID09ICdvYmplY3QnICYmIG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fd2lkZ2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHByb3BzID0gX2ZpbHRlclByb3BzKG1vZGVsLCBlZGl0VHlwZSwgbGV2ZWwpO1xuXG4gICAgdmFyIGhhc0N1c3RvbVN0eWxlID0gZWRpdFR5cGUgPT0gJ3N0eWxlcicgJiYgbW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLmN1c3RvbVN0eWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgc2VsZWN0ZWRJdGVtQmluZGluZyA9ICcnO1xuICAgIHZhciBhZGRpdGlvbmFsQ2xhc3NlcyA9ICcnO1xuICAgIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3VuZGVmaW5lZCcgJiYgZWRpdFR5cGUgPT0gJ2VkaXQnKSB7XG4gICAgICBzZWxlY3RlZEl0ZW1CaW5kaW5nID0gJywgY2xpY2s6IGZ1bmN0aW9uKG9iaiwgZXZ0KSB7ICRyb290LnNlbGVjdEl0ZW0oJyArIHByb3AgKyAnLCAkZGF0YSk7IHJldHVybiBmYWxzZSB9LCBjbGlja0J1YmJsZTogZmFsc2UsIGNzczogeyBzZWxlY3RlZGl0ZW06ICRyb290LmlzU2VsZWN0ZWRJdGVtKCcgKyBwcm9wICsgJykgfSwgc2Nyb2xsSW50b1ZpZXc6ICRyb290LmlzU2VsZWN0ZWRJdGVtKCcgKyBwcm9wICsgJyksICc7XG4gICAgICBhZGRpdGlvbmFsQ2xhc3NlcyArPSAnIHNlbGVjdGFibGUnO1xuICAgIH1cbiAgICBpZiAoaGFzQ3VzdG9tU3R5bGUpIHtcbiAgICAgIGFkZGl0aW9uYWxDbGFzc2VzICs9ICcgc3VwcG9ydHNDdXN0b21TdHlsZXMnO1xuICAgIH1cbiAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwib2JqRWRpdCBsZXZlbCcgKyBsZXZlbCArIGFkZGl0aW9uYWxDbGFzc2VzICsgJ1wiIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7fScgKyBzZWxlY3RlZEl0ZW1CaW5kaW5nICsgJ1wiPic7XG4gICAgdmFyIG1vZGVsTmFtZSA9IChtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX25hbWUgIT0gJ3VuZGVmaW5lZCcgPyBtb2RlbC5fbmFtZSA6ICh0eXBlb2YgcHJvcCAhPT0gJ3VuZGVmaW5lZCcgPyAnWycgKyBwcm9wICsgJ10nIDogJycpKTtcbiAgICBpZiAoaGFzQ3VzdG9tU3R5bGUpIHtcbiAgICAgIHZhciB0aGVtZVNlY3Rpb25OYW1lID0gJ1N0aWxlJztcbiAgICAgIGlmICh0eXBlb2YgdGhlbWVNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhlbWVNb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgdGhlbWVNb2RlbC5fbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhlbWVTZWN0aW9uTmFtZSA9IHRoZW1lTW9kZWwuX25hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gbWlzc2luZyBsYWJlbCBmb3IgdGhlbWUgc2VjdGlvbiBcIiwgcHJvcCwgbW9kZWwgIT09IG51bGwgPyBtb2RlbC50eXBlIDogJy0nKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWxOYW1lID0gJzxzcGFuIGNsYXNzPVwiYmxvY2tTZWxlY3Rpb25NZXRob2RcIiBkYXRhLWJpbmQ9XCJ0ZXh0OiBjdXN0b21TdHlsZSgpID8gJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsTmFtZSkgKyAnXFwnKSA6ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyh0aGVtZVNlY3Rpb25OYW1lKSArICdcXCcpXCI+QmxvY2s8L3NwYW4+JztcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxOYW1lID0gJzxzcGFuIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbE5hbWUpICsgJ1xcJylcIj4nICsgbW9kZWxOYW1lICsgJzwvc3Bhbj4nO1xuICAgIH1cbiAgICB0aXRsZSA9IG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5faGVscCAhPT0gJ3VuZGVmaW5lZCcgPyAnIHRpdGxlPVwiJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWwuX2hlbHApICsgJ1wiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbC5faGVscCkgKyAnXFwnKSB9XCInIDogJyc7XG4gICAgaHRtbCArPSAnPHNwYW4nICsgdGl0bGUgKyAnIGNsYXNzPVwib2JqTGFiZWwgbGV2ZWwnICsgbGV2ZWwgKyAnXCI+JyArIG1vZGVsTmFtZSArICc8L3NwYW4+JztcblxuICAgIGlmIChlZGl0VHlwZSA9PSAnZWRpdCcgJiYgdHlwZW9mIG1vZGVsLl9ibG9ja0Rlc2NyaXB0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cImJsb2NrRGVzY3JpcHRpb25cIiBkYXRhLWJpbmQ9XCJodG1sOiAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWwuX2Jsb2NrRGVzY3JpcHRpb24pICsgJ1xcJylcIj4nICsgbW9kZWwuX2Jsb2NrRGVzY3JpcHRpb24gKyAnPC9kaXY+JztcbiAgICB9XG5cbiAgICAvKiBDVVNUT00gU1RZTEUgKi9cbiAgICBpZiAoaGFzQ3VzdG9tU3R5bGUpIHtcbiAgICAgIGh0bWwgKz0gJzxsYWJlbCBjbGFzcz1cImRhdGEtYm9vbGVhbiBibG9ja0NoZWNrXCIgZGF0YS1iaW5kPVwidG9vbHRpcHM6IHsgfVwiPic7XG4gICAgICBodG1sICs9ICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJub3RoaW5nXCIgZGF0YS1iaW5kPVwiZm9jdXNhYmxlOiB0cnVlLCBjaGVja2VkOiBjdXN0b21TdHlsZVwiIC8+JztcbiAgICAgIGh0bWwgKz0gJzxzcGFuIHRpdGxlPVwiU3dpdGNoIGJldHdlZW4gZ2xvYmFsIGFuZCBibG9jayBsZXZlbCBzdHlsZXMgZWRpdGluZ1wiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnU3dpdGNoIGJldHdlZW4gZ2xvYmFsIGFuZCBibG9jayBsZXZlbCBzdHlsZXMgZWRpdGluZ1xcJykgfVwiIGNsYXNzPVwiY2hlY2tib3gtcmVwbGFjZXIgY2hlY2tib3gtcmVwbGFjZXItb25vZmZcIj48L3NwYW4+JzsgLy8gIGRhdGEtYmluZD1cInRvb2x0aXA6IHsgY29udGVudDogXFwncGVyc29uYWxpenphIHR1dHRpXFwnIH1cIlxuICAgICAgaHRtbCArPSAnPC9sYWJlbD4nO1xuICAgICAgaHRtbCArPSAnPCEtLSBrbyB0ZW1wbGF0ZTogeyBuYW1lOiBcXCdjdXN0b21zdHlsZVxcJywgaWY6IGN1c3RvbVN0eWxlIH0gLS0+PCEtLSAva28gLS0+JztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3AgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGh0bWwgKz0gJzwhLS0ga28gd2l0aDogJyArIHByb3AgKyAnIC0tPic7XG5cbiAgICAgIC8qIFBSRVZJRVcgKi9cbiAgICAgIGlmIChsZXZlbCA9PSAxICYmIHR5cGVvZiBwcm9wICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZWwuX3ByZXZpZXdCaW5kaW5ncyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2l0aEJpbmRpbmdQcm92aWRlciAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygcm9vdFByZXZpZXdCaW5kaW5nICE9ICd1bmRlZmluZWQnKSBodG1sICs9ICc8IS0tIGtvIHdpdGg6ICRyb290LmNvbnRlbnQoKSAtLT48ZGl2IGNsYXNzPVwib2JqUHJldmlld1wiIGRhdGEtYmluZD1cIicgKyByb290UHJldmlld0JpbmRpbmcgKyAnXCI+PC9kaXY+PCEtLSAva28gLS0+JztcbiAgICAgICAgICBpZiAodHlwZW9mIHByZXZpZXdCYWNrZ3JvdW5kICE9ICd1bmRlZmluZWQnKSBodG1sICs9ICc8IS0tIGtvIHdpdGg6ICRwYXJlbnQgLS0+PGRpdiBjbGFzcz1cIm9ialByZXZpZXdcIiBkYXRhLWJpbmQ9XCInICsgcHJldmlld0JhY2tncm91bmQgKyAnXCI+PC9kaXY+PCEtLSAva28gLS0+JztcbiAgICAgICAgICB2YXIgcHJldmlld0JpbmRpbmdzID0gZWxhYm9yYXRlRGVjbGFyYXRpb25zKHVuZGVmaW5lZCwgbW9kZWwuX3ByZXZpZXdCaW5kaW5ncywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHdpdGhCaW5kaW5nUHJvdmlkZXIuYmluZCh0aGlzLCBwYXRoICsgJy4nKSk7XG4gICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm9ialByZXZpZXdcIj48ZGl2IGNsYXNzPVwib2JqUHJldmlld0lubmVyXCIgZGF0YS1iaW5kPVwiJyArIHByZXZpZXdCaW5kaW5ncyArICdcIj48L2Rpdj48L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogUFJFVklFVyAqL1xuICAgIHZhciBwcmV2aWV3Qkc7XG4gICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICBpZiAodHlwZW9mIG1vZGVsLl9wcmV2aWV3QmluZGluZ3MgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJldmlld0JHID0gZWxhYm9yYXRlRGVjbGFyYXRpb25zKHVuZGVmaW5lZCwgbW9kZWwuX3ByZXZpZXdCaW5kaW5ncywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHdpdGhCaW5kaW5nUHJvdmlkZXIuYmluZCh0aGlzLCBwYXRoLmxlbmd0aCA+IDAgPyBwYXRoICsgJy4nIDogJycpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaSwgbmV3UGF0aDtcblxuICAgIHZhciBiZWZvcmUgPSBodG1sLmxlbmd0aDtcblxuICAgIHZhciBuZXdUaGVtZU1vZGVsO1xuICAgIHZhciBuZXdHbG9iYWxTdHlsZVByb3A7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld1BhdGggPSBwYXRoLmxlbmd0aCA+IDAgPyBwYXRoICsgXCIuXCIgKyBwcm9wc1tpXSA6IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBtb2RlbFtwcm9wc1tpXV0gIT0gJ29iamVjdCcgfHwgbW9kZWxbcHJvcHNbaV1dID09PSBudWxsIHx8IHR5cGVvZiBtb2RlbFtwcm9wc1tpXV0uX3dpZGdldCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBuZXdHbG9iYWxTdHlsZVByb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gMCAmJiBwcm9wc1tpXSA9PSAndGhlbWUnKVxuICAgICAgICAgIGh0bWwgKz0gX3Byb3BFZGl0b3Iod2l0aEJpbmRpbmdQcm92aWRlciwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG1vZGVsW3Byb3BzW2ldXSwgbmV3VGhlbWVNb2RlbCwgbmV3UGF0aCwgcHJvcHNbaV0sIGVkaXRUeXBlLCAwLCBiYXNlVGhyZXNob2xkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJhY2tVc2FnZSwgcm9vdFByZXZpZXdCaW5kaW5nKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3R2xvYmFsU3R5bGVQcm9wID0gX2dldEdsb2JhbFN0eWxlUHJvcChnbG9iYWxTdHlsZXMsIG1vZGVsW3Byb3BzW2ldXSwgcHJvcHNbaV0sIG5ld1BhdGgpO1xuICAgICAgICAgIGh0bWwgKz0gX3Byb3BFZGl0b3Iod2l0aEJpbmRpbmdQcm92aWRlciwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG1vZGVsW3Byb3BzW2ldXSwgbmV3VGhlbWVNb2RlbCwgbmV3UGF0aCwgcHJvcHNbaV0sIGVkaXRUeXBlLCBsZXZlbCArIDEsIGJhc2VUaHJlc2hvbGQsIGdsb2JhbFN0eWxlcywgbmV3R2xvYmFsU3R5bGVQcm9wLCB0cmFja1VzYWdlLCByb290UHJldmlld0JpbmRpbmcsIHByZXZpZXdCRyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdQYXRoID0gcGF0aC5sZW5ndGggPiAwID8gcGF0aCArIFwiLlwiICsgcHJvcHNbaV0gOiBwcm9wc1tpXTtcbiAgICAgIGlmICghKHR5cGVvZiBtb2RlbFtwcm9wc1tpXV0gIT0gJ29iamVjdCcgfHwgbW9kZWxbcHJvcHNbaV1dID09PSBudWxsIHx8IHR5cGVvZiBtb2RlbFtwcm9wc1tpXV0uX3dpZGdldCAhPSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgbmV3R2xvYmFsU3R5bGVQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobGV2ZWwgPT09IDAgJiYgcHJvcHNbaV0gPT0gJ3RoZW1lJylcbiAgICAgICAgICBodG1sICs9IF9wcm9wRWRpdG9yKHdpdGhCaW5kaW5nUHJvdmlkZXIsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBtb2RlbFtwcm9wc1tpXV0sIG5ld1RoZW1lTW9kZWwsIG5ld1BhdGgsIHByb3BzW2ldLCBlZGl0VHlwZSwgMCwgYmFzZVRocmVzaG9sZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRyYWNrVXNhZ2UsIHJvb3RQcmV2aWV3QmluZGluZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld0dsb2JhbFN0eWxlUHJvcCA9IF9nZXRHbG9iYWxTdHlsZVByb3AoZ2xvYmFsU3R5bGVzLCBtb2RlbFtwcm9wc1tpXV0sIHByb3BzW2ldLCBuZXdQYXRoKTtcbiAgICAgICAgICBodG1sICs9IF9wcm9wRWRpdG9yKHdpdGhCaW5kaW5nUHJvdmlkZXIsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBtb2RlbFtwcm9wc1tpXV0sIG5ld1RoZW1lTW9kZWwsIG5ld1BhdGgsIHByb3BzW2ldLCBlZGl0VHlwZSwgbGV2ZWwgKyAxLCBiYXNlVGhyZXNob2xkLCBnbG9iYWxTdHlsZXMsIG5ld0dsb2JhbFN0eWxlUHJvcCwgdHJhY2tVc2FnZSwgcm9vdFByZXZpZXdCaW5kaW5nLCBwcmV2aWV3QkcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZGVkID0gaHRtbC5sZW5ndGggLSBiZWZvcmU7XG4gICAgaWYgKGFkZGVkID09PSAwKSB7XG4gICAgICAvLyBObyBlZGl0YWJsZSBjb250ZW50OiBpZiB0aGlzIGlzIGluIGNvbnRleHQgXCJ0ZW1wbGF0ZVwiIHdlIGxlYXZlIGl0IGVtcHR5LCBvdGhlcndpc2Ugd2Ugc2hvdyBhbiBoZWxwLlxuICAgICAgaWYgKHR5cGVvZiBtb2RlbCA9PSAnb2JqZWN0JyAmJiBtb2RlbCAhPT0gbnVsbCAmJiBtb2RlbC5fY29udGV4dCA9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE8gbW92ZSBtZSB0byBhIHRtcGw/XG4gICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJvYmpFbXB0eVwiIGRhdGEtYmluZD1cImh0bWw6ICRyb290LnQoXFwnU2VsZWN0ZWQgZWxlbWVudCBoYXMgbm8gZWRpdGFibGUgcHJvcGVydGllc1xcJylcIj5TZWxlY3RlZCBlbGVtZW50IGhhcyBubyBlZGl0YWJsZSBwcm9wZXJ0aWVzPC9kaXY+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3AgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGh0bWwgKz0gJzwhLS0gL2tvIC0tPic7XG4gICAgfVxuICAgIGh0bWwgKz0gJzwvZGl2Pic7XG5cbiAgfSBlbHNlIHtcbiAgICB2YXIgY2hlY2tib3hlcyA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbFN0eWxlcyA9PSAndW5kZWZpbmVkJykgY2hlY2tib3hlcyA9IGZhbHNlO1xuXG4gICAgaWYgKG1vZGVsID09PSBudWxsIHx8IHR5cGVvZiBtb2RlbCAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgbW9kZWwuX3dpZGdldCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGJpbmRpbmdzID0gW107XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wICE9ICd1bmRlZmluZWQnKSBiaW5kaW5ncy5wdXNoKCdjc3M6IHsgbm90bnVsbDogJyArIHByb3AgKyAnKCkgIT09IG51bGwgfScpO1xuICAgICAgdGl0bGUgPSBtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX2hlbHAgIT09ICd1bmRlZmluZWQnID8gJyB0aXRsZT1cIicgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsLl9oZWxwKSArICdcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWwuX2hlbHApICsgJ1xcJykgfVwiJyA6ICcnO1xuICAgICAgaWYgKHRpdGxlLmxlbmd0aCA+IDApIGJpbmRpbmdzLnB1c2goJ3Rvb2x0aXBzOiB7fScpO1xuICAgICAgdmFyIGJpbmQgPSBiaW5kaW5ncy5sZW5ndGggPiAwID8gJ2RhdGEtYmluZD1cIicgKyB1dGlscy5hZGRTbGFzaGVzKGJpbmRpbmdzLmpvaW4oKSkgKyAnXCInIDogJyc7XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicHJvcEVkaXRvciAnICsgKGNoZWNrYm94ZXMgPyAnY2hlY2tib3hlcycgOiAnJykgKyAnXCInICsgYmluZCArICc+JztcblxuICAgICAgdmFyIG1vZGVsTmFtZTIgPSAobW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl9uYW1lICE9ICd1bmRlZmluZWQnID8gbW9kZWwuX25hbWUgOiAodHlwZW9mIHByb3AgIT09ICd1bmRlZmluZWQnID8gJ1snICsgcHJvcCArICddJyA6ICcnKSk7XG4gICAgICBtb2RlbE5hbWUyID0gJzxzcGFuIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbE5hbWUyKSArICdcXCcpXCI+JyArIG1vZGVsTmFtZTIgKyAnPC9zcGFuPic7XG4gICAgICBodG1sICs9ICc8c3BhbicgKyB0aXRsZSArICcgY2xhc3M9XCJwcm9wTGFiZWxcIj4nICsgbW9kZWxOYW1lMiArICc8L3NwYW4+JztcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJwcm9wSW5wdXQgJyArICh0eXBlb2YgZ2xvYmFsU3R5bGVzICE9ICd1bmRlZmluZWQnID8gJ2xvY2FsJyA6ICcnKSArICdcIiBkYXRhLWJpbmQ9XCJjc3M6IHsgZGVmYXVsdDogJyArIHByb3AgKyAnKCkgPT09IG51bGwgfVwiPic7XG4gICAgICBodG1sICs9IF9wcm9wSW5wdXQobW9kZWwsIHByb3AsIHByb3BBY2Nlc3NvciwgZWRpdFR5cGUsIHdpZGdldHMpO1xuICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJwcm9wSW5wdXQgZ2xvYmFsXCIgZGF0YS1iaW5kPVwiY3NzOiB7IG92ZXJyaWRkZW46ICcgKyBwcm9wICsgJygpICE9PSBudWxsIH1cIj4nO1xuICAgICAgICBodG1sICs9IF9wcm9wSW5wdXQobW9kZWwsIHByb3AsIGdsb2JhbFN0eWxlUHJvcCwgZWRpdFR5cGUsIHdpZGdldHMpO1xuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuXG4gICAgICAgIGlmIChjaGVja2JveGVzKSB7XG4gICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInByb3BDaGVja1wiPjxsYWJlbCBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge31cIj48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgZGF0YS1iaW5kPVwiZm9jdXNhYmxlOiB0cnVlLCBjbGljazogZnVuY3Rpb24oZXZ0LCBvYmopIHsgJHJvb3QubG9jYWxHbG9iYWxTd2l0Y2goJyArIHByb3AgKyAnLCAnICsgZ2xvYmFsU3R5bGVQcm9wICsgJyk7IHJldHVybiB0cnVlOyB9LCBjaGVja2VkOiAnICsgcHJvcCArICcoKSAhPT0gbnVsbFwiPic7XG4gICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJjaGVja2JveC1yZXBsYWNlclwiIGRhdGEtYmluZD1cImNzczogeyBjaGVja2VkOiAnICsgcHJvcCArICcoKSAhPT0gbnVsbCB9LCBhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1RoaXMgc3R5bGUgaXMgc3BlY2lmaWMgZm9yIHRoaXMgYmxvY2s6IGNsaWNrIGhlcmUgdG8gcmVtb3ZlIHRoZSBjdXN0b20gc3R5bGUgYW5kIHJldmVydCB0byB0aGUgdGhlbWUgdmFsdWVcXCcpIH1cIj48L3NwYW4+JztcbiAgICAgICAgICBodG1sICs9ICc8L2xhYmVsPjwvZGl2Pic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgfSBlbHNlIGlmIChtb2RlbCA9PT0gbnVsbCB8fCB0eXBlb2YgbW9kZWwgIT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIFRPRE8gcmVtb3ZlIGRlYnVnIG91dHB1dFxuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInByb3BFZGl0b3IgdW5rbm93blwiPltBfCcgKyBwcm9wICsgXCJ8XCIgKyB0eXBlb2YgbW9kZWwgKyAnXTwvZGl2Pic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE8gcmVtb3ZlIGRlYnVnIG91dHB1dFxuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInByb3BFZGl0b3IgdW5rbm93blwiPltCfCcgKyBwcm9wICsgXCJ8XCIgKyB0eXBlb2YgbW9kZWwgKyAnXTwvZGl2Pic7XG4gICAgfVxuXG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCAhPSAndW5kZWZpbmVkJyAmJiAhIXRyYWNrVXNhZ2UpIHtcbiAgICBodG1sICs9ICc8IS0tIC9rbyAtLT4nO1xuICAgIGh0bWwgKz0gJzwhLS0ga28gaWZTdWJzOiB7IG5vdDogdHJ1ZSwgZGF0YTogJyArIGlmU3Vic1Byb3AgKyAnLCB0aHJlc2hvbGQ6ICcgKyBpZlN1YnNUaHJlc2hvbGQgKyAnLCBndXR0ZXI6IDAgfSAtLT4nO1xuICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwibGFiZWwgbm90dXNlZFwiPignICsgcHJvcCArICcpPC9zcGFuPic7XG4gICAgaHRtbCArPSAnPCEtLSAva28gLS0+JztcbiAgfVxuXG4gIHJldHVybiBodG1sO1xufTtcblxuXG52YXIgY3JlYXRlQmxvY2tFZGl0b3IgPSBmdW5jdGlvbihkZWZzLCB3aWRnZXRzLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsIGVkaXRUeXBlLCB0ZW1wbGF0ZUNyZWF0b3IsIGJhc2VUaHJlc2hvbGQsIHRyYWNrR2xvYmFsU3R5bGVzLCB0cmFja1VzYWdlLCBmcm9tTGV2ZWwpIHtcbiAgaWYgKHR5cGVvZiB0cmFja1VzYWdlID09ICd1bmRlZmluZWQnKSB0cmFja1VzYWdlID0gdHJ1ZTtcbiAgdmFyIG1vZGVsID0gbW9kZWxEZWYuZ2V0RGVmKGRlZnMsIHRlbXBsYXRlTmFtZSk7XG5cbiAgdmFyIHJvb3RNb2RlbCA9IG1vZGVsRGVmLmdldERlZihkZWZzLCByb290TW9kZWxOYW1lKTtcbiAgdmFyIHJvb3RQcmV2aWV3QmluZGluZ3M7XG4gIGlmICh0eXBlb2Ygcm9vdE1vZGVsLl9wcmV2aWV3QmluZGluZ3MgIT0gJ3VuZGVmaW5lZCcgJiYgdGVtcGxhdGVOYW1lICE9ICd0aGFlbWUnICYmIGVkaXRUeXBlID09ICdzdHlsZXInKSB7XG4gICAgcm9vdFByZXZpZXdCaW5kaW5ncyA9IGVsYWJvcmF0ZURlY2xhcmF0aW9ucyh1bmRlZmluZWQsIHJvb3RNb2RlbC5fcHJldmlld0JpbmRpbmdzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbW9kZWxEZWYuZ2V0QmluZFZhbHVlLmJpbmQodW5kZWZpbmVkLCBkZWZzLCB0aGVtZVVwZGF0ZXIsIHJvb3RNb2RlbE5hbWUsIHJvb3RNb2RlbE5hbWUsICcnKSk7XG4gIH1cblxuICB2YXIgZ2xvYmFsU3R5bGVzID0gdHlwZW9mIHRyYWNrR2xvYmFsU3R5bGVzICE9ICd1bmRlZmluZWQnICYmIHRyYWNrR2xvYmFsU3R5bGVzID8gZGVmc1t0ZW1wbGF0ZU5hbWVdLl9nbG9iYWxTdHlsZXMgOiB1bmRlZmluZWQ7XG4gIHZhciBnbG9iYWxTdHlsZVByb3AgPSB0eXBlb2YgdHJhY2tHbG9iYWxTdHlsZXMgIT0gJ3VuZGVmaW5lZCcgJiYgdHJhY2tHbG9iYWxTdHlsZXMgPyBkZWZzW3RlbXBsYXRlTmFtZV0uX2dsb2JhbFN0eWxlIDogdW5kZWZpbmVkO1xuXG5cbiAgdmFyIHRoZW1lTW9kZWw7XG4gIGlmICh0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBtbSA9IG1vZGVsRGVmLmdldERlZihkZWZzLCAndGhlbWUnKTtcbiAgICAvLyBUT0RPIHJlbW92ZSBkZXByZWNhdGVkICR0aGVtZVxuICAgIHRoZW1lTW9kZWwgPSBtbVtnbG9iYWxTdHlsZVByb3AucmVwbGFjZSgvXihcXCR0aGVtZXxfdGhlbWVfKVxcLi8sICcnKV07XG4gIH1cblxuXG4gIHZhciB3aXRoQmluZGluZ1Byb3ZpZGVyID0gbW9kZWxEZWYuZ2V0QmluZFZhbHVlLmJpbmQodW5kZWZpbmVkLCBkZWZzLCB0aGVtZVVwZGF0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSk7XG4gIHdpdGhCaW5kaW5nUHJvdmlkZXIuX3RlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcblxuICB2YXIgaHRtbCA9ICc8ZGl2IGNsYXNzPVwiZWRpdG9yXCI+JztcbiAgaHRtbCArPSBcIjxkaXYgY2xhc3M9XFxcImJsb2NrVHlwZVwiICsgKHR5cGVvZiBnbG9iYWxTdHlsZXMgIT0gJ3VuZGVmaW5lZCcgPyBcIiB3aXRoZGVmYXVsdHNcIiA6IFwiXCIpICsgXCJcXFwiPlwiICsgbW9kZWwudHlwZSArIFwiPC9kaXY+XCI7XG5cbiAgdmFyIGVkaXRvckNvbnRlbnQgPSBfcHJvcEVkaXRvcih3aXRoQmluZGluZ1Byb3ZpZGVyLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbW9kZWwsIHRoZW1lTW9kZWwsIFwiXCIsIHVuZGVmaW5lZCwgZWRpdFR5cGUsIGZyb21MZXZlbCwgYmFzZVRocmVzaG9sZCwgZ2xvYmFsU3R5bGVzLCBnbG9iYWxTdHlsZVByb3AsIHRyYWNrVXNhZ2UsIHJvb3RQcmV2aWV3QmluZGluZ3MpO1xuICBpZiAoZWRpdG9yQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgaHRtbCArPSBlZGl0b3JDb250ZW50O1xuICB9XG5cbiAgaHRtbCArPSAnPC9kaXY+JztcblxuICB0ZW1wbGF0ZUNyZWF0b3IoaHRtbCwgdGVtcGxhdGVOYW1lLCBlZGl0VHlwZSk7XG59O1xuXG52YXIgY3JlYXRlQmxvY2tFZGl0b3JzID0gZnVuY3Rpb24oZGVmcywgd2lkZ2V0cywgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZUNyZWF0b3IsIGJhc2VUaHJlc2hvbGQpIHtcbiAgY3JlYXRlQmxvY2tFZGl0b3IoZGVmcywgd2lkZ2V0cywgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCAnZWRpdCcsIHRlbXBsYXRlQ3JlYXRvciwgYmFzZVRocmVzaG9sZCk7XG4gIGNyZWF0ZUJsb2NrRWRpdG9yKGRlZnMsIHdpZGdldHMsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgJ3N0eWxlcicsIHRlbXBsYXRlQ3JlYXRvciwgYmFzZVRocmVzaG9sZCwgdHJ1ZSk7XG59O1xuXG52YXIgZ2VuZXJhdGVFZGl0b3JzID0gZnVuY3Rpb24odGVtcGxhdGVEZWYsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCB0ZW1wbGF0ZUNyZWF0b3IsIGJhc2VUaHJlc2hvbGQpIHtcbiAgdmFyIGRlZnMgPSB0ZW1wbGF0ZURlZi5fZGVmcztcbiAgdmFyIHRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlRGVmLnRlbXBsYXRlTmFtZTtcbiAgdmFyIGJsb2NrcyA9IHRlbXBsYXRlRGVmLl9ibG9ja3M7XG4gIHZhciBpZHg7XG4gIHZhciBibG9ja0RlZnMgPSBbXTtcbiAgZm9yIChpZHggPSAwOyBpZHggPCBibG9ja3MubGVuZ3RoOyBpZHgrKykge1xuICAgIGlmICh0eXBlb2YgYmxvY2tzW2lkeF0uY29udGFpbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYmxvY2tEZWZzLnB1c2gobW9kZWxEZWYuZ2VuZXJhdGVNb2RlbChkZWZzLCBibG9ja3NbaWR4XS5ibG9jaykpO1xuICAgIH1cbiAgICBjcmVhdGVCbG9ja0VkaXRvcnMoZGVmcywgd2lkZ2V0cywgdW5kZWZpbmVkLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgYmxvY2tzW2lkeF0ucm9vdCwgYmxvY2tzW2lkeF0uYmxvY2ssIHRlbXBsYXRlQ3JlYXRvciwgYmFzZVRocmVzaG9sZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZnNbJ3RoZW1lJ10gIT0gJ3VuZGVmaW5lZCcpIGNyZWF0ZUJsb2NrRWRpdG9yKGRlZnMsIHdpZGdldHMsIHVuZGVmaW5lZCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHRlbXBsYXRlTmFtZSwgJ3RoZW1lJywgJ3N0eWxlcicsIHRlbXBsYXRlQ3JlYXRvciwgdW5kZWZpbmVkLCBmYWxzZSwgZmFsc2UsIC0xKTtcbiAgcmV0dXJuIGJsb2NrRGVmcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVFZGl0b3JzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgbW9kZWxEZWYgPSByZXF1aXJlKFwiLi9tb2RlbC5qc1wiKTtcblxudmFyIHdyYXBwZWRSZXN1bHRNb2RlbCA9IGZ1bmN0aW9uKHRlbXBsYXRlRGVmKSB7XG4gIHZhciBkZWZzID0gdGVtcGxhdGVEZWYuX2RlZnM7XG4gIHZhciB0ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZURlZi50ZW1wbGF0ZU5hbWU7XG4gIHZhciBmaW5hbE1vZGVsQ29udGVudERlZiA9IG1vZGVsRGVmLmdldERlZihkZWZzLCB0ZW1wbGF0ZU5hbWUpO1xuXG4gIHZhciBmaW5hbE1vZGVsQ29udGVudCA9IG1vZGVsRGVmLmdlbmVyYXRlUmVzdWx0TW9kZWwodGVtcGxhdGVEZWYpO1xuXG4gIHZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4vd3JhcHBlci5qc1wiKTtcbiAgdmFyIHJlcyA9IHdyYXBwZXIoZmluYWxNb2RlbENvbnRlbnQsIGZpbmFsTW9kZWxDb250ZW50RGVmLCBkZWZzKTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuLy8gcmVxdWlyZXMgb25seSB3aGVuIGltcG9ydGVkXG52YXIgdHJhbnNsYXRlVGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHR0ID0gcmVxdWlyZSgnLi9wYXJzZXIuanMnKTtcbiAgcmV0dXJuIHR0LmFwcGx5KHR0LCBhcmd1bWVudHMpO1xufTtcblxuLy8gcmVxdWlyZXMgb25seSB3aGVuIGltcG9ydGVkXG52YXIgZ2VuZXJhdGVFZGl0b3JzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnZSA9IHJlcXVpcmUoJy4vZWRpdG9yLmpzJyk7XG4gIHJldHVybiBnZS5hcHBseShnZSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBjaGVja01vZGVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjbSA9IHJlcXVpcmUoJy4vY2hlY2ttb2RlbC5qcycpO1xuICByZXR1cm4gY20uYXBwbHkoY20sIGFyZ3VtZW50cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNsYXRlVGVtcGxhdGU6IHRyYW5zbGF0ZVRlbXBsYXRlLFxuICB3cmFwcGVkUmVzdWx0TW9kZWw6IHdyYXBwZWRSZXN1bHRNb2RlbCxcbiAgZ2VuZXJhdGVSZXN1bHRNb2RlbDogbW9kZWxEZWYuZ2VuZXJhdGVSZXN1bHRNb2RlbCxcbiAgZ2VuZXJhdGVFZGl0b3JzOiBnZW5lcmF0ZUVkaXRvcnMsXG4gIGNoZWNrTW9kZWw6IGNoZWNrTW9kZWxcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpFeHRlbmQgPSByZXF1aXJlKFwiLi9kb211dGlscy5qc1wiKS5vYmpFeHRlbmQ7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG52YXIgX3ZhbHVlU2V0ID0gZnVuY3Rpb24oZGVmcywgbW9kZWwsIHByb3AsIHZhbHVlKSB7XG4gIHZhciBkb3RQb3MgPSBwcm9wLmluZGV4T2YoJy4nKTtcbiAgaWYgKGRvdFBvcyA9PSAtMSkge1xuICAgIGlmICh0eXBlb2YgbW9kZWxbcHJvcF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVW5kZWZpbmVkIHByb3AgXCIgKyBwcm9wICsgXCIgd2hpbGUgc2V0dGluZyB2YWx1ZSBcIiArIHZhbHVlICsgXCIgaW4gbW9kZWwuX3ZhbHVlU2V0XCIpO1xuICAgIH0gZWxzZSBpZiAobW9kZWxbcHJvcF0gPT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnB1c2ggPT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUubG9nKFwibnVsbHByb3BvYmplY3R2YWx1ZVwiLCBwcm9wLCB2YWx1ZSk7XG4gICAgICBtb2RlbFtwcm9wXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsW3Byb3BdID09ICdvYmplY3QnICYmIHR5cGVvZiBtb2RlbFtwcm9wXS5wdXNoID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB2YWx1ZXM7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmFsdWVzU3RyaW5nID0gdmFsdWUubWF0Y2goL15cXFsoLiopXFxdJC8pO1xuICAgICAgICBpZiAodmFsdWVzU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWVzID0gdmFsdWVzU3RyaW5nWzFdLnNwbGl0KCcsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGRlZmF1bHQgdmFsdWUgZm9yIGFycmF5IHByb3BlcnR5IFwiICsgcHJvcCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnB1c2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGRlZmF1bHQgdmFsdWUgZm9yIGFycmF5IHByb3BlcnR5IFwiICsgcHJvcCArIFwiOiBcIiArIHZhbHVlICsgXCIgdHlwZW9mIFwiICsgKHR5cGVvZiB2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodmFsdWVzW2ldLnN1YnN0cigwLCAxKSA9PSAnQCcpIHtcbiAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IChAKSwgc28gd2UgY2FuIHJlbW92ZSBcImRlZnNcIiBmcm9tIHRoaXMgZnVuY3Rpb24sIHRvby5cbiAgICAgICAgICByZXMucHVzaChfZ2VuZXJhdGVNb2RlbChkZWZzLCB2YWx1ZXNbaV0uc3Vic3RyKDEpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXMucHVzaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb2RlbFtwcm9wXSA9IHJlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgbW9kZWxbcHJvcF0gPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBUT0RPIGRvZXMgdGhpcyBzdGlsbCBoYXBwZW4/IERlYnVnL3Rlc3QgbWUuXG4gICAgICBtb2RlbFtwcm9wXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsW3Byb3BdID09ICdvYmplY3QnICYmIG1vZGVsW3Byb3BdICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbFtwcm9wXS5fd2lkZ2V0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSBjb25zb2xlLmxvZyhcIm9iamVjdHZhbHVlXCIsIHByb3AsIG1vZGVsW3Byb3BdLl93aWRnZXQsIHZhbHVlKTtcbiAgICAgIC8vIF9kYXRhIGlzIGRlZmluZWQgZm9yIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgbW9kZWxbcHJvcF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJzZXR0aW5nXCIsIHR5cGVvZiBtb2RlbFtwcm9wXSwgbW9kZWxbcHJvcF0sIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcC5zdWJzdHIoMCwgZG90UG9zKTtcbiAgICBfdmFsdWVTZXQoZGVmcywgbW9kZWxbcHJvcE5hbWVdLCBwcm9wLnN1YnN0cihkb3RQb3MgKyAxKSwgdmFsdWUpO1xuICB9XG59O1xuXG52YXIgX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZiA9IGZ1bmN0aW9uKGRlZnMsIHRlbXBsYXRlTmFtZSwgcHJvcGVydGllcywgbmFtZWRQcm9wZXJ0aWVzKSB7XG4gIGlmICh0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdICE9PSAndW5kZWZpbmVkJyAmJiBkZWZzW3RlbXBsYXRlTmFtZV0uX2luaXRpYWxpemVkICYmICFkZWZzW3RlbXBsYXRlTmFtZV0uX3dyaXRlYWJsZSkge1xuICAgIGNvbnNvbGUubG9nKFwiX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZlwiLCBkZWZzLCB0ZW1wbGF0ZU5hbWUsIHByb3BlcnRpZXMsIG5hbWVkUHJvcGVydGllcyk7XG4gICAgdGhyb3cgXCJUcnlpbmcgdG8gYWx0ZXIgbm9uIHdyaXRlYWJsZSBtb2RlbDogXCIgKyB0ZW1wbGF0ZU5hbWUgKyBcIiAvIFwiICsgcHJvcGVydGllcztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdID09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVmc1t0ZW1wbGF0ZU5hbWVdID0ge1xuICAgICAgX3dyaXRlYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgLy8gRmFsbGJhY2sgY29tcHV0YXRpb24gb2YgXCJjYXRlZ29yeVwiIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgbmFtZVxuICAgIC8vIFRPRE8gcmVtb3ZlIG1lOiB0aGlzIHNob3VsZCBiZSBhbHdheXMgZGVmaW5lZCBpbiB0aGUgdGVtcGxhdGUgZGVmaW5pdGlvbiwgbm8gbmVlZCB0byBoYXJkY29kZSB0aGlzIHN0dWZmLlxuICAgIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzID09ICd1bmRlZmluZWQnKSBuYW1lZFByb3BlcnRpZXMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcy5jYXRlZ29yeSA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9jYXRlZ29yeSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHRlbXBsYXRlTmFtZS5tYXRjaCgvKF50fC5UKWhlbWUkLykgfHwgdGVtcGxhdGVOYW1lLm1hdGNoKC8oXnN8LlMpdHlsZSQvKSB8fCB0ZW1wbGF0ZU5hbWUubWF0Y2goLyheY3wuQylvbG9yJC8pIHx8IHRlbXBsYXRlTmFtZS5tYXRjaCgvKF5yfC5SKWFkaXVzJC8pKSB7XG4gICAgICAgIG5hbWVkUHJvcGVydGllcy5jYXRlZ29yeSA9ICdzdHlsZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lZFByb3BlcnRpZXMuY2F0ZWdvcnkgPSAnY29udGVudCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUT0RPIGNoZWNrIGlmIHRoaXMgaXMgbmVlZGVkIGJlZm9yZSB0aGUgZW5kaW5nIG5hbWVkUHJvcGVydHkgXCJsb29wXCIgb3Igbm90LlxuICAgIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzLm5hbWUgIT0gJ3VuZGVmaW5lZCcpIGRlZnNbdGVtcGxhdGVOYW1lXS5fbmFtZSA9IG5hbWVkUHJvcGVydGllcy5uYW1lO1xuXG4gICAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMudGhlbWVPdmVycmlkZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgZGVmc1t0ZW1wbGF0ZU5hbWVdLl90aGVtZU92ZXJyaWRlID0gbmFtZWRQcm9wZXJ0aWVzLnRoZW1lT3ZlcnJpZGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzLmdsb2JhbFN0eWxlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWZzW3RlbXBsYXRlTmFtZV0uX2dsb2JhbFN0eWxlID0gbmFtZWRQcm9wZXJ0aWVzLmdsb2JhbFN0eWxlO1xuICAgICAgLy8gVE9ETyByZW1vdmUgZGVwcmVjYXRlZCAkdGhlbWVcbiAgICAgIHZhciBnbG9iYWxTdHlsZVN1YiA9IG5hbWVkUHJvcGVydGllcy5nbG9iYWxTdHlsZS5yZXBsYWNlKC9eKFxcJHRoZW1lfF90aGVtZV8pXFwuLywgJycpO1xuICAgICAgdmFyIHAgPSBnbG9iYWxTdHlsZVN1Yi5pbmRleE9mKCcuJyk7XG4gICAgICB2YXIgZ3MgPSBwICE9IC0xID8gZ2xvYmFsU3R5bGVTdWIuc3Vic3RyKDAsIHApIDogZ2xvYmFsU3R5bGVTdWI7XG4gICAgICBfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsICd0aGVtZScsIGdzKTtcblxuICAgICAgaWYgKHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0uX3RoZW1lT3ZlcnJpZGUgPT09ICd1bmRlZmluZWQnIHx8ICEhZGVmc1t0ZW1wbGF0ZU5hbWVdLl90aGVtZU92ZXJyaWRlKSB7XG4gICAgICAgIF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgdGVtcGxhdGVOYW1lLCBcImN1c3RvbVN0eWxlPWZhbHNlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcy5jb250ZXh0TmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlZnNbdGVtcGxhdGVOYW1lXS5fY29udGV4dCA9IG5hbWVkUHJvcGVydGllcy5jb250ZXh0TmFtZTtcbiAgICAgIC8vIFRPRE8gaXMgaXQgY29ycmVjdCB0byBmYWxsYmFjayB0byBcImJvZHlUaGVtZVwiIGZvciBibG9ja3Mgbm90IGRlY2xhcmluZyBhIGRlZmF1bHQgdGhlbWU/XG4gICAgICAvLyBNYXliZSBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gc2ltcGx5IGRlY2xhcmUgaXQgYXMgbWFuZGF0b3J5IGJ1dCBsZWF2ZSB0aGUgZGVmYXVsdCBjb25maWd1dGF0aW9uXG4gICAgICAvLyB0byB0aGUgdGVtcGxhdGUgZGVmaW5pdGlvbi5cbiAgICAgIGlmIChuYW1lZFByb3BlcnRpZXMuY29udGV4dE5hbWUgPT0gJ2Jsb2NrJyAmJiB0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9nbG9iYWxTdHlsZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWZzW3RlbXBsYXRlTmFtZV0uX2dsb2JhbFN0eWxlID0gJ190aGVtZV8uYm9keVRoZW1lJztcbiAgICAgICAgX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCAndGhlbWUnLCAnYm9keVRoZW1lJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0uX3RoZW1lT3ZlcnJpZGUgPT0gJ3VuZGVmaW5lZCcgfHwgZGVmc1t0ZW1wbGF0ZU5hbWVdLl90aGVtZU92ZXJyaWRlKSB7XG4gICAgICAgICAgX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCB0ZW1wbGF0ZU5hbWUsIFwiY3VzdG9tU3R5bGU9ZmFsc2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMuZXh0ZW5kICE9ICd1bmRlZmluZWQnKSBkZWZzW3RlbXBsYXRlTmFtZV0udHlwZSA9IG5hbWVkUHJvcGVydGllcy5leHRlbmQ7XG4gIH1cblxuICBmb3IgKHZhciBucCBpbiBuYW1lZFByb3BlcnRpZXMpIGlmIChuYW1lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobnApICYmIHR5cGVvZiBuYW1lZFByb3BlcnRpZXNbbnBdICE9PSAndW5kZWZpbmVkJyAmJiBbJ25hbWUnLCAnZXh0ZW5kJywgJ2NvbnRleHROYW1lJywgJ2dsb2JhbFN0eWxlJywndGhlbWVPdmVycmlkZSddLmluZGV4T2YobnApID09IC0xKSB7XG4gICAgZGVmc1t0ZW1wbGF0ZU5hbWVdWydfJytucF0gPSBuYW1lZFByb3BlcnRpZXNbbnBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9ICd1bmRlZmluZWQnICYmIHByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgIGRlZnNbdGVtcGxhdGVOYW1lXS5fcHJvcHMgPSB0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9wcm9wcyAhPSAndW5kZWZpbmVkJyAmJiBkZWZzW3RlbXBsYXRlTmFtZV0uX3Byb3BzLmxlbmd0aCA+IDAgPyBkZWZzW3RlbXBsYXRlTmFtZV0uX3Byb3BzICsgXCIgXCIgKyBwcm9wZXJ0aWVzIDogcHJvcGVydGllcztcbiAgfVxufTtcblxuLy8gcmVtb3ZlIHRoZSBmaXJzdCBcInNlcXVlbmNlXCIgaW4gYSBjYW1lbGNhc2VkIHdvcmQgKGUuZzogbXlDYW1lbENhc2UgPT4gY2FtZWxDYXNlKS5cbnZhciBfcmVtb3ZlUHJlZml4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciByZXMgPSBzdHIubWF0Y2goL15bXkEtWl0rKFtBLVpdKSguKikkLyk7XG4gIHJldHVybiByZXMgIT09IG51bGwgPyByZXNbMV0udG9Mb3dlckNhc2UoKSArIHJlc1syXSA6IG51bGw7XG59O1xuXG4vLyBUT0RPIGRlZnMgaXMgbmVlZGVkIG9ubHkgYmVjYXVzZSBfdmFsdWVTZXQgbmVlZHMgaXQuLiB3ZSBzaG91bGQgcmVtb3ZlIGl0IGRvd25zdHJlYW0uXG52YXIgX2dlbmVyYXRlTW9kZWxGcm9tRGVmID0gZnVuY3Rpb24obW9kZWxEZWYsIGRlZnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gbW9kZWxEZWYpXG4gICAgaWYgKCFwcm9wLm1hdGNoKC9eXy4qLykgJiYgbW9kZWxEZWYuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1vZGVsRGVmW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuX2NvbXBsZXggIT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuX2NvbXBsZXgpIHtcbiAgICAgICAgcmVzW3Byb3BdID0gX2dlbmVyYXRlTW9kZWxGcm9tRGVmKHZhbHVlLCBkZWZzKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcCA9PSAndHlwZScpIHtcbiAgICAgICAgcmVzW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBtb3N0IHRpbWVzIHRoaXMgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBfdmFsdWVTZXRcbiAgICAgICAgcmVzW3Byb3BdID0gbnVsbDtcbiAgICAgICAgLy8gZm9yIGN1c3RvbVN0eWxlIHRoaXMgaXMgc2V0IHRvIG51bGwuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBtb2RlbCBkZWZcIiwgcHJvcCwgdmFsdWUsIG1vZGVsRGVmKTtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIG1vZGVsIGRlZiBbXCIgKyBwcm9wICsgXCJdPVwiICsgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gIGlmICh0eXBlb2YgbW9kZWxEZWYuX2RlZmF1bHRWYWx1ZXMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSBtb2RlbERlZi5fZGVmYXVsdFZhbHVlcztcbiAgICBmb3IgKHZhciBwcm9wMiBpbiBkZWZhdWx0cylcbiAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShwcm9wMikpIHtcbiAgICAgICAgX3ZhbHVlU2V0KGRlZnMsIHJlcywgcHJvcDIsIGRlZmF1bHRzW3Byb3AyXSk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxudmFyIF9nZW5lcmF0ZU1vZGVsID0gZnVuY3Rpb24oZGVmcywgbmFtZSkge1xuICB2YXIgbW9kZWxEZWYgPSBfZ2V0TW9kZWxEZWYoZGVmcywgbmFtZSwgZmFsc2UsIHRydWUpO1xuICByZXR1cm4gX2dlbmVyYXRlTW9kZWxGcm9tRGVmKG1vZGVsRGVmLCBkZWZzKTtcbn07XG5cbnZhciBfZ2V0RGVmID0gZnVuY3Rpb24oZGVmcywgbmFtZSkge1xuICByZXR1cm4gX2dldE1vZGVsRGVmKGRlZnMsIG5hbWUsIGZhbHNlLCB0cnVlKTtcbn07XG5cbnZhciBfZ2V0TW9kZWxEZWYgPSBmdW5jdGlvbihkZWZzLCBuYW1lLCByZXR1cm5DbG9uZSwgcmVhZG9ubHkpIHtcbiAgLy8gbG9va3VwIFwibmFtZVwiIGluIHRoZSB0ZW1wbGF0ZSBkZWZpbml0aW9uXG4gIGlmICh0eXBlb2YgZGVmc1tuYW1lXSA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGlmIHRoZSBuYW1lIGhhcyBhIHNwYWNlIHRoZW4gcmV0dXJucy5cbiAgICBpZiAobmFtZS5pbmRleE9mKCcgJykgIT0gLTEpIHJldHVybiBudWxsO1xuICAgIC8vIG90aGVyd2lzZSB0cnkgbG9va2luZyB1cCB1c2luZyBhIGRlcHJlZml4ZWQgbmFtZS5cbiAgICB2YXIgcmVzID0gX3JlbW92ZVByZWZpeChuYW1lKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPIHRoZSBkZXByZWZpeGluZyBpcyBwb3dlcmZ1bCwgYnV0IG1heWJlIG5vdCByZWFsbHkgbmVlZGVkLlxuICAgICAgcmV0dXJuIF9nZXRNb2RlbERlZihkZWZzLCByZXMsIHJldHVybkNsb25lLCByZWFkb25seSk7XG4gICAgfVxuICAgIC8vIG5vdCBhIHByZWZpeGVkIG5hbWVcbiAgICAvLyBUT0RPIHNob3VsZCB3ZSByYWlzZSBhbiBlcnJvcj9cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyB3aGVuIHRoZSBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZC4uLlxuICAgIHZhciBkZWZPYmogPSBkZWZzW25hbWVdO1xuICAgIGlmICh0eXBlb2YgZGVmT2JqICE9ICdvYmplY3QnKSB0aHJvdyBcIkJsb2NrIGRlZmluaXRpb24gbXVzdCBiZSBhbiBvYmplY3Q6IGZvdW5kIFwiICsgZGVmT2JqICsgXCIgZm9yIFwiICsgbmFtZTtcblxuICAgIGlmICh0eXBlb2YgZGVmT2JqLl9pbml0aWFsaXplZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUG9wdWxhdGUgXCJ0eXBlXCIgZGVwZW5kaW5nIG9uIG5hbWVcbiAgICAgIGlmICh0eXBlb2YgZGVmT2JqLnR5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignICcpID09IC0xKSB7XG4gICAgICAgICAgZGVmT2JqLnR5cGUgPSBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZk9iai50eXBlID0gbmFtZS5zdWJzdHIobmFtZS5pbmRleE9mKCcgJykgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBub3QgYSBcImRhdGFcIiB0eXBlIHRoZW4gbGV0J3MgZGVhbCB3aXRoIGluaGVyaXRhbmNlXG4gICAgICBpZiAoZGVmT2JqLnR5cGUgIT0gbmFtZSAmJiB0eXBlb2YgZGVmT2JqLl93aWRnZXQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHR5cGVEZWYgPSBfZ2V0TW9kZWxEZWYoZGVmcywgZGVmT2JqLnR5cGUsIHRydWUpO1xuICAgICAgICB2YXIgZXh0ZW5kZWQgPSBvYmpFeHRlbmQodHlwZURlZiwgZGVmT2JqKTtcbiAgICAgICAgZGVmT2JqID0gZXh0ZW5kZWQ7XG4gICAgICAgIGRlZnNbbmFtZV0gPSBkZWZPYmo7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZPYmouX3dpZGdldCA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmT2JqLl9wcm9wcyA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmT2JqLl9jb21wbGV4ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFRPRE8gaGVyZSBJIHRyaWVkIHRvIGRlYWwgd2l0aCBpbmhlcml0YW5jZSBmb3IgZXZlcnkgb2JqZWN0IHdpdGhvdXQgYSBcInR5cGVcIiBieSB1c2luZyBhIHNpbXBsZSBkZXByZWZpeC5cbiAgICAgICAgLy8gYnV0IHRoaXMgYnJlYWsgb24gdGhlbWUgY29udGFpbmluZyBcInBhZ2VUaGVtZVwiIHRoYXQgd291bGQgaW5oZXJpdCBmcm9tIGlzIHBhcmVudC4gKGNyZWF0aW5nIGEgbG9vcClcbiAgICAgICAgLypcbiAgICAgICAgdmFyIHN1cGVyVHlwZSA9IF9yZW1vdmVQcmVmaXgoZGVmT2JqLnR5cGUpO1xuICAgICAgICBpZiAoc3VwZXJUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFeHRlbmRpbmdcIiwgdHlwZURlZiwgbmFtZSwgc3VwZXJUeXBlLCBkZWZPYmoudHlwZSk7XG4gICAgICAgICAgdmFyIHR5cGVEZWYgPSBfZ2V0TW9kZWxEZWYoZGVmcywgc3VwZXJUeXBlLCB0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgZXh0ZW5kZWQgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHR5cGVEZWYsIGRlZk9iaik7XG4gICAgICAgICAgZGVmT2JqID0gZXh0ZW5kZWQ7XG4gICAgICAgICAgZGVmc1tuYW1lXSA9IGRlZk9iajtcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgfVxuICAgICAgZGVmT2JqLl93cml0ZWFibGUgPSB0cnVlO1xuICAgICAgZGVmT2JqLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZWZPYmouX3Byb3BzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZGVmID0gZGVmT2JqLl9wcm9wcztcbiAgICAgIGRlZiA9IGRlZi5zcGxpdChcIiBcIik7XG5cbiAgICAgIGlmIChkZWYubGVuZ3RoID4gMCAmJiB0eXBlb2YgZGVmT2JqLl93cml0ZWFibGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkFsdGVyaW5nIGEgbm9uIHdyaXRhYmxlIG9iamVjdCBcIiwgbmFtZSwgZGVmLCBkZWZPYmopO1xuICAgICAgICB0aHJvdyBcIkFsdGVyaW5nIGEgbm9uIHdyaXRhYmxlIG9iamVjdDogXCIgKyBuYW1lICsgXCIgZGVmOiBcIiArIGRlZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkZWZPYmouX3Byb2Nlc3NlZERlZnMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVmT2JqLl9wcm9jZXNzZWREZWZzID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVmT2JqLl9nbG9iYWxTdHlsZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVmT2JqLl9nbG9iYWxTdHlsZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkZWZPYmouX2RlZmF1bHRWYWx1ZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVmT2JqLl9kZWZhdWx0VmFsdWVzID0ge307XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gZGVmW2ldO1xuICAgICAgICBpZiAocHJvcC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICB2YXIgb3JpZ1Byb3AgPSBwcm9wO1xuICAgICAgICB2YXIgZGVmVmFsdWUgPSBudWxsO1xuICAgICAgICAvLyBwYXJzZXMgIFwicHJvcFwiIFwicHJvcD12YWx1ZVwiIGFuZCBcInByb3BbXVwiIGRlY2xhcmF0aW9uc1xuICAgICAgICB2YXIgcHJvcERlZiA9IHByb3AubWF0Y2goL14oW149XFxbXFxdXSspKFxcW1xcXSk/KD0/KSguKikkLyk7XG4gICAgICAgIGlmIChwcm9wRGVmICE9PSBudWxsKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BEZWZbMV07XG4gICAgICAgICAgLy8gVE9ETyBhcnJheSBkZWZpbml0aW9uIHNob3VsZCBiZSBkb25lIGRpZmZlcmVudGx5XG4gICAgICAgICAgaWYgKHByb3BEZWZbMl0gPT0gJ1tdJykge1xuICAgICAgICAgICAgLy8gVE9ETyB0eXBlIHNob3VsZCBub3QgYmUgZGVmaW5lZCBpbiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZk9ialtwcm9wXSA9PSAndW5kZWZpbmVkJykgZGVmT2JqW3Byb3BdID0gW107XG4gICAgICAgICAgICBkZWZWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcERlZlszXSA9PSAnPScpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIGhhcmRjb2RlZCBcInZpc2libGVcIiBtYXRjaGluZyAodGhpcyBzaG91bGQgYmUgZGVmaW5lZCBpbiB0aGUgdGVtcGxhdGUgZGVmaW5pdGlvbilcbiAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC8oXnZ8Vilpc2libGUkLykpIGRlZlZhbHVlID0gU3RyaW5nKHByb3BEZWZbNF0pLnRvTG93ZXJDYXNlKCkgPT0gJ3RydWUnO1xuICAgICAgICAgICAgZWxzZSBpZiAocHJvcC5tYXRjaCgvXmN1c3RvbVN0eWxlJC8pKSB7XG4gICAgICAgICAgICAgIGRlZlZhbHVlID0gU3RyaW5nKHByb3BEZWZbNF0pLnRvTG93ZXJDYXNlKCkgPT0gJ3RydWUnO1xuICAgICAgICAgICAgfSBlbHNlIGRlZlZhbHVlID0gcHJvcERlZls0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXMgZm91bmQgaW4gXCJwcm9wZXJ0aWVzXCIgYXJlIG5vdCBiZWluZyBwcm9jZXNzZWQgYnkgXCJtb2RlbEVuc3VyZVZhbHVlXCIgYW5kIGJ5IGNvbnNlcXVlbmNlIGRvIG5vdCBjYWxsIFwidGhlbWVVcGRhdGVyXCIuXG4gICAgICAgIC8vIFRPRE8gZG9jdW1lbnQgd2h5IHRoaXMgaXMgbmVlZGVkLCBvciByZW1vdmUuXG4gICAgICAgIGlmIChkZWZWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGVmT2JqLl9kZWZhdWx0VmFsdWVzW3Byb3BdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiAocHJvcC5tYXRjaCgvXl8vKSkgY29uc29sZS5sb2coXCJkZWZWYWx1ZSBmb3JcIiwgcHJvcCwgXCJpblwiLCBuYW1lKTtcbiAgICAgICAgICAgIGRlZk9iai5fZGVmYXVsdFZhbHVlc1twcm9wXSA9IGRlZlZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVmT2JqW3Byb3BdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IF9nZXRNb2RlbERlZihkZWZzLCBuYW1lICsgJyAnICsgcHJvcCwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsID0gX2dldE1vZGVsRGVmKGRlZnMsIHByb3AsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZPYmpbcHJvcF0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWZPYmouX3Byb2Nlc3NlZERlZnNbcHJvcF0gPSBvcmlnUHJvcDtcbiAgICAgICAgZGVmT2JqLl9jb21wbGV4ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGRlZk9iai5fcHJvcHM7XG4gICAgfVxuXG4gICAgaWYgKHJldHVybkNsb25lKSB7XG4gICAgICBkZWZPYmouX3dyaXRlYWJsZSA9IGZhbHNlO1xuICAgICAgdmFyIGNsb25lZCA9IG9iakV4dGVuZCh7fSwgZGVmT2JqKTtcbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfSBlbHNlIGlmIChyZWFkb25seSkge1xuICAgICAgZGVmT2JqLl93cml0ZWFibGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBkZWZPYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZGVmT2JqLl93cml0ZWFibGUgPT0gJ3VuZGVmaW5lZCcgfHwgZGVmT2JqLl93cml0ZWFibGUgPT09IGZhbHNlKSB0aHJvdyBcIlJldHJpZXZpbmcgbm9uIHdyaXRlYWJsZSBvYmplY3QgZGVmaW5pdGlvbjogXCIgKyBuYW1lO1xuICAgICAgcmV0dXJuIGRlZk9iajtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfaW5jcmVhc2VVc2VDb3VudCA9IGZ1bmN0aW9uKHJlYWRvbmx5LCBtb2RlbCkge1xuICBpZiAoIXJlYWRvbmx5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlbC5fdXNlY291bnQgPT0gJ3VuZGVmaW5lZCcpIG1vZGVsLl91c2Vjb3VudCA9IDA7XG4gICAgbW9kZWwuX3VzZWNvdW50Kys7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsLl91c2Vjb3VudCA9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUiB0cnlpbmcgdG8gYmluZCBhbiB1bnVzZWQgcHJvcGVydHkgd2hpbGUgcmVhZG9ubHlcIiwgbW9kZWwpO1xuICAgIHRocm93IFwiRVJST1IgdHJ5aW5nIHRvIGJpbmQgYW4gdW51c2VkIHByb3BlcnR5XCI7XG4gIH1cbn07XG5cbnZhciBlbnN1cmVHbG9iYWxTdHlsZSA9IGZ1bmN0aW9uKGRlZnMsIHJlYWRvbmx5LCBnc0JpbmRpbmdQcm92aWRlciwgbW9kZWxOYW1lLCBwYXRoLCBnc0Z1bGxQYXRoLCBkZWZhdWx0VmFsdWUsIG92ZXJyaWRlRGVmYXVsdCkge1xuXG4gIHZhciBnbG9iYWxTdHlsZUJpbmRpbmdCaW5kVmFsdWUgPSBnc0JpbmRpbmdQcm92aWRlcihnc0Z1bGxQYXRoLCBkZWZhdWx0VmFsdWUsIG92ZXJyaWRlRGVmYXVsdCk7XG5cbiAgaWYgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlc1twYXRoXSA9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChyZWFkb25seSkgdGhyb3cgXCJDYW5ub3QgZmluZCBfZ2xvYmFsU3R5bGUgZm9yIFwiICsgcGF0aCArIFwiIGluIFwiICsgbW9kZWxOYW1lICsgXCIhXCI7XG4gICAgaWYgKHBhdGguaW5kZXhPZignLicpICE9IC0xIHx8ICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3BhdGhdID09ICdvYmplY3QnICYmIHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcGF0aF0uX3dpZGdldCAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICBkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlc1twYXRoXSA9IGdsb2JhbFN0eWxlQmluZGluZ0JpbmRWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZXNbcGF0aF0gIT0gZ2xvYmFsU3R5bGVCaW5kaW5nQmluZFZhbHVlKSB0aHJvdyBcIlVuZXhwZWN0ZWQgY29uZmxpY3RpbmcgZ2xvYmFsU3R5bGUgWzJdIGZvciBcIiArIG1vZGVsTmFtZSArIFwiL1wiICsgcGF0aCArIFwiOiBvbGQ9XCIgKyBkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlc1twYXRoXSArIFwiIG5ldz1cIiArIGdsb2JhbFN0eWxlQmluZGluZ0JpbmRWYWx1ZTtcbn07XG5cbi8vIHRoZW1lVXBkYXRlciwgZGVmYXVsdFZhbHVlLCBvdmVycmlkZURlZmF1bHQsIHNldGNhdGVnb3J5IGFyZSBvbmx5IHVzZWQgaW4gIXJlYWRvbmx5IG1vZGVcbnZhciBtb2RlbEVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUgPSBmdW5jdGlvbihyZWFkb25seSwgZGVmcywgdGhlbWVVcGRhdGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsIHdpdGhpbiwgZnVsbFBhdGgsIGRlZmF1bHRWYWx1ZSwgb3ZlcnJpZGVEZWZhdWx0LCBzZXRjYXRlZ29yeSkge1xuICB2YXIgbW9kZWxOYW1lO1xuICB2YXIgcmVzO1xuICB2YXIgcGF0aDtcbiAgLy8gVE9ETyByZW1vdmUgJyQnIGFuZCAnIycgaGFuZGluZ1xuICBpZiAoZnVsbFBhdGguc3Vic3RyKDAsIDEpID09ICckJykge1xuICAgIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQgJCBpbiBiaW5kaW5nUHJvdmlkZXI6IFwiLCBmdWxsUGF0aCwgdGVtcGxhdGVOYW1lKTtcbiAgICB2YXIgcCA9IGZ1bGxQYXRoLmluZGV4T2YoJy4nKTtcbiAgICBpZiAocCA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGZ1bGxQYXRoOiBcIiArIGZ1bGxQYXRoICsgXCIvXCIgKyB3aXRoaW4gKyBcIi9cIiArIHRlbXBsYXRlTmFtZSArIFwiL1wiICsgZGVmYXVsdFZhbHVlICsgXCIvXCIgKyBvdmVycmlkZURlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsTmFtZSA9IGZ1bGxQYXRoLnN1YnN0cigxLCBwIC0gMSk7XG4gICAgICBwYXRoID0gZnVsbFBhdGguc3Vic3RyKHAgKyAxKTtcbiAgICAgIC8vIFRPRE8gcmVmYWN0b3IgbWUgcGxlYXNlXG4gICAgICBpZiAobW9kZWxOYW1lID09ICd0aGVtZScpIHtcbiAgICAgICAgdmFyIHAyID0gcGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgIG1vZGVsTmFtZSA9IHBhdGguc3Vic3RyKDAsIHAyKTtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKHAyICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgJCBzZXF1ZW5jZTogXCIgKyBtb2RlbE5hbWUgKyBcIiBpbiBcIiArIGZ1bGxQYXRoO1xuICAgICAgfVxuICAgICAgcmVzID0gXCIkcm9vdC5jb250ZW50KCkudGhlbWUoKS5cIiArIG1vZGVsTmFtZSArIFwiKCkuXCIgKyBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXC4nLCAnZycpLCAnKCkuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZ1bGxQYXRoLnN1YnN0cigwLCAxKSA9PSAnIycpIHtcbiAgICBjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEICMgaW4gYmluZGluZ1Byb3ZpZGVyOiBcIiwgZnVsbFBhdGgsIHRlbXBsYXRlTmFtZSk7XG4gICAgbW9kZWxOYW1lID0gcm9vdE1vZGVsTmFtZTtcbiAgICBwYXRoID0gZnVsbFBhdGguc3Vic3RyKDEpO1xuICAgIHJlcyA9IFwiJHJvb3QuY29udGVudCgpLlwiICsgcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwuJywgJ2cnKSwgJygpLicpO1xuICB9IGVsc2UgaWYgKGZ1bGxQYXRoLnN1YnN0cigwLCA4KSA9PSAnX3RoZW1lXy4nKSB7XG4gICAgdmFyIHAzID0gZnVsbFBhdGguaW5kZXhPZignLicsIDgpO1xuICAgIG1vZGVsTmFtZSA9IGZ1bGxQYXRoLnN1YnN0cig4LCBwMyAtIDgpO1xuICAgIHBhdGggPSBmdWxsUGF0aC5zdWJzdHIocDMgKyAxKTtcbiAgICByZXMgPSBcIiRyb290LmNvbnRlbnQoKS50aGVtZSgpLlwiICsgbW9kZWxOYW1lICsgXCIoKS5cIiArIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcLicsICdnJyksICcoKS4nKTtcbiAgfSBlbHNlIGlmIChmdWxsUGF0aC5zdWJzdHIoMCwgNykgPT0gJ19yb290Xy4nKSB7XG4gICAgbW9kZWxOYW1lID0gcm9vdE1vZGVsTmFtZTtcbiAgICBwYXRoID0gZnVsbFBhdGguc3Vic3RyKDcpO1xuICAgIHJlcyA9IFwiJHJvb3QuY29udGVudCgpLlwiICsgcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwuJywgJ2cnKSwgJygpLicpO1xuICB9IGVsc2Uge1xuICAgIG1vZGVsTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICBwYXRoID0gd2l0aGluICsgZnVsbFBhdGg7XG4gICAgcmVzID0gZnVsbFBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcLicsICdnJyksICcoKS4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdID09PSAndW5kZWZpbmVkJykgdGhyb3cgXCJDYW5ub3QgZmluZCBtb2RlbCBkZWYgZm9yIFtcIiArIG1vZGVsTmFtZSArIFwiXVwiO1xuXG4gIHZhciBwcm9wUG9zID0gcGF0aC5pbmRleE9mKCcuJyk7XG4gIHZhciBwcm9wTmFtZSA9IHByb3BQb3MgPT0gLTEgPyBwYXRoIDogcGF0aC5zdWJzdHIoMCwgcHJvcFBvcyk7XG5cbiAgaWYgKG1vZGVsTmFtZS5pbmRleE9mKCctJykgIT0gLTEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRVJST1IgY2Fubm90IHVzZSAtIGZvciBibG9jayBuYW1lc1wiLCBtb2RlbE5hbWUpO1xuICAgIHRocm93IFwiRVJST1IgdW5leHBlY3RlZCBjaGFyIGluIGJsb2NrIG5hbWU6IFwiICsgbW9kZWxOYW1lO1xuICB9XG4gIGlmIChwcm9wTmFtZS5pbmRleE9mKCctJykgIT0gLTEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRVJST1IgY2Fubm90IHVzZSAtIGZvciBwcm9wZXJ0eSBuYW1lc1wiLCBwcm9wTmFtZSk7XG4gICAgdGhyb3cgXCJFUlJPUiB1bmV4cGVjdGVkIGNoYXIgaW4gcHJvcGVydHkgbmFtZTogXCIgKyBtb2RlbE5hbWU7XG4gIH1cblxuICAvLyBGYXN0cGF0aFxuICBpZiAocmVhZG9ubHkpIHtcbiAgICBpZiAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdICE9PSAndW5kZWZpbmVkJyAmJiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdLl9jYXRlZ29yeSA9PSAnc3R5bGUnKSB7XG4gICAgICByZXMgKz0gJy5fZGVmYXVsdENvbXB1dGVkJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIGdldHMgdGhlIHdyaXRhYmxlIG1vZGVsIHdoZW4gXCIhcmVhZG9ubHlcIiBvciB0aGUgcmVhZG9ubHkgbW9kZWwgb3RoZXJ3aXNlXG4gIHZhciBtb2RlbDtcbiAgaWYgKHJlYWRvbmx5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB0aHJvdyBcIkNhbm5vdCB1c2UgZGVmYXVsdFZhbHVlIGluIHJlYWRvbmx5IG1vZGUhXCI7XG4gICAgaWYgKG92ZXJyaWRlRGVmYXVsdCkgdGhyb3cgXCJDYW5ub3QgdXNlIG92ZXJyaWRlRGVmYXVsdCBpbiByZWFkb25seSBtb2RlIGZvciBcIiArIG1vZGVsTmFtZSArIFwiL1wiICsgcGF0aCArIFwiL1wiICsgb3ZlcnJpZGVEZWZhdWx0ICsgXCIhXCI7XG4gICAgaWYgKHR5cGVvZiBzZXRjYXRlZ29yeSAhPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IHNldCBjYXRlZ29yeSBmb3IgXCIgKyBtb2RlbE5hbWUgKyBcIi9cIiArIHBhdGggKyBcIi9cIiArIHNldGNhdGVnb3J5ICsgXCIgaW4gcmVhZG9ubHkgbW9kZSFcIjtcbiAgICBtb2RlbCA9IF9nZXRNb2RlbERlZihkZWZzLCBtb2RlbE5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVmc1ttb2RlbE5hbWVdLl93cml0ZWFibGUgPT09IGZhbHNlKSBjb25zb2xlLmxvZyhcIlRPRE8gZGVidWcgdXNlIGNhc2VzIGZvciB0aGlzIGNvbmRpdGlvblwiLCBtb2RlbE5hbWUsIHBhdGgpO1xuICAgIG1vZGVsID0gX2dldE1vZGVsRGVmKGRlZnMsIG1vZGVsTmFtZSwgZGVmc1ttb2RlbE5hbWVdLl93cml0ZWFibGUgPT09IGZhbHNlKTtcbiAgfVxuXG4gIGlmIChtb2RlbCA9PT0gbnVsbCkgdGhyb3cgXCJVbmV4cGVjdGVkIG1vZGVsIGZvciBbXCIgKyBtb2RlbE5hbWUgKyBcIl1cIjtcblxuICAvLyBpZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgZXhpc3RzIHdlIGhhdmUgdG8gY3JlYXRlIGl0LlxuICBpZiAodHlwZW9mIG1vZGVsW3Byb3BOYW1lXSA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHdoZW4gaW4gcmVhZG9ubHkgbW9kZSB0aGlzIGNhbm5vdCBiZSBkb25lIVxuICAgIGlmIChyZWFkb25seSkgdGhyb3cgXCJDYW5ub3QgZmluZCBwYXRoIFwiICsgcHJvcE5hbWUgKyBcIiBmb3IgXCIgKyBtb2RlbE5hbWUgKyBcIiFcIjtcbiAgICBfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsIG1vZGVsTmFtZSwgcHJvcE5hbWUpO1xuICAgIG1vZGVsID0gX2dldE1vZGVsRGVmKGRlZnMsIG1vZGVsTmFtZSwgZmFsc2UpO1xuICB9XG5cbiAgLy8gTmVlZHMgdG8gZG8gdGhpcyBhZ2FpbiwgYmVjYXVzZSBcIl9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWZcIiBjb3VsZCBoYXZlIGJlZW4ganVzdCBjcmVhdGVkIHRoZSBwcm9wZXJ0eSAoZS5nOiBiYWNrZ3JvdW5kQ29sb3IgYnV0dG9uQmxvY2sgbm90IGdldHRpbmcgZGVmYXVsdENvbXB1dGVkIGluIHRlbXBsYXRlLWxtKVxuICBpZiAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdICE9PSAndW5kZWZpbmVkJyAmJiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdICE9PSBudWxsICYmIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0uX2NhdGVnb3J5ID09ICdzdHlsZScpIHtcbiAgICByZXMgKz0gJy5fZGVmYXVsdENvbXB1dGVkJztcbiAgfVxuXG4gIHZhciBjaGlsZE1vZGVsID0gbW9kZWw7XG4gIHRyeSB7XG4gICAgX2luY3JlYXNlVXNlQ291bnQocmVhZG9ubHksIGNoaWxkTW9kZWwpO1xuICAgIGlmIChwcm9wUG9zICE9IC0xKSB7XG4gICAgICB2YXIgbXlwYXRoID0gcGF0aDtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHByb3AgPSBteXBhdGguc3Vic3RyKDAsIHByb3BQb3MpO1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkTW9kZWxbcHJvcF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBcIkZvdW5kIGFuIHVuZXhwZWN0ZWQgcHJvcCBcIiArIHByb3AgKyBcIiBmb3IgbW9kZWwgXCIgKyBtb2RlbE5hbWUgKyBcIiBmb3IgXCIgKyBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRNb2RlbCA9IGNoaWxkTW9kZWxbcHJvcF07XG4gICAgICAgIF9pbmNyZWFzZVVzZUNvdW50KHJlYWRvbmx5LCBjaGlsZE1vZGVsKTtcbiAgICAgICAgbXlwYXRoID0gbXlwYXRoLnN1YnN0cihwcm9wUG9zICsgMSk7XG4gICAgICAgIHByb3BQb3MgPSBteXBhdGguaW5kZXhPZignLicpO1xuICAgICAgfSB3aGlsZSAocHJvcFBvcyAhPSAtMSk7XG5cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRNb2RlbFtteXBhdGhdID09ICd1bmRlZmluZWQnIHx8IGNoaWxkTW9kZWxbbXlwYXRoXSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIkZvdW5kIGFuIHVuZXhwZWN0ZWQgcGF0aCB0ZXJtaW5hdGlvbiBcIiArIG15cGF0aCArIFwiIGZvciBtb2RlbCBcIiArIG1vZGVsTmFtZSArIFwiIGZvciBcIiArIHBhdGg7XG4gICAgICB9XG4gICAgICBjaGlsZE1vZGVsID0gY2hpbGRNb2RlbFtteXBhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZE1vZGVsID0gY2hpbGRNb2RlbFtwYXRoXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkTW9kZWwgPT09ICd1bmRlZmluZWQnIHx8IGNoaWxkTW9kZWwgPT09IG51bGwpIHRocm93IFwiVW5leHBlY3RlZCBudWxsIG1vZGVsIGZvciBcIiArIG1vZGVsTmFtZSArIFwiL1wiICsgd2l0aGluICsgXCIvXCIgKyBmdWxsUGF0aDtcblxuICAgIGlmICh0eXBlb2Ygc2V0Y2F0ZWdvcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjaGlsZE1vZGVsLl9jYXRlZ29yeSA9IHNldGNhdGVnb3J5O1xuICAgIH1cblxuICAgIF9pbmNyZWFzZVVzZUNvdW50KHJlYWRvbmx5LCBjaGlsZE1vZGVsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUT0RPIEVSUk9SIFByb3BlcnR5IGxvb2t1cCBleGNlcHRpb25cIiwgZSwgbW9kZWxOYW1lLCBwYXRoLCB0ZW1wbGF0ZU5hbWUsIGZ1bGxQYXRoLCBkZWZzKTtcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXSA9PSAnb2JqZWN0JyAmJiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdICE9PSBudWxsICYmIHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdLl9jYXRlZ29yeSAhPSAndW5kZWZpbmVkJyAmJiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdLl9jYXRlZ29yeSA9PSAnc3R5bGUnKSB7XG4gICAgLy8gVE9ETyBjYW4gSSByZXN0cmljdCB0aGlzIGNvZGUgdG8gIXJlYWRvbmx5IG1vZGU/XG4gICAgdmFyIGdzQmluZGluZ1Byb3ZpZGVyID0gbW9kZWxFbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlLmJpbmQodW5kZWZpbmVkLCByZWFkb25seSwgZGVmcywgdGhlbWVVcGRhdGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsICcnKTtcblxuICAgIHZhciBzdWJQYXRoID0gcGF0aC5pbmRleE9mKCcuJykgIT0gLTEgPyBwYXRoLnN1YnN0cihwYXRoLmluZGV4T2YoJy4nKSkgOiAnJztcblxuICAgIC8vIFRoZSBuZXh0IGNvZGUgc3VwcG9ydHMgb25seSBwcm9wZXJ0aWVzIHdpdGggb25lIGRvdCAob2JqZWN0LnByb3BlcnR5KS5cbiAgICBpZiAoc3ViUGF0aC5pbmRleE9mKCcuJywgMSkgIT0gLTEpIHRocm93IFwiVE9ETyB1bnN1cHBvcnRlZCBvYmplY3QgbmVzdGluZyEgXCIgKyBwYXRoO1xuXG4gICAgdmFyIGdzUGF0aCA9IGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGUgKyAnLicgKyBwcm9wTmFtZTtcbiAgICBpZiAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0gPT0gJ29iamVjdCcgJiYgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXSAhPT0gbnVsbCAmJiB0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXS5fZ2xvYmFsU3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdzUGF0aCA9IGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0uX2dsb2JhbFN0eWxlO1xuICAgIH1cblxuICAgIGVuc3VyZUdsb2JhbFN0eWxlKGRlZnMsIHJlYWRvbmx5LCBnc0JpbmRpbmdQcm92aWRlciwgbW9kZWxOYW1lLCBwcm9wTmFtZSwgZ3NQYXRoLCB1bmRlZmluZWQsIGZhbHNlKTtcblxuICAgIHZhciBnc0Z1bGxQYXRoID0gZ3NQYXRoICsgc3ViUGF0aDtcblxuICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09ICd1bmRlZmluZWQnICYmIGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXSAhPT0gbnVsbCkgZGVmYXVsdFZhbHVlID0gZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdO1xuXG4gICAgZW5zdXJlR2xvYmFsU3R5bGUoZGVmcywgcmVhZG9ubHksIGdzQmluZGluZ1Byb3ZpZGVyLCBtb2RlbE5hbWUsIHBhdGgsIGdzRnVsbFBhdGgsIGRlZmF1bHRWYWx1ZSwgb3ZlcnJpZGVEZWZhdWx0KTtcblxuICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHJlYWRvbmx5KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3Qgc2V0IGEgbmV3IHRoZW1lIGRlZmF1bHQgdmFsdWVcIiwgZ3NGdWxsUGF0aC5zdWJzdHIoNyksIGRlZmF1bHRWYWx1ZSwgXCJ3aGlsZSBpbiByZWFkb25seSBtb2RlXCIpO1xuICAgICAgICB0aHJvdyBcIkNhbm5vdCBzZXQgYSBuZXcgdGhlbWUgZGVmYXVsdCB2YWx1ZSAoXCIgKyBkZWZhdWx0VmFsdWUgKyBcIikgZm9yIFwiICsgZ3NGdWxsUGF0aC5zdWJzdHIoNykgKyBcIiB3aGlsZSBpbiByZWFkb25seSBtb2RlIVwiO1xuICAgICAgfVxuICAgICAgdGhlbWVVcGRhdGVyKCdkZWZhdWx0JywgZ3NGdWxsUGF0aC5zdWJzdHIoNyksIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBjb21wbGV4IHN0dWZmLiBJZiB0aGUgdGhlbWUgdXNlcyBpbmhlcml0YW5jZSB3ZSBlbmZvcmNlIGl0IHVzaW5nIHdpdGggdGhlIHNhbWUgdmFsdWUsIGJ1dCB0aGlzIGlzIGEgbGltaXQuXG4gICAgZGVmYXVsdFZhbHVlID0gbnVsbDtcblxuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXSA9PSAndW5kZWZpbmVkJyB8fCAodHlwZW9mIG92ZXJyaWRlRGVmYXVsdCAhPSAndW5kZWZpbmVkJyAmJiBvdmVycmlkZURlZmF1bHQpKSB7XG4gICAgICBpZiAocmVhZG9ubHkpIHRocm93IFwiQ2Fubm90IHNldCBuZXcgX2RlZmF1bHRWYWx1ZXMgWzFdIGZvciBcIiArIHBhdGggKyBcIiBpbiBcIiArIG1vZGVsTmFtZSArIFwiIVwiO1xuICAgICAgZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdID0gZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChyZWFkb25seSAmJiBkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF0gIT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBzZXQgbmV3IF9kZWZhdWx0VmFsdWVzIFsyXSBmb3IgXCIgKyBwYXRoICsgXCIgaW4gXCIgKyBtb2RlbE5hbWUgKyBcIiFcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHJlbW92ZSBkZWZhdWx0IHZhbHVlLiBVZ2x5LiAoTmVlZHMgdGhpcyBmb3IgZGVmYXVsdHMgaW4gdGVtcGxhdGUtbG0gc29jaWFsTGlua3NJY29uKVxuICAgICAgICBkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF0gIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUT0RPIGVycm9yISEhIFRyeWluZyB0byBzZXQgYSBuZXcgZGVmYXVsdCB2YWx1ZSBmb3IgXCIgKyBtb2RlbE5hbWUgKyBcIiBcIiArIHBhdGggKyBcIiB3aGlsZSBpdCBhbHJlYWR5IGV4aXN0cyAoY3VycmVudDogXCIgKyBkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF0gKyBcIiwgbmV3OiBcIiArIGRlZmF1bHRWYWx1ZSArIFwiKVwiKTtcbiAgICAgICAgdGhyb3cgXCJUcnlpbmcgdG8gc2V0IGEgbmV3IGRlZmF1bHQgdmFsdWUgZm9yIFwiICsgbW9kZWxOYW1lICsgXCIgXCIgKyBwYXRoICsgXCIgd2hpbGUgaXQgYWxyZWFkeSBleGlzdHMgKGN1cnJlbnQ6IFwiICsgZGVmc1ttb2RlbE5hbWVdLmRlZmF1bHRWYWx1ZXNbcGF0aF0gKyBcIiwgbmV3OiBcIiArIGRlZmF1bHRWYWx1ZSArIFwiKVwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgZ2VuZXJhdGVSZXN1bHRNb2RlbCA9IGZ1bmN0aW9uKHRlbXBsYXRlRGVmKSB7XG4gIHZhciBkZWZzID0gdGVtcGxhdGVEZWYuX2RlZnM7XG4gIHZhciB0ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZURlZi50ZW1wbGF0ZU5hbWU7XG5cbiAgdmFyIGZpbmFsTW9kZWxDb250ZW50ID0gX2dlbmVyYXRlTW9kZWwoZGVmcywgdGVtcGxhdGVOYW1lKTtcblxuICAvLyBUT0RPIHVnbHkgdG8gYWRkIHRoaXMgbWFudWFsbHlcbiAgaWYgKHR5cGVvZiBkZWZzWyd0aGVtZSddICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZpbmFsTW9kZWxDb250ZW50LnRoZW1lID0gX2dlbmVyYXRlTW9kZWwoZGVmcywgJ3RoZW1lJyk7XG4gIH1cblxuICByZXR1cm4gZmluYWxNb2RlbENvbnRlbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gdXNlZCB0byBjb21waWxlIHRoZSB0ZW1wbGF0ZVxuICBlbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlOiBtb2RlbEVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUuYmluZCh1bmRlZmluZWQsIGZhbHNlKSxcbiAgLy8gdXNlZCBpbiBydW50aW1lIHRoZSB0ZW1wbGF0ZVxuICBnZXRCaW5kVmFsdWU6IG1vZGVsRW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgdHJ1ZSksXG4gIGdlbmVyYXRlTW9kZWw6IF9nZW5lcmF0ZU1vZGVsLFxuICBnZW5lcmF0ZVJlc3VsdE1vZGVsOiBnZW5lcmF0ZVJlc3VsdE1vZGVsLFxuICBnZXREZWY6IF9nZXREZWYsXG4gIGNyZWF0ZU9yVXBkYXRlQmxvY2tEZWY6IF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWZcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIGNvbnZlcnRlclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG52YXIgZWxhYm9yYXRlRGVjbGFyYXRpb25zID0gcmVxdWlyZShcIi4vZGVjbGFyYXRpb25zLmpzXCIpO1xudmFyIHByb2Nlc3NTdHlsZXNoZWV0UnVsZXMgPSByZXF1aXJlKFwiLi9zdHlsZXNoZWV0LmpzXCIpO1xudmFyIG1vZGVsRGVmID0gcmVxdWlyZShcIi4vbW9kZWwuanNcIik7XG52YXIgZG9tdXRpbHMgPSByZXF1aXJlKFwiLi9kb211dGlscy5qc1wiKTtcblxudmFyIHdyYXBFbGVtZW50V2l0aENvbmRpdGlvbiA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgZWxlbWVudCwgYmluZGluZ1Byb3ZpZGVyKSB7XG4gIHZhciBjb25kID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYmluZGluZyA9IGNvbnZlcnRlclV0aWxzLmNvbmRpdGlvbkJpbmRpbmcoY29uZCwgYmluZGluZ1Byb3ZpZGVyKTtcbiAgICAkKGVsZW1lbnQpLmJlZm9yZSgnPCEtLSBrbyBpZjogJyArIGJpbmRpbmcgKyAnIC0tPicpO1xuICAgICQoZWxlbWVudCkuYWZ0ZXIoJzwhLS0gL2tvIC0tPicpO1xuICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKFwiTW9kZWwgZW5zdXJlIHBhdGggZmFpbGVkIGluIGlmL3ZhcmlhbnRcIiwgZWxlbWVudCwgY29uZCwgYXR0cmlidXRlKTtcbiAgICB0aHJvdyBlO1xuICB9XG5cbn07XG5cbnZhciByZXBsYWNlZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lKSB7XG4gIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJyZXBsYWNlZFwiICsgYXR0cmlidXRlTmFtZSkpO1xufTtcblxudmFyIHByb2Nlc3NTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBiaW5kaW5nUHJvdmlkZXIsIGFkZFVuaXF1ZUlkKSB7XG4gIHZhciBzdHlsZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAncmVwbGFjZWRzdHlsZScpO1xuICB2YXIgbmV3U3R5bGUgPSBudWxsO1xuICB2YXIgbmV3QmluZGluZ3M7XG4gIGlmIChhZGRVbmlxdWVJZCkgbmV3QmluZGluZ3MgPSB7XG4gICAgdW5pcXVlSWQ6ICckZGF0YScsXG4gICAgYXR0cjoge1xuICAgICAgaWQ6ICdpZCdcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbW92ZURpc3BsYXlOb25lID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWRpc3BsYXknKSAhPT0gbnVsbDtcblxuICBuZXdTdHlsZSA9IGVsYWJvcmF0ZURlY2xhcmF0aW9ucyhzdHlsZSwgdW5kZWZpbmVkLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgYmluZGluZ1Byb3ZpZGVyLCBlbGVtZW50LCBuZXdCaW5kaW5ncywgcmVtb3ZlRGlzcGxheU5vbmUpO1xuXG4gIC8vIG9ubHkgd2hlbiB1c2luZyBcInJlcGxhY2VkXCJcbiAgaWYgKG5ld1N0eWxlID09PSBudWxsKSB7XG4gICAgbmV3U3R5bGUgPSBzdHlsZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBiaW5kaW5ncyB3ZSBrZWVwIHJlcGxhY2Vkc3R5bGUgdG8gYmUgdXNlZCBieSBJRSBkdXJpbmcgb3V0cHV0XG4gICAgLy8gb3RoZXJ3aXNlIEkgcmVtb3ZlIGl0IGJlY2F1c2UgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB2aXJ0dWFsQXR0clN0eWxlIGJpbmRpbmcuXG4gICAgLy8gVE9ETyBtYXliZSB3ZSBiZXR0ZXIgdXNlIGRpZmZlcmVudCBuYW1lcyBmb3IgXCJyZXBsYWNlZFwiIHVzZWQgZHVyaW5nIHRlbXBsYXRlIGNvbnZlcnNpb25cbiAgICAvLyBhbmQgdGhlIG9uZXMgdXNlZCB0byBjcmVhdGUgdGhlIG91dHB1dC5cbiAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ3JlcGxhY2Vkc3R5bGUnKTtcbiAgfVxuXG4gIGlmIChuZXdTdHlsZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXdTdHlsZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdzdHlsZScsIG5ld1N0eWxlKTtcbiAgICB9IGVsc2UgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdzdHlsZScpO1xuICB9XG59O1xuXG5cbi8vIFRPRE8gZml4aW5nIFVSTHMgaXMgYWxzbyBuZWVkZWQgd2hlcmUgc3R5bGVzIHVzZXMgcGF0aCAoZS5nOiBiYWNrZ3JvdW5kLWltYWdlLCBAaW1wb3J0KVxudmFyIF9maXhSZWxhdGl2ZVBhdGggPSBmdW5jdGlvbihhdHRyaWJ1dGUsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBpbmRleCwgZWxlbWVudCkge1xuICB2YXIgdXJsID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSk7XG4gIHZhciBuZXdVcmwgPSB0ZW1wbGF0ZVVybENvbnZlcnRlcih1cmwpO1xuICBpZiAobmV3VXJsICE9PSBudWxsKSB7XG4gICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgbmV3VXJsKTtcbiAgfVxufTtcblxuXG52YXIgcHJvY2Vzc0Jsb2NrID0gZnVuY3Rpb24oZWxlbWVudCwgZGVmcywgdGhlbWVVcGRhdGVyLCBibG9ja1B1c2hlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGNvbnRleHROYW1lLCByb290TW9kZWxOYW1lLCBjb250YWluZXJOYW1lLCBnZW5lcmF0ZVVuaXF1ZUlkLCB0ZW1wbGF0ZUNyZWF0b3IpIHtcblxuICB0cnkge1xuXG4gIHZhciB0ZW1wbGF0ZU5hbWU7XG4gIHZhciB2YXJpYW50TmFtZSA9ICcnLFxuICAgIHZhcmlhbnREZWYgPSAnJztcbiAgaWYgKGNvbnRleHROYW1lID09ICdibG9jaycpIHtcbiAgICB0ZW1wbGF0ZU5hbWUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tYmxvY2snKTtcbiAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tYmxvY2snKTtcbiAgfSBlbHNlIGlmIChjb250ZXh0TmFtZSA9PSAndGVtcGxhdGUnKSB7XG4gICAgdGVtcGxhdGVOYW1lID0gcm9vdE1vZGVsTmFtZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgY29udGV4dCBuYW1lIHdoaWxlIHByb2Nlc3NpbmcgYmxvY2s6IFwiICsgY29udGV4dE5hbWU7XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyhcInByb2Nlc3NCbG9ja1wiLCBjb250ZXh0TmFtZSwgcm9vdE1vZGVsTmFtZSwgY29udGFpbmVyTmFtZSwgdGVtcGxhdGVOYW1lKTtcblxuICAvLyBSZW1vdmUgZWxlbWVudFxuICAkKCdbZGF0YS1rby1yZW1vdmVdJywgZWxlbWVudCkucmVtb3ZlKCk7XG5cbiAgdmFyIGZpeGVkQmxvY2tzID0gJCgnW2RhdGEta28tYmxvY2tdJywgZWxlbWVudCkucmVwbGFjZVdpdGgoJzxyZXBsYWNlZGJsb2NrPicpO1xuXG4gIC8vIFVybHMgaW4gdGhlc2UgYXR0cmlidXRlcyBuZWVkcyBcInJlbGF0aXZpemF0aW9uXCJcbiAgdmFyIHVybGF0dHJzID0gWydocmVmJywgJ3NyYycsICdkYXRhLWtvLXBsYWNlaG9sZGVyLXNyYycsICdiYWNrZ3JvdW5kJ107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXJsYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBmYWNjaW8gaWwgYmluZCBwZXIgbm9uIGRlZmluaXJlIGZ1bnppb25pIGluIHVuIGxvb3AgKGpzaGludClcbiAgICB2YXIgZnVuYyA9IF9maXhSZWxhdGl2ZVBhdGguYmluZCh1bmRlZmluZWQsIHVybGF0dHJzW2ldLCB0ZW1wbGF0ZVVybENvbnZlcnRlcik7XG4gICAgJCgnWycgKyB1cmxhdHRyc1tpXSArICddJywgZWxlbWVudCkuZWFjaChmdW5jKTtcbiAgfVxuXG4gIHZhciBkYXRhRGVmcyA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wcm9wZXJ0aWVzJyk7XG4gIGlmIChkYXRhRGVmcyA9PT0gbnVsbCkgZGF0YURlZnMgPSBcIlwiO1xuICAkKFwiW2RhdGEta28tcHJvcGVydGllc11cIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIGlmIChkYXRhRGVmcy5sZW5ndGggPiAwKSBkYXRhRGVmcyA9IGRhdGFEZWZzICsgXCIgXCI7XG4gICAgZGF0YURlZnMgPSBkYXRhRGVmcyArIGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wcm9wZXJ0aWVzJyk7XG4gICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXByb3BlcnRpZXMnKTtcbiAgfSk7XG5cbiAgbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCB0ZW1wbGF0ZU5hbWUsIGRhdGFEZWZzLCB7IGNvbnRleHROYW1lOiBjb250ZXh0TmFtZSB9KTtcblxuICB2YXIgYmluZGluZ1Byb3ZpZGVyID0gbW9kZWxEZWYuZW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgZGVmcywgdGhlbWVVcGRhdGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsICcnKTtcbiAgaWYgKGNvbnRleHROYW1lID09ICdibG9jaycpIGJpbmRpbmdQcm92aWRlcignaWQnLCAnJyk7XG5cbiAgJCgnc3R5bGUnLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIHN0eWxlID0gZG9tdXRpbHMuZ2V0SW5uZXJIdG1sKGVsZW1lbnQpO1xuXG4gICAgdmFyIGJsb2NrRGVmc1VwZGF0ZXIgPSBtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmLmJpbmQodW5kZWZpbmVkLCBkZWZzKTtcbiAgICB2YXIgbG9jYWxXaXRoQmluZGluZ1Byb3ZpZGVyID0gbW9kZWxEZWYuZW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgZGVmcywgdGhlbWVVcGRhdGVyLCByb290TW9kZWxOYW1lKTtcbiAgICB2YXIgbmV3U3R5bGUgPSBwcm9jZXNzU3R5bGVzaGVldFJ1bGVzKHN0eWxlLCB1bmRlZmluZWQsIGxvY2FsV2l0aEJpbmRpbmdQcm92aWRlciwgYmxvY2tEZWZzVXBkYXRlciwgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lKTtcblxuICAgIGlmIChuZXdTdHlsZSAhPSBzdHlsZSkge1xuICAgICAgaWYgKG5ld1N0eWxlLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgdmFyIHRtcE5hbWUgPSB0ZW1wbGF0ZUNyZWF0b3IobmV3U3R5bGUpO1xuICAgICAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcsICd0ZW1wbGF0ZTogeyBuYW1lOiBcXCcnICsgdG1wTmFtZSArICdcXCcgfScpO1xuICAgICAgICAvLyBobyBjcmVhdG8gaWwgdGVtcGxhdGUgcXVpbmRpIHBvc3NvIHN2dW90YXJlIGlsIHNvcmdlbnRlLlxuICAgICAgICBkb211dGlscy5zZXRDb250ZW50KGVsZW1lbnQsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBlbXB0eSBzdHlsZXMgYmxvY2tzXG4gICAgICAgIGRvbXV0aWxzLnJlbW92ZUVsZW1lbnRzKCQoZWxlbWVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcHJvY2Vzc1N0eWxlKGVsZW1lbnQsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBiaW5kaW5nUHJvdmlkZXIsIGdlbmVyYXRlVW5pcXVlSWQpO1xuXG4gIC8vIFRPRE8gaHJlZiBzaG91bGQgYmUgc3VwcG9ydGVkLiBkYXRhLWtvLWRpc3BsYXkgYW5kIGRhdGEta28td3JhcCBzaG91bGQgbmV2ZXIgaGFwcGVuIGluIGhlcmUuXG4gIHZhciBub3RzdXBwb3J0ZWQgPSBbJ2RhdGEta28tZGlzcGxheScsICdkYXRhLWtvLWVkaXRhYmxlJywgJ2RhdGEta28td3JhcCcsICdocmVmJ107XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbm90c3VwcG9ydGVkLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGF0dHIgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgbm90c3VwcG9ydGVkW2pdKTtcbiAgICBpZiAoYXR0cikge1xuICAgICAgY29uc29sZS53YXJuKFwiRVJST1I6IFVuc3VwcG9ydGVkIFwiICsgbm90c3VwcG9ydGVkW2pdICsgXCIgdXNlZCB0b2dldGhlciB3aXRoIGRhdGEta28tYmxvY2tcIiwgZWxlbWVudCk7XG4gICAgICB0aHJvdyBcIkVSUk9SOiBVbnN1cHBvcnRlZCBcIiArIG5vdHN1cHBvcnRlZFtqXSArIFwiIHVzZWQgdG9nZXRoZXIgd2l0aCBkYXRhLWtvLWJsb2NrXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gc2ltcGx5IHByZXByb2Nlc3NlZCBhcyBkYXRhLWtvLXdyYXAgKyAta28tYXR0ci1ocmVmXG4gICQoXCJbZGF0YS1rby1saW5rXVwiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIHVybFZhciA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1saW5rJyk7XG4gICAgdmFyIHJlcFN0eWxlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdyZXBsYWNlZHN0eWxlJyk7XG4gICAgaWYgKHR5cGVvZiByZXBTdHlsZSA9PSAndW5kZWZpbmVkJyB8fCByZXBTdHlsZSA9PT0gbnVsbCkgcmVwU3R5bGUgPSAnJztcbiAgICBpZiAocmVwU3R5bGUgIT09ICcnKSByZXBTdHlsZSA9ICcta28tYXR0ci1ocmVmOiBAJyArIHVybFZhciArIFwiOyBcIiArIHJlcFN0eWxlO1xuICAgIGVsc2UgcmVwU3R5bGUgPSAnLWtvLWF0dHItaHJlZjogQCcgKyB1cmxWYXI7XG4gICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdyZXBsYWNlZHN0eWxlJywgcmVwU3R5bGUpO1xuICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby13cmFwJywgdXJsVmFyKTtcbiAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tbGluaycpO1xuICB9KTtcblxuICAkKFwiW3JlcGxhY2Vkc3R5bGVdXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICBwcm9jZXNzU3R5bGUoZWxlbWVudCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGJpbmRpbmdQcm92aWRlciwgZmFsc2UpO1xuICB9KTtcblxuICAkKFwiW3JlcGxhY2VkaHR0cC1lcXVpdl1cIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHJlcGxhY2VkQXR0cmlidXRlcyhlbGVtZW50LCBcImh0dHAtZXF1aXZcIik7XG4gIH0pO1xuXG4gICQoXCJbZGF0YS1rby1kaXNwbGF5XVwiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgd3JhcEVsZW1lbnRXaXRoQ29uZGl0aW9uKCdkYXRhLWtvLWRpc3BsYXknLCBlbGVtZW50LCBiaW5kaW5nUHJvdmlkZXIpO1xuICB9KTtcblxuICAkKFwiW2RhdGEta28tZWRpdGFibGVdXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgbmV3QmluZGluZywgZGVmYXVsdFZhbHVlLCBtb2RlbCwgY3VycmVudEJpbmRpbmdzLCBkYXRhQmluZDtcblxuXG4gICAgdmFyIGRhdGFFZGl0YWJsZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCBcImRhdGEta28tZWRpdGFibGVcIik7XG5cbiAgICAvLyBUT0RPIGFkZCB2YWxpZGF0aW9uIG9mIHRoZSBlZGl0YWJsZVxuXG4gICAgdmFyIGl0ZW1CaW5kVmFsdWU7XG4gICAgdmFyIHNlbGVjdEJpbmRpbmc7XG4gICAgaWYgKGRhdGFFZGl0YWJsZS5sYXN0SW5kZXhPZignLicpID4gMCkge1xuICAgICAgdmFyIHN1YnMgPSBkYXRhRWRpdGFibGUuc3Vic3RyKDAsIGRhdGFFZGl0YWJsZS5sYXN0SW5kZXhPZignLicpKTtcbiAgICAgIGl0ZW1CaW5kVmFsdWUgPSBiaW5kaW5nUHJvdmlkZXIoc3Vicyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1CaW5kVmFsdWUgPSBiaW5kaW5nUHJvdmlkZXIoZGF0YUVkaXRhYmxlKTtcbiAgICB9XG4gICAgc2VsZWN0QmluZGluZyA9IFwid3lzaXd5Z0NsaWNrOiBmdW5jdGlvbihvYmosIGV2dCkgeyAkcm9vdC5zZWxlY3RJdGVtKFwiICsgaXRlbUJpbmRWYWx1ZSArIFwiLCAkZGF0YSk7IHJldHVybiBmYWxzZSB9LCBjbGlja0J1YmJsZTogZmFsc2UsIHd5c2l3eWdDc3M6IHsgc2VsZWN0ZWRpdGVtOiAkcm9vdC5pc1NlbGVjdGVkSXRlbShcIiArIGl0ZW1CaW5kVmFsdWUgKyBcIikgfSwgc2Nyb2xsSW50b1ZpZXc6ICRyb290LmlzU2VsZWN0ZWRJdGVtKFwiICsgaXRlbUJpbmRWYWx1ZSArIFwiKVwiO1xuXG4gICAgaWYgKGRvbXV0aWxzLmdldExvd2VyVGFnTmFtZShlbGVtZW50KSAhPSAnaW1nJykge1xuXG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9IGRvbXV0aWxzLmdldElubmVySHRtbChlbGVtZW50KTtcbiAgICAgIHZhciBtb2RlbEJpbmRWYWx1ZSA9IGJpbmRpbmdQcm92aWRlcihkYXRhRWRpdGFibGUsIGRlZmF1bHRWYWx1ZSwgdHJ1ZSwgJ3d5c2l3eWcnKTtcbiAgICAgIG5ld0JpbmRpbmcgPSBcIlwiO1xuXG4gICAgICBpZiAoIWRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCBcImlkXCIpKSB7XG4gICAgICAgIG5ld0JpbmRpbmcgKz0gXCJ3eXNpd3lnSWQ6IGlkKCkrJ19cIiArIGRhdGFFZGl0YWJsZS5yZXBsYWNlKCcuJywgJ18nKSArIFwiJywgXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0QmluZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbmV3QmluZGluZyArPSBzZWxlY3RCaW5kaW5nICsgXCIsIFwiO1xuICAgICAgfVxuXG4gICAgICBuZXdCaW5kaW5nICs9IFwid3lzaXd5Z09ySHRtbDogXCIgKyBtb2RlbEJpbmRWYWx1ZTtcblxuICAgICAgaWYgKGRvbXV0aWxzLmdldExvd2VyVGFnTmFtZShlbGVtZW50KSA9PSAndGQnKSB7XG4gICAgICAgIHZhciB3cmFwcGluZ0RpdiA9ICQoJzxkaXYgZGF0YS1rby13cmFwPVwiZmFsc2VcIiBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCVcIj48L2Rpdj4nKVswXTtcbiAgICAgICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKHdyYXBwaW5nRGl2LCAnZGF0YS1iaW5kJywgbmV3QmluZGluZyk7XG4gICAgICAgIHZhciBuZXdDb250ZW50ID0gZG9tdXRpbHMuZ2V0SW5uZXJIdG1sKCQoJzxkaXY+PC9kaXY+JykuYXBwZW5kKHdyYXBwaW5nRGl2KSk7XG4gICAgICAgIGRvbXV0aWxzLnNldENvbnRlbnQoZWxlbWVudCwgbmV3Q29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QmluZGluZ3MgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcpO1xuICAgICAgICBkYXRhQmluZCA9IChjdXJyZW50QmluZGluZ3MgIT09IG51bGwgPyBjdXJyZW50QmluZGluZ3MgKyBcIiwgXCIgOiBcIlwiKSArIG5ld0JpbmRpbmc7XG4gICAgICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJywgZGF0YUJpbmQpO1xuICAgICAgICBkb211dGlscy5zZXRDb250ZW50KGVsZW1lbnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1lZGl0YWJsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd2lkdGggPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3dpZHRoJyk7XG4gICAgICBpZiAod2lkdGggPT09ICcnKSB3aWR0aCA9IG51bGw7XG4gICAgICBpZiAod2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SOiBkYXRhLWtvLWVkaXRhYmxlIGltYWdlcyBtdXN0IGRlY2xhcmUgYSBXSURUSCBhdHRyaWJ1dGUhXCIsIGVsZW1lbnQpO1xuICAgICAgICB0aHJvdyBcIkVSUk9SOiBkYXRhLWtvLWVkaXRhYmxlIGltYWdlcyBtdXN0IGRlY2xhcmUgYSBXSURUSCBhdHRyaWJ1dGUhXCI7XG4gICAgICB9XG4gICAgICB2YXIgaGVpZ2h0ID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdoZWlnaHQnKTtcbiAgICAgIGlmIChoZWlnaHQgPT09ICcnKSBoZWlnaHQgPSBudWxsO1xuXG4gICAgICB2YXIgYWxpZ24gPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2FsaWduJyk7XG5cbiAgICAgIGN1cnJlbnRCaW5kaW5ncyA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJyk7XG5cbiAgICAgIC8vIFRPRE8gdGhpcyBpcyB1Z2x5Li4uIG1heWJlIGEgYmV0dGVyIHN0cmF0ZWd5IGlzIHRvIHBhc3MgdGhpcyBhcm91bmQgdXNpbmcgXCJkYXRhLVwiIGF0dHJpYnV0ZXNcbiAgICAgIHZhciBkeW5IZWlnaHQgPSBjdXJyZW50QmluZGluZ3MgJiYgY3VycmVudEJpbmRpbmdzLm1hdGNoKC92aXJ0dWFsQXR0cjoge1tefV0qIGhlaWdodDogKFteLH1dKilbLH1dLyk7XG4gICAgICBpZiAoZHluSGVpZ2h0KSBoZWlnaHQgPSBkeW5IZWlnaHRbMV07XG4gICAgICB2YXIgZHluV2lkdGggPSBjdXJyZW50QmluZGluZ3MgJiYgY3VycmVudEJpbmRpbmdzLm1hdGNoKC92aXJ0dWFsQXR0cjoge1tefV0qIHdpZHRoOiAoW14sfV0qKVssfV0vKTtcbiAgICAgIGlmIChkeW5XaWR0aCkgd2lkdGggPSBkeW5XaWR0aFsxXTtcblxuICAgICAgdmFyIG1ldGhvZDtcblxuICAgICAgZGVmYXVsdFZhbHVlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXBsYWNlaG9sZGVyLXNyYycpO1xuICAgICAgLy8gVE9ETyBtYWtlIHN1cmUgdGhpcyBkZWZhdWx0IHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBvbmUgY2hlY2tlZCBieSBpbWctd3lzaXd5ZyB0ZW1wbGF0ZS5cbiAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnc3JjJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3NyYycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgc2l6ZSA9IHdpZHRoICsgXCIrJ3gnK1wiICsgaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmICghaGVpZ2h0KSB7XG4gICAgICAgIHNpemUgPSBcIid3JytcIiArIHdpZHRoICsgXCIrJydcIjtcbiAgICAgIH0gZWxzZSBpZiAoIXdpZHRoKSB7XG4gICAgICAgIHNpemUgPSBcIidoJytcIiArIGhlaWdodCArIFwiKycnXCI7XG4gICAgICB9XG4gICAgICB2YXIgcGxhY2Vob2xkZXJzcmM7XG4gICAgICB2YXIgcGxoZWlnaHQgPSBoZWlnaHQgfHwgZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXBsYWNlaG9sZGVyLWhlaWdodCcpO1xuICAgICAgdmFyIHBsd2lkdGggPSB3aWR0aCB8fCBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcGxhY2Vob2xkZXItd2lkdGgnKTtcblxuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdzcmMnKTtcbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1lZGl0YWJsZScpO1xuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXBsYWNlaG9sZGVyLWhlaWdodCcpO1xuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXBsYWNlaG9sZGVyLXdpZHRoJyk7XG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcGxhY2Vob2xkZXItc3JjJyk7XG5cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcGxhY2Vob2xkZXJzcmMgPSBcInsgd2lkdGg6IFwiICsgcGx3aWR0aCArIFwiLCBoZWlnaHQ6IFwiICsgcGxoZWlnaHQgKyBcIiwgdGV4dDogXCIgKyBzaXplICsgXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGx3aWR0aCB8fCAhcGxoZWlnaHQpIHtcbiAgICAgICAgLy8gVE9ETyByYWlzZSBhbiBleGNlcHRpb24/XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJTUcgZGF0YS1rby1lZGl0YWJsZSBtdXN0IGRlY2xhcmUgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzLCBvciB0aGVpciBwbGFjZWhvbGRlciBjb3VudGVycGFydHMgZGF0YS1rby1wbGFjZWhvbGRlci13aWR0aC9kYXRhLWtvLXBsYWNlaG9sZGVyLWhlaWdodFwiLCBlbGVtZW50KTtcbiAgICAgICAgdGhyb3cgXCJFUlJPUjogSU1HIGRhdGEta28tZWRpdGFibGUgTVVTVCBkZWNsYXJlIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcywgb3IgdGhlaXIgcGxhY2Vob2xkZXIgY291bnRlcnBhcnRzIGRhdGEta28tcGxhY2Vob2xkZXItd2lkdGgvZGF0YS1rby1wbGFjZWhvbGRlci1oZWlnaHRcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJpbmRpbmdWYWx1ZSA9IGJpbmRpbmdQcm92aWRlcihkYXRhRWRpdGFibGUsIHZhbHVlLCBmYWxzZSwgJ3d5c2l3eWcnKTtcbiAgICAgIG5ld0JpbmRpbmcgPSBcInd5c2l3eWdTcmM6IHsgd2lkdGg6IFwiICsgd2lkdGggKyBcIiwgaGVpZ2h0OiBcIiArIGhlaWdodCArIFwiLCBzcmM6IFwiICsgYmluZGluZ1ZhbHVlICsgXCIsIHBsYWNlaG9sZGVyOiBcIiArIHBsYWNlaG9sZGVyc3JjICsgXCIgfVwiO1xuICAgICAgZGF0YUJpbmQgPSAoY3VycmVudEJpbmRpbmdzICE9PSBudWxsID8gY3VycmVudEJpbmRpbmdzICsgXCIsIFwiIDogXCJcIikgKyBuZXdCaW5kaW5nO1xuICAgICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnLCBkYXRhQmluZCk7XG5cbiAgICAgIHZhciB0bXBsTmFtZSA9IHRlbXBsYXRlQ3JlYXRvcihlbGVtZW50KTtcblxuICAgICAgdmFyIGNvbnRhaW5lckJpbmQgPSAneyB3aWR0aDogJyArIHdpZHRoO1xuICAgICAgaWYgKGFsaWduID09ICdsZWZ0JykgY29udGFpbmVyQmluZCArPSAnLCBmbG9hdDogXFwnbGVmdFxcJyc7XG4gICAgICBlbHNlIGlmIChhbGlnbiA9PSAncmlnaHQnKSBjb250YWluZXJCaW5kICs9ICcsIGZsb2F0OiBcXCdyaWdodFxcJyc7XG4gICAgICBlbHNlIGlmIChhbGlnbiA9PSAnY2VudGVyJykgY29uc29sZS5sb2coJ25vbiBzbyBjb3NhIGZhIGFsaWduPWNlbnRlciBzdSB1bmEgaW1nIGUgcXVpbmRpIG5vbiBzbyBjb21lIHNpbXVsYXJuZSBsXFwnZWRpdGluZycpO1xuICAgICAgZWxzZSBpZiAoYWxpZ24gPT0gJ3RvcCcpIGNvbnRhaW5lckJpbmQgKz0gJywgdmVydGljYWxBbGlnbjogXFwndG9wXFwnJztcbiAgICAgIGVsc2UgaWYgKGFsaWduID09ICdtaWRkbGUnKSBjb250YWluZXJCaW5kICs9ICcsIHZlcnRpY2FsQWxpZ246IFxcJ21pZGRsZVxcJyc7XG4gICAgICBlbHNlIGlmIChhbGlnbiA9PSAnYm90dG9tJykgY29udGFpbmVyQmluZCArPSAnLCB2ZXJ0aWNhbEFsaWduOiBcXCdib3R0b21cXCcnO1xuICAgICAgY29udGFpbmVyQmluZCArPSAnfSc7XG5cbiAgICAgICQoZWxlbWVudCkuYmVmb3JlKCc8IS0tIGtvIHd5c2l3eWdJbWc6IHsgX2RhdGE6ICRkYXRhLCBfaXRlbTogJyArIGl0ZW1CaW5kVmFsdWUgKyAnLCBfdGVtcGxhdGU6IFxcJycgKyB0bXBsTmFtZSArICdcXCcsIF9lZGl0VGVtcGxhdGU6IFxcJ2ltZy13eXNpd3lnXFwnLCBfc3JjOiAnICsgYmluZGluZ1ZhbHVlICsgJywgX3dpZHRoOiAnICsgd2lkdGggKyAnLCBfaGVpZ2h0OiAnICsgaGVpZ2h0ICsgJywgX2FsaWduOiAnICsgKGFsaWduID09PSBudWxsID8gdW5kZWZpbmVkIDogJ1xcJycgKyBhbGlnbiArICdcXCcnKSArICcsIF9zaXplOiAnICsgc2l6ZSArICcsIF9tZXRob2Q6ICcgKyBtZXRob2QgKyAnLCBfcGxhY2Vob2xkZXJzcmM6ICcgKyBwbGFjZWhvbGRlcnNyYyArICcsIF9zdHlsZWJpbmQ6ICcgKyBjb250YWluZXJCaW5kICsgJyB9IC0tPicpO1xuICAgICAgJChlbGVtZW50KS5hZnRlcignPCEtLSAva28gLS0+Jyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEFwcGxpZWQgYWZ0ZXIgdGhlIGRhdGEtZWRpdGFibGUgc28gdG8gYXZvaWQgcHJvY2Vzc2luZyBocmVmcyBmb3IgZWRpdGFibGUgY29udGVudFxuICAkKFwiW2hyZWZdXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgYXR0clZhbHVlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdocmVmJyk7XG4gICAgdmFyIG5ld0JpbmRpbmcgPSAnd3lzaXd5Z0hyZWY6IFxcJycgKyBjb252ZXJ0ZXJVdGlscy5hZGRTbGFzaGVzKGF0dHJWYWx1ZSkgKyAnXFwnJztcbiAgICB2YXIgY3VycmVudEJpbmRpbmdzID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnKTtcbiAgICB2YXIgZGF0YUJpbmQgPSAoY3VycmVudEJpbmRpbmdzICE9PSBudWxsID8gY3VycmVudEJpbmRpbmdzICsgXCIsIFwiIDogXCJcIikgKyBuZXdCaW5kaW5nO1xuICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJywgZGF0YUJpbmQpO1xuICB9KTtcblxuICAkKFwicmVwbGFjZWRibG9ja1wiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIGJsb2NrRWxlbWVudCA9IGZpeGVkQmxvY2tzW2luZGV4XTtcblxuICAgIHZhciBibG9ja05hbWUgPSBwcm9jZXNzQmxvY2soYmxvY2tFbGVtZW50LCBkZWZzLCB0aGVtZVVwZGF0ZXIsIGJsb2NrUHVzaGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgJ2Jsb2NrJywgdGVtcGxhdGVOYW1lLCBjb250YWluZXJOYW1lLCB0cnVlLCB0ZW1wbGF0ZUNyZWF0b3IpO1xuICAgIC8vIHJlcGxhY2VkIGJsb2NrcyBhcmUgZGVmaW5lZCBpbiB0aGUgbW9kZWwgcm9vdFxuICAgIHZhciBtb2RlbEJpbmRWYWx1ZSA9IG1vZGVsRGVmLmVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUoZGVmcywgdGhlbWVVcGRhdGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsICcnLCBibG9ja05hbWUpO1xuXG4gICAgLy8gdGhpcyB3YXkgd2UgY2FsbCBibG9jay13eXNpd3lnIG9yIGJsb2NrLXNob3cgYW5kIG5vdCBkaXJlY3RseSB0aGUgcmlnaHQgYmxvY2tcbiAgICAkKGVsZW1lbnQpLmJlZm9yZSgnPCEtLSBrbyBibG9jazogeyBkYXRhOiAnICsgY29udmVydGVyVXRpbHMuYWRkU2xhc2hlcyhtb2RlbEJpbmRWYWx1ZSkgKyAnLCB0ZW1wbGF0ZTogXFwnYmxvY2tcXCcgfSAtLT4nKTtcbiAgICAkKGVsZW1lbnQpLmFmdGVyKCc8IS0tIC9rbyAtLT4nKTtcbiAgICAkKGVsZW1lbnQpLnJlbW92ZSgpO1xuICB9KTtcblxuICAvLyBUT0RPIGRvIHdlIHJlYWxseSBuZWVkIHRvIGxvb3AgaW4gcmV2ZXJzZSBvcmRlcj9cbiAgLy8gZGF0YS1rby13cmFwIGhhdmUgdG8gYmUgcHJvY2Vzc2VkIGF0IHRoZSBlbmQsIGV4cGVjaWFsbHkgYWZ0ZXIgXCJyZXBsYWNlYmxvY2tzXCJcbiAgLy8gb3RoZXJ3aXNlIGEgZGF0YS1rby13cmFwIHdyYXBwaW5nIGEgZGF0YS1rby1ibG9jayB3b3VsZCBicmVhayBldmVyeXRoaW5nLlxuICAkKCQoXCJbZGF0YS1rby13cmFwXVwiLCBlbGVtZW50KS5nZXQoKS5yZXZlcnNlKCksIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgY29uZCA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby13cmFwJyk7XG4gICAgaWYgKHR5cGVvZiBjb25kID09PSAndW5kZWZpbmVkJyB8fCBjb25kID09PSAnJyB8fCBjb25kID09PSAndHJ1ZScpIHtcbiAgICAgIHRocm93IFwiVW5zdXBwb3J0ZWQgZW1wdHkgdmFsdWUgZm9yIGRhdGEta28td3JhcDogdXNlIGZhbHNlIHZhbHVlIGlmIHlvdSB3YW50IHRvIGFsd2F5cyByZW1vdmUgdGhlIHRhZ1wiO1xuICAgIH1cblxuICAgIHZhciBjb25kQmluZGluZyA9IGNvbnZlcnRlclV0aWxzLmNvbmRpdGlvbkJpbmRpbmcoY29uZCwgYmluZGluZ1Byb3ZpZGVyKTtcblxuICAgIC8qXG4gICAgICAgICAgdmFyIGNvbmRCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25kID09PSAndW5kZWZpbmVkJyB8fCBjb25kID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgXCJVbnN1cHBvcnRlZCBlbXB0eSB2YWx1ZSBmb3IgZGF0YS1rby13cmFwOiB1c2UgZmFsc2UgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWx3YXlzIHJlbW92ZSB0aGUgdGFnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25kID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICBjb25kQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZCA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlVuc3VwcG9ydGVkIHRydWUgdmFsdWUgZm9yIGRhdGEta28td3JhcC4gVGhpcyBtYWtlcyBubyBzZW5zZTogdXNlIGZhbHNlIG9yIGEgdmFyaWFibGVcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZEJpbmRpbmcgPSBiaW5kaW5nUHJvdmlkZXIoY29uZCkrJygpJztcbiAgICAgICAgICB9XG4gICAgKi9cblxuICAgIHZhciBkYXRhQmluZCA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJyk7XG5cbiAgICB2YXIgaW5uZXJUbXBsTmFtZSwgb3V0ZXJUbXBsTmFtZTtcbiAgICAvLyBUT0RPIHVnbHkgaGFyZGNvZGVkIGhhbmRsaW5nOiBhdCB0aGUgdmVyeSBsZWFzdCB0aGlzIHNob3VsZCBiZSBpbnZva2VkIGJ5IHRoZSBkYXRhLWNvbnRhaW5lciBjYWxsZXIuXG4gICAgaWYgKGRhdGFCaW5kICE9PSAnJyAmJiBkYXRhQmluZCAhPT0gbnVsbCAmJiBkYXRhQmluZC5tYXRjaCgvKGJsb2NrfHd5c2l3eWdPckh0bWwpOi8pKSB7XG4gICAgICAvLyB3ZSBjYW4ndCBwdXQgdGhlIGNvbnRlbnQgaW4gYSB0ZW1wbGF0ZSBiZWNhdXNlIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIGJpbmRpbmdcbiAgICAgIHZhciBpbm5lclRtcGxDb250ZW50ID0gJzwhLS0ga28gJyArIGRhdGFCaW5kICsgJyAtLT4nICsgZG9tdXRpbHMuZ2V0SW5uZXJIdG1sKGVsZW1lbnQpICsgJzwhLS0gL2tvIC0tPic7XG4gICAgICBpbm5lclRtcGxOYW1lID0gdGVtcGxhdGVDcmVhdG9yKGlubmVyVG1wbENvbnRlbnQpO1xuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXdyYXAnKTtcbiAgICAgIG91dGVyVG1wbE5hbWUgPSB0ZW1wbGF0ZUNyZWF0b3IoZWxlbWVudCk7XG4gICAgICBkb211dGlscy5yZXBsYWNlSHRtbChlbGVtZW50LCAnPCEtLSBrbyB0ZW1wbGF0ZTogLyogc3BlY2lhbCAqLyAodHlwZW9mIHRlbXBsYXRlTW9kZSAhPSBcXCd1bmRlZmluZWRcXCcgJiYgdGVtcGxhdGVNb2RlID09IFxcJ3d5c2l3eWdcXCcpIHx8ICcgKyBjb25kQmluZGluZyArICcgPyBcXCcnICsgb3V0ZXJUbXBsTmFtZSArICdcXCcgOiBcXCcnICsgaW5uZXJUbXBsTmFtZSArICdcXCcgLS0+PCEtLSAva28gLS0+Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIHB1dCB0aGUgY29udGVudCBpbiBhIHRlbXBsYXRlIGFuZCB0aGUgZnJhbWUgaW4gYW5vdGhlciB0ZW1wbGF0ZSBpbmNsdWRpbmcgdGhpcyBvbmUuXG4gICAgICBpbm5lclRtcGxOYW1lID0gdGVtcGxhdGVDcmVhdG9yKGRvbXV0aWxzLmdldElubmVySHRtbChlbGVtZW50KSk7XG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28td3JhcCcpO1xuICAgICAgZG9tdXRpbHMuc2V0Q29udGVudChlbGVtZW50LCAnPCEtLSBrbyB0ZW1wbGF0ZTogXFwnJyArIGlubmVyVG1wbE5hbWUgKyAnXFwnIC0tPjwhLS0gL2tvIC0tPicpO1xuICAgICAgb3V0ZXJUbXBsTmFtZSA9IHRlbXBsYXRlQ3JlYXRvcihlbGVtZW50KTtcbiAgICAgIGRvbXV0aWxzLnJlcGxhY2VIdG1sKGVsZW1lbnQsICc8IS0tIGtvIHRlbXBsYXRlOiAodHlwZW9mIHRlbXBsYXRlTW9kZSAhPSBcXCd1bmRlZmluZWRcXCcgJiYgdGVtcGxhdGVNb2RlID09IFxcJ3d5c2l3eWdcXCcpIHx8ICcgKyBjb25kQmluZGluZyArICcgPyBcXCcnICsgb3V0ZXJUbXBsTmFtZSArICdcXCcgOiBcXCcnICsgaW5uZXJUbXBsTmFtZSArICdcXCcgLS0+PCEtLSAva28gLS0+Jyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHRlbXBsYXRlQ3JlYXRvcihlbGVtZW50LCB0ZW1wbGF0ZU5hbWUsICdzaG93Jyk7XG5cbiAgYmxvY2tQdXNoZXIocm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCBjb250ZXh0TmFtZSwgY29udGFpbmVyTmFtZSk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlTmFtZTtcblxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkV4Y2VwdGlvbiB3aGlsZSBwYXJzaW5nIHRoZSB0ZW1wbGF0ZVwiLCBlLCBlbGVtZW50KTtcbiAgICB0aHJvdyBlO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsX3JlcGxhY2UoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKC88IS0tXFxbaWYgKFteXFxdXSopXFxdPigoPzooPyEtLSlbXFxzXFxTXSkqPyk8IVxcW2VuZGlmXFxdLS0+L2csIGZ1bmN0aW9uKG1hdGNoLCBjb25kaXRpb24sIGJvZHkpIHtcbiAgICB2YXIgZGQgPSAnPCEtLSBjYzpzdGFydCAtLT4nO1xuICAgIGRkICs9IGJvZHkucmVwbGFjZSgvPChbQS1aYS16Ol0rKS9nLCAnPCEtLSBjYzpibzokMSAtLT48Y2MnKSAvLyBiZWZvcmUgb3BlbiB0YWdcbiAgICAgICAgICAgLnJlcGxhY2UoLzxcXC8oW0EtWmEtejpdKyk+L2csJzwhLS0gY2M6YmM6JDEgLS0+PC9jYz48IS0tIGNjOmFjOiQxIC0tPicpIC8vIGJlZm9yZS9hZnRlciBjbG9zZSB0YWdcbiAgICAgICAgICAgLnJlcGxhY2UoL1xcLz4vZywnLz48IS0tIGNjOnNjIC0tPicpOyAvLyBzZWxmLWNsb3NlIHRhZ1xuICAgIGRkICs9ICc8IS0tIGNjOmVuZCAtLT4nO1xuICAgIHZhciBvdXRwdXQgPSAnPHJlcGxhY2VkY2MgY29uZGl0aW9uPVwiJytjb25kaXRpb24rJ1wiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiPic7XG4gICAgb3V0cHV0ICs9ICQoJzxkaXY+JykuYXBwZW5kKCQoZGQpKS5odG1sKClcbiAgICAgIC5yZXBsYWNlKC9ePCEtLSBjYzpzdGFydCAtLT4vLCAnJylcbiAgICAgIC5yZXBsYWNlKC88IS0tIGNjOmVuZCAtLT4kLywgJycpO1xuICAgIG91dHB1dCArPSAnPC9yZXBsYWNlZGNjPic7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG59XG5cblxudmFyIHRyYW5zbGF0ZVRlbXBsYXRlID0gZnVuY3Rpb24odGVtcGxhdGVOYW1lLCBodG1sLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgdGVtcGxhdGVDcmVhdG9yKSB7XG4gIHZhciBkZWZzID0ge307XG4gIHZhciByZXBsYWNlZEh0bWwgPSBjb25kaXRpb25hbF9yZXBsYWNlKGh0bWwucmVwbGFjZSgvKDxbXj5dK1xccykoc3R5bGV8aHR0cC1lcXVpdikoPVwiW15cIl0qXCJbXj5dKj4pL2dpLCBmdW5jdGlvbihtYXRjaCwgcDEsIHAyLCBwMykge1xuICAgIHJldHVybiBwMSArICdyZXBsYWNlZCcgKyBwMiArIHAzO1xuICB9KSk7XG4gIHZhciBjb250ZW50ID0gJChyZXBsYWNlZEh0bWwpO1xuICB2YXIgZWxlbWVudCA9IGNvbnRlbnRbMF07XG5cbiAgdmFyIGJsb2NrcyA9IFtdOyAvLyB7cm9vdE5hbWUsIGJsb2NrTmFtZSwgY29udGFpbmVyTmFtZX1cbiAgdmFyIF9ibG9ja1B1c2hlciA9IGZ1bmN0aW9uKHJvb3ROYW1lLCBibG9ja05hbWUsIGNvbnRleHROYW1lLCBjb250YWluZXJOYW1lKSB7XG4gICAgYmxvY2tzLnB1c2goe1xuICAgICAgcm9vdDogcm9vdE5hbWUsXG4gICAgICBibG9jazogYmxvY2tOYW1lLFxuICAgICAgY29udGV4dDogY29udGV4dE5hbWUsXG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lck5hbWVcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIGhhdmUgdG8gYWNjZXB0IG51bGxzIGFzIHVuZGVmaW5lZHMgKGJlY2F1c2Ugb2YgbW9kZWwuanMgYmVoYXZpb3VyKVxuICB2YXIgdGhlbWVVcGRhdGVyID0gZnVuY3Rpb24obmFtZSwga2V5LCB2YWwpIHtcbiAgICBpZiAodHlwZW9mIGRlZnNbJ3RoZW1lcyddID09PSAndW5kZWZpbmVkJykgZGVmc1sndGhlbWVzJ10gPSB7fTtcbiAgICBpZiAodHlwZW9mIGRlZnNbJ3RoZW1lcyddW25hbWVdID09PSAndW5kZWZpbmVkJykgZGVmc1sndGhlbWVzJ11bbmFtZV0gPSB7fTtcbiAgICBpZiAodHlwZW9mIGRlZnNbJ3RoZW1lcyddW25hbWVdW2tleV0gPT09ICd1bmRlZmluZWQnIHx8IGRlZnNbJ3RoZW1lcyddW25hbWVdW2tleV0gPT09IG51bGwpIGRlZnNbJ3RoZW1lcyddW25hbWVdW2tleV0gPSB2YWw7XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJlY1ZhbCA9IGRlZnNbJ3RoZW1lcyddW25hbWVdW2tleV07XG4gICAgICBpZiAocHJlY1ZhbCAhPSB2YWwpIGNvbnNvbGUubG9nKFwiRXJyb3Igc2V0dGluZyBhIG5ldyBkZWZhdWx0IGZvciBwcm9wZXJ0eSBcIiArIGtleSArIFwiIGluIHRoZW1lIFwiICsgbmFtZSArIFwiLiBvbGQ6XCIgKyBwcmVjVmFsICsgXCIgbmV3OlwiICsgdmFsICsgXCIhXCIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY29udGFpbmVycyA9ICQoXCJbZGF0YS1rby1jb250YWluZXJdXCIsIGNvbnRlbnQpO1xuICB2YXIgY29udGFpbmVyc0RvbSA9IHt9O1xuICBjb250YWluZXJzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgY29udGFpbmVyTmFtZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1jb250YWluZXInKSArIFwiQmxvY2tzXCI7XG5cbiAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tY29udGFpbmVyJyk7XG4gICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnLCAnYmxvY2s6ICcgKyBjb250YWluZXJOYW1lKTtcblxuICAgIHZhciBjb250YWluZXJCbG9ja3MgPSAkKFwiPiBbZGF0YS1rby1ibG9ja11cIiwgZWxlbWVudCk7XG4gICAgZG9tdXRpbHMucmVtb3ZlRWxlbWVudHMoY29udGFpbmVyQmxvY2tzLCB0cnVlKTtcblxuICAgIGNvbnRhaW5lcnNEb21bY29udGFpbmVyTmFtZV0gPSBjb250YWluZXJCbG9ja3M7XG4gIH0pO1xuXG4gIC8vIFRPRE8gcmVtb3ZlIGhhcmRjb2RlZCBwcm9wZXJ0aWVzOiB3ZSBuZWVkIHRoZW0gYmVjYXVzZSB3aXRob3V0IHRoZXNlIGxvYWRpbmcgYSBiYXNpYyB0ZW1wbGF0ZSBmYWlscy5cbiAgLy8gTmVlZGVkIGluIG9yZGVyIHRvIHVzZSBkYXRhLWtvLWJsb2NrXG4gIG1vZGVsRGVmLmNyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgJ2lkJyk7XG4gIC8vIE5lZWRlZCBhbHdheXMgYXMgaXQgaXMgdGhlIGRlZmF1bHQgdGhlbWUgc2VjdGlvbi5cbiAgbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCAnYm9keVRoZW1lJyk7XG4gIC8vIE5lZWRlZCBmb3IgZGF0YS1rby1jb250YWluZXJcbiAgbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCAnYmxvY2tzJywgJ2Jsb2Nrc1tdJyk7XG5cbiAgLy8gTmVlZGVkIGlmIHlvdSB3YW50IHRvIHVzZSBhIHRleHQgdmFyaWFibGU/IFRPRE8gdGhpcyBzaG91bGQgbm90IGJlIG5lZWRlZCFcbiAgbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCAndGV4dCcpO1xuXG4gIHByb2Nlc3NCbG9jayhlbGVtZW50LCBkZWZzLCB0aGVtZVVwZGF0ZXIsIF9ibG9ja1B1c2hlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsICd0ZW1wbGF0ZScsIHRlbXBsYXRlTmFtZSwgdW5kZWZpbmVkLCBmYWxzZSwgdGVtcGxhdGVDcmVhdG9yKTtcblxuICB2YXIgYmxvY2tQcm9jZXNzID0gZnVuY3Rpb24oY29udGFpbmVyTmFtZSwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgICBwcm9jZXNzQmxvY2soZWxlbWVudCwgZGVmcywgdGhlbWVVcGRhdGVyLCBfYmxvY2tQdXNoZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCAnYmxvY2snLCB0ZW1wbGF0ZU5hbWUsIGNvbnRhaW5lck5hbWUsIHRydWUsIHRlbXBsYXRlQ3JlYXRvcik7XG4gIH07XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBjb250YWluZXJzRG9tKVxuICAgIGlmIChjb250YWluZXJzRG9tLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICB2YXIgY29udGFpbmVyQmxvY2tzID0gY29udGFpbmVyc0RvbVtwcm9wXTtcbiAgICAgIHZhciBjb250YWluZXJOYW1lID0gcHJvcDtcblxuICAgICAgbW9kZWxEZWYuZW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZShkZWZzLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlTmFtZSwgdGVtcGxhdGVOYW1lLCAnJywgY29udGFpbmVyTmFtZSArIFwiLmJsb2Nrc1wiLCBcIltdXCIpO1xuXG4gICAgICBjb250YWluZXJCbG9ja3MuZWFjaChibG9ja1Byb2Nlc3MuYmluZCh1bmRlZmluZWQsIGNvbnRhaW5lck5hbWUpKTtcbiAgICB9XG5cbiAgdmFyIHRlbXBsYXRlRGVmID0ge1xuICAgIF9kZWZzOiBkZWZzLFxuICAgIHRlbXBsYXRlTmFtZTogdGVtcGxhdGVOYW1lLFxuICAgIF9ibG9ja3M6IGJsb2Nrc1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdLl92ZXJzaW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRlbXBsYXRlRGVmLnZlcnNpb24gPSBkZWZzW3RlbXBsYXRlTmFtZV0uX3ZlcnNpb247XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGVEZWY7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNsYXRlVGVtcGxhdGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFBhcnNlcyBDU1Mvc3R5bGVzaGVldHMgZGVjbGFyYXRpb25zIC1rby1ibG9ja2RlZnMvLWtvLXRoZW1lc1xuLy8gSXQgcmV0dXJucyBLTyBiaW5kaW5ncyBidXQgZG9lc24ndCBkZXBlbmQgb24gS09cbi8vIE5lZWRzIGEgYmluZGluZ1Byb3ZpZGVyXG4vLyBBbHNvIHVzZXMgYSBibG9ja0RlZnNVcGRhdGVyIHRvIHVwZGF0ZSBkZWZpbml0aW9ucyB3aGlsZSBwYXJzaW5nIHRoZSBzdHlsZXNoZWV0LlxuXG52YXIgY3NzUGFyc2UgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL21lbnNjaC9saWIvcGFyc2VyLmpzXCIpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBjb252ZXJ0ZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xudmFyIGVsYWJvcmF0ZURlY2xhcmF0aW9ucyA9IHJlcXVpcmUoXCIuL2RlY2xhcmF0aW9ucy5qc1wiKTtcblxuLyogVGVtcG9yYXJ5IGV4cGVyaW1lbnRhbCBjb2RlIG5vdCB1c2VkXG52YXIgX3Byb2Nlc3NTdHlsZVNoZWV0UnVsZXNfcHJvY2Vzc1RoZW1lcyA9IGZ1bmN0aW9uIChiaW5kaW5nUHJvdmlkZXIsIHRoZW1lVXBkYXRlciwgcnVsZXMpIHtcbiAgdmFyIHNlbHMsIGRlY2xzLCBpLCBqLCBrO1xuICBmb3IoIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocnVsZXNbaV0udHlwZSA9PSAncnVsZScpIHtcbiAgICAgIHNlbHMgPSBydWxlc1tpXS5zZWxlY3RvcnM7XG4gICAgICBkZWNscyA9IHJ1bGVzW2ldLmRlY2xhcmF0aW9ucztcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBkZWNscy5sZW5ndGg7IGsrKykgaWYgKGRlY2xzW2tdLnR5cGUgPT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYmluZFZhbCA9IGJpbmRpbmdQcm92aWRlcignJCcrZGVjbHNba10ubmFtZSk7XG4gICAgICAgICAgICB0aGVtZVVwZGF0ZXIoc2Vsc1tqXSwgZGVjbHNba10ubmFtZSwgZGVjbHNba10udmFsdWUsIGJpbmRWYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXhjZXB0aW9uIHNldHRpbmcgdGhlbWUgZm9yXCIsIGRlY2xzW2tdLm5hbWUsIGRlY2xzW2tdLnZhbHVlLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4qL1xuXG52YXIgX3Byb2Nlc3NTdHlsZVNoZWV0UnVsZXNfcHJvY2Vzc0Jsb2NrRGVmID0gZnVuY3Rpb24oYmxvY2tEZWZzVXBkYXRlciwgcnVsZXMpIHtcbiAgdmFyIHByb3BlcnRpZXMsIG5hbWVkUHJvcHMsIGRlY2xzO1xuICAvLyBuYW1lLCBjb250ZXh0TmFtZSwgZ2xvYmFsU3R5bGUsIHRoZW1lT3ZlcnJpZGUsIGV4dGVuZCwgbWluLCBtYXgsIHdpZGdldCwgb3B0aW9ucywgY2F0ZWdvcnksIHZhcmlhbnQsIGhlbHAsIGJsb2NrRGVzY3JpcHRpb24sIHZlcnNpb24sIFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJ1bGVzW2ldLnR5cGUgPT0gJ3J1bGUnKSB7XG4gICAgICB2YXIgc2VscyA9IHJ1bGVzW2ldLnNlbGVjdG9ycztcbiAgICAgIHZhciBoYXNEZWNsYXJhdGlvbnMgPSBmYWxzZTtcbiAgICAgIHZhciBoYXNQcmV2aWV3cyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChzZWxzW2pdLm1hdGNoKC86cHJldmlldyQvKSkge1xuICAgICAgICAgIGhhc1ByZXZpZXdzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNEZWNsYXJhdGlvbnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzUHJldmlld3MgJiYgaGFzRGVjbGFyYXRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2Fubm90IG1peCBzZWxlY3RvcnMgdHlwZSAoOnByZXZpZXcgYW5kIGRlY2xhcmF0aW9ucykgaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnMgXCIsIHNlbHMpO1xuICAgICAgICB0aHJvdyBcIkNhbm5vdCBtaXggc2VsZWN0b3JzIHR5cGUgKDpwcmV2aWV3IGFuZCBkZWNsYXJhdGlvbnMpIGluIEBzdXBwb3J0cyAta28tYmxvY2tkZWZzXCI7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1ByZXZpZXdzICYmICFoYXNEZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjYW5ub3QgZmluZCBrbm93biBzZWxlY3RvcnMgaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnMgXCIsIHNlbHMpO1xuICAgICAgICB0aHJvdyBcIkNhbm5vdCBmaW5kIGtub3duIHNlbGVjdG9ycyBpbiBAc3VwcG9ydHMgLWtvLWJsb2NrZGVmc1wiO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0RlY2xhcmF0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzID0gJyc7XG4gICAgICAgIG5hbWVkUHJvcHMgPSB7fTtcblxuLypcbiAgICAgICAgbmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udGV4dE5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGdsb2JhbFN0eWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGVtZU92ZXJyaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBleHRlbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbWluID0gdW5kZWZpbmVkO1xuICAgICAgICB3aWRnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNhdGVnb3J5ID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXJpYW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBoZWxwID0gdW5kZWZpbmVkO1xuICAgICAgICBibG9ja0Rlc2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB2ZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAqL1xuICAgICAgICBkZWNscyA9IHJ1bGVzW2ldLmRlY2xhcmF0aW9ucztcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkZWNscy5sZW5ndGg7IGsrKykgaWYgKGRlY2xzW2tdLnR5cGUgPT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgIGlmIChkZWNsc1trXS5uYW1lID09ICdsYWJlbCcpIG5hbWVkUHJvcHMubmFtZSA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ2NvbnRleHQnKSBuYW1lZFByb3BzLmNvbnRleHROYW1lID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAncHJvcGVydGllcycpIHByb3BlcnRpZXMgPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICd0aGVtZScpIG5hbWVkUHJvcHMuZ2xvYmFsU3R5bGUgPSAnX3RoZW1lXy4nICsgZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAndGhlbWVPdmVycmlkZScpIG5hbWVkUHJvcHMudGhlbWVPdmVycmlkZSA9IFN0cmluZyhkZWNsc1trXS52YWx1ZSkudG9Mb3dlckNhc2UoKSA9PSAndHJ1ZSc7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnZXh0ZW5kJykgZXh0ZW5kID0gZGVjbHNba10udmFsdWU7XG5cbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdtYXgnKSBtYXggPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdtaW4nKSBtaW4gPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdvcHRpb25zJykgb3B0aW9ucyA9IGRlY2xzW2tdLnZhbHVlO1xuXG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnd2lkZ2V0Jykgd2lkZ2V0ID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnY2F0ZWdvcnknKSBjYXRlZ29yeSA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ3ZhcmlhbnQnKSB2YXJpYW50ID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnaGVscCcpIGhlbHAgPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdibG9ja0Rlc2NyaXB0aW9uJykgYmxvY2tEZXNjcmlwdGlvbiA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ3ZlcnNpb24nKSB2ZXJzaW9uID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lZFByb3BzW2RlY2xzW2tdLm5hbWVdID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgICAvLyBUT0RPIGluIHBhc3Qgd2UgZGV0ZWN0ZWQgdW5zdXBwb3J0ZWQgcHJvcGVydGllcywgd2hpbGUgbm93IHdlIHNpbXBsZSBwdXNoIGV2ZXJ5IGRlY2xhcmF0aW9uIGluIGEgbmFtZWRQcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIFRoaXMgbWFrZSBpdCBoYXJkZXIgdG8gc3BvdCBlcnJvcnMgaW4gZGVjbGFyYXRpb25zLlxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiVW5rbm93biBwcm9wZXJ0eSBwcm9jZXNzaW5nIEBzdXBwb3J0cyAta28tYmxvY2tkZWZzIFwiLCBkZWNsc1trXSwgc2Vscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc2Vscy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIGJsb2NrRGVmc1VwZGF0ZXIoc2Vsc1tsXSwgcHJvcGVydGllcywgbmFtZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNQcmV2aWV3cykge1xuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHNlbHMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICB2YXIgbG9jYWxCbG9ja05hbWUgPSBzZWxzW21dLnN1YnN0cigwLCBzZWxzW21dLmluZGV4T2YoJzonKSk7XG4gICAgICAgICAgdmFyIHByZXZpZXdCaW5kaW5ncyA9IHJ1bGVzW2ldLmRlY2xhcmF0aW9ucztcbiAgICAgICAgICBibG9ja0RlZnNVcGRhdGVyKGxvY2FsQmxvY2tOYW1lLCB1bmRlZmluZWQsIHsgcHJldmlld0JpbmRpbmdzOiBwcmV2aWV3QmluZGluZ3MgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZ25vcmluZyBjb21tZW50cyBvciBvdGhlciBjb250ZW50XG4gICAgfVxuICB9XG59O1xuXG52YXIgcHJvY2Vzc1N0eWxlc2hlZXRSdWxlcyA9IGZ1bmN0aW9uKHN0eWxlLCBydWxlcywgbG9jYWxXaXRoQmluZGluZ1Byb3ZpZGVyLCBibG9ja0RlZnNVcGRhdGVyLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUpIHtcbiAgdmFyIG5ld1N0eWxlID0gc3R5bGU7XG4gIHZhciBsYXN0U3RhcnQgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YgcnVsZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgc3R5bGVTaGVldCA9IGNzc1BhcnNlKHN0eWxlLCB7XG4gICAgICBjb21tZW50czogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHN0eWxlU2hlZXQudHlwZSAhPSAnc3R5bGVzaGVldCcgfHwgdHlwZW9mIHN0eWxlU2hlZXQuc3R5bGVzaGVldCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5sb2coXCJ1bmFibGUgdG8gcHJvY2VzcyBzdHlsZVNoZWV0XCIsIHN0eWxlU2hlZXQpO1xuICAgICAgdGhyb3cgXCJVbmFibGUgdG8gcGFyc2Ugc3R5bGVzaGVldFwiO1xuICAgIH1cbiAgICBydWxlcyA9IHN0eWxlU2hlZXQuc3R5bGVzaGVldC5ydWxlcztcbiAgfVxuXG4gIC8vIFdBUk4gY3VycmVubHR5IHRoaXMgcGFyc2VzIHJ1bGVzIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCBzdHJpbmcgcmVwbGFjZW1lbnRzIHdvcmtzIHVzaW5nIGlucHV0IFwicG9zaXRpb25zXCJcbiAgLy8gb3RoZXJ3aXNlIGl0IHNob3VsZCBjb21wdXRlIG5ldyBvZmZzZXRzIG9uIGV2ZXJ5IHJlcGxhY2VtZW50LlxuICAvLyBCdXQgdGhpcyBjcmVhdGUgaXNzdWVzIGJlY2F1c2Ugb2YgZGVmaW5pdGlvbnMgYmVpbmcgcGFyc2VkIGluIHJldmVyc2Ugb3JkZXIsIHNvIHRoaXMgaXMgbm90IGEgZ29vZCBpZGVhLlxuICAvLyBTb21ldGltZXMsIHRvIHdvcmsgYXJvdW5kIHRoaXMgaXNzdWVzLCB5b3UgbmVlZCB0byBjcmVhdGUgMiBkaWZmZXJlbnQgPHN0eWxlPiBibG9ja3MuXG4gIHZhciBiaW5kaW5nUHJvdmlkZXI7XG5cbiAgZm9yICh2YXIgaSA9IHJ1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHJ1bGVzW2ldLnR5cGUgPT0gJ3N1cHBvcnRzJyAmJiBydWxlc1tpXS5uYW1lID09ICcta28tYmxvY2tkZWZzJykge1xuICAgICAgX3Byb2Nlc3NTdHlsZVNoZWV0UnVsZXNfcHJvY2Vzc0Jsb2NrRGVmKGJsb2NrRGVmc1VwZGF0ZXIsIHJ1bGVzW2ldLnJ1bGVzKTtcbiAgICAgIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIHJ1bGVzW2ldLnBvc2l0aW9uLnN0YXJ0LCBsYXN0U3RhcnQsIDAsIDAsIDAsICcnKTtcbiAgICAgIC8qIHRlbXBvcmFyeSBleHBlcmltZW50YWwgY29kZSBub3QgdXNlZFxuICAgICAgfSBlbHNlIGlmIChydWxlc1tpXS50eXBlID09ICdzdXBwb3J0cycgJiYgcnVsZXNbaV0ubmFtZSA9PSAnLWtvLXRoZW1lcycpIHtcbiAgICAgICAgYmluZGluZ1Byb3ZpZGVyID0gbG9jYWxXaXRoQmluZGluZ1Byb3ZpZGVyLmJpbmQodGhpcywgJ3RoZW1lJywgJycpO1xuICAgICAgICBfcHJvY2Vzc1N0eWxlU2hlZXRSdWxlc19wcm9jZXNzVGhlbWVzKGJpbmRpbmdQcm92aWRlciwgdGhlbWVVcGRhdGVyLCBydWxlc1tpXS5ydWxlcyk7XG4gICAgICAgIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIHJ1bGVzW2ldLnBvc2l0aW9uLnN0YXJ0LCBsYXN0U3RhcnQsIDAsIDAsIDAsICcnKTtcbiAgICAgICovXG4gICAgfSBlbHNlIGlmIChydWxlc1tpXS50eXBlID09ICdtZWRpYScgfHwgcnVsZXNbaV0udHlwZSA9PSAnc3VwcG9ydHMnKSB7XG4gICAgICBuZXdTdHlsZSA9IHByb2Nlc3NTdHlsZXNoZWV0UnVsZXMobmV3U3R5bGUsIHJ1bGVzW2ldLnJ1bGVzLCBsb2NhbFdpdGhCaW5kaW5nUHJvdmlkZXIsIGJsb2NrRGVmc1VwZGF0ZXIsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSk7XG4gICAgfSBlbHNlIGlmIChydWxlc1tpXS50eXBlID09ICdjb21tZW50Jykge1xuICAgICAgLy8gaWdub3JlIGNvbW1lbnRzXG4gICAgfSBlbHNlIGlmIChydWxlc1tpXS50eXBlID09ICdydWxlJykge1xuICAgICAgdmFyIHNlbHMgPSBydWxlc1tpXS5zZWxlY3RvcnM7XG4gICAgICB2YXIgbmV3U2VsID0gXCJcIjtcbiAgICAgIHZhciBmb3VuZEJsb2NrTWF0Y2ggPSBudWxsO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChuZXdTZWwubGVuZ3RoID4gMCkgbmV3U2VsICs9IFwiLCBcIjtcbiAgICAgICAgdmFyIG1hdGNoID0gc2Vsc1tqXS5tYXRjaCgvXFxbZGF0YS1rby1ibG9jaz0oW14gXSopXFxdLyk7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChmb3VuZEJsb2NrTWF0Y2ggIT09IG51bGwgJiYgZm91bmRCbG9ja01hdGNoICE9IG1hdGNoWzFdKSB0aHJvdyBcIkZvdW5kIG11bHRpcGxlIGJsb2NrLW1hdGNoIGF0dHJpYnV0ZSBzZWxlY3RvcnM6IGNhbm5vdCB0cmFuc2xhdGUgaXQgKFwiICsgZm91bmRCbG9ja01hdGNoICsgXCIgdnMgXCIgKyBtYXRjaFsxXSArIFwiKVwiO1xuICAgICAgICAgIGZvdW5kQmxvY2tNYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIG5ld1NlbCArPSAnPCEtLSBrbyB0ZXh0OiB0ZW1wbGF0ZU1vZGUgPT1cXCd3eXNpd3lnXFwnID8gXFwnI21haW4td3lzaXd5Zy1hcmVhIFxcJyA6IFxcJ1xcJyAtLT48IS0tIC9rbyAtLT4nICsgc2Vsc1tqXTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZEJsb2NrTWF0Y2gpIHtcbiAgICAgICAgdmFyIGxvb3BQcmVmaXggPSAnPCEtLSBrbyBmb3JlYWNoOiAkcm9vdC5maW5kT2JqZWN0c09mVHlwZSgkZGF0YSwgXFwnJyArIGZvdW5kQmxvY2tNYXRjaCArICdcXCcpIC0tPic7XG4gICAgICAgIHZhciBsb29wUG9zdGZpeCA9ICc8IS0tIC9rbyAtLT4nO1xuICAgICAgICB2YXIgZW5kID0gbGFzdFN0YXJ0O1xuICAgICAgICB2YXIgc3BhY2luZyA9IFwiIFwiO1xuICAgICAgICBpZiAocnVsZXNbaV0uZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocnVsZXNbaV0uZGVjbGFyYXRpb25zWzBdLnBvc2l0aW9uLnN0YXJ0LmxpbmUgIT0gcnVsZXNbaV0ucG9zaXRpb24uZW5kLmxpbmUpIHtcbiAgICAgICAgICAgIHNwYWNpbmcgPSBcIlxcblwiICsgKG5ldyBBcnJheShydWxlc1tpXS5wb3NpdGlvbi5zdGFydC5jb2wpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kID0gcnVsZXNbaV0uZGVjbGFyYXRpb25zW3J1bGVzW2ldLmRlY2xhcmF0aW9ucy5sZW5ndGggLSAxXS5wb3NpdGlvbi5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkgbmV3U3R5bGUgKz0gc3BhY2luZyArIGxvb3BQb3N0Zml4O1xuICAgICAgICBlbHNlIGlmIChlbmQgPT0gbGFzdFN0YXJ0KSBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBlbmQsIGxhc3RTdGFydCwgMCwgMCwgMCwgc3BhY2luZyArIGxvb3BQb3N0Zml4KTtcbiAgICAgICAgZWxzZSBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBlbmQsIGxhc3RTdGFydCwgMCwgMCwgMCwgc3BhY2luZyArICd9JyArIHNwYWNpbmcgKyBsb29wUG9zdGZpeCk7XG4gICAgICAgIG5ld1NlbCA9IGxvb3BQcmVmaXggKyBzcGFjaW5nICsgbmV3U2VsLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXFtkYXRhLWtvLWJsb2NrPScgKyBmb3VuZEJsb2NrTWF0Y2ggKyAnXFxcXF0nLCAnZycpLCAnPCEtLSBrbyB0ZXh0OiBcXCcjXFwnK2lkKCkgLS0+JyArIGZvdW5kQmxvY2tNYXRjaCArICc8IS0tIC9rbyAtLT4nKTtcblxuICAgICAgICBibG9ja0RlZnNVcGRhdGVyKGZvdW5kQmxvY2tNYXRjaCwgJycsIHsgY29udGV4dE5hbWU6ICdibG9jaycgfSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPIG1lbnNjaCB1cGRhdGUgKHVzaW5nIG9yaWdpbmFsIG1lbnNjaCBsaWJyYXJ5IHdlIG5lZWRlZCB0aGlzIGxpbmUsIHdoaWxlIHRoZSBwYXRjaGVkIG9uZSBkb2Vzbid0IG5lZWQgdGhpcyBjb2RlKVxuICAgICAgLy8gbmV3U2VsICs9IFwiIHtcIjtcbiAgICAgIHZhciBsb2NhbEJsb2NrTmFtZSA9IGZvdW5kQmxvY2tNYXRjaCA/IGZvdW5kQmxvY2tNYXRjaCA6IHRlbXBsYXRlTmFtZTtcbiAgICAgIGJpbmRpbmdQcm92aWRlciA9IGxvY2FsV2l0aEJpbmRpbmdQcm92aWRlci5iaW5kKHRoaXMsIGxvY2FsQmxvY2tOYW1lLCAnJyk7XG4gICAgICB2YXIgZWxhYm9yYXRlZFN0eWxlID0gZWxhYm9yYXRlRGVjbGFyYXRpb25zKG5ld1N0eWxlLCBydWxlc1tpXS5kZWNsYXJhdGlvbnMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBiaW5kaW5nUHJvdmlkZXIpO1xuICAgICAgaWYgKGVsYWJvcmF0ZWRTdHlsZSAhPT0gbnVsbCkgbmV3U3R5bGUgPSBlbGFib3JhdGVkU3R5bGU7XG5cbiAgICAgIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIHJ1bGVzW2ldLnBvc2l0aW9uLnN0YXJ0LCBydWxlc1tpXS5wb3NpdGlvbi5lbmQsIDAsIDAsIDAsIG5ld1NlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBydWxlIHR5cGVcIiwgcnVsZXNbaV0udHlwZSwgXCJ3aGlsZSBwYXJzaW5nIDxzdHlsZT4gcnVsZXNcIik7XG4gICAgfVxuICAgIGxhc3RTdGFydCA9IHJ1bGVzW2ldLnBvc2l0aW9uLnN0YXJ0O1xuICB9XG4gIHJldHVybiBuZXdTdHlsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1N0eWxlc2hlZXRSdWxlczsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIganNlcCA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvanNlcC9zcmMvanNlcC5qc1wiKTtcblxuanNlcC5hZGRCaW5hcnlPcChcIm9yXCIsIDEpO1xuanNlcC5hZGRCaW5hcnlPcChcImFuZFwiLCAyKTtcbmpzZXAuYWRkQmluYXJ5T3AoXCJlcVwiLCA2KTtcbmpzZXAuYWRkQmluYXJ5T3AoXCJuZXFcIiwgNik7XG5qc2VwLmFkZEJpbmFyeU9wKFwibHRcIiwgNyk7XG5qc2VwLmFkZEJpbmFyeU9wKFwibHRlXCIsIDcpO1xuanNlcC5hZGRCaW5hcnlPcChcImd0XCIsIDcpO1xuanNlcC5hZGRCaW5hcnlPcChcImd0ZVwiLCA3KTtcblxudmFyIGFkZFNsYXNoZXMgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxcXFwiJ10vZywgJ1xcXFwkJicpLnJlcGxhY2UoL1xcdTAwMDAvZywgJ1xcXFwwJyk7XG59O1xuXG52YXIgcmVtb3ZlU3R5bGUgPSBmdW5jdGlvbihzdHlsZSwgc3RhcnRQb3MsIGVuZFBvcywgc2tpcFJvd3MsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIGluc2VydCkge1xuICB2YXIgc3R5bGVSb3dzID0gc3R5bGUuc3BsaXQoXCJcXG5cIik7XG4gIHZhciBzdGFydCA9IHN0YXJ0T2Zmc2V0O1xuICB2YXIgZW5kID0gZW5kT2Zmc2V0O1xuICBmb3IgKHZhciByID0gMSArIHNraXBSb3dzOyByIDwgc3RhcnRQb3MubGluZTsgcisrKSBzdGFydCArPSBzdHlsZVJvd3NbciAtIDEgLSBza2lwUm93c10ubGVuZ3RoICsgMTtcbiAgc3RhcnQgKz0gc3RhcnRQb3MuY29sO1xuICBpZiAoZW5kUG9zICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgcjIgPSAxICsgc2tpcFJvd3M7IHIyIDwgZW5kUG9zLmxpbmU7IHIyKyspIGVuZCArPSBzdHlsZVJvd3NbcjIgLSAxIC0gc2tpcFJvd3NdLmxlbmd0aCArIDE7XG4gICAgZW5kICs9IGVuZFBvcy5jb2w7XG4gIH0gZWxzZSBlbmQgKz0gc3R5bGUubGVuZ3RoICsgMTtcbiAgdmFyIG5ld1N0eWxlID0gc3R5bGUuc3Vic3RyKDAsIHN0YXJ0IC0gMSkgKyBpbnNlcnQgKyBzdHlsZS5zdWJzdHIoZW5kIC0gMSk7XG4gIHJldHVybiBuZXdTdHlsZTtcbn07XG5cbnZhciBleHByZXNzaW9uR2VuZXJhdG9yID0gZnVuY3Rpb24obm9kZSwgYmluZGluZ1Byb3ZpZGVyLCBkZWZWYWwpIHtcbiAgZnVuY3Rpb24gbWFwT3BlcmF0b3Iob3ApIHtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlICdvcic6XG4gICAgICAgIHJldHVybiAnfHwnO1xuICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgcmV0dXJuICcmJic7XG4gICAgICBjYXNlICdsdCc6XG4gICAgICAgIHJldHVybiAnPCc7XG4gICAgICBjYXNlICdsdGUnOlxuICAgICAgICByZXR1cm4gJzw9JztcbiAgICAgIGNhc2UgJ2d0JzpcbiAgICAgICAgcmV0dXJuICc+JztcbiAgICAgIGNhc2UgJ2d0ZSc6XG4gICAgICAgIHJldHVybiAnPj0nO1xuICAgICAgY2FzZSAnZXEnOlxuICAgICAgICByZXR1cm4gJz09JztcbiAgICAgIGNhc2UgJ25lcSc6XG4gICAgICAgIHJldHVybiAnIT0nO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbihub2RlLCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlciwgZGVmVmFsKSB7XG4gICAgaWYgKHR5cGVvZiBsb29rdXBtZW1iZXIgPT0gJ3VuZGVmaW5lZCcpIGxvb2t1cG1lbWJlciA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlZlZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgbm9kZS50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBub2RlLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSBjb25zb2xlLmxvZyhcIkNhbm5vdCBhcHBseSBkZWZhdWx0IHZhbHVlIHRvIHZhcmlhYmxlIHdoZW4gdXNpbmcgZXhwcmVzc2lvbnNcIik7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkJpbmFyeUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuICcoJyArIGdlbihub2RlLmxlZnQsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKSArICcgJyArIG1hcE9wZXJhdG9yKG5vZGUub3BlcmF0b3IpICsgJyAnICsgZ2VuKG5vZGUucmlnaHQsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKSArICcpJztcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgdmFyIGFyZ3MgPSBub2RlLmFyZ3VtZW50cy5tYXAoZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gZ2VuKG4sIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdlbihub2RlLmNhbGxlZSwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpICsgJygnICsgYXJncy5qb2luKCcsICcpICsgJyknO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gbm9kZS5vcGVyYXRvciArIGdlbihub2RlLmFyZ3VtZW50LCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT0gJ01lbWJlckV4cHJlc3Npb24nICYmIG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHRocm93IFwiVW5leHBlY3RlZCBjb21wdXRlZCBtZW1iZXIgZXhwcmVzc2lvblwiO1xuICAgICAgLy8gcmV0dXJuIGdlbihub2RlLm9iamVjdCkgKyAnWycgKyBnZW4obm9kZS5wcm9wZXJ0eSkgKyAnXSc7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT0gJ01lbWJlckV4cHJlc3Npb24nICYmICFub2RlLmNvbXB1dGVkKSB7XG4gICAgICB2YXIgbWUgPSBnZW4obm9kZS5vYmplY3QsIGJpbmRpbmdQcm92aWRlciwgZmFsc2UpICsgJy4nICsgZ2VuKG5vZGUucHJvcGVydHksIGJpbmRpbmdQcm92aWRlciwgZmFsc2UpO1xuICAgICAgaWYgKGxvb2t1cG1lbWJlciAmJiBub2RlLm9iamVjdC5uYW1lICE9PSAnTWF0aCcgJiYgbm9kZS5vYmplY3QubmFtZSAhPT0gJ0NvbG9yJykgcmV0dXJuIGJpbmRpbmdQcm92aWRlcihtZSwgZGVmVmFsKSArICcoKSc7XG4gICAgICByZXR1cm4gbWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiTGl0ZXJhbFwiKSB7XG4gICAgICByZXR1cm4gbm9kZS5yYXc7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdmFyIGlkID0gbm9kZS5uYW1lO1xuICAgICAgaWYgKGxvb2t1cG1lbWJlcikgcmV0dXJuIGJpbmRpbmdQcm92aWRlcihpZCwgZGVmVmFsKSArICcoKSc7XG4gICAgICBlbHNlIHJldHVybiBpZDtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiAnKCcgKyBnZW4obm9kZS50ZXN0LCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcikgKyAnID8gJyArIGdlbihub2RlLmNvbnNlcXVlbnQsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKSArICcgOiAnICsgZ2VuKG5vZGUuYWx0ZXJuYXRlLCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcikgKyAnKSc7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdDb21wb3VuZCcpIHtcbiAgICAgIHRocm93IFwiU3ludGF4IGVycm9yIGluIGV4cHJlc3Npb246IG9wZXJhdG9yIGV4cGVjdGVkIGFmdGVyIFwiICsgZ2VuKG5vZGUuYm9keVswXSwgYmluZGluZ1Byb3ZpZGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiRm91bmQgYW4gdW5zdXBwb3J0ZWQgZXhwcmVzc2lvbiB0eXBlOiBcIiArIG5vZGUudHlwZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2VuKG5vZGUsIGJpbmRpbmdQcm92aWRlciwgdW5kZWZpbmVkLCBkZWZWYWwpO1xufTtcblxudmFyIGV4cHJlc3Npb25CaW5kaW5nID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgYmluZGluZ1Byb3ZpZGVyLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIG1hdGNoZXM7XG4gIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiBkZWZhdWx0VmFsdWUgIT09IG51bGwpIHtcbiAgICB2YXIgY2hlY2sgPSBleHByZXNzaW9uLnRyaW0oKS5yZXBsYWNlKC9AXFxbKFteXFxdXSspXFxdfEAoW2EtekEtWjAtOVxcLl9dKylcXGIvZywgJyMjI3ZhciMjIycpO1xuICAgIGNoZWNrID0gY2hlY2sucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpO1xuICAgIGlmIChjaGVjayA9PSAnIyMjdmFyIyMjJykgbWF0Y2hlcyA9IFtudWxsLCBkZWZhdWx0VmFsdWVdO1xuICAgIGVsc2Uge1xuICAgICAgY2hlY2sgPSAnXicgKyBjaGVjay5yZXBsYWNlKC8jIyN2YXIjIyMvZywgJyguKyknKSArICckJztcbiAgICAgIG1hdGNoZXMgPSBkZWZhdWx0VmFsdWUudHJpbSgpLm1hdGNoKG5ldyBSZWdFeHAoY2hlY2spKTtcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAvLyBUT0RPIHRocm93IGVycm9yP1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNhbm5vdCBmaW5kIG1hdGNoZXNcIiwgbWF0Y2hlcywgXCJmb3JcIiwgZGVmYXVsdFZhbHVlLCBleHByZXNzaW9uLCBjaGVjaywgZXhwcmVzc2lvbik7XG4gICAgICAgIHRocm93IFwiQ2Fubm90IGZpbmQgZGVmYXVsdCB2YWx1ZSBmb3IgXCIgKyBleHByZXNzaW9uICsgXCIgaW4gXCIgKyBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgdmFyIHZhcnMgPSAwO1xuICAgIHZhciByZXN1bHQgPSBcIidcIiArIGV4cHJlc3Npb24ucmVwbGFjZSgvQFxcWyhbXlxcXV0rKVxcXXxAKFthLXpBLVowLTlcXC5fXSspXFxifCgnKS9nLCBmdW5jdGlvbihtYXRjaCwgcDEsIHAyLCBwMykge1xuICAgICAgLy8gZXNjYXBpbmcuLlxuICAgICAgaWYgKHAzKSByZXR1cm4gXCJcXFxcXCIgKyBwMztcbiAgICAgIHZhcnMrKztcbiAgICAgIHZhciB2YXJOYW1lID0gcDEgfHwgcDI7XG4gICAgICB2YXIgZGVmVmFsO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVzW3ZhcnNdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRlZlZhbCA9IG1hdGNoZXNbdmFyc10udHJpbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQUJaWlogQ2Fubm90IGZpbmQgZGVmYXVsdCB2YWx1ZSBmb3JcIiwgdmFyTmFtZSwgXCJpblwiLCBtYXRjaGVzLCBcImFzXCIsIHZhcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpbiBjYXNlIHdlIGZvdW5kIHAxIHdlIGFyZSBpbiBhIEBbc2VxdWVuY2VdIHNvIHdlIHN0YXJ0IGFuIGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICBpZiAocDEpIHtcbiAgICAgICAgdmFyIHBhcnNldHJlZSA9IGpzZXAocDEpO1xuICAgICAgICB2YXIgZ2VudHJlZSA9IGV4cHJlc3Npb25HZW5lcmF0b3IocGFyc2V0cmVlLCBiaW5kaW5nUHJvdmlkZXIsIGRlZlZhbCk7XG4gICAgICAgIHJldHVybiBcIicrXCIgKyBnZW50cmVlICsgXCIrJ1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiJytcIiArIGJpbmRpbmdQcm92aWRlcih2YXJOYW1lLCBkZWZWYWwpICsgXCIoKSsnXCI7XG4gICAgfSkgKyBcIidcIjtcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvKF58W15cXFxcXSknJ1xcKy9nLCAnJDEnKS5yZXBsYWNlKC9cXCsnJy9nLCAnJyk7XG5cbiAgICBpZiAodmFycyA9PT0gMCAmJiByZXN1bHQgIT09ICdmYWxzZScgJiYgcmVzdWx0ICE9PSAndHJ1ZScpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGV4cHJlc3Npb24gd2l0aCBubyB2YWxpZCBAdmFyaWFibGUgcmVmZXJlbmNlc1wiLCBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IFwiRXhjZXB0aW9uIHBhcnNpbmcgZXhwcmVzc2lvbiBcIiArIGV4cHJlc3Npb24gKyBcIiBcIiArIGU7XG4gIH1cbn07XG5cbnZhciBjb25kaXRpb25CaW5kaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBiaW5kaW5nUHJvdmlkZXIpIHtcbiAgdmFyIHBhcnNldHJlZSA9IGpzZXAoY29uZGl0aW9uKTtcbiAgdmFyIGdlbnRyZWUgPSBleHByZXNzaW9uR2VuZXJhdG9yKHBhcnNldHJlZSwgYmluZGluZ1Byb3ZpZGVyKTtcbiAgcmV0dXJuIGdlbnRyZWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkU2xhc2hlczogYWRkU2xhc2hlcyxcbiAgcmVtb3ZlU3R5bGU6IHJlbW92ZVN0eWxlLFxuICBjb25kaXRpb25CaW5kaW5nOiBjb25kaXRpb25CaW5kaW5nLFxuICBleHByZXNzaW9uQmluZGluZzogZXhwcmVzc2lvbkJpbmRpbmdcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgaXMgY29tcGxleCBjb2RlIHRvIGhhbmRsZSBcImxpdmVcIiBtb2RlbCBpbnN0cnVtZW50YXRpb24gYW5kIGRlcGVuZGVuY3kgdHJhY2tpbmcuXG4vLyBUaGlzIGFkZHMgX3dyYXAgYW5kIF91bndyYXAgbWV0aG9kcyB0byB0aGUgbW9kZWwgYW5kIGFsc28gaW5zdHJ1bWVudCB0aGUgYmxvY2sgbGlzdCBzbyB0byBhdXRvbWF0aWNhbGx5XG4vLyB3cmFwL3Vwd3JhcCBvYmplY3RzIG9uIHNpbXBsZSBhcnJheSBtZXRob2RzIChwdXNoLCBzcGxpY2UpXG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGtvd3JhcCA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMva25vY2tvdXQud3JhcC9rbm9ja291dC53cmFwLmpzXCIpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxudmFyIF9nZXRPcHRpb25zT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgb3B0aW9uc0NvdXBsZXMgPSBvcHRpb25zLnNwbGl0KCd8Jyk7XG4gIHZhciBvcHRzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uc0NvdXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3B0ID0gb3B0aW9uc0NvdXBsZXNbaV0uc3BsaXQoJz0nKTtcbiAgICBvcHRzW29wdFswXV0gPSBvcHQubGVuZ3RoID4gMSA/IG9wdFsxXSA6IG9wdFswXTtcbiAgfVxuICByZXR1cm4gb3B0cztcbn07XG5cbi8vIGdlbmVyYXRlIGEgY29tcHV0ZWQgdmFyaWFibGUgaGFuZGxpbmcgdGhlIGZhbGxiYWNrIHRvIHRoZW1lIHZhcmlhYmxlXG52YXIgX21ha2VDb21wdXRlZCA9IGZ1bmN0aW9uKHRhcmdldCwgZGVmLCBudWxsSWZFcXVhbCwgc2NoZW1lU2VsZWN0b3IsIHRoZW1lUGF0aCwgdGhlbWVzKSB7XG4gIHZhciByZXMgPSBrby5jb21wdXRlZCh7XG4gICAgJ3JlYWQnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWwgPSB0YXJnZXQoKTtcbiAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoc2NoZW1lU2VsZWN0b3IpO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtZSA9PSAndW5kZWZpbmVkJyB8fCBzY2hlbWUgPT0gJ2N1c3RvbScpIHtcbiAgICAgICAgICByZXR1cm4ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShkZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGVtZXNbc2NoZW1lXVt0aGVtZVBhdGhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3dyaXRlJzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBzY2hlbWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHNjaGVtZVNlbGVjdG9yKTtcbiAgICAgIHZhciBkZWZWYWw7XG4gICAgICBpZiAodHlwZW9mIHNjaGVtZSA9PSAndW5kZWZpbmVkJyB8fCBzY2hlbWUgPT0gJ2N1c3RvbScpIHtcbiAgICAgICAgZGVmVmFsID0ga28udXRpbHMucGVla09ic2VydmFibGUoZGVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZlZhbCA9IHRoZW1lc1tzY2hlbWVdW3RoZW1lUGF0aF07XG4gICAgICB9XG5cbiAgICAgIGlmICghIW51bGxJZkVxdWFsKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBkZWZWYWwpIHRhcmdldChudWxsKTtcbiAgICAgICAgZWxzZSB0YXJnZXQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh0YXJnZXQpO1xuICAgICAgICBpZiAodmFsdWUgIT0gZGVmVmFsIHx8IGN1cnJlbnQgIT09IG51bGwpIHRhcmdldCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufTtcblxudmFyIF9uZXh0VmFyaWFudEZ1bmN0aW9uID0gZnVuY3Rpb24oa28sIHByb3AsIHZhcmlhbnRzKSB7XG4gIHZhciBjdXJyZW50VmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHByb3ApO1xuICB2YXIgdmFyaWFudFZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyaWFudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXJpYW50VmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh2YXJpYW50c1tpXSk7XG4gICAgaWYgKHZhcmlhbnRWYWx1ZSA9PSBjdXJyZW50VmFsdWUpIGJyZWFrO1xuICB9XG5cbiAgaWYgKGkgPT0gdmFyaWFudHMubGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKFwiRGlkbid0IGZpbmQgYSB2YXJpYW50IVwiLCBwcm9wLCBjdXJyZW50VmFsdWUsIHZhcmlhbnRzKTtcbiAgICBpID0gdmFyaWFudHMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIHZhciBuZXh0VmFyaWFudCA9IGkgKyAxO1xuICBpZiAobmV4dFZhcmlhbnQgPT0gdmFyaWFudHMubGVuZ3RoKSBuZXh0VmFyaWFudCA9IDA7XG4gIHZhciBuZXh0VmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh2YXJpYW50c1tuZXh0VmFyaWFudF0pO1xuXG4gIHByb3AobmV4dFZhbHVlKTtcbn07XG5cbnZhciBfZ2V0VmFyaWFudHMgPSBmdW5jdGlvbihkZWYpIHtcbiAgdmFyIHZhcmlhbnRQcm9wID0gZGVmLl92YXJpYW50O1xuICB2YXIgdmFyaWFudE9wdGlvbnM7XG4gIGlmICh0eXBlb2YgZGVmW3ZhcmlhbnRQcm9wXSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGRlZlt2YXJpYW50UHJvcF0uX3dpZGdldCA9PT0gJ3VuZGVmaW5lZCcgfHwgKHR5cGVvZiBkZWZbdmFyaWFudFByb3BdLl9vcHRpb25zICE9PSAnc3RyaW5nJyAmJiBkZWZbdmFyaWFudFByb3BdLl93aWRnZXQgIT09ICdib29sZWFuJykpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCB2YXJpYW50IGRlY2xhcmF0aW9uXCIsIHZhcmlhbnRQcm9wLCBkZWZbdmFyaWFudFByb3BdKTtcbiAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgdmFyaWFudCBkZWNsYXJhdGlvbjogY2Fubm90IGZpbmQgcHJvcGVydHkgXCIgKyB2YXJpYW50UHJvcCArIFwiIG9yIGl0cyBfb3B0aW9ucyBzdHJpbmcgYW5kIGl0IGlzIG5vdCBhIGJvb2xlYW5cIjtcbiAgfVxuICAvLyBUT0RPIEkgcmVhZCB0aGUgXCJrZXlzXCIgYnV0IHRoaXMgaXMgbm90IDEwMCUgY29ycmVjdCBiZWNhdXNlIHRoZXkgYXJlIG5vdCBnYXJhbnRlZWQgdG8gYmUgc29ydGVkIGFzIGluIGRlY2xhcmF0aW9uXG4gIGlmICh0eXBlb2YgZGVmW3ZhcmlhbnRQcm9wXS5fb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIHZhcmlhbnRPcHRpb25zID0gT2JqZWN0LmtleXMoX2dldE9wdGlvbnNPYmplY3QoZGVmW3ZhcmlhbnRQcm9wXS5fb3B0aW9ucykpO1xuICB9IGVsc2Uge1xuICAgIHZhcmlhbnRPcHRpb25zID0gW3RydWUsIGZhbHNlXTtcbiAgfVxuICByZXR1cm4gdmFyaWFudE9wdGlvbnM7XG59O1xuXG52YXIgX21ha2VDb21wdXRlZEZ1bmN0aW9uID0gZnVuY3Rpb24oZGVmLCBkZWZzLCB0aG1zLCBrbywgY29udGVudE1vZGVsLCBpc0NvbnRlbnQsIHQpIHtcbiAgaWYgKHR5cGVvZiBkZWYgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodCkudHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBFUlJPUiBGb3VuZCBhIG5vbi10eXBlZCBkZWYgXCIsIGRlZiwgdCk7XG4gICAgICB0aHJvdyBcIkZvdW5kIGEgbm9uLXR5cGVkIGRlZiBcIiArIGRlZjtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodCkudHlwZSk7XG4gICAgZGVmID0gZGVmc1t0eXBlXTtcbiAgICBpZiAodHlwZW9mIGRlZiAhPT0gJ29iamVjdCcpIGNvbnNvbGUubG9nKFwiVE9ETyBFUlJPUiBGb3VuZCBhIG5vbi1vYmplY3QgZGVmIFwiLCBkZWYsIFwiZm9yXCIsIHR5cGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50TW9kZWwgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGlzQ29udGVudCAhPSAndW5kZWZpbmVkJyAmJiBpc0NvbnRlbnQpIHtcbiAgICBjb250ZW50TW9kZWwgPSB0O1xuICB9XG5cbiAgdmFyIHNlbGZQYXRoID0gJyRyb290LmNvbnRlbnQoKS4nO1xuXG4gIHZhciBwcCA9IGRlZi5fZ2xvYmFsU3R5bGVzO1xuICBpZiAodHlwZW9mIHBwICE9ICd1bmRlZmluZWQnKVxuICAgIGZvciAodmFyIHAgaW4gcHApXG4gICAgICBpZiAocHAuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgdmFyIHNjaGVtZVBhdGhPcmlnID0gJyRyb290LmNvbnRlbnQoKS50aGVtZSgpLnNjaGVtZSc7XG4gICAgICAgIHZhciBzY2hlbWVQYXRoLCB2bSwgcGF0aDtcblxuICAgICAgICBpZiAocHBbcF0uc3Vic3RyKDAsIHNlbGZQYXRoLmxlbmd0aCkgPT0gc2VsZlBhdGgpIHtcbiAgICAgICAgICBwYXRoID0gcHBbcF0uc3Vic3RyKHNlbGZQYXRoLmxlbmd0aCk7XG4gICAgICAgICAgdm0gPSBjb250ZW50TW9kZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJVTkVYUEVDVEVEIGdsb2JhbFN0eWxlIHBhdGggKFwiICsgcHBbcF0gKyBcIikgb3V0c2lkZSBzZWxmUGF0aCAoXCIgKyBzZWxmUGF0aCArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWVQYXRoT3JpZy5zdWJzdHIoMCwgc2VsZlBhdGgubGVuZ3RoKSA9PSBzZWxmUGF0aCkge1xuICAgICAgICAgIHNjaGVtZVBhdGggPSBzY2hlbWVQYXRoT3JpZy5zdWJzdHIoc2VsZlBhdGgubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIklTIFRISVMgQ09SUkVDVD9cIiwgc2NoZW1lUGF0aE9yaWcsIHNlbGZQYXRoKTtcbiAgICAgICAgICBzY2hlbWVQYXRoID0gc2NoZW1lUGF0aE9yaWc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NoZW1lU2VsZWN0b3IgPSB2bTtcblxuICAgICAgICB2YXIgcGF0aFBhcnRzID0gcGF0aC5zcGxpdCgnKCkuJyk7XG4gICAgICAgIHZhciB0aGVtZVBhdGggPSAnJztcbiAgICAgICAgdmFyIHNraXAgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZtID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2bSlbcGF0aFBhcnRzW2ldXTtcbiAgICAgICAgICAvLyB1Z2x5IHRoaW5nIHRvIGZpbmQgdGhlIHBhdGggdG8gdGhlIHNjaGVtYSBjb2xvciBwcm9wZXJ0eSAoc29tZXRpbWVzIHdlIGhhdmUgdGhlbWUuYm9keVRoZW1lLCBzb21lIG90aGVyIHdlIGhhdmUgY29udGVudC50aGVtZS5ib2R5VGhlbWUuLi4pXG4gICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgIGlmIChwYXRoUGFydHNbaV0gPT0gJ3RoZW1lJykgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhlbWVQYXRoLmxlbmd0aCA+IDApIHRoZW1lUGF0aCArPSAnLic7XG4gICAgICAgICAgICB0aGVtZVBhdGggKz0gcGF0aFBhcnRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2hlbWVQYXJ0cyA9IHNjaGVtZVBhdGguc3BsaXQoJygpLicpO1xuICAgICAgICBmb3IgKHZhciBpMyA9IDA7IGkzIDwgc2NoZW1lUGFydHMubGVuZ3RoOyBpMysrKSB7XG4gICAgICAgICAgc2NoZW1lU2VsZWN0b3IgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHNjaGVtZVNlbGVjdG9yKVtzY2hlbWVQYXJ0c1tpM11dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG51bGxJZkVxdWFsID0gdHJ1ZTtcbiAgICAgICAgdmFyIHRQYXJ0cyA9IHAuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHQ7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB0UGFydHMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgdGFyZ2V0ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0YXJnZXQpW3RQYXJ0c1tpMl1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrby5pc09ic2VydmFibGUodGFyZ2V0KSkgdGhyb3cgXCJVbmV4cGVjdGVkIG5vbiBvYnNlcnZhYmxlIHRhcmdldCBcIiArIHAgKyBcIi9cIiArIHRoZW1lUGF0aDtcblxuICAgICAgICB0YXJnZXQuX2RlZmF1bHRDb21wdXRlZCA9IF9tYWtlQ29tcHV0ZWQodGFyZ2V0LCB2bSwgbnVsbElmRXF1YWwsIHNjaGVtZVNlbGVjdG9yLCB0aGVtZVBhdGgsIHRobXMpO1xuICAgICAgfVxuXG4gIGlmICh0eXBlb2YgZGVmLl92YXJpYW50ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHBQYXJ0cyA9IGRlZi5fdmFyaWFudC5zcGxpdCgnLicpO1xuICAgIC8vIGxvb2tzIGluIHQgYW5kIG5vdCBjb250ZW50TW9kZWwgYmVjYXVzZSB2YXJpYW50cyBhcmUgZGVjbGFyZWQgb24gc2luZ2xlIGJsb2Nrcy5cbiAgICB2YXIgcFRhcmdldCA9IHQ7XG4gICAgdmFyIHBQYXJlbnQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHQpO1xuICAgIGZvciAodmFyIGk0ID0gMDsgaTQgPCBwUGFydHMubGVuZ3RoOyBpNCsrKSB7XG4gICAgICBwVGFyZ2V0ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShwVGFyZ2V0KVtwUGFydHNbaTRdXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwVGFyZ2V0Ll9kZWZhdWx0Q29tcHV0ZWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgdmFyaWFudCBvbiBhIHN0eWxlIHByb3BlcnR5OiBiZXdhcmUgdmFyaWFudHMgc2hvdWxkIGJlIG9ubHkgdXNlZCBvbiBjb250ZW50IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IG1hdGNoIHRoZSB0aGVtZSBmYWxsYmFjayBiZWhhdmlvdXJcIiwgZGVmLl92YXJpYW50KTtcbiAgICAgIHBUYXJnZXQgPSBwVGFyZ2V0Ll9kZWZhdWx0Q29tcHV0ZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcFRhcmdldCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5sb2coXCJFUlJPUiBsb29raW5nIGZvciB2YXJpYW50IHRhcmdldFwiLCBkZWYuX3ZhcmlhbnQsIHQpO1xuICAgICAgdGhyb3cgXCJFUlJPUiBsb29raW5nIGZvciB2YXJpYW50IHRhcmdldCBcIiArIGRlZi5fdmFyaWFudDtcbiAgICB9XG4gICAgcFBhcmVudC5fbmV4dFZhcmlhbnQgPSBfbmV4dFZhcmlhbnRGdW5jdGlvbi5iaW5kKHBUYXJnZXQsIGtvLCBwVGFyZ2V0LCBfZ2V0VmFyaWFudHMoZGVmKSk7XG4gIH1cblxuICBmb3IgKHZhciBwcm9wMiBpbiBkZWYpXG4gICAgaWYgKGRlZi5oYXNPd25Qcm9wZXJ0eShwcm9wMikpIHtcbiAgICAgIHZhciB2YWwgPSBkZWZbcHJvcDJdO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwuX2NvbnRleHQgIT0gJ3VuZGVmaW5lZCcgJiYgdmFsLl9jb250ZXh0ID09ICdibG9jaycpIHtcbiAgICAgICAgdmFyIHByb3BWbSA9IGNvbnRlbnRNb2RlbFtwcm9wMl0oKTtcbiAgICAgICAgdmFyIG5ld1ZtID0gX21ha2VDb21wdXRlZEZ1bmN0aW9uKGRlZnNbcHJvcDJdLCBkZWZzLCB0aG1zLCBrbywgY29udGVudE1vZGVsLCBpc0NvbnRlbnQsIHByb3BWbSk7XG4gICAgICAgIHRbcHJvcDJdKG5ld1ZtKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgdmFsLnR5cGUgPT0gJ2Jsb2NrcycpIHtcbiAgICAgICAgdmFyIG1haW5WbSA9IGNvbnRlbnRNb2RlbFtwcm9wMl0oKTtcbiAgICAgICAgdmFyIGJsb2Nrc1ZtID0gbWFpblZtLmJsb2NrcygpO1xuICAgICAgICB2YXIgb2xkQmxvY2ssIGJsb2NrVHlwZSwgbmV3QmxvY2s7XG4gICAgICAgIGZvciAodmFyIGliID0gMDsgaWIgPCBibG9ja3NWbS5sZW5ndGg7IGliKyspIHtcbiAgICAgICAgICBvbGRCbG9jayA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYmxvY2tzVm1baWJdKTtcbiAgICAgICAgICBibG9ja1R5cGUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKG9sZEJsb2NrLnR5cGUpO1xuICAgICAgICAgIG5ld0Jsb2NrID0gX21ha2VDb21wdXRlZEZ1bmN0aW9uKGRlZnNbYmxvY2tUeXBlXSwgZGVmcywgdGhtcywga28sIGNvbnRlbnRNb2RlbCwgaXNDb250ZW50LCBvbGRCbG9jayk7XG4gICAgICAgICAgYmxvY2tzVm1baWJdKG5ld0Jsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBibG9ja3NPYnMgPSBtYWluVm0uYmxvY2tzO1xuXG4gICAgICAgIF9hdWdtZW50QmxvY2tzT2JzZXJ2YWJsZShibG9ja3NPYnMsIF9ibG9ja0luc3RydW1lbnRGdW5jdGlvbi5iaW5kKG1haW5WbSwgdW5kZWZpbmVkLCBkZWZzLCB0aG1zLCBrbywgdW5kZWZpbmVkLCBjb250ZW50TW9kZWwsIGlzQ29udGVudCkpO1xuXG4gICAgICAgIGNvbnRlbnRNb2RlbFtwcm9wMl0uX3dyYXAgPSBfbWFrZUJsb2Nrc1dyYXAuYmluZChjb250ZW50TW9kZWxbcHJvcDJdLCBibG9ja3NPYnMuX2luc3RydW1lbnRCbG9jayk7XG4gICAgICAgIGNvbnRlbnRNb2RlbFtwcm9wMl0uX3Vud3JhcCA9IF91bndyYXAuYmluZChjb250ZW50TW9kZWxbcHJvcDJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIHQ7XG59O1xuXG52YXIgX2F1Z21lbnRCbG9ja3NPYnNlcnZhYmxlID0gZnVuY3Rpb24oYmxvY2tzT2JzLCBpbnN0cnVtZW50KSB7XG4gIGJsb2Nrc09icy5faW5zdHJ1bWVudEJsb2NrID0gaW5zdHJ1bWVudDtcbiAgaWYgKHR5cGVvZiBibG9ja3NPYnMub3JpZ1B1c2ggPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBibG9ja3NPYnMub3JpZ1B1c2ggPSBibG9ja3NPYnMucHVzaDtcbiAgICBibG9ja3NPYnMucHVzaCA9IF9tYWtlUHVzaC5iaW5kKGJsb2Nrc09icyk7XG4gICAgYmxvY2tzT2JzLm9yaWdTcGxpY2UgPSBibG9ja3NPYnMuc3BsaWNlO1xuICAgIGJsb2Nrc09icy5zcGxpY2UgPSBfbWFrZVNwbGljZS5iaW5kKGJsb2Nrc09icyk7XG4gIH1cbn07XG5cbnZhciBfbWFrZUJsb2Nrc1dyYXAgPSBmdW5jdGlvbihpbnN0cnVtZW50LCBpbnB1dE1vZGVsKSB7XG4gIHZhciBtb2RlbCA9IGtvLnRvSlMoaW5wdXRNb2RlbCk7XG4gIHZhciBpbnB1dCA9IG1vZGVsLmJsb2NrcztcbiAgbW9kZWwuYmxvY2tzID0gW107XG4gIHZhciByZXMgPSBrb3dyYXAuZnJvbUpTKG1vZGVsLCB1bmRlZmluZWQsIHRydWUpKCk7XG4gIF9hdWdtZW50QmxvY2tzT2JzZXJ2YWJsZShyZXMuYmxvY2tzLCBpbnN0cnVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvYmogPSBrby50b0pTKGlucHV0W2ldKTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIl9tYWtlQmxvY2tzV3JhcCBzZXQgYmxvY2tJZFwiLCBvYmouaWQsICdibG9ja18nK2kpO1xuICAgIG9iai5pZCA9ICdibG9ja18nICsgaTtcbiAgICByZXMuYmxvY2tzLnB1c2gob2JqKTtcbiAgfVxuICB0aGlzKHJlcyk7XG59O1xuXG52YXIgX21ha2VQdXNoID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgdGhyb3cgXCJBcnJheSBwdXNoIHdpdGggbXVsdGlwbGUgYXJndW1lbnRzIG5vdCBpbXBsZW1lbnRlZFwiO1xuICAvLyB1bndyYXAgb2JzZXJ2YWJsZSBibG9ja3MsIG90aGVyd2lzZSB2aXNpYmlsaXR5IChkZXBlbmRlbmN5KSBoYW5kbGluZyBicmVha3NcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGtvLmlzT2JzZXJ2YWJsZShhcmd1bWVudHNbMF0pKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0uX3Vud3JhcCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF0uX3Vud3JhcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldBUk46IHB1c2hpbmcgb2JzZXJ2YWJsZSB3aXRoIG5vIF91bndyYXAgZnVuY3Rpb24gKFRPRE8gcmVtb3ZlIG1lLCBleHBlY3RlZCBjb25kaXRpb24pXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoIWtvLmlzT2JzZXJ2YWJsZShhcmd1bWVudHNbMF0pKSB7XG4gICAgdmFyIGluc3RydW1lbnRlZCA9IHRoaXMuX2luc3RydW1lbnRCbG9jayhhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiB0aGlzLm9yaWdQdXNoLmFwcGx5KHRoaXMsIFtpbnN0cnVtZW50ZWRdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnUHVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG52YXIgX21ha2VTcGxpY2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB0aHJvdyBcIkFycmF5IHNwbGljZSB3aXRoIG11bHRpcGxlIG9iamVjdHMgbm90IGltcGxlbWVudGVkXCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBrby5pc09ic2VydmFibGUoYXJndW1lbnRzWzJdKSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdLl91bndyYXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJndW1lbnRzWzJdID0gYXJndW1lbnRzWzJdLl91bndyYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBzcGxpY2luZyBvYnNlcnZhYmxlIHdpdGggbm8gX3Vud3JhcCBmdW5jdGlvbiAoVE9ETyByZW1vdmUgbWUsIGV4cGVjdGVkIGNvbmRpdGlvbilcIik7XG4gICAgfVxuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiAha28uaXNPYnNlcnZhYmxlKGFyZ3VtZW50c1syXSkpIHtcbiAgICB2YXIgaW5zdHJ1bWVudGVkID0gdGhpcy5faW5zdHJ1bWVudEJsb2NrKGFyZ3VtZW50c1syXSk7XG4gICAgcmV0dXJuIHRoaXMub3JpZ1NwbGljZS5hcHBseSh0aGlzLCBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGluc3RydW1lbnRlZF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm9yaWdTcGxpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLy8gZGVmLCBkZWZzIGFuZCB0aGVtZXMgYXJlIGJvdW5kIGluIFwiX21vZGVsSW5zdHJ1bWVudFwiIHdoaWxlIHRoZSBuZXh0IHBhcmFtZXRlcnMgYXJlIGV4cG9zZWQgYnkgdGhpcyBtb2R1bGVcbnZhciBfYmxvY2tJbnN0cnVtZW50RnVuY3Rpb24gPSBmdW5jdGlvbihkZWYsIGRlZnMsIHRoZW1lcywga25vY2tvdXQsIHNlbGYsIG1vZGVsQ29udGVudCwgaXNDb250ZW50LCBzZWxmMikge1xuICAvLyB1Z2x5OiBzb21ldGltZXMgd2UgaGF2ZSB0byBiaW5kIGNvbnRlbnQgYnV0IG5vdCBzZWxmLCBzbyB3ZSByZXBlYXQgc2VsZiBhdCB0aGUgZW5kIGFzIFwic2VsZjJcIlxuICBpZiAodHlwZW9mIHNlbGYgPT0gJ3VuZGVmaW5lZCcpIHNlbGYgPSBzZWxmMjtcblxuICB2YXIgY29tcHV0ZWRGdW5jdGlvbnM7XG4gIGNvbXB1dGVkRnVuY3Rpb25zID0ge1xuICAgICcnOiBfbWFrZUNvbXB1dGVkRnVuY3Rpb24uYmluZChzZWxmLCBkZWYsIGRlZnMsIHRoZW1lcywga25vY2tvdXQsIG1vZGVsQ29udGVudCwgaXNDb250ZW50KVxuICB9O1xuXG4gIHZhciByZXMgPSBrb3dyYXAuZnJvbUpTKHNlbGYsIGNvbXB1dGVkRnVuY3Rpb25zLCB0cnVlKTtcbiAgcmVzLl91bndyYXAgPSBfdW53cmFwLmJpbmQocmVzKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBfd3JhcCA9IGZ1bmN0aW9uKGluc3RydW1lbnQsIHVud3JhcHBlZCkge1xuICB2YXIgbmV3Q29udGVudCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoaW5zdHJ1bWVudChrbywgdW53cmFwcGVkLCB1bmRlZmluZWQsIHRydWUpKTtcbiAgdGhpcyhuZXdDb250ZW50KTtcbn07XG5cbnZhciBfdW53cmFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBrby50b0pTKHRoaXMpO1xufTtcblxudmFyIF9tb2RlbEluc3RydW1lbnQgPSBmdW5jdGlvbihtb2RlbCwgbW9kZWxEZWYsIGRlZnMpIHtcbiAgdmFyIF9pbnN0cnVtZW50ID0gX2Jsb2NrSW5zdHJ1bWVudEZ1bmN0aW9uLmJpbmQodW5kZWZpbmVkLCBtb2RlbERlZiwgZGVmcywgZGVmc1sndGhlbWVzJ10pO1xuICB2YXIgcmVzID0gX2luc3RydW1lbnQoa28sIG1vZGVsLCB1bmRlZmluZWQsIHRydWUpO1xuICAvLyByZXMuX2luc3RydW1lbnQgPSBfaW5zdHJ1bWVudDtcbiAgcmVzLl93cmFwID0gX3dyYXAuYmluZChyZXMsIF9pbnN0cnVtZW50KTtcbiAgcmVzLl91bndyYXAgPSBfdW53cmFwLmJpbmQocmVzKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gX21vZGVsSW5zdHJ1bWVudDsiLCJ2YXIgdGlueWNvbG9yID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy90aW55Y29sb3IvdGlueWNvbG9yLmpzXCIpO1xuXG5mdW5jdGlvbiBDb2xvcih0aW55Y29sb3IpIHtcbiAgdGhpcy5nZXRCcmlnaHRuZXNzID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5nZXRCcmlnaHRuZXNzKCk7XG4gIH07XG4gIHRoaXMuaXNMaWdodCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuaXNMaWdodCgpO1xuICB9O1xuICB0aGlzLmlzRGFyayA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuaXNEYXJrKCk7XG4gIH07XG4gIHRoaXMuZ2V0THVtaW5hbmNlID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5nZXRMdW1pbmFuY2UoKTtcbiAgfTtcblxuXG4gIHRoaXMubGlnaHRlbiA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5saWdodGVuKGFtb3VudCkudG9IZXhTdHJpbmcoKTtcbiAgfTtcbiAgdGhpcy5icmlnaHRlbiA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5icmlnaHRlbihhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuZGFya2VuID0gZnVuY3Rpb24oY29sb3IsIGFtb3VudCkge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmRhcmtlbihhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5kZXNhdHVyYXRlKGFtb3VudCkudG9IZXhTdHJpbmcoKTtcbiAgfTtcbiAgdGhpcy5zYXR1cmF0ZSA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5zYXR1cmF0ZShhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuZ3JleXNjYWxlID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5ncmV5c2NhbGUoKS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLnNwaW4gPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuc3BpbihhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuY29tcGxlbWVudCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuY29tcGxlbWVudCgpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG5cbiAgdGhpcy5taXggPSB0aW55Y29sb3IubWl4O1xuICB0aGlzLnJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5O1xuICB0aGlzLmlzUmVhZGFibGUgPSB0aW55Y29sb3IuaXNSZWFkYWJsZTtcbiAgdGhpcy5tb3N0UmVhZGFibGUgPSB0aW55Y29sb3IubW9zdFJlYWRhYmxlO1xufVxuXG52YXIgY29sb3JQbHVnaW4gPSBmdW5jdGlvbih2bSkge1xuICBnbG9iYWwuQ29sb3IgPSBuZXcgQ29sb3IodGlueWNvbG9yKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29sb3JQbHVnaW47IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciAkICAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKVxudmFyIGtvICAgICAgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKVxudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKVxuXG5mdW5jdGlvbiBoYW5kbGVNYWlsaW5nTmFtZSh2aWV3TW9kZWwpIHtcbiAgdmFyIG9yaWdpbmFsVmFsdWVcbiAgdmlld01vZGVsLnRpdGxlTW9kZSAgICAgICAgID0ga28ub2JzZXJ2YWJsZSgnc2hvdycpXG4gIHZpZXdNb2RlbC5tZXRhZGF0YS5uYW1lICAgICA9IGtvLm9ic2VydmFibGUodmlld01vZGVsLm1ldGFkYXRhLm5hbWUpXG5cbiAgdmlld01vZGVsLm1haWxpbmdOYW1lICAgICAgID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZpZXdNb2RlbC5tZXRhZGF0YS5uYW1lKClcbiAgfSwgdmlld01vZGVsKVxuXG4gIHZpZXdNb2RlbC5lbmFibGVFZGl0TWFpbGluZ05hbWUgID0gZnVuY3Rpb24gKGRhdGEsIGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coJ2VuYWJsZUVkaXRNYWlsaW5nTmFtZScsIGRhdGEpXG4gICAgb3JpZ2luYWxWYWx1ZSA9IHZpZXdNb2RlbC5tZXRhZGF0YS5uYW1lKClcbiAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdlZGl0JylcbiAgfVxuXG4gIHZpZXdNb2RlbC5jYW5jZWxFZGl0TWFpbGluZ05hbWUgID0gZnVuY3Rpb24gKGRhdGEsIGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coJ2NhbmNlbEVkaXRNYWlsaW5nTmFtZScpXG4gICAgdmlld01vZGVsLm1ldGFkYXRhLm5hbWUob3JpZ2luYWxWYWx1ZSlcbiAgICBvcmlnaW5hbFZhbHVlID0gJydcbiAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdzaG93JylcbiAgfVxuXG4gIHZpZXdNb2RlbC5zYXZlRWRpdE1haWxpbmdOYW1lICA9IGZ1bmN0aW9uIChkYXRhLCBldmVudCkge1xuICAgIGNvbnNvbGUubG9nKCdzYXZlRWRpdE1haWxpbmdOYW1lJywgdmlld01vZGVsLm1ldGFkYXRhLm5hbWUoKSlcbiAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdzYXZpbmcnKVxuICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KCdlZGl0LXRpdGxlLWFqYXgtcGVuZGluZycpKVxuXG4gICAgJC5hamF4KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAgICB2aWV3TW9kZWwubWV0YWRhdGEudXJsLnVwZGF0ZSxcbiAgICAgIGRhdGE6ICAge1xuICAgICAgICBuYW1lOiB2aWV3TW9kZWwubWV0YWRhdGEubmFtZSgpLFxuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChtb3NhaWNvTWFpbGluZykge1xuICAgICAgICB2aWV3TW9kZWwubWV0YWRhdGEubmFtZSggbW9zYWljb01haWxpbmcubWV0YS5uYW1lIClcbiAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLnN1Y2Nlc3Modmlld01vZGVsLnQoJ2VkaXQtdGl0bGUtYWpheC1zdWNjZXNzJykpXG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdlZGl0LXRpdGxlLWFqYXgtZmFpbCcpKVxuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9yaWdpbmFsVmFsdWUgPSAnJ1xuICAgICAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdzaG93JylcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZU1haWxpbmdOYW1lXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGtvICAgICAgICAgICAgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKVxudmFyIHVybCAgICAgICAgICAgPSByZXF1aXJlKCd1cmwnKVxudmFyIHNsdWdGaWxlbmFtZSAgPSByZXF1aXJlKCcuLi8uLi8uLi9zaGFyZWQvc2x1Zy1maWxlbmFtZS5qcycpXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS92b2lkbGFicy9tb3NhaWNvL3dpa2kvTW9zYWljby1QbHVnaW5zXG5cbi8vLy8vL1xuLy8gVklFVy1NT0RFTCBQTFVHSU5TXG4vLy8vLy9cblxuY29uc3Qgc2VydmVyU3RvcmFnZSA9IHJlcXVpcmUoJy4vY3VzdG9tLXNlcnZlci1zdG9yYWdlJylcbmNvbnN0IGVkaXRUaXRsZSAgICAgPSByZXF1aXJlKCcuL2N1c3RvbS1lZGl0LXRpdGxlJylcbmxldCAgIHRleHRFZGl0b3IgICAgPSByZXF1aXJlKCcuL2N1c3RvbS10ZXh0LWVkaXRvcicpXG5jb25zdCBnYWxsZXJ5ICAgICAgID0gcmVxdWlyZSgnLi9jdXN0b20tZ2FsbGVyeScpXG5jb25zdCByZW1vdmVJbWFnZSAgID0gcmVxdWlyZSgnLi9jdXN0b20tcmVtb3ZlLWdhbGxlcnktaW1hZ2UnKVxuLy8gd2lkZ2V0c1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZvaWRsYWJzL21vc2FpY28vd2lraS9Nb3NhaWNvLVBsdWdpbnMjd2lkZ2V0LXBsdWdpbnNcbmNvbnN0IHdpZGdldEJnaW1hZ2UgPSByZXF1aXJlKCcuL2N1c3RvbS13aWRnZXQtYmdpbWFnZScpXG5cblxuY29uc3Qgc2V0RWRpdG9ySWNvbiA9IG9wdHMgPT4gdmlld01vZGVsID0+IHtcbiAgdmlld01vZGVsLmxvZ29QYXRoICA9IGZhbHNlXG4gIHZpZXdNb2RlbC5sb2dvVXJsICAgPSBmYWxzZVxuICB2aWV3TW9kZWwubG9nb0FsdCAgID0gZmFsc2VcbiAgdmlld01vZGVsLmJyYW5kTmFtZSA9IG9wdHMuYnJhbmROYW1lXG59XG5cbmZ1bmN0aW9uIGV4dGVuZFZpZXdNb2RlbChvcHRzLCBjdXN0b21FeHRlbnNpb25zKSB7XG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaCggc2VydmVyU3RvcmFnZSApXG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaCggc2V0RWRpdG9ySWNvbihvcHRzKSApXG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaCggZWRpdFRpdGxlIClcbiAgY3VzdG9tRXh0ZW5zaW9ucy5wdXNoKCBnYWxsZXJ5KG9wdHMpIClcbiAgY3VzdG9tRXh0ZW5zaW9ucy5wdXNoKCByZW1vdmVJbWFnZSApXG4gIC8vIHdpZGdldCBzaG91bGQgYmUgZGlmZmVyZW5jaWF0aW5nIG9mIFZNIGV4dGVudGlvbnMgYnlcbiAgLy8gdGVtcGxhdGUtbG9hZGVyLmpzI3BsdWdpbnNDYWxsXG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaCggd2lkZ2V0QmdpbWFnZShvcHRzKSApXG59XG5cbi8vLy8vL1xuLy8gS05PQ0tPVVQgRVhURU5EXG4vLy8vLy9cblxuZnVuY3Rpb24gdGVtcGxhdGVVcmxDb252ZXJ0ZXIob3B0cykge1xuICB2YXIgYXNzZXRzID0gb3B0cy5tZXRhZGF0YS5hc3NldHMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIGN1c3RvbVRlbXBsYXRlVXJsQ29udmVydGVyKHVybCkge1xuICAgIGlmICghdXJsKSByZXR1cm4gbnVsbFxuICAgICAgY29uc29sZS5sb2coJ2N1c3RvbVRlbXBsYXRlVXJsQ29udmVydGVyJywgdXJsKVxuICAgIC8vIGhhbmRsZTogW3Vuc3Vic2NyaWJlX2xpbmtdIG9yIG1haWx0bzpbbWFpbF1cbiAgICBpZiAoL1xcXSQvLnRlc3QodXJsKSkgcmV0dXJuIG51bGxcbiAgICAvLyBoYW5kbGUgYWJzb2x1dGUgdXJsOiBodHRwXG4gICAgaWYgKC9eaHR0cC8udGVzdCh1cmwpKSByZXR1cm4gbnVsbFxuICAgIC8vIGhhbmRsZSBFU1AgdGFnczogaW4gVVJMIDwlXG4gICAgaWYgKC88JS8udGVzdCh1cmwpKSByZXR1cm4gbnVsbFxuICAgIC8vIGhhbmRsZSBvdGhlciB1cmxzOiBpbWcvc29jaWFsX2RlZi90d2l0dGVyX29rLnBuZ1xuICAgIHZhciB1cmxSZWdleHAgICAgICAgPSAvKFteXFwvXSopJC9cbiAgICB2YXIgZXh0ZW50aW9uUmVnZXhwID0gL1xcLlswLTlhLXpdKyQvXG4gICAgLy8gYXMgaXQgaXMgZG9uZSwgYWxsIGZpbGVzIGFyZSBmbGF0dGVuIGluIGFzc2V0IGZvbGRlciAodXBsb2FkcyBvciBTMylcbiAgICB1cmwgPSB1cmxSZWdleHAuZXhlYyh1cmwpWzFdXG4gICAgLy8gaGFuZGxlIGV2ZXJ5IG90aGVyIGNhc2U6XG4gICAgLy8gICAqfFVOU1VCfCpcbiAgICAvLyAgICNwb3VpY1xuICAgIGlmICghZXh0ZW50aW9uUmVnZXhwLnRlc3QodXJsKSkgcmV0dXJuIG51bGxcbiAgICBjb25zb2xlLmxvZygnY3VzdG9tVGVtcGxhdGVVcmxDb252ZXJ0ZXInLCB1cmwpXG4gICAgLy8gQWxsIGltYWdlcyBhdCB1cGxvYWRlZCBhcmUgcmVuYW1lZCB3aXRoIG1kNVxuICAgIC8vICAgIGJsb2NrIHRodW1ibmFpbHMgYXJlIGJhc2VkIG9uIGh0bWwgYmxvY2sgSURcbiAgICAvLyAgICA9PiB3ZSBuZWVkIHRvIG1haW50YWluIGEgZGljdGlvbmFyeSBvZiBuYW1lIC0+IG1kNSBuYW1lXG4gICAgLy8gICAgaGVyZSBjb21lIHRoZSBhc3NldHMgYmxvY2tcbiAgICAvLyB3ZSBzdGlsbCBrZWVwIHRoZSBzbHVnIHBhcnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVhc29uIHdpdGggb2xkIGltYWdlIG5hbWUgY29udmVudGlvbnNcbiAgICB1cmwgPSBzbHVnRmlsZW5hbWUoIHVybCApXG4gICAgdXJsID0gYXNzZXRzWyB1cmwgXSA/IG9wdHMuaW1nUHJvY2Vzc29yQmFja2VuZCArIGFzc2V0c1sgdXJsIF0gOiBudWxsXG4gICAgcmV0dXJuIHVybFxuICB9XG59XG5cbi8vIGtub2Nrb3V0IGlzIGEgZ2xvYmFsIG9iamVjdC5cbi8vIFNvIHdlIGNhbiBleHRlbmQgaXQgZWFzaWx5XG5cbi8vIHRoaXMgZXF1aXZhbGVudCB0byB0aGUgb3JpZ2luYWwgYXBwLmpzI2FwcGx5QmluZGluZ09wdGlvbnNcbmZ1bmN0aW9uIGV4dGVuZEtub2Nrb3V0KG9wdHMpIHtcblxuICAvLy0tLS0tIFRJTllNQ0VcblxuICAvLyBDaGFuZ2UgdGlueU1DRSBmdWxsIGVkaXRvciBvcHRpb25zXG4gIGlmIChvcHRzLmxhbmcgPT09ICdmcicpIHtcbiAgICB0ZXh0RWRpdG9yLmxhbmd1YWdlX3VybCA9ICcvdGlueW1jZS1sYW5ncy9mcl9GUi5qcydcbiAgICB0ZXh0RWRpdG9yLmxhbmd1YWdlICAgICA9ICdmcl9GUidcbiAgICB0aW55bWNlLnV0aWwuSTE4bi5hZGQoJ2ZyX0ZSJywge1xuICAgICAgJ0NhbmNlbCc6ICdBbm51bGVyJyxcbiAgICAgICdpbiBwaXhlbCc6ICdlbiBwaXhlbCcsXG4gICAgICAnRW50ZXIgYSBmb250LXNpemUnOiAnRW50cmV6IHVuZSB0YWlsbGUgZGUgcG9saWNlJyxcbiAgICAgICdMZXR0ZXIgc3BhY2luZyc6ICdJbnRlcmxldHRyYWdlJyxcbiAgICAgICdGb250IHNpemUnOiAnVGFpbGxlIGRlIHBvbGljZScsXG4gICAgICAnRm9udCBzaXplOiAnOiAnVGFpbGxlIDogJyxcbiAgICAgICdtaW5pbXVtIHNpemU6IDhweCc6ICd0YWlsbGUgbWluaW11bSA6IDhweCcsXG4gICAgICAnbm8gZGVjaW1hbHMnOiAncGFzIGRlIGTDqWNpbWFsZXMnLFxuICAgIH0gKVxuICB9XG4gIC8vLSBodHRwczovL3d3dy50aW55bWNlLmNvbS9kb2NzL2NvbmZpZ3VyZS91cmwtaGFuZGxpbmcvI2NvbnZlcnRfdXJsc1xuICB0ZXh0RWRpdG9yID0gJC5leHRlbmQoIHtjb252ZXJ0X3VybHM6IGZhbHNlfSwgdGV4dEVkaXRvciwgb3B0cy50aW55bWNlIClcbiAga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuZnVsbE9wdGlvbnMgPSB0ZXh0RWRpdG9yXG5cbiAgLy8gbWlycm9yIG9wdGlvbnMgdG8gdGhlIHNtYWxsIHZlcnNpb24gb2YgdGlueW1jZVxuICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5zdGFuZGFyZE9wdGlvbnMgPSB7XG4gICAgY29udmVydF91cmxzOiBmYWxzZSxcbiAgICBleHRlcm5hbF9wbHVnaW5zOiB7XG4gICAgICBwYXN0ZTogdGV4dEVkaXRvci5leHRlcm5hbF9wbHVnaW5zLnBhc3RlLFxuICAgIH0sXG4gICAgdGhlbWVfdXJsOiAgdGV4dEVkaXRvci50aGVtZV91cmwsXG4gICAgc2tpbl91cmw6ICAgdGV4dEVkaXRvci5za2luX3VybCxcbiAgfVxuXG4gIC8vLS0tLS0gVVJMUyBIQU5ETElOR1xuXG4gIC8vIFRoaXMgaXMgbm90IHVzZWQgYnkga25vY2tvdXQgcGVyIHNlLlxuICAvLyBTdG9yZSB0aGlzIGZ1bmN0aW9uIGluIEtPIGdsb2JhbCBvYmplY3Qgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRlbXBsYXRlLWxvYWRlci5qcyN0ZW1wbGF0ZUxvYWRlclxuICAvLyBjdXN0b21UZW1wbGF0ZVVybENvbnZlcnRlciBpcyB1c2VkOlxuICAvLyAgLSBmb3IgcHJldmlldyBpbWFnZXMgb24gbGVmdCBiYXJcbiAgLy8gIC0gZm9yIHN0YXRpYyBsaW5rcyBpbiB0ZW1wbGF0ZXNcbiAga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMudGVtcGxhdGVVcmxDb252ZXJ0ZXIgPSB0ZW1wbGF0ZVVybENvbnZlcnRlcihvcHRzKVxuXG4gIC8vIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCBpbiB0aGUgZWRpdG9yIHRlbXBsYXRlXG4gIHZhciBpbWdQcm9jZXNzb3JCYWNrZW5kID0gdXJsLnBhcnNlKCBvcHRzLmltZ1Byb2Nlc3NvckJhY2tlbmQgKVxuXG4gIC8vIHNlbmQgdGhlIG5vbi1yZXNpemVkIGltYWdlIHVybFxuICBrby5iaW5kaW5nSGFuZGxlcnMuZmlsZXVwbG9hZC5yZW1vdGVGaWxlUHJlcHJvY2Vzc29yID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBjb25zb2xlLmluZm8oJ1JFTU9URSBGSUxFIFBSRVBST0NFU1NPUicpXG4gICAgY29uc29sZS5sb2coZmlsZSlcbiAgICB2YXIgZmlsZVVybCA9IHVybC5mb3JtYXQoe1xuICAgICAgcHJvdG9jb2w6IGltZ1Byb2Nlc3NvckJhY2tlbmQucHJvdG9jb2wsXG4gICAgICBob3N0OiAgICAgaW1nUHJvY2Vzc29yQmFja2VuZC5ob3N0LFxuICAgICAgcGF0aG5hbWU6IGltZ1Byb2Nlc3NvckJhY2tlbmQucGF0aG5hbWUsXG4gICAgfSk7XG4gICAgZmlsZS51cmwgPSB1cmwucmVzb2x2ZShmaWxlVXJsLCB1cmwucGFyc2UoZmlsZS51cmwpLnBhdGhuYW1lKVxuICAgIHJldHVybiBmaWxlXG4gIH1cblxuICAvLyBwdXNoIFwiY29udmVydGVkVXJsXCIgbWV0aG9kIHRvIHRoZSB3eXNpd3lnU3JjIGJpbmRpbmdcbiAga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMuY29udmVydGVkVXJsID0gZnVuY3Rpb24oc3JjLCBtZXRob2QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaW1hZ2VOYW1lID0gdXJsLnBhcnNlKHNyYykucGF0aG5hbWVcbiAgICBpZiAoIWltYWdlTmFtZSkgY29uc29sZS53YXJuKCdubyBwYXRobmFtZSBmb3IgaW1hZ2UnLCBzcmMpXG4gICAgY29uc29sZS5pbmZvKCdDT05WRVJURUQgVVJMJywgaW1hZ2VOYW1lLCBtZXRob2QsIHdpZHRoLCBoZWlnaHQpXG4gICAgaW1hZ2VOYW1lICAgICA9IGltYWdlTmFtZS5yZXBsYWNlKCcvaW1nLycsICcnKVxuICAgIHZhciBwYXRoICAgICAgPSBvcHRzLmJhc2VQYXRoICsgJy8nICsgbWV0aG9kXG4gICAgcGF0aCAgICAgICAgICA9IHBhdGggKyAnLycgKyB3aWR0aCArICd4JyArIGhlaWdodCArICcvJyArIGltYWdlTmFtZVxuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYy5wbGFjZWhvbGRlclVybCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHRleHQpIHtcbiAgICAvLyBjb25zb2xlLmluZm8oJ1BMQUNFSE9MREVSIFVSTCcsIHdpZHRoLCBoZWlnaHQsIHRleHQpXG4gICAgcmV0dXJuIG9wdHMuYmFzZVBhdGggKyAnL3BsYWNlaG9sZGVyLycgKyB3aWR0aCArICd4JyArIGhlaWdodCArICcucG5nJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHRlbmRWaWV3TW9kZWwsXG4gIGV4dGVuZEtub2Nrb3V0LFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIilcbnZhciAkICAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKVxudmFyIGtvICAgICAgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKVxudmFyIF9maW5kICAgPSByZXF1aXJlKCdsb2Rhc2guZmluZCcpXG5cbmZ1bmN0aW9uIGdhbGxlcnlMb2FkZXIoIG9wdHMgKSB7XG5cbiAgdmFyIGdhbGxlcnlVcmwgPSBvcHRzLmZpbGV1cGxvYWRDb25maWcudXJsXG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3TW9kZWwpIHtcblxuICAgIHZpZXdNb2RlbC5tYWlsaW5nR2FsbGVyeSAgICAgICAgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pXG4gICAgdmlld01vZGVsLnRlbXBsYXRlR2FsbGVyeSAgICAgICA9IGtvLm9ic2VydmFibGVBcnJheShbXSlcbiAgICB2aWV3TW9kZWwubWFpbGluZ0dhbGxlcnlTdGF0dXMgID0ga28ub2JzZXJ2YWJsZShmYWxzZSlcbiAgICB2aWV3TW9kZWwudGVtcGxhdGVHYWxsZXJ5U3RhdHVzID0ga28ub2JzZXJ2YWJsZShmYWxzZSlcblxuICAgIGZ1bmN0aW9uIGxvYWRHYWxsZXJ5KCB0eXBlICkge1xuICAgICAgdmFyIHVybCAgICAgID0gZ2FsbGVyeVVybFsgdHlwZSBdXG4gICAgICB2YXIgZ2FsbGVyeSAgPSB2aWV3TW9kZWxbIHR5cGUgKyAnR2FsbGVyeScgXVxuICAgICAgdmFyIHN0YXR1cyAgID0gdmlld01vZGVsWyB0eXBlICsgJ0dhbGxlcnlTdGF0dXMnIF1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RhdHVzKCdsb2FkaW5nJylcbiAgICAgICAgLy8gcmV0cmlldmUgdGhlIGZ1bGwgbGlzdCBvZiByZW1vdGUgZmlsZXNcbiAgICAgICAgJC5nZXRKU09OKHVybCwgZnVuY3Rpb24gKCBkYXRhICkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5maWxlcy5sZW5ndGg7IGkrKykgZGF0YS5maWxlc1tpXSA9IHZpZXdNb2RlbC5yZW1vdGVGaWxlUHJvY2Vzc29yKGRhdGEuZmlsZXNbaV0pXG4gICAgICAgICAgc3RhdHVzKCBkYXRhLmZpbGVzLmxlbmd0aCApXG4gICAgICAgICAgZ2FsbGVyeSggZGF0YS5maWxlcy5yZXZlcnNlKCkgKVxuICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0YXR1cyggZmFsc2UgKVxuICAgICAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5lcnJvcih2aWV3TW9kZWwudCgnVW5leHBlY3RlZCBlcnJvciBsaXN0aW5nIGZpbGVzJykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgdXNlZCBhcyBhIHBhcmFtYXRlciBpbiBmaWxldXBsb2FkIGJpbmRpbmdcbiAgICAvLyBzZWUgdG9vbGJveC50bXBsLmh0bWwgYCN0b29saW1hZ2VzZ2FsbGVyeSBmaWxldXBsb2FkYFxuICAgIC8vIGZpbGV1cGxvYWQgYmluZGluZyB3aWxsIGl0ZXJhdGUgb24gZXZlcnkgdXBsb2FkZWQgZmlsZSBhbmQgY2FsbCB0aGlzIGNhbGxiYWNrXG4gICAgLy8gZmlsZXVwbG9hZC5qcyA9PiBlLnR5cGUgPT0gJ2ZpbGV1cGxvYWRkb25lJyBmb3IgbW9yZSBkZXRhaWxzXG4gICAgZnVuY3Rpb24gbG9hZEltYWdlKCB0eXBlICkge1xuICAgICAgdmFyIGdhbGxlcnkgID0gdmlld01vZGVsWyB0eXBlICsgJ0dhbGxlcnknIF1cbiAgICAgIHZhciBzdGF0dXMgICA9IHZpZXdNb2RlbFsgdHlwZSArICdHYWxsZXJ5U3RhdHVzJyBdXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCBpbWcgKSB7XG4gICAgICAgIHZhciBpbWFnZU5hbWUgICAgICAgICA9IGltZy5uYW1lXG4gICAgICAgIC8vIGNhbGwgZ2FsbGVyeSgpLCBiZWNhdXNlIGl0IGlzIGEga25vY2tvdXQgb2JzZXJ2YWJsZSBhbmQgbm90IGEgcmVhbCBhcnJheVxuICAgICAgICAvLyBEb24ndCBzaG93IHR3aWNlIHRoZSBzYW1lIGltYWdlXG4gICAgICAgIHZhciBpc0FscmVhZHlVcGxvYWRlZCA9IF9maW5kKCBnYWxsZXJ5KCksIGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUgPT09IGltYWdlTmFtZVxuICAgICAgICB9KVxuICAgICAgICBpZiAoIGlzQWxyZWFkeVVwbG9hZGVkICkgcmV0dXJuXG4gICAgICAgIC8vIERvbid0IHVwZGF0ZSB0aGUgZ2FsbGVyeSB1bnRpbCBpdCBoYXMgYmVlbiBvcGVuZWQgb25jZVxuICAgICAgICAvLyBUaGlzIHdhcyBsZWFkaW5nIHRvIHByZXZlbnRpbmcgdGhlIHdob2xlIGdhbGxlcnkgdG8gYmUgZmV0Y2hlZOKAplxuICAgICAgICAvLyDigKZpZiB3ZSBoYWQgdXBsb2FkZWQgYW4gaW1hZ2UgaW4gdGhlIGVkaXRvclxuICAgICAgICBpZiAoIHN0YXR1cygpID09PSBmYWxzZSApIHJldHVyblxuICAgICAgICBnYWxsZXJ5LnVuc2hpZnQoIGltZyApXG4gICAgICAgIHN0YXR1cyggZ2FsbGVyeSgpLmxlbmd0aCApXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlld01vZGVsLmxvYWRNYWlsaW5nR2FsbGVyeSAgICA9IGxvYWRHYWxsZXJ5KCAnbWFpbGluZycgKVxuICAgIHZpZXdNb2RlbC5sb2FkVGVtcGxhdGVHYWxsZXJ5ICAgPSBsb2FkR2FsbGVyeSggJ3RlbXBsYXRlJyApXG4gICAgdmlld01vZGVsLmxvYWRNYWlsaW5nSW1hZ2UgICAgICA9IGxvYWRJbWFnZSggJ21haWxpbmcnIClcbiAgICB2aWV3TW9kZWwubG9hZFRlbXBsYXRlSW1hZ2UgICAgID0gbG9hZEltYWdlKCAndGVtcGxhdGUnIClcblxuICAgIGNvbnN0IGdhbGxlcnlPcGVuID0gdmlld01vZGVsLnNob3dHYWxsZXJ5LnN1YnNjcmliZSggbmV3VmFsdWUgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB0cnVlICYmIHZpZXdNb2RlbC5tYWlsaW5nR2FsbGVyeVN0YXR1cygpID09PSBmYWxzZSkge1xuICAgICAgICB2aWV3TW9kZWwubG9hZE1haWxpbmdHYWxsZXJ5KClcbiAgICAgICAgZ2FsbGVyeU9wZW4uZGlzcG9zZSgpXG4gICAgICB9XG4gICAgfSApXG5cbiAgICBjb25zdCB0YWJDaGFuZ2UgPSB2aWV3TW9kZWwuc2VsZWN0ZWRJbWFnZVRhYi5zdWJzY3JpYmUoIG5ld1ZhbHVlID0+IHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gMSAmJiB2aWV3TW9kZWwudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHZpZXdNb2RlbC5sb2FkVGVtcGxhdGVHYWxsZXJ5KClcbiAgICAgICAgdGFiQ2hhbmdlLmRpc3Bvc2UoKVxuICAgICAgfVxuICAgIH0sIHZpZXdNb2RlbCwgJ2NoYW5nZScpXG5cbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2FsbGVyeUxvYWRlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIilcbnZhciAkICAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKVxudmFyIGtvICAgICAgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKVxuXG5mdW5jdGlvbiByZW1vdmVHYWxsZXJ5SW1hZ2UoIHZpZXdNb2RlbCApIHtcblxuICB2aWV3TW9kZWwucmVtb3ZlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgZXZlbnQpIHtcbiAgICB2YXIgZGVsZXRlVXJsID0gZGF0YS5kZWxldGVVcmxcblxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICAgIGRlbGV0ZVVybCxcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAvLyBgdHlwZWAgb3B0aW9ucyBpcyBhbiBhbGlhcyBmb3IgYG1ldGhvZGAgb3B0aW9uLlxuICAgICAgLy8gVXNlIGB0eXBlYCBiZWNhdXNlIGBtZXRob2RgIGlzIG5vdCBzdXBwb3J0ZWQgalF1ZXJ5IHByaW9yIHRvIDEuOS4wLlxuICAgICAgLy8gYWN0dWFsIGJvd2VyIHZlcnNpb24gaXMgMS4xMi40IDooXG4gICAgICB0eXBlOiAgICdERUxFVEUnLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2aWV3TW9kZWwubm90aWZpZXIuc3VjY2Vzcyh2aWV3TW9kZWwudCgnZ2FsbGVyeS1yZW1vdmUtaW1hZ2Utc3VjY2VzcycpKVxuICAgICAgICB2YXIgZ2FsbGVyeSAgPSB2aWV3TW9kZWxbIHR5cGUgKyAnR2FsbGVyeScgXVxuICAgICAgICB2YXIgc3RhdHVzICAgPSB2aWV3TW9kZWxbIHR5cGUgKyAnR2FsbGVyeVN0YXR1cycgXVxuICAgICAgICBzdGF0dXMoIHJlcy5maWxlcy5sZW5ndGggKVxuICAgICAgICBnYWxsZXJ5KCByZXMuZmlsZXMucmV2ZXJzZSgpIClcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5lcnJvcih2aWV3TW9kZWwudCgnZ2FsbGVyeS1yZW1vdmUtaW1hZ2UtZmFpbCcpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbW92ZUdhbGxlcnlJbWFnZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIilcbnZhciAkICAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKVxudmFyIGtvICAgICAgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKVxudmFyIF9vbWl0ICAgPSByZXF1aXJlKCdsb2Rhc2gub21pdCcpXG52YXIgaXNFbWFpbCA9IHJlcXVpcmUoJ3ZhbGlkYXRvci9saWIvaXNFbWFpbCcpXG5cbmZ1bmN0aW9uIGdldERhdGEodmlld01vZGVsKSB7XG4gIC8vIGdhdGhlciBtZXRhXG4gIC8vIHJlbW92ZSBrZXlzIHRoYXQgYXJlbid0IG5lY2Vzc2FyeSB0byB1cGRhdGVcbiAgdmFyIGRhdGFzICA9IF9vbWl0KGtvLnRvSlModmlld01vZGVsLm1ldGFkYXRhKSwgWyd1cmxDb252ZXJ0ZXInLCAndGVtcGxhdGUnXSlcbiAgZGF0YXMuZGF0YSA9IHZpZXdNb2RlbC5leHBvcnRKUygpXG4gIHJldHVybiBkYXRhc1xufVxuXG52YXIgbG9hZGVyID0gZnVuY3Rpb24gKHZpZXdNb2RlbCkge1xuICBjb25zb2xlLmluZm8oJ2luaXQgc2VydmVyIHN0b3JhZ2UgKHNhdmUsIHRlc3QsIGRvd25sb2FkKScpXG5cbiAgLy8vLy8vXG4gIC8vIFNBVkVcbiAgLy8vLy8vXG5cbiAgdmFyIHNhdmVDbWQgPSB7XG4gICAgbmFtZTogJ1NhdmUnLCAvLyBsMTBuIGhhcHBlbnMgaW4gdGhlIHRlbXBsYXRlXG4gICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICB9O1xuICBzYXZlQ21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICBzYXZlQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgIHZhciBkYXRhID0gZ2V0RGF0YSh2aWV3TW9kZWwpXG4gICAgY29uc29sZS5pbmZvKCdTQVZFIERBVEEnKVxuICAgIGNvbnNvbGUubG9nKGRhdGEpXG5cbiAgICAvLyBmb3JjZSBKU09OIGZvciBib2R5cGFyc2VyIHRvIGNhdGNoIHVwXG4gICAgLy8gPT4ga2VlcCB0eXBlcyBzZXJ2ZXIgc2lkZVxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgbWV0aG9kOiAgICAgICAnUE9TVCcsXG4gICAgICBjb250ZW50VHlwZTogICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIGRhdGE6ICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICBzdWNjZXNzOiAgICAgIG9uUG9zdFN1Y2Nlc3MsXG4gICAgICBlcnJvcjogICAgICAgIG9uUG9zdEVycm9yLFxuICAgICAgY29tcGxldGU6ICAgICBvblBvc3RDb21wbGV0ZSxcbiAgICB9KVxuXG4gICAgLy8gdXNlIGNhbGxiYWNrIGZvciBlYXNpZXIgalF1ZXJ5IHVwZGF0ZXNcbiAgICAvLyA9PiBEZXByZWNhdGlvbiBub3RpY2UgZm9yIC5zdWNjZXNzKCksIC5lcnJvcigpLCBhbmQgLmNvbXBsZXRlKClcbiAgICBmdW5jdGlvbiBvblBvc3RTdWNjZXNzKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICBjb25zb2xlLmxvZygnc2F2ZSBzdWNjZXNzJylcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5zdWNjZXNzKCB2aWV3TW9kZWwudCgnc2F2ZS1tZXNzYWdlLXN1Y2Nlc3MnKSApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Qb3N0RXJyb3IoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICBjb25zb2xlLmxvZygnc2F2ZSBlcnJvcicpXG4gICAgICBjb25zb2xlLmxvZyhlcnJvclRocm93bilcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5lcnJvcih2aWV3TW9kZWwudCgnc2F2ZS1tZXNzYWdlLWVycm9yJykpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Qb3N0Q29tcGxldGUoKSB7XG4gICAgICBzYXZlQ21kLmVuYWJsZWQodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8vLy8vXG4gIC8vIEVNQUlMXG4gIC8vLy8vL1xuXG4gIHZhciB0ZXN0Q21kID0ge1xuICAgIG5hbWU6ICdUZXN0JywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgIGVuYWJsZWQ6IGtvLm9ic2VydmFibGUodHJ1ZSlcbiAgfVxuICB0ZXN0Q21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmluZm8oJ1RFU1QnKVxuICAgIGNvbnNvbGUubG9nKHZpZXdNb2RlbC5tZXRhZGF0YS51cmwuc2VuZClcbiAgICB0ZXN0Q21kLmVuYWJsZWQoZmFsc2UpXG4gICAgdmFyIGVtYWlsID0gdmlld01vZGVsLnQoJ0luc2VydCBoZXJlIHRoZSByZWNpcGllbnQgZW1haWwgYWRkcmVzcycpXG4gICAgZW1haWwgICAgID0gZ2xvYmFsLnByb21wdCh2aWV3TW9kZWwudChcIlRlc3QgZW1haWwgYWRkcmVzc1wiKSwgZW1haWwpXG5cbiAgICAvLyBEb24ndCB2YWxpZGF0ZSBgbnVsbGAgdmFsdWVzID0+IGlzRW1haWwgd2lsbCBlcnJvclxuICAgIGlmICggIWVtYWlsICkgcmV0dXJuIHRlc3RDbWQuZW5hYmxlZCh0cnVlKVxuXG4gICAgaWYgKCFpc0VtYWlsKGVtYWlsKSkge1xuICAgICAgZ2xvYmFsLmFsZXJ0KHZpZXdNb2RlbC50KCdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKSk7XG4gICAgICByZXR1cm4gdGVzdENtZC5lbmFibGVkKHRydWUpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJUT0RPIHRlc3RpbmcuLi5cIiwgZW1haWwpXG4gICAgdmFyIG1ldGFkYXRhICA9IGtvLnRvSlModmlld01vZGVsLm1ldGFkYXRhKVxuICAgIHZhciBkYXRhcyAgICAgPSB7XG4gICAgICByY3B0OiAgICAgZW1haWwsXG4gICAgICBodG1sOiAgICAgdmlld01vZGVsLmV4cG9ydEhUTUwoKSxcbiAgICB9XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogICAgICAgICAgdmlld01vZGVsLm1ldGFkYXRhLnVybC5zZW5kLFxuICAgICAgbWV0aG9kOiAgICAgICAnUE9TVCcsXG4gICAgICBkYXRhOiAgICAgICAgIGRhdGFzLFxuICAgICAgc3VjY2VzczogICAgICBvblRlc3RTdWNjZXNzLFxuICAgICAgZXJyb3I6ICAgICAgICBvblRlc3RFcnJvcixcbiAgICAgIGNvbXBsZXRlOiAgICAgb25UZXN0Q29tcGxldGUsXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIG9uVGVzdFN1Y2Nlc3MoZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd0ZXN0IHN1Y2Nlc3MnKVxuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLnN1Y2Nlc3Modmlld01vZGVsLnQoXCJUZXN0IGVtYWlsIHNlbnQuLi5cIikpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25UZXN0RXJyb3IoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICBjb25zb2xlLmxvZygndGVzdCBlcnJvcicpXG4gICAgICBjb25zb2xlLmxvZyhlcnJvclRocm93bilcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5lcnJvcih2aWV3TW9kZWwudCgnVW5leHBlY3RlZCBlcnJvciB0YWxraW5nIHRvIHNlcnZlcjogY29udGFjdCB1cyEnKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRlc3RDb21wbGV0ZSgpIHtcbiAgICAgIHRlc3RDbWQuZW5hYmxlZCh0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLy8vLy9cbiAgLy8gWklQXG4gIC8vLy8vL1xuXG4gIHZhciBkb3dubG9hZENtZCA9IHtcbiAgICBuYW1lOiAgICdEb3dubG9hZCcsIC8vIGwxMG4gaGFwcGVucyBpbiB0aGUgdGVtcGxhdGVcbiAgICBlbmFibGVkOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICB9XG4gIGRvd25sb2FkQ21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmluZm8oJ0RPV05MT0FEJylcbiAgICBkb3dubG9hZENtZC5lbmFibGVkKGZhbHNlKVxuICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KFwiRG93bmxvYWRpbmcuLi5cIikpXG4gICAgdmlld01vZGVsLmV4cG9ydEhUTUx0b1RleHRhcmVhKCcjZG93bmxvYWRIdG1sVGV4dGFyZWEnKVxuICAgICQoJyNkb3dubG9hZEh0bWxGaWxlbmFtZScpLnZhbCh2aWV3TW9kZWwubWV0YWRhdGEubmFtZSgpKVxuICAgICQoJyNkb3dubG9hZEZvcm0nKVxuICAgIC5hdHRyKCdhY3Rpb24nLCB2aWV3TW9kZWwubWV0YWRhdGEudXJsLnppcClcbiAgICAuc3VibWl0KClcbiAgICBkb3dubG9hZENtZC5lbmFibGVkKHRydWUpXG4gIH1cblxuICB2aWV3TW9kZWwuc2F2ZSAgICAgID0gc2F2ZUNtZFxuICB2aWV3TW9kZWwudGVzdCAgICAgID0gdGVzdENtZFxuICB2aWV3TW9kZWwuZG93bmxvYWQgID0gZG93bmxvYWRDbWRcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRlcjtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZGVib3VuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKVxuXG4vLy8vLy9cbi8vIERFRklORSBUSU5ZTUNFIENVU1RPTSBQTFVHSU5TXG4vLy8vLy9cblxuLy8tLS0tLSBMRVRURVIgU1BBQ0lOR1xuXG4vLyBjb252ZXJ0IGEgZmlib25hY2NpIHN1aXRlIHRvIGVtXG52YXIgZGVmYXVsdHMgPSBbMCwgMSwgMiwgMywgNSwgOCwgMTNdXG4ubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBNYXRoLnJvdW5kKChlICogMC4xKSAqIDEwMCkgLyAxMDAgfSlcbi5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkgKyAnPScgKyBpICsgJ2VtJyB9KVxuLmpvaW4oJyAnKVxuXG50aW55bWNlLlBsdWdpbk1hbmFnZXIuYWRkKCdzcGFjaW5nJywgYWRkTGV0dGVyU3BhY2luZylcblxuZnVuY3Rpb24gYWRkTGV0dGVyU3BhY2luZyhlZGl0b3IsIHVybCkge1xuICBlZGl0b3IuYWRkQnV0dG9uKCdsZXR0ZXJzcGFjaW5nc2VsZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtYXRzICAgPSBlZGl0b3Iuc2V0dGluZ3Muc3BhY2luZ19mb3JtYXRzIHx8IGRlZmF1bHRzXG4gICAgdmFyIGl0ZW1zICAgICA9IGZvcm1hdHMuc3BsaXQoJyAnKS5tYXAoIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgdGV4dCAgPSBpdGVtXG4gICAgICB2YXIgdmFsdWUgPSBpdGVtXG4gICAgICAvLyBBbGxvdyB0ZXh0PXZhbHVlIGZvbnQgc2l6ZXMuXG4gICAgICB2YXIgdmFsdWVzID0gaXRlbS5zcGxpdCgnPScpXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGV4dCA9IHZhbHVlc1swXVxuICAgICAgICB2YWx1ZSA9IHZhbHVlc1sxXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt0ZXh0OiB0ZXh0LCB2YWx1ZTogdmFsdWUsfVxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBzZXRMZXR0ZXJTcGFjaW5nKGUpIHtcbiAgICAgIGlmICghZS5jb250cm9sLnNldHRpbmdzLnZhbHVlKSByZXR1cm5cbiAgICAgIHRpbnltY2UuYWN0aXZlRWRpdG9yLmZvcm1hdHRlci5yZWdpc3RlcignbGV0dGVyLXNwYWNpbmcnLCB7XG4gICAgICAgIGlubGluZSA6ICdzcGFuJyxcbiAgICAgICAgc3R5bGVzIDogeyAnbGV0dGVyLXNwYWNpbmcnIDogZS5jb250cm9sLnNldHRpbmdzLnZhbHVlIH0sXG4gICAgICB9KVxuICAgICAgdGlueW1jZS5hY3RpdmVFZGl0b3IuZm9ybWF0dGVyLmFwcGx5KCdsZXR0ZXItc3BhY2luZycpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICAgICAgICdsaXN0Ym94JyxcbiAgICAgIHRleHQ6ICAgICAgICdMZXR0ZXIgc3BhY2luZycsXG4gICAgICB0b29sdGlwOiAgICAnTGV0dGVyIHNwYWNpbmcnLFxuICAgICAgdmFsdWVzOiAgICAgaXRlbXMsXG4gICAgICBmaXhlZFdpZHRoOiB0cnVlLFxuICAgICAgb25jbGljazogICAgc2V0TGV0dGVyU3BhY2luZyxcbiAgICB9XG5cbiAgfSlcbn1cblxuLy8tLS0tLSBGUkVFIEZPTlQgU0laRVxuXG4vLyBVdGlsIGZ1bmN0aW9uIGNvcGllZCBmcm9tIFRpbnkgTUNFXG5mdW5jdGlvbiBlYWNoKG8sIGNiLCBzKSB7XG4gIHZhciBuLCBsO1xuXG4gIGlmICghbykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcyA9IHMgfHwgbztcblxuICBpZiAoby5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEluZGV4ZWQgYXJyYXlzLCBuZWVkZWQgZm9yIFNhZmFyaVxuICAgIGZvciAobiA9IDAsIGwgPSBvLmxlbmd0aDsgbiA8IGw7IG4rKykge1xuICAgICAgaWYgKGNiLmNhbGwocywgb1tuXSwgbiwgbykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBIYXNodGFibGVzXG4gICAgZm9yIChuIGluIG8pIHtcbiAgICAgIGlmIChvLmhhc093blByb3BlcnR5KG4pKSB7XG4gICAgICAgIGlmIChjYi5jYWxsKHMsIG9bbl0sIG4sIG8pID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbi8vIGluc3BpcmVkIGJ5IHRpbnltY2UuanMjNDQyNjVcbnRpbnltY2UuUGx1Z2luTWFuYWdlci5hZGQoJ2ZvbnRzaXplZGlhbG9nJywgZm9udHNpemVkaWFsb2cpO1xuXG5mdW5jdGlvbiBmb250c2l6ZWRpYWxvZyhlZGl0b3IsIHVybCkge1xuICBjb25zb2xlLmRpcihlZGl0b3IpXG4gIHZhciBmb250U2l6ZU1pbiAgICAgPSA4XG4gIHZhciBmb250U2l6ZU1heCAgICAgPSA2NjZcbiAgdmFyIHNlbGVjdGlvbkZzICAgICA9IGZhbHNlXG4gIHZhciBkaWFsb2dIZWxwVGV4dCAgPSBbXG4gICAgdGlueW1jZS51dGlsLkkxOG4udHJhbnNsYXRlKCdtaW5pbXVtIHNpemU6IDhweCcpLFxuICAgIHRpbnltY2UudXRpbC5JMThuLnRyYW5zbGF0ZSgnbm8gZGVjaW1hbHMnKSxcbiAgXVxuICAubWFwKCBmdW5jdGlvbiAodCkgeyByZXR1cm4gJ+KAoiAnICsgdH0gKVxuICAuam9pbiggJzxicj4nICk7XG5cbiAgZWRpdG9yLmFkZEJ1dHRvbignZm9udHNpemVkaWFsb2didXR0b24nLCB7XG4gICAgdGV4dDogICAgICAgICAnRm9udCBzaXplJyxcbiAgICB0b29sdGlwOiAgICAgICdGb250IHNpemUnLFxuICAgIC8vIGFkZCBhIGNsYXNzIHRvIGZpeCBidXR0b24gd2lkdGhcbiAgICAvLyBIYXZlbid0IGZvdW5kIGEgd2F5IHRvIHVwZGF0ZSB0b29sYmFyIHNpemUgZHluYW1pY2FsbHlcbiAgICAvLyBpdGVyYXRpbmcgb3ZlciBodHRwczovL3d3dy50aW55bWNlLmNvbS9kb2NzL2FwaS90aW55bWNlLnVpL3RpbnltY2UudWkuYnV0dG9uLyNwYXJlbnRzXG4gICAgLy8gYW5kIGNhbGxpbmcgLnJlZmxvdygpIGRvZXNuJ3QgbWFrZSB0aGUgdHJpY2tcbiAgICBjbGFzc2VzOiAgICAgICdmb250c2l6ZWRpYWxvZ2J1dHRvbicsXG4gICAgaWNvbjogICAgICAgICBmYWxzZSxcbiAgICBvblBvc3RSZW5kZXI6IGFmdGVyQnRuSW5pdCxcbiAgICBvbmNsaWNrOiAgICAgIG9wZW5Gc0RpYWxvZyxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXJCdG5Jbml0KGluaXRFdmVudCkge1xuICAgIHZhciBidG5JbnN0YW5jZSA9IGluaXRFdmVudC5jb250cm9sXG4gICAgdmFyIGZvcm1hdE5hbWUgID0gJ2ZvbnRzaXplJ1xuICAgIHZhciBzZWxmICAgICAgICA9IHRoaXNcblxuICAgIGVkaXRvci5vbignbm9kZUNoYW5nZScsIGRlYm91bmNlKG9uTm9kZUNoYW5nZSwgMTUwKSApXG5cbiAgICBmdW5jdGlvbiBvbk5vZGVDaGFuZ2UoIGUgKSB7XG4gICAgICBlYWNoKGUucGFyZW50cywgZ2V0Rm9udFNpemUpXG4gICAgICBpZiAoIXNlbGVjdGlvbkZzKSB7XG4gICAgICAgIHNlbGVjdGlvbkZzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlLnBhcmVudHNbMF0gfHwgZS5lbGVtZW50LCBudWxsKVxuICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGb250U2l6ZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlLmZvbnRTaXplKSB7XG4gICAgICAgIGJ0bkluc3RhbmNlLnRleHQoIHRpbnltY2UudXRpbC5JMThuLnRyYW5zbGF0ZSgnRm9udCBzaXplOiAnKSArIG5vZGUuc3R5bGUuZm9udFNpemUpXG4gICAgICAgIHNlbGVjdGlvbkZzID0gbm9kZS5zdHlsZS5mb250U2l6ZVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbkZzID0gZmFsc2VcbiAgICAgIGJ0bkluc3RhbmNlLnRleHQoIHRpbnltY2UudXRpbC5JMThuLnRyYW5zbGF0ZSgnRm9udCBzaXplJykgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5Gc0RpYWxvZyhidG5FdmVudCkge1xuICAgIHZhciBpbml0VmFsdWUgPSBzZWxlY3Rpb25GcyA/IC9eKFxcZCspLy5leGVjKHNlbGVjdGlvbkZzKSA6IG51bGxcbiAgICBpbml0VmFsdWUgICAgID0gQXJyYXkuaXNBcnJheShpbml0VmFsdWUpID8gaW5pdFZhbHVlWzBdIDogJydcblxuICAgIGVkaXRvci53aW5kb3dNYW5hZ2VyLm9wZW4oe1xuICAgICAgdGl0bGU6ICdFbnRlciBhIGZvbnQtc2l6ZScsXG4gICAgICB3aWR0aDogMzIwLFxuICAgICAgaGVpZ2h0OiAxMjAsXG4gICAgICBib2R5OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAgICAgICAnbGFiZWwnLFxuICAgICAgICAgIG11bHRpbGluZTogIHRydWUsXG4gICAgICAgICAgdGV4dDogICAgICAgJycsXG4gICAgICAgICAgLy8gbXVsdGlsaW5lIOKAnGhhY2vigJ0gZnJvbTpcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LmRldnN1bW8uY29tL3RlY2hub3Rlcy8yMDE0LzA3L3RpbnltY2UtNC1tdWx0aS1saW5lLWxhYmVscy1pbi1wb3B1cC1kaWFsb2dzL1xuICAgICAgICAgIG9uUG9zdFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRFbCgpLmlubmVySFRNTCA9IGRpYWxvZ0hlbHBUZXh0O1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAgICAgJ3RleHRib3gnLFxuICAgICAgICAgIG5hbWU6ICAgICAnYnNkaWFsb2dmb250c2l6ZScsXG4gICAgICAgICAgbGFiZWw6ICAgICdpbiBwaXhlbCcsXG4gICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiAgICAgaW5pdFZhbHVlLFxuICAgICAgICAgIG9uUG9zdFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuYXR0cih7XG4gICAgICAgICAgICAgIHR5cGU6ICAgJ251bWJlcicsXG4gICAgICAgICAgICAgIG1pbjogICAgZm9udFNpemVNaW4sXG4gICAgICAgICAgICAgIHN0ZXA6ICAgMSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG9uc3VibWl0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbmV3Rm9udFNpemUgPSB+fmUuZGF0YS5ic2RpYWxvZ2ZvbnRzaXplXG4gICAgICAgIGlmIChuZXdGb250U2l6ZSA+PSBmb250U2l6ZU1pbiAmJiBuZXdGb250U2l6ZSA8PSBmb250U2l6ZU1heCkge1xuICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnRm9udFNpemUnLCBmYWxzZSwgbmV3Rm9udFNpemUgKyAncHgnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRpbnlNQ0Ugbm90aWZpY2F0aW9ucyBhcmUgdmVyeSBzbWFsbOKAplxuICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcHV0IHRoZW0gZm9yIG5vd1xuICAgICAgICAgIC8vIGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyLm9wZW4oe1xuICAgICAgICAgIC8vICAgdGV4dDogJ0ludmFsaWQgZm9udCBzaXplJyxcbiAgICAgICAgICAvLyAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgLy8gfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbn1cblxuLy8vLy8vXG4vLyBDT05GSUdVUkFUSU9OXG4vLy8vLy9cblxudmFyIHRpbnltY2VDb25maWdGdWxsID0ge1xuICB0b29sYmFyMTogJ2JvbGQgaXRhbGljIGZvcmVjb2xvciBiYWNrY29sb3IgaHIgfCBmb250c2l6ZWRpYWxvZ2J1dHRvbiBzdHlsZXNlbGVjdCBsZXR0ZXJzcGFjaW5nc2VsZWN0IHJlbW92ZWZvcm1hdCB8IGxpbmsgdW5saW5rIHwgcGFzdGV0ZXh0IGNvZGUnLFxuICAvLy0gYWRkIGNvbG9ycGlja2VyICYgY3VzdG9tIHBsdWdpbnNcbiAgLy8tIGh0dHBzOi8vd3d3LnRpbnltY2UuY29tL2RvY3MvcGx1Z2lucy9jb2xvcnBpY2tlci9cbiAgcGx1Z2luczogW1wibGluayBociBwYXN0ZSBsaXN0cyB0ZXh0Y29sb3IgY29sb3JwaWNrZXIgY29kZSBzcGFjaW5nIGZvbnRzaXplZGlhbG9nXCJdLFxuICAvLy0gaHR0cHM6Ly93d3cudGlueW1jZS5jb20vZG9jcy9jb25maWd1cmUvY29udGVudC1mb3JtYXR0aW5nLyNzdHlsZV9mb3JtYXRzXG4gIHN0eWxlX2Zvcm1hdHM6IFtcbiAgICB7dGl0bGU6ICdJbmxpbmUnLCBpdGVtczogW1xuICAgICAge3RpdGxlOiAnQm9sZCcgICAgICAgICAsIGljb246IFwiYm9sZFwiICAgICAgICAgLCBpbmxpbmU6ICdzdHJvbmcnfSxcbiAgICAgIHt0aXRsZTogJ0l0YWxpYycgICAgICAgLCBpY29uOiBcIml0YWxpY1wiICAgICAgICwgaW5saW5lOiAnZW0nfSxcbiAgICAgIHt0aXRsZTogJ1VuZGVybGluZScgICAgLCBpY29uOiBcInVuZGVybGluZVwiICAgICwgaW5saW5lOiAnc3BhbicsIHN0eWxlczogeyd0ZXh0LWRlY29yYXRpb24nIDogJ3VuZGVybGluZSd9fSxcbiAgICAgIHt0aXRsZTogJ1N0cmlrZXRocm91Z2gnLCBpY29uOiBcInN0cmlrZXRocm91Z2hcIiwgaW5saW5lOiAnc3BhbicsIHN0eWxlczogeyd0ZXh0LWRlY29yYXRpb24nIDogJ2xpbmUtdGhyb3VnaCd9fSxcbiAgICAgIHt0aXRsZTogJ1N1cGVyc2NyaXB0JyAgLCBpY29uOiBcInN1cGVyc2NyaXB0XCIgICwgaW5saW5lOiAnc3VwJ30sXG4gICAgICB7dGl0bGU6ICdTdWJzY3JpcHQnICAgICwgaWNvbjogXCJzdWJzY3JpcHRcIiAgICAsIGlubGluZTogJ3N1Yid9LFxuICAgICAge3RpdGxlOiAnQ29kZScgICAgICAgICAsIGljb246IFwiY29kZVwiICAgICAgICAgLCBpbmxpbmU6ICdjb2RlJ30sXG4gICAgXX0sXG4gICAge3RpdGxlOiAnQWxpZ25tZW50JywgaXRlbXM6IFtcbiAgICAgIHt0aXRsZTogJ0xlZnQnICAgLCBpY29uOiBcImFsaWdubGVmdFwiICAgLCBibG9jazogJ2RpdicsIHN0eWxlczogeyd0ZXh0LWFsaWduJyA6ICdsZWZ0J319LFxuICAgICAge3RpdGxlOiAnQ2VudGVyJyAsIGljb246IFwiYWxpZ25jZW50ZXJcIiAsIGJsb2NrOiAnZGl2Jywgc3R5bGVzOiB7J3RleHQtYWxpZ24nIDogJ2NlbnRlcid9fSxcbiAgICAgIHt0aXRsZTogJ1JpZ2h0JyAgLCBpY29uOiBcImFsaWducmlnaHRcIiAgLCBibG9jazogJ2RpdicsIHN0eWxlczogeyd0ZXh0LWFsaWduJyA6ICdyaWdodCd9fSxcbiAgICAgIHt0aXRsZTogJ0p1c3RpZnknLCBpY29uOiBcImFsaWduanVzdGlmeVwiLCBibG9jazogJ2RpdicsIHN0eWxlczogeyd0ZXh0LWFsaWduJyA6ICdqdXN0aWZ5J319LFxuICAgIF19LFxuICBdLFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbnltY2VDb25maWdGdWxsXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qga28gICAgICAgICAgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKVxuY29uc3QgY29uc29sZSAgICAgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKVxuXG4vLyB3ZSBuZWVkIHRvIGRlY2xhcmUgd2hpY2ggcGFyYW1hdGVycyBhcmUgc3VwcG9ydGVkXG4vLyBzbyBpbiBAc3VwcG9ydHMgLWtvLWJsb2NrZGVmcyB3ZSBjYW4gd3JpdGU6XG4vLyBiZ2ltYWdlIHtcbi8vICAgbGFiZWw6IEJhY2tncm91bmQgSW1hZ2U7XG4vLyAgIHdpZGdldDogYmdpbWFnZTtcbi8vICAgc2l6ZTogMjAweDEwMDsgLy8gPD0gbm90IHVzZWQgYW55bW9yZVxuLy8gfVxuXG4vLyBvdGhlciDigJxuYXRpdmXigJ0gd2lkZ2V0cyBhcmUgZGVmaW5lZCBpbiBjb252ZXJ0ZXIvZWRpdG9yLmpzXG4vLyBzaXplIGlzIGRlYWN0aXZhdGUgZm9yIG5vdzogYmFja2dyb3VuZC1pbWFnZXMgYXJlIHVzZWQgZm9yIHJlcGVhdGluZyBwYXR0ZXJuc1xuY29uc3QgZGVmYXVsdFBhcmFtZXRlcnMgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gc2l6ZTogYDEwMHgxMDBgLFxufSlcbmNvbnN0IHRyYW5zcGFyZW50R2lmICAgID0gYGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQVAvLy93QUFBQ0g1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlDUkFFQU93PT1gXG5cbmNvbnN0IGlzVmFsaWRTaXplICAgPSBzaXplID0+IC8oXFxkKyl4KFxcZCspLy50ZXN0KCBzaXplLnRyaW0oKSApXG5cblxuZnVuY3Rpb24gaHRtbCggcHJvcEFjY2Vzc29yLCBvbmZvY3VzYmluZGluZywgcGFyYW1ldGVycyApIHtcbiAgcmV0dXJuIGBcbiAgICA8aW5wdXQgc2l6ZT1cIjdcIiB0eXBlPVwiaGlkZGVuXCIgdmFsdWU9XCJub3RoaW5nXCIgaWQ9XCIke3Byb3BBY2Nlc3Nvcn1cIiBkYXRhLWJpbmQ9XCJ2YWx1ZTogJHtwcm9wQWNjZXNzb3J9LCAke29uZm9jdXNiaW5kaW5nfVwiIC8+XG4gICAgPGJ1dHRvbiBkYXRhLWJpbmQ9XCJ0ZXh0OiAkcm9vdC50KCd3aWRnZXQtYmdpbWFnZS1idXR0b24nKSwgY2xpY2s6ICRyb290Lm9wZW5EaWFsb2dHYWxsZXJ5LmJpbmQoJGVsZW1lbnQsICcke3Byb3BBY2Nlc3Nvcn0nLCAnJHtwYXJhbWV0ZXJzfScpO1wiPnBpY2sgYW4gaW1hZ2U8L2J1dHRvbj5cbiAgICA8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiAkcm9vdC5yZXNldEJnaW1hZ2UuYmluZCgkZWxlbWVudCwgJyR7cHJvcEFjY2Vzc29yfScsICcke3BhcmFtZXRlcnN9JyksIGJ1dHRvbjoge2ljb25zOiB7cHJpbWFyeTogJ2ZhIGZhLWVyYXNlcid9LCB0ZXh0OiBmYWxzZSwgbGFiZWw6ICRyb290LnQoJ3dpZGdldC1iZ2ltYWdlLXJlc2V0JykgfVwiPjwvYnV0dG9uPlxuICBgXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3B0cyA9PiB7XG5cbiAgY29uc3QgeyBiYXNlUGF0aCB9ID0gb3B0c1xuXG4gIGZ1bmN0aW9uIHdpZGdldCggJCwga28sIGtvanF1aSApIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkZ2V0OiAnYmdpbWFnZScsXG4gICAgICBkZWZhdWx0UGFyYW1ldGVycyxcbiAgICAgIGh0bWwsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmlld01vZGVsKCB2bSApIHtcbiAgICB2bS5zaG93RGlhbG9nR2FsbGVyeSAgPSBrby5vYnNlcnZhYmxlKCBmYWxzZSApXG4gICAgdm0uY3VycmVudEJnaW1hZ2UgICAgID0ga28ub2JzZXJ2YWJsZSggZmFsc2UgKVxuICAgIHZtLnNldEJnSW1hZ2UgICAgICAgICA9ICggaW1hZ2VOYW1lLCBpbWcsIGV2ZW50ICkgPT4ge1xuICAgICAgLy8gaW1hZ2VzIGhhdmUgdG8gYmUgb24gYW4gYWJzb2x1dGUgcGF0aFxuICAgICAgLy8gPT4gVGVzdGluZyBieSBlbWFpbCBuZWVkcyBpdCB0aGF0IHdheVxuICAgICAgLy8gPT4gWklQIGRvd25sb2FkIG5lZWRzIGl0IHRoYXQgd2F5XG4gICAgICAvLyB2bS5jdXJyZW50QmdpbWFnZSgpKCBgJHsgYmFzZVBhdGggfS9jb3Zlci8keyB2bS5jdXJyZW50QmdzaXplKCkgfS8keyBpbWFnZU5hbWUgfWAgKVxuICAgICAgdm0uY3VycmVudEJnaW1hZ2UoKSggYCR7IGJhc2VQYXRoIH0vaW1nLyR7IGltYWdlTmFtZSB9YCApXG4gICAgICB2bS5jbG9zZURpYWxvZ0dhbGxlcnkoKVxuICAgIH1cbiAgICB2bS5yZXNldEJnaW1hZ2UgICAgICAgPSAoIHByb3BBY2Nlc3NvciwgcGFyYW1ldGVycywgYmxvY2tQcm9wZXJ0aWVzLCBldmVudCApID0+IHtcbiAgICAgIGJsb2NrUHJvcGVydGllc1sgcHJvcEFjY2Vzc29yIF0oIHRyYW5zcGFyZW50R2lmIClcbiAgICB9XG4gICAgdm0ub3BlbkRpYWxvZ0dhbGxlcnkgID0gKCBwcm9wQWNjZXNzb3IsIHBhcmFtZXRlcnMsIGJsb2NrUHJvcGVydGllcywgZXZlbnQgKSA9PiB7XG4gICAgICAvLyB0byBzZXQgdGhlIHJpZ2h0IHByb3BlcnR5LCBzdG9yZSB0aGUgY29uY2VybmVkIHNldHRlclxuICAgICAgdm0uY3VycmVudEJnaW1hZ2UoIGJsb2NrUHJvcGVydGllc1sgcHJvcEFjY2Vzc29yIF0uYmluZCggYmxvY2tQcm9wZXJ0aWVzICkgKVxuICAgICAgdm0uc2hvd0RpYWxvZ0dhbGxlcnkoIHRydWUgKVxuICAgIH1cbiAgICB2bS5jbG9zZURpYWxvZ0dhbGxlcnkgPSAoKSA9PiB7XG4gICAgICB2bS5jdXJyZW50QmdpbWFnZSggZmFsc2UgKVxuICAgICAgdm0uc2hvd0RpYWxvZ0dhbGxlcnkoIGZhbHNlIClcbiAgICB9XG5cbiAgICBjb25zdCBkaWFsb2dHYWxsZXJ5T3BlbiA9IHZtLnNob3dEaWFsb2dHYWxsZXJ5LnN1YnNjcmliZSggbmV3VmFsdWUgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB0cnVlICYmIHZtLm1haWxpbmdHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHZtLmxvYWRNYWlsaW5nR2FsbGVyeSgpXG4gICAgICAgIGRpYWxvZ0dhbGxlcnlPcGVuLmRpc3Bvc2UoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZGdldCxcbiAgICB2aWV3TW9kZWwsXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIgaW5saW5lRG9jdW1lbnQgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2p1aWNlL2xpYi9pbmxpbmVcIikoe30pLmlubGluZURvY3VtZW50O1xuXG52YXIgaW5saW5lclBsdWdpbiA9IGZ1bmN0aW9uKHZtKSB7XG4gIHZtLmlubGluZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgIC8vIHRpbnltY2UgbWF5IGhhdmUgYWRkZWQgc3R5bGUgYXR0cmlidXRlcyB0byBlbGVtZW50cyB0aGF0IHdpbGwgYWxzbyBoYXZlIGdsb2JhbCBzdHlsZXMgdG8gYmUgaW5saW5lZFxuICAgICQoJ1tzdHlsZV06bm90KFtyZXBsYWNlZHN0eWxlXSknLCBkb2MpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsKSB7XG4gICAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgICAkZWwuYXR0cigncmVwbGFjZWRzdHlsZScsICRlbC5hdHRyKCdzdHlsZScpKTtcbiAgICB9KTtcblxuICAgIHZhciBzdHlsZSA9IFtdO1xuICAgICQoJ3N0eWxlW2RhdGEtaW5saW5lPVwidHJ1ZVwiXScsIGRvYykuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSAkKGVsZW1lbnQpLmh0bWwoKTtcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzwhLS0ga28gKCg/IS0tKS4pKj8gLS0+L2csICcnKTsgLy8gdGhpcyByZXBsYWNlcyB0aGUgYWJvdmUgd2l0aCBhIG1vcmUgZm9ybWFsIChidXQgc2xvd2VyKSBzb2x1dGlvblxuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvPCEtLSBcXC9rbyAtLT4vZywgJycpO1xuICAgICAgc3R5bGUucHVzaChjb250ZW50KTtcbiAgICAgICQoZWxlbWVudCkucmVtb3ZlQXR0cignZGF0YS1pbmxpbmUnKTtcbiAgICB9KTtcbiAgICB2YXIgc3R5bGVUZXh0ID0gc3R5bGUuam9pbihcIlxcblwiKTtcbiAgICB2YXIgJGNvbnRleHQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09ICd1bmRlZmluZWQnKSBjb250ZXh0ID0gZG9jO1xuICAgICAgcmV0dXJuICQoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgJGNvbnRleHQucm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICQoJzpyb290JywgZG9jKTtcbiAgICB9O1xuICAgIGlubGluZURvY3VtZW50KCRjb250ZXh0LCBzdHlsZVRleHQsIHsgc3R5bGVBdHRyaWJ1dGVOYW1lOiAncmVwbGFjZWRzdHlsZScgfSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlubGluZXJQbHVnaW47IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xuXG5pZiAoZmFsc2UpIHtcblxudmFyIGxzTG9hZGVyID0gZnVuY3Rpb24oaGFzaF9rZXksIGVtYWlsUHJvY2Vzc29yQmFja2VuZCkge1xuICB2YXIgbWRTdHIgPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtZXRhZGF0YS1cIiArIGhhc2hfa2V5KTtcbiAgaWYgKG1kU3RyICE9PSBudWxsKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHZhciB0ZCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRlbXBsYXRlLVwiICsgaGFzaF9rZXkpO1xuICAgIGlmICh0ZCAhPT0gbnVsbCkgbW9kZWwgPSBKU09OLnBhcnNlKHRkKTtcbiAgICB2YXIgbWQgPSBKU09OLnBhcnNlKG1kU3RyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IG1kLFxuICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgZXh0ZW5zaW9uOiBsc0NvbW1hbmRQbHVnaW5GYWN0b3J5KG1kLCBlbWFpbFByb2Nlc3NvckJhY2tlbmQpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIkNhbm5vdCBmaW5kIHN0b3JlZCBkYXRhIGZvciBcIitoYXNoX2tleTtcbiAgfVxufTtcblxudmFyIGxzQ29tbWFuZFBsdWdpbkZhY3RvcnkgPSBmdW5jdGlvbihtZCwgZW1haWxQcm9jZXNzb3JCYWNrZW5kKSB7XG4gIHZhciBjb21tYW5kc1BsdWdpbiA9IGZ1bmN0aW9uKG1ka2V5LCBtZG5hbWUsIHZpZXdNb2RlbCkge1xuXG4gICAgLy8gY29uc29sZS5sb2coXCJsb2FkaW5nIGZyb20gbWV0YWRhdGFcIiwgbWQsIG1vZGVsKTtcbiAgICB2YXIgc2F2ZUNtZCA9IHtcbiAgICAgIG5hbWU6ICdTYXZlJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgc2F2ZUNtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzYXZlQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmlld01vZGVsLm1ldGFkYXRhLmNoYW5nZWQgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKHR5cGVvZiB2aWV3TW9kZWwubWV0YWRhdGEua2V5ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBmaW5kIGtldCBpbiBtZXRhZGF0YSBvYmplY3QuLi5cIiwgdmlld01vZGVsLm1ldGFkYXRhKTtcbiAgICAgICAgdmlld01vZGVsLm1ldGFkYXRhLmtleSA9IG1ka2V5O1xuICAgICAgfVxuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWV0YWRhdGEtXCIgKyBtZGtleSwgdmlld01vZGVsLmV4cG9ydE1ldGFkYXRhKCkpO1xuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidGVtcGxhdGUtXCIgKyBtZGtleSwgdmlld01vZGVsLmV4cG9ydEpTT04oKSk7XG4gICAgICBzYXZlQ21kLmVuYWJsZWQodHJ1ZSk7XG4gICAgfTtcbiAgICB2YXIgdGVzdENtZCA9IHtcbiAgICAgIG5hbWU6ICdUZXN0JywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgdmFyIGRvd25sb2FkQ21kID0ge1xuICAgICAgbmFtZTogJ0Rvd25sb2FkJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgdGVzdENtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0ZXN0Q21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmFyIGVtYWlsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidGVzdGVtYWlsXCIpO1xuICAgICAgaWYgKGVtYWlsID09PSBudWxsIHx8IGVtYWlsID09ICdudWxsJykgZW1haWwgPSB2aWV3TW9kZWwudCgnSW5zZXJ0IGhlcmUgdGhlIHJlY2lwaWVudCBlbWFpbCBhZGRyZXNzJyk7XG4gICAgICBlbWFpbCA9IGdsb2JhbC5wcm9tcHQodmlld01vZGVsLnQoXCJUZXN0IGVtYWlsIGFkZHJlc3NcIiksIGVtYWlsKTtcbiAgICAgIGlmIChlbWFpbC5tYXRjaCgvQC8pKSB7XG4gICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRlc3RlbWFpbFwiLCBlbWFpbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyB0ZXN0aW5nLi4uXCIsIGVtYWlsKTtcbiAgICAgICAgdmFyIHBvc3RVcmwgPSBlbWFpbFByb2Nlc3NvckJhY2tlbmQgPyBlbWFpbFByb2Nlc3NvckJhY2tlbmQgOiAnL2RsLyc7XG4gICAgICAgIHZhciBwb3N0ID0gJC5wb3N0KHBvc3RVcmwsIHtcbiAgICAgICAgICBhY3Rpb246ICdlbWFpbCcsXG4gICAgICAgICAgcmNwdDogZW1haWwsXG4gICAgICAgICAgc3ViamVjdDogXCJbdGVzdF0gXCIgKyBtZGtleSArIFwiIC0gXCIgKyBtZG5hbWUsXG4gICAgICAgICAgaHRtbDogdmlld01vZGVsLmV4cG9ydEhUTUwoKVxuICAgICAgICB9LCBudWxsLCAnaHRtbCcpO1xuICAgICAgICBwb3N0LmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdVbmV4cGVjdGVkIGVycm9yIHRhbGtpbmcgdG8gc2VydmVyOiBjb250YWN0IHVzIScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvc3Quc3VjY2VzcyhmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInN1Y2Nlc3NcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgICB2aWV3TW9kZWwubm90aWZpZXIuc3VjY2Vzcyh2aWV3TW9kZWwudChcIlRlc3QgZW1haWwgc2VudC4uLlwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwb3N0LmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ZXN0Q21kLmVuYWJsZWQodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLmFsZXJ0KHZpZXdNb2RlbC50KCdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKSk7XG4gICAgICAgIHRlc3RDbWQuZW5hYmxlZCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvd25sb2FkQ21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRvd25sb2FkQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmluZm8odmlld01vZGVsLnQoXCJEb3dubG9hZGluZy4uLlwiKSk7XG4gICAgICB2aWV3TW9kZWwuZXhwb3J0SFRNTHRvVGV4dGFyZWEoJyNkb3dubG9hZEh0bWxUZXh0YXJlYScpO1xuICAgICAgdmFyIHBvc3RVcmwgPSBlbWFpbFByb2Nlc3NvckJhY2tlbmQgPyBlbWFpbFByb2Nlc3NvckJhY2tlbmQgOiAnL2RsLyc7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkRm9ybScpLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCBwb3N0VXJsKTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWRGb3JtJykuc3VibWl0KCk7XG4gICAgICBkb3dubG9hZENtZC5lbmFibGVkKHRydWUpO1xuICAgIH07XG5cbiAgICB2aWV3TW9kZWwuc2F2ZSA9IHNhdmVDbWQ7XG4gICAgdmlld01vZGVsLnRlc3QgPSB0ZXN0Q21kO1xuICAgIHZpZXdNb2RlbC5kb3dubG9hZCA9IGRvd25sb2FkQ21kO1xuICB9LmJpbmQodW5kZWZpbmVkLCBtZC5rZXksIG1kLm5hbWUpO1xuXG4gIHJldHVybiBjb21tYW5kc1BsdWdpbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbHNMb2FkZXI7XG5cbn0gZWxzZSBpZiAodHJ1ZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge31cblxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCIuLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMva25vY2tvdXQtc29ydGFibGUvYnVpbGQva25vY2tvdXQtc29ydGFibGUubWluLmpzXCIpO1xuXG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9qcXVlcnl1aS1zcGlubmVyLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvanF1ZXJ5dWktdGFicy5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL2NvbG9ycGlja2VyLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvYmxvY2tzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvY3NzdGV4dC5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL2JpbmQtaWZyYW1lLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZHJvcHBhYmxlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZmlsZXVwbG9hZC5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL3ZpcnR1YWxzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3Mvd3lzaXd5Z3MuanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9zY3JvbGxmaXguanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9pZi1zdWJzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZXh0c29ydGFibGVzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZXZlbnRhYmxlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvdG9vbHRpcHMuanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9leHRlbmRlci1wYWdpbmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvdmFsaWRhdGVkLXZhbHVlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3Mvc2Nyb2xsaW50b3ZpZXcuanNcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBrb2pxdWkgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna29qcXVpJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrb2pxdWknXSA6IG51bGwpOyAvLyBqdXN0IGZvciB0aGUgd2lkZ2V0IHBsdWdpbnNcbnZhciB0ZW1wbGF0ZUNvbnZlcnRlciA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlci9tYWluLmpzXCIpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBpbml0aWFsaXplVmlld21vZGVsID0gcmVxdWlyZShcIi4vdmlld21vZGVsLmpzXCIpO1xudmFyIHRlbXBsYXRlU3lzdGVtID0gcmVxdWlyZSgnLi9iaW5kaW5ncy9jaG9vc2UtdGVtcGxhdGUuanMnKTtcblxuLy8gY2FsbCBhIGdpdmVuIG1ldGhvZCBvbiBldmVyeSBwbHVnaW4gaW1wbGVtZW50aW5nIGl0LlxuLy8gc3VwcG9ydHMgYSBcInJldmVyc2VcIiBwYXJhbWV0ZXIgdG8gY2FsbCB0aGUgbWV0aG9kcyBmcm9tIHRoZSBsYXN0IG9uZSB0byB0aGUgZmlyc3Qgb25lLlxudmFyIHBsdWdpbnNDYWxsID0gZnVuY3Rpb24ocGx1Z2lucywgbWV0aG9kTmFtZSwgYXJncywgcmV2ZXJzZSkge1xuICB2YXIgc3RhcnQsIGVuZCwgZGlmZiwgcmVzLCByZXN1bHRzO1xuICByZXN1bHRzID0gW107XG4gIGlmICh0eXBlb2YgcmV2ZXJzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV2ZXJzZSkge1xuICAgIHN0YXJ0ID0gcGx1Z2lucy5sZW5ndGggLSAxO1xuICAgIGVuZCA9IDA7XG4gICAgZGlmZiA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gMDtcbiAgICBlbmQgPSBwbHVnaW5zLmxlbmd0aCAtIDE7XG4gICAgZGlmZiA9IDE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpICE9IGVuZCArIGRpZmY7IGkgKz0gZGlmZikge1xuICAgIGlmICh0eXBlb2YgcGx1Z2luc1tpXVttZXRob2ROYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlcyA9IHBsdWdpbnNbaV1bbWV0aG9kTmFtZV0uYXBwbHkocGx1Z2luc1tpXSwgYXJncyk7XG4gICAgICBpZiAodHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdHMucHVzaChyZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIHdvcmthcm91bmQgZm9yIGtub2Nrb3V0LWpxdWVyeXVpJ3MgYnV0dG9uc2V0L2J1dHRvbiBkaXNwb3NhbDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ndmFzL2tub2Nrb3V0LWpxdWVyeXVpL2lzc3Vlcy8yNVxudmFyIG9yaWdEaXNwb3NlQ2FsbGJhY2sgPSBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrO1xua28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayA9IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrKSB7XG4gIHZhciBuZXdDYWxsYmFjayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ2F1Z2h0IHVuZXhwZWN0ZWQgZGlzcG9zZSBjYWxsYmFjayBleGNlcHRpb25cIiwgZSk7XG4gICAgfVxuICB9O1xuICBvcmlnRGlzcG9zZUNhbGxiYWNrKG5vZGUsIG5ld0NhbGxiYWNrKTtcbn07XG5cbnZhciBiaW5kaW5nUGx1Z2luTWFrZXIgPSBmdW5jdGlvbihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSB7XG4gIHJldHVybiB7XG4gICAgdmlld01vZGVsOiBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ2FwcGx5QmluZGluZ3MnLCBrby5hcHBseUJpbmRpbmdzLmJpbmQodW5kZWZpbmVkLCB2aWV3TW9kZWwpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyLCBlcnIuc3RhY2spO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ3VuYXBwbHlCaW5kaW5ncycsIGtvLmNsZWFuTm9kZS5iaW5kKHRoaXMsIGdsb2JhbC5kb2N1bWVudC5ib2R5KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGVyciwgZXJyLnN0YWNrKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciB0ZW1wbGF0ZUNyZWF0b3IgPSBmdW5jdGlvbih0ZW1wbGF0ZVBsdWdpbiwgaHRtbE9yRWxlbWVudCwgb3B0aW9uYWxOYW1lLCB0ZW1wbGF0ZU1vZGUpIHtcbiAgdmFyIHRtcE5hbWUgPSBvcHRpb25hbE5hbWU7XG4gIGlmICh0eXBlb2Ygb3B0aW9uYWxOYW1lICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0ZW1wbGF0ZU1vZGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGh0bWxPckVsZW1lbnQgIT0gJ29iamVjdCcgfHwgaHRtbE9yRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3JlcGxhY2VkaHRtbCcpIHRtcE5hbWUgKz0gJy0nICsgdGVtcGxhdGVNb2RlO1xuICB9XG5cbiAgd2hpbGUgKHR5cGVvZiB0bXBOYW1lID09ICd1bmRlZmluZWQnIHx8IHRtcE5hbWUgPT09IG51bGwgfHwgdGVtcGxhdGVQbHVnaW4uZXhpc3RzKHRtcE5hbWUpKSB7XG4gICAgdG1wTmFtZSA9ICdhbm9ueW1vdXMtJyArIE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApICsgMSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGh0bWxPckVsZW1lbnQgPT0gJ29iamVjdCcgJiYgaHRtbE9yRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ3JlcGxhY2VkaHRtbCcpIHtcbiAgICB2YXIgJGVsID0gJChodG1sT3JFbGVtZW50KTtcbiAgICB2YXIgJGhlYWQgPSAkKCdyZXBsYWNlZGhlYWQnLCAkZWwpO1xuICAgIHZhciAkYm9keSA9ICQoJ3JlcGxhY2VkYm9keScsICRlbCk7XG4gICAgdGVtcGxhdGVQbHVnaW4uYWRkZXIodG1wTmFtZSArICctaGVhZCcsICRoZWFkLmh0bWwoKSB8fCAnJyk7XG4gICAgdGVtcGxhdGVQbHVnaW4uYWRkZXIodG1wTmFtZSArICctc2hvdycsICRib2R5Lmh0bWwoKSB8fCAnJyk7XG4gICAgdGVtcGxhdGVQbHVnaW4uYWRkZXIodG1wTmFtZSArICctcHJldmlldycsICRlbC5odG1sKCkpO1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLXd5c2l3eWcnLCAkZWwuaHRtbCgpKTtcblxuICAgIC8vICRoZWFkLmF0dHIoJ2RhdGEtYmluZCcsICdibG9jazogY29udGVudCcpO1xuICAgICRoZWFkLmNoaWxkcmVuKCkuZGV0YWNoKCk7XG4gICAgJGhlYWQuaHRtbChcIjwhLS0ga28gYmxvY2s6IGNvbnRlbnQgLS0+PCEtLSAva28gLS0+XCIpO1xuICAgICRoZWFkLmJlZm9yZSgnPCEtLSBrbyB3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6IFxcJ2hlYWRcXCcgfSAtLT4nKTtcbiAgICAkaGVhZC5hZnRlcignPCEtLSAva28gLS0+Jyk7XG4gICAgJGJvZHkuaHRtbChcIjwhLS0ga28gYmxvY2s6IGNvbnRlbnQgLS0+PCEtLSAva28gLS0+XCIpO1xuXG4gICAgdGVtcGxhdGVQbHVnaW4uYWRkZXIodG1wTmFtZSArICctaWZyYW1lJywgJGVsWzBdLm91dGVySFRNTCk7XG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgaHRtbE9yRWxlbWVudCA9PSAnb2JqZWN0Jykge1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUsIGh0bWxPckVsZW1lbnQub3V0ZXJIVE1MKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZVBsdWdpbi5hZGRlcih0bXBOYW1lLCBodG1sT3JFbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiB0bXBOYW1lO1xufTtcblxuLy8gQWRhcHRlciB0byB0cmFuc2Zvcm0gXCJ2aWV3TW9kZWwgcGx1Z2luc1wiIGludG8gbW9yZSBnZW5lcmljIHBsdWdpbnMuXG5mdW5jdGlvbiBfdmlld01vZGVsUGx1Z2luSW5zdGFuY2UocGx1Z2luRnVuY3Rpb24pIHtcbiAgdmFyIGluc3RhbmNlO1xuICByZXR1cm4ge1xuICAgIHZpZXdNb2RlbDogZnVuY3Rpb24odmlld01vZGVsKSB7XG4gICAgICBpbnN0YW5jZSA9IHBsdWdpbkZ1bmN0aW9uKHZpZXdNb2RlbCk7XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbnN0YW5jZS5pbml0ICE9PSAndW5kZWZpbmVkJykgaW5zdGFuY2UuaW5pdCgpO1xuICAgIH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW5zdGFuY2UuZGlzcG9zZSAhPT0gJ3VuZGVmaW5lZCcpIGluc3RhbmNlLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG59XG5cbmlmIChmYWxzZSkge1xuXG52YXIgX3RlbXBsYXRlVXJsQ29udmVydGVyID0gZnVuY3Rpb24oYmFzZVBhdGgsIHVybCkge1xuICBpZiAoIXVybC5tYXRjaCgvXlteXFwvXSo6LykgJiYgIXVybC5tYXRjaCgvXlxcLy8pICYmICF1cmwubWF0Y2goL15cXFsvKSAmJiAhdXJsLm1hdGNoKC9eIz8kLykpIHtcbiAgICAvLyBUT0RPIHRoaXMgY291bGQgYmUgc21hcnRlciBqb2luaW5nIHRoZSB1cmxzLi4uXG4gICAgcmV0dXJuIGJhc2VQYXRoICsgdXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgdGVtcGxhdGVMb2FkZXIgPSBmdW5jdGlvbihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLCB0ZW1wbGF0ZUZpbGVOYW1lLCB0ZW1wbGF0ZU1ldGFkYXRhLCBqc29yanNvbiwgZXh0ZW5zaW9ucywgZ2FsbGVyeVVybCkge1xuICB2YXIgdGVtcGxhdGVGaWxlID0gdHlwZW9mIHRlbXBsYXRlRmlsZU5hbWUgPT0gJ3N0cmluZycgPyB0ZW1wbGF0ZUZpbGVOYW1lIDogdGVtcGxhdGVNZXRhZGF0YS50ZW1wbGF0ZTtcbiAgdmFyIHRlbXBsYXRlUGF0aCA9IFwiLi9cIjtcbiAgdmFyIHAgPSB0ZW1wbGF0ZUZpbGUubGFzdEluZGV4T2YoJy8nKTtcbiAgaWYgKHAgIT0gLTEpIHtcbiAgICB0ZW1wbGF0ZVBhdGggPSB0ZW1wbGF0ZUZpbGUuc3Vic3RyKDAsIHAgKyAxKTtcbiAgfVxuXG4gIHZhciB0ZW1wbGF0ZVVybENvbnZlcnRlciA9IF90ZW1wbGF0ZVVybENvbnZlcnRlci5iaW5kKHVuZGVmaW5lZCwgdGVtcGxhdGVQYXRoKTtcblxuICB2YXIgbWV0YWRhdGE7XG4gIGlmICh0eXBlb2YgdGVtcGxhdGVNZXRhZGF0YSA9PSAndW5kZWZpbmVkJykge1xuICAgIG1ldGFkYXRhID0ge1xuICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlRmlsZSxcbiAgICAgIC8vIFRPRE8gbDEwbj9cbiAgICAgIG5hbWU6ICdObyBuYW1lJyxcbiAgICAgIGNyZWF0ZWQ6IERhdGUubm93KClcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1ldGFkYXRhID0gdGVtcGxhdGVNZXRhZGF0YTtcbiAgfVxuXG4gICQuZ2V0KHRlbXBsYXRlRmlsZSwgZnVuY3Rpb24odGVtcGxhdGVjb2RlKSB7XG4gICAgdmFyIHJlcyA9IHRlbXBsYXRlQ29tcGlsZXIocGVyZm9ybWFuY2VBd2FyZUNhbGxlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIFwidGVtcGxhdGVcIiwgdGVtcGxhdGVjb2RlLCBqc29yanNvbiwgbWV0YWRhdGEsIGV4dGVuc2lvbnMsIGdhbGxlcnlVcmwpO1xuICAgIHJlcy5pbml0KCk7XG4gIH0pO1xufTtcblxufSBlbHNlIGlmICh0cnVlKSB7XG5cbi8vIGtlZXAgZnVuY3Rpb24gc2lnbmF0dXJlc1xudmFyIHRlbXBsYXRlTG9hZGVyID0gZnVuY3Rpb24ocGVyZm9ybWFuY2VBd2FyZUNhbGxlciwgdGVtcGxhdGVGaWxlTmFtZSwgdGVtcGxhdGVNZXRhZGF0YSwganNvcmpzb24sIGV4dGVuc2lvbnMsIGdhbGxlcnlVcmwpIHtcbiAgY29uc29sZS5pbmZvKCdURU1QTEFURSBMT0FERVInKVxuXG4gIC8vIHNlZSBleHQvY3VzdG9tLWV4dGVuc2lvbnMuanMjdGVtcGxhdGVVcmxDb252ZXJ0ZXJcbiAgdmFyIHRlbXBsYXRlVXJsQ29udmVydGVyID0ga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMudGVtcGxhdGVVcmxDb252ZXJ0ZXI7XG5cbiAgdmFyIG1ldGFkYXRhICA9IHRlbXBsYXRlTWV0YWRhdGE7XG5cbiAgLy8gS2VlcCBYSFIgdG8gbG9hZCB0ZW1wbGF0ZS5cbiAgLy8gRG9uJ3Qgd2FudCB0byBvdXRwdXQgYWxsIHRoZSBodG1sIGluIGluaXRpYWxpemF0aW9uXG4gICQuYWpheCh7XG4gICAgdXJsOiAgICAgIHRlbXBsYXRlRmlsZU5hbWUsXG4gICAgbWV0aG9kOiAgICdHRVQnLFxuICAgIHN1Y2Nlc3M6ICBvblN1Y2Nlc3MsXG4gICAgZXJyb3I6ICAgIG9uRXJyb3IsXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG9uU3VjY2Vzcyh0ZW1wbGF0ZWNvZGUsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgdmFyIHJlcyA9IHRlbXBsYXRlQ29tcGlsZXIocGVyZm9ybWFuY2VBd2FyZUNhbGxlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIFwidGVtcGxhdGVcIiwgdGVtcGxhdGVjb2RlLCBqc29yanNvbiwgbWV0YWRhdGEsIGV4dGVuc2lvbnMsIGdhbGxlcnlVcmwpO1xuICAgIHJlcy5pbml0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2Nhbm5vdCByZXRyaWV2ZSBIVE1MIGRhdGEgZnJvbSB0ZW1wbGF0ZScpO1xuICAgICQoJy5tby1zdGFuZGFsb25lJykuaHRtbCgnPGgxPmVycm9yPC9oMT48aDI+JyArIGVycm9yVGhyb3duICsgJzwvaDI+Jyk7XG4gIH1cbn07XG5cbn1cblxudmFyIHRlbXBsYXRlQ29tcGlsZXIgPSBmdW5jdGlvbihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgdGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZWNvZGUsIGpzb3Jqc29uLCBtZXRhZGF0YSwgZXh0ZW5zaW9ucywgZ2FsbGVyeVVybCkge1xuICAvLyB3ZSBzdHJpcCBjb250ZW50IGJlZm9yZSA8aHRtbD4gdGFnIGFuZCBhZnRlciA8L2h0bWw+IGJlY2F1c2UganF1ZXJ5IGRvZXNuJ3QgcGFyc2UgaXQuXG4gIC8vIHdlJ2xsIGtlZXAgaXQgXCJyYXdcIiBhbmQgdXNlIGl0IGluIHRoZSBwcmV2aWV3L291dHB1dCBtZXRob2RzLlxuICB2YXIgcmVzID0gdGVtcGxhdGVjb2RlLm1hdGNoKC9eKFtcXFNcXHNdKikoWzxdaHRtbFtePl0qPltcXFNcXHNdKjxcXC9odG1sPikoW1xcU1xcc10qKSQvaSk7XG4gIGlmIChyZXMgPT09IG51bGwpIHRocm93IFwiVW5hYmxlIHRvIGZpbmQgPGh0bWw+IG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyBpbiB0aGUgdGVtcGxhdGVcIjtcbiAgdmFyIHByZWZpeCA9IHJlc1sxXTtcbiAgLy8gd2UgcGFyc2UgdGhlIGh0bWwgY29udGVudCBhZnRlciByZXBsYWNpbmcgdGhlIHRhZyBuYW1lIGZvciBodG1sL2hlYWQvYm9keSBzbyB0byBhdm9pZCBqcXVlcnkgaXNzdWVzIGluIHBhcnNpbmcuXG4gIHZhciBiYXNpY1N0cnVjdHVyZSA9IHsgJzxodG1sJzogMCwgJzxoZWFkJzogMCwgJzxib2R5JzogMCwgJzwvaHRtbCc6IDAsICc8L2JvZHknOiAwLCAnPC9oZWFkJzogMCB9O1xuICB2YXIgaHRtbCA9IHJlc1syXS5yZXBsYWNlKC8oPFxcLz8pKGh0bWx8aGVhZHxib2R5KShbXj5dKj4pL2dpLCBmdW5jdGlvbihtYXRjaCwgcDEsIHAyLCBwMykge1xuICAgIGJhc2ljU3RydWN0dXJlWyhwMStwMikudG9Mb3dlckNhc2UoKV0gKz0gMTtcbiAgICByZXR1cm4gcDEgKyAncmVwbGFjZWQnICsgcDIgKyBwMztcbiAgfSk7XG4gIGZvciAodmFyIGVsZSBpbiBiYXNpY1N0cnVjdHVyZSkgaWYgKGJhc2ljU3RydWN0dXJlLmhhc093blByb3BlcnR5KGVsZSkpIGlmIChiYXNpY1N0cnVjdHVyZVtlbGVdICE9IDEpIHtcbiAgICBpZiAoYmFzaWNTdHJ1Y3R1cmVbZWxlXSA9PT0gMCkgdGhyb3cgXCJFUlJPUjogbWlzc2luZyBtYW5kYXRvcnkgZWxlbWVudCBcIitlbGUrXCI+XCI7XG4gICAgaWYgKGJhc2ljU3RydWN0dXJlW2VsZV0gPiAxKSB0aHJvdyBcIkVSUk9SOiBtdWx0aXBsZSBlbGVtZW50IFwiK2VsZStcIj4gb2Njb3VyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQgKGZvdW5kIFwiK2Jhc2ljU3RydWN0dXJlW2VsZV0rXCIgb2Njb3VyZW5jZXMpXCI7XG4gIH1cbiAgdmFyIHBvc3RmaXggPSByZXNbM107XG4gIHZhciBibG9ja0RlZnMgPSBbXTtcbiAgdmFyIGVuYWJsZVVuZG8gPSB0cnVlO1xuICB2YXIgZW5hYmxlUmVjb3JkZXIgPSB0cnVlO1xuICB2YXIgYmFzZVRocmVzaG9sZCA9ICcrJHJvb3QuY29udGVudExpc3RlbmVycygpJztcblxuICB2YXIgcGx1Z2lucyA9IFtdO1xuXG4gIGlmICh0eXBlb2YgZXh0ZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uc1tpXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBsdWdpbnMucHVzaChfdmlld01vZGVsUGx1Z2luSW5zdGFuY2UoZXh0ZW5zaW9uc1tpXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGx1Z2lucy5wdXNoKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjcmVhdGVkVGVtcGxhdGVzID0gW107XG4gIHZhciB0ZW1wbGF0ZXNQbHVnaW4gPSB7XG4gICAgYWRkZXI6IGZ1bmN0aW9uKGlkLCBodG1sKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgIT09ICdzdHJpbmcnKSB0aHJvdyBcIlRlbXBsYXRlIHN5c3RlbTogY2Fubm90IGNyZWF0ZSBuZXcgdGVtcGxhdGUgXCIgKyBpZDtcbiAgICAgIHZhciB0cmFzaCA9IGh0bWwubWF0Y2goLyhkYXRhKT8ta28tW14gPTpdKi9nKTtcbiAgICAgIGlmICh0cmFzaCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6IGZvdW5kIHVuZXhwZWN0ZWQgLWtvLSBhdHRyaWJ1dGUgaW4gY29tcGlsZWQgdGVtcGxhdGVcIiwgaWQsIFwiLCB5b3UgcHJvYmFibHkgbWlzcGVsbGVkIGl0OlwiLCB0cmFzaCk7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShpZCwgaHRtbCk7XG4gICAgICBjcmVhdGVkVGVtcGxhdGVzLnB1c2goaWQpO1xuICAgIH0sXG4gICAgZXhpc3RzOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIGVsID0gdGVtcGxhdGVTeXN0ZW0uZ2V0VGVtcGxhdGVDb250ZW50KGlkKTtcbiAgICAgIGlmICh0eXBlb2YgZWwgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gY3JlYXRlZFRlbXBsYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ZW1wbGF0ZVN5c3RlbS5yZW1vdmVUZW1wbGF0ZShjcmVhdGVkVGVtcGxhdGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLnRlbXBsYXRlRXhpc3RzID0gdGVtcGxhdGVzUGx1Z2luLmV4aXN0cztcblxuICAvLyB0ZW1wbGF0ZWNyZWF0b3IgdHJhY2tzIGNyZWF0ZWQgdGVtcGxhdGUgKHZpYSB0ZW1wbGF0ZUFkZGVyKSBzbyB0byBiZSBhYmxlIHRvIGRpc3Bvc2UgdGhlbSBsYXRlclxuICB2YXIgbXlUZW1wbGF0ZUNyZWF0b3IgPSB0ZW1wbGF0ZUNyZWF0b3IuYmluZCh1bmRlZmluZWQsIHRlbXBsYXRlc1BsdWdpbik7XG5cbiAgLy8gZmlyc3QgcGFzczogd2UgXCJjb21waWxlXCIgdGhlIHRlbXBsYXRlIGludG8gYSB0ZXJtcGxhdGVEZWYgb2JqZWN0XG4gIHZhciB0ZW1wbGF0ZURlZiA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ3RyYW5zbGF0ZVRlbXBsYXRlJywgdGVtcGxhdGVDb252ZXJ0ZXIudHJhbnNsYXRlVGVtcGxhdGUuYmluZCh1bmRlZmluZWQsIHRlbXBsYXRlTmFtZSwgaHRtbCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG15VGVtcGxhdGVDcmVhdG9yKSk7XG5cbiAgLy8gc2Vjb25kIHBhc3M6IGdpdmVuIHRoZSB0ZW1wbGF0ZURlZiB3ZSBjcmVhdGUgYSBiYXNlIGNvbnRlbnQgbW9kZWwgb2JqZWN0IGZvciB0aGlzIHRlbXBsYXRlLlxuICB2YXIgY29udGVudCA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ2dlbmVyYXRlTW9kZWwnLCB0ZW1wbGF0ZUNvbnZlcnRlci53cmFwcGVkUmVzdWx0TW9kZWwuYmluZCh1bmRlZmluZWQsIHRlbXBsYXRlRGVmKSk7XG5cbiAgLy8gdGhpcmQgcGFzczogd2UgY3JlYXRlIFwic3R5bGUvY29udGVudCBlZGl0b3JzXCIgZm9yIGV2ZXJ5IGJsb2NrXG4gIHZhciB3aWRnZXRzID0ge307XG4gIHZhciB3aWRnZXRQbHVnaW5zID0gcGx1Z2luc0NhbGwocGx1Z2lucywgJ3dpZGdldCcsIFskLCBrbywga29qcXVpXSk7XG4gIGZvciAodmFyIHdpID0gMDsgd2kgPCB3aWRnZXRQbHVnaW5zLmxlbmd0aDsgd2krKykge1xuICAgIHdpZGdldHNbd2lkZ2V0UGx1Z2luc1t3aV0ud2lkZ2V0XSA9IHdpZGdldFBsdWdpbnNbd2ldO1xuICB9XG4gIGJsb2NrRGVmcy5wdXNoLmFwcGx5KGJsb2NrRGVmcywgcGVyZm9ybWFuY2VBd2FyZUNhbGxlcignZ2VuZXJhdGVFZGl0b3JzJywgdGVtcGxhdGVDb252ZXJ0ZXIuZ2VuZXJhdGVFZGl0b3JzLmJpbmQodW5kZWZpbmVkLCB0ZW1wbGF0ZURlZiwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG15VGVtcGxhdGVDcmVhdG9yLCBiYXNlVGhyZXNob2xkKSkpO1xuXG4gIHZhciBpbmNvbXBhdGlibGVUZW1wbGF0ZSA9IGZhbHNlO1xuICBpZiAodHlwZW9mIGpzb3Jqc29uICE9PSAndW5kZWZpbmVkJyAmJiBqc29yanNvbiAhPT0gbnVsbCkge1xuICAgIHZhciB1bndyYXBwZWQ7XG4gICAgaWYgKHR5cGVvZiBqc29yanNvbiA9PSAnc3RyaW5nJykge1xuICAgICAgdW53cmFwcGVkID0ga28udXRpbHMucGFyc2VKc29uKGpzb3Jqc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW53cmFwcGVkID0ganNvcmpzb247XG4gICAgfVxuXG4gICAgLy8gd2UgcnVuIGEgYmFzaWMgY29tcGF0aWJpbGl0eSBjaGVjayBiZXR3ZWVuIHRoZSBjb250ZW50LW1vZGVsIHdlIGV4cGVjdCBhbmQgdGhlIGluaXRpYWxpemF0aW9uIG1vZGVsXG4gICAgdmFyIGNoZWNrTW9kZWxSZXMgPSBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKCdjaGVja01vZGVsJywgdGVtcGxhdGVDb252ZXJ0ZXIuY2hlY2tNb2RlbC5iaW5kKHVuZGVmaW5lZCwgY29udGVudC5fdW53cmFwKCksIGJsb2NrRGVmcywgdW53cmFwcGVkKSk7XG4gICAgLy8gaWYgY2hlY2tNb2RlbFJlcyBpcyAxIHRoZW4gdGhlIG1vZGVsIGlzIG5vdCBmdWxseSBjb21wYXRpYmxlIGJ1dCB3ZSBmaXhlZCBpdFxuICAgIGlmIChjaGVja01vZGVsUmVzID09IDIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcnlpbmcgdG8gY29tcGlsZSBhbiBpbmNvbXBhdGlibGUgdGVtcGxhdGUgdmVyc2lvbiFcIiwgY29udGVudC5fdW53cmFwKCksIGJsb2NrRGVmcywgdW53cmFwcGVkKTtcbiAgICAgIGluY29tcGF0aWJsZVRlbXBsYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29udGVudC5fd3JhcCh1bndyYXBwZWQpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluamVjdCBtb2RlbCBjb250ZW50IVwiLCBleCk7XG4gICAgICBpbmNvbXBhdGlibGVUZW1wbGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBidWlsZCB0aGUgdGVtcGxhdGUgZm9yIHRoZSBwcmV2aWV3L291dHB1dCwgYnV0IGNvbmNhdGVuYXRpbmcgcHJlZml4LCB0ZW1wbGF0ZSBhbmQgY29udGVudCBhbmQgc3RyaXBwaW5nIHRoZSBcInJlcGxhY2VkXCIgcHJlZml4IGFkZGVkIHRvIFwicHJvYmxlbWF0aWNcIiB0YWcgKGh0bWwvaGVhZC9ib2R5KVxuICB2YXIgaWZyYW1lVHBsID0gcHJlZml4ICsgdGVtcGxhdGVTeXN0ZW0uZ2V0VGVtcGxhdGVDb250ZW50KHRlbXBsYXRlTmFtZSArICctaWZyYW1lJykucmVwbGFjZSgvKDxcXC8/KXJlcGxhY2VkKGh0bWx8aGVhZHxib2R5KShbXj5dKj4pL2dpLCBmdW5jdGlvbihtYXRjaCwgcDEsIHAyLCBwMykge1xuICAgIHJldHVybiBwMSArIHAyICsgcDM7XG4gIH0pICsgcG9zdGZpeDtcblxuICAvLyBzdG9yZSB0aGlzIHNvIHRvIHJlc3RvcmUgaXQgb24gZGlzcG9zYWxlXG4gIHZhciBvcmlnaUZyYW1lVHBsID0ga28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsO1xuICBrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGwgPSBpZnJhbWVUcGw7XG4gIHZhciBpRnJhbWVQbHVnaW4gPSB7XG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGwgPSBvcmlnaUZyYW1lVHBsO1xuICAgIH1cbiAgfTtcblxuICBwbHVnaW5zLnB1c2goaUZyYW1lUGx1Z2luKTtcbiAgcGx1Z2lucy5wdXNoKHRlbXBsYXRlc1BsdWdpbik7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgdmlld01vZGVsIG9iamVjdCBiYXNlZCBvbiB0aGUgY29udGVudCBtb2RlbC5cbiAgdmFyIHZpZXdNb2RlbCA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ2luaXRpYWxpemVWaWV3bW9kZWwnLCBpbml0aWFsaXplVmlld21vZGVsLmJpbmQodGhpcywgY29udGVudCwgYmxvY2tEZWZzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgZ2FsbGVyeVVybCkpO1xuXG4gIHZpZXdNb2RlbC5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAvLyBsZXQncyBydW4gc29tZSB2ZXJzaW9uIGNoZWNrIG9uIHRlbXBsYXRlIGFuZCBlZGl0b3IgdXNlZCB0byBidWlsZCB0aGUgbW9kZWwgYmVpbmcgbG9hZGVkLlxuICB2YXIgZWRpdHZlciA9ICcwLjE2LjAnO1xuICBpZiAodHlwZW9mIHZpZXdNb2RlbC5tZXRhZGF0YS5lZGl0b3J2ZXJzaW9uICE9PSAndW5kZWZpbmVkJyAmJiB2aWV3TW9kZWwubWV0YWRhdGEuZWRpdG9ydmVyc2lvbiAhPT0gZWRpdHZlcikge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBtb2RlbCBiZWluZyBsb2FkZWQgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGFuIG9sZGVyIGVkaXRvciB2ZXJzaW9uXCIsIHZpZXdNb2RlbC5tZXRhZGF0YS5lZGl0b3J2ZXJzaW9uLCBcInZzXCIsIGVkaXR2ZXIpO1xuICB9XG4gIHZpZXdNb2RlbC5tZXRhZGF0YS5lZGl0b3J2ZXJzaW9uID0gZWRpdHZlcjtcblxuICBpZiAodHlwZW9mIHRlbXBsYXRlRGVmLnZlcnNpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3TW9kZWwubWV0YWRhdGEudGVtcGxhdGV2ZXJzaW9uICE9PSAndW5kZWZpbmVkJyAmJiB2aWV3TW9kZWwubWV0YWRhdGEudGVtcGxhdGV2ZXJzaW9uICE9PSB0ZW1wbGF0ZURlZi52ZXJzaW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhlIG1vZGVsIGJlaW5nIGxvYWRlZCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYSBkaWZmZXJlbnQgdGVtcGxhdGUgdmVyc2lvblwiLCB0ZW1wbGF0ZURlZi52ZXJzaW9uLCBcInZzXCIsIHZpZXdNb2RlbC5tZXRhZGF0YS50ZW1wbGF0ZXZlcnNpb24pO1xuICAgIH1cbiAgICB2aWV3TW9kZWwubWV0YWRhdGEudGVtcGxhdGV2ZXJzaW9uID0gdGVtcGxhdGVEZWYudmVyc2lvbjtcbiAgfVxuXG4gIHRlbXBsYXRlU3lzdGVtLmluaXQoKTtcblxuICAvLyBldmVyeXRoaW5nJ3MgcmVhZHksIHN0YXJ0IGtub2Nrb3V0IGJpbmRpbmdzLlxuICBwbHVnaW5zLnB1c2goYmluZGluZ1BsdWdpbk1ha2VyKHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIpKTtcblxuICBwbHVnaW5zQ2FsbChwbHVnaW5zLCAndmlld01vZGVsJywgW3ZpZXdNb2RlbF0pO1xuXG4gIGlmIChpbmNvbXBhdGlibGVUZW1wbGF0ZSkge1xuICAgICQoJyNpbmNvbXBhdGlibGUtdGVtcGxhdGUnKS5kaWFsb2coe1xuICAgICAgbW9kYWw6IHRydWUsXG4gICAgICBhcHBlbmRUbzogJyNtby1ib2R5JyxcbiAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgT2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICQodGhpcykuZGlhbG9nKFwiY2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbW9kZWw6IHZpZXdNb2RlbCxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHBsdWdpbnNDYWxsKHBsdWdpbnMsICdpbml0JywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcGx1Z2luc0NhbGwocGx1Z2lucywgJ2Rpc3Bvc2UnLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cbiAgfTtcblxufTtcblxuXG52YXIgY2hlY2tGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSwgZnVuYykge1xuICBpZiAoIWZ1bmMoKSkge1xuICAgIGNvbnNvbGUud2FybihcIk1pc3NpbmcgZmVhdHVyZVwiLCBmZWF0dXJlKTtcbiAgICB0aHJvdyBcIk1pc3NpbmcgZmVhdHVyZSBcIiArIGZlYXR1cmU7XG4gIH1cbn07XG5cbnZhciBpc0NvbXBhdGlibGUgPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyB3aW5kb3cubXNNYXRjaE1lZGlhIHdvdWxkIG1hdGNoIGFsc28gSUU5XG4gICAgLy8gSUU5IHdvdWxkbid0IGJlIHNvIGhhcmQgdG8gc3VwcG9ydCwgYnV0IGl0IGRvZXNuJ3Qgd29ydGggaXQuIChwcmV2aWV3IGlmcmFtZSBhbmQgYXV0b21hdGljIHNjcm9sbCBhcmUgMiB0aGluZ3Mgbm90IHdvcmtpbmcgaW4gSUU5KVxuICAgIGNoZWNrRmVhdHVyZSgnbWF0Y2hNZWRpYScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBnbG9iYWwubWF0Y2hNZWRpYSAhPSAndW5kZWZpbmVkJztcbiAgICB9KTtcbiAgICBjaGVja0ZlYXR1cmUoJ1hNTEh0dHBSZXF1ZXN0IDInLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnWE1MSHR0cFJlcXVlc3QnIGluIGdsb2JhbCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSk7XG4gICAgY2hlY2tGZWF0dXJlKCdFUzUgc3RyaWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8qIFwidXNlIHN0cmljdFwiOyovXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PSAndW5kZWZpbmVkJztcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgICBjaGVja0ZlYXR1cmUoJ0NTUyBib3JkZXJSYWRpdXMnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LmJvZHkuc3R5bGVbJ2JvcmRlclJhZGl1cyddICE9ICd1bmRlZmluZWQnO1xuICAgIH0pO1xuICAgIGNoZWNrRmVhdHVyZSgnQ1NTIGJveFNoYWRvdycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQuYm9keS5zdHlsZVsnYm94U2hhZG93J10gIT0gJ3VuZGVmaW5lZCc7XG4gICAgfSk7XG4gICAgY2hlY2tGZWF0dXJlKCdDU1MgYm94U2l6aW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbC5kb2N1bWVudC5ib2R5LnN0eWxlWydib3hTaXppbmcnXSAhPSAndW5kZWZpbmVkJztcbiAgICB9KTtcbiAgICBjaGVja0ZlYXR1cmUoJ0NTUyBiYWNrZ3JvdW5kU2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQuYm9keS5zdHlsZVsnYmFja2dyb3VuZFNpemUnXSAhPSAndW5kZWZpbmVkJztcbiAgICB9KTtcbiAgICBjaGVja0ZlYXR1cmUoJ0NTUyBiYWNrZ3JvdW5kT3JpZ2luJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbC5kb2N1bWVudC5ib2R5LnN0eWxlWydiYWNrZ3JvdW5kT3JpZ2luJ10gIT0gJ3VuZGVmaW5lZCc7XG4gICAgfSk7XG4gICAgY2hlY2tCYWRCcm93c2VyRXh0ZW5zaW9ucygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBjaGVja0JhZEJyb3dzZXJFeHRlbnNpb25zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZCA9ICdjaGVja2JhZGJyb3dzZXJzZnJhbWUnO1xuICB2YXIgb3JpZ1RwbCA9IGtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbDtcbiAga28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsID0gXCI8IURPQ1RZUEUgaHRtbD5cXHJcXG48aHRtbD5cXHJcXG48aGVhZD48dGl0bGU+QTwvdGl0bGU+XFxyXFxuPC9oZWFkPlxcclxcbjxib2R5PjxwIHN0eWxlPVxcXCJjb2xvcjogYmx1ZVxcXCIgYWxpZ249XFxcInJpZ2h0XFxcIiBkYXRhLWJpbmQ9XFxcInN0eWxlOiB7IGNvbG9yOiAncmVkJyB9XFxcIj5CPC9wPjxkaXYgZGF0YS1iaW5kPVxcXCJ0ZXh0OiBjb250ZW50XFxcIj48L2Rpdj48L2JvZHk+XFxyXFxuPC9odG1sPlxcclxcblwiO1xuICAkKCdib2R5JykuYXBwZW5kKCc8aWZyYW1lIGlkPVwiJyArIGlkICsgJ1wiIGRhdGEtYmluZD1cImJpbmRJZnJhbWU6ICRkYXRhXCI+PC9pZnJhbWU+Jyk7XG4gIHZhciBmcmFtZUVsID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAga28uYXBwbHlCaW5kaW5ncyh7IGNvbnRlbnQ6IFwiZHVtbXkgY29udGVudFwiIH0sIGZyYW1lRWwpO1xuICAvLyBPYnNvbGV0ZSBtZXRob2QgZGlkbid0IHdvcmsgb24gSUUxMSB3aGVuIHVzaW5nIFwiSFRNTDUgZG9jdHlwZVwiOlxuICAvLyB2YXIgZG9jVHlwZSA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZ2xvYmFsLmRvY3VtZW50LmRvY3R5cGUpO1xuICB2YXIgbm9kZSA9IGZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudC5kb2N0eXBlO1xuICB2YXIgZG9jVHlwZSA9IFwiPCFET0NUWVBFIFwiICsgbm9kZS5uYW1lICtcbiAgICAobm9kZS5wdWJsaWNJZCA/ICcgUFVCTElDIFwiJyArIG5vZGUucHVibGljSWQgKyAnXCInIDogJycpICtcbiAgICAoIW5vZGUucHVibGljSWQgJiYgbm9kZS5zeXN0ZW1JZCA/ICcgU1lTVEVNJyA6ICcnKSArXG4gICAgKG5vZGUuc3lzdGVtSWQgPyAnIFwiJyArIG5vZGUuc3lzdGVtSWQgKyAnXCInIDogJycpICsgJz4nO1xuICB2YXIgY29udGVudCA9IGRvY1R5cGUgKyBcIlxcblwiICsgZnJhbWVFbC5jb250ZW50V2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gIGtvLmNsZWFuTm9kZShmcmFtZUVsKTtcbiAga28ucmVtb3ZlTm9kZShmcmFtZUVsKTtcbiAga28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsID0gb3JpZ1RwbDtcblxuICB2YXIgZXhwZWN0ZWQgPSBcIjwhRE9DVFlQRSBodG1sPlxcbjxodG1sPjxoZWFkPjx0aXRsZT5BPC90aXRsZT5cXG48L2hlYWQ+XFxuPGJvZHk+PHAgYWxpZ249XFxcInJpZ2h0XFxcIiBzdHlsZT1cXFwiY29sb3I6IHJlZDtcXFwiIGRhdGEtYmluZD1cXFwic3R5bGU6IHsgY29sb3I6ICdyZWQnIH1cXFwiPkI8L3A+PGRpdiBkYXRhLWJpbmQ9XFxcInRleHQ6IGNvbnRlbnRcXFwiPmR1bW15IGNvbnRlbnQ8L2Rpdj5cXG5cXG48L2JvZHk+PC9odG1sPlwiO1xuICB2YXIgZXhwZWN0ZWQyID0gXCI8IURPQ1RZUEUgaHRtbD5cXG48aHRtbD48aGVhZD48dGl0bGU+QTwvdGl0bGU+XFxuPC9oZWFkPlxcbjxib2R5PjxwIHN0eWxlPVxcXCJjb2xvcjogcmVkO1xcXCIgZGF0YS1iaW5kPVxcXCJzdHlsZTogeyBjb2xvcjogJ3JlZCcgfVxcXCIgYWxpZ249XFxcInJpZ2h0XFxcIj5CPC9wPjxkaXYgZGF0YS1iaW5kPVxcXCJ0ZXh0OiBjb250ZW50XFxcIj5kdW1teSBjb250ZW50PC9kaXY+XFxuXFxuPC9ib2R5PjwvaHRtbD5cIjtcbiAgdmFyIGV4cGVjdGVkMyA9IFwiPCFET0NUWVBFIGh0bWw+XFxuPGh0bWw+PGhlYWQ+PHRpdGxlPkE8L3RpdGxlPlxcbjwvaGVhZD5cXG48Ym9keT48cCBzdHlsZT1cXFwiY29sb3I6IHJlZDtcXFwiIGFsaWduPVxcXCJyaWdodFxcXCIgZGF0YS1iaW5kPVxcXCJzdHlsZTogeyBjb2xvcjogJ3JlZCcgfVxcXCI+QjwvcD48ZGl2IGRhdGEtYmluZD1cXFwidGV4dDogY29udGVudFxcXCI+ZHVtbXkgY29udGVudDwvZGl2PlxcblxcbjwvYm9keT48L2h0bWw+XCI7XG4gIGlmIChleHBlY3RlZCAhPT0gY29udGVudCAmJiBleHBlY3RlZDIgIT09IGNvbnRlbnQgJiYgZXhwZWN0ZWQzICE9PSBjb250ZW50KSB7XG4gICAgY29uc29sZS5pbmZvKFwiQmFkQnJvd3Nlci5GcmFtZUNvbnRlbnRDaGVja1wiLCBjb250ZW50Lmxlbmd0aCwgZXhwZWN0ZWQubGVuZ3RoLCBleHBlY3RlZDIubGVuZ3RoLCBleHBlY3RlZDMubGVuZ3RoLCBjb250ZW50ID09IGV4cGVjdGVkLCBjb250ZW50ID09IGV4cGVjdGVkMiwgY29udGVudCA9PSBleHBlY3RlZDMpO1xuICAgIGNvbnNvbGUuaW5mbyhjb250ZW50KTtcbiAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZnJhbWUgY29udGVudC4gTWlzYmVoYXZpbmcgYnJvd3NlcjogXCIrY29udGVudC5sZW5ndGgrXCIvXCIrZXhwZWN0ZWQubGVuZ3RoK1wiL1wiK2V4cGVjdGVkMi5sZW5ndGgrXCIvXCIrZXhwZWN0ZWQzLmxlbmd0aDtcbiAgfVxufTtcblxudmFyIGZpeFBhZ2VFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gVGhpcyBpcyBnbG9iYWwgY29kZSB0byBwcmV2ZW50IGRyYWdnaW5nL2Ryb3BwaW5nIGluIHRoZSBwYWdlIHdoZXJlIHdlIGRvbid0IGRlYWwgd2l0aCBpdC5cbiAgLy8gSUU4IGRvZXNuJ3QgaGF2ZSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCBkcmFnJmRyb3AgdG9vLlxuICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAvLyBwcmV2ZW50IGdlbmVyaWMgZmlsZSBkcm9wcHBpbmcgaW4gdGhlIHBhZ2VcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJicm93c2VyIGlzIHVzaW5nIGRyYWcgbGlzdGVuZXIgb24gd2luZG93XCIpO1xuICAgICAgZSA9IGUgfHwgZ2xvYmFsLmV2ZW50O1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImJyb3dzZXIgaXMgdXNpbmcgZHJhZ3N0YXJ0IGxpc3RlbmVyIG9uIHdpbmRvd1wiKTtcbiAgICAgIGUgPSBlIHx8IGdsb2JhbC5ldmVudDtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyB0aGlzIGlzIGNhbGxlZCBvbiBtb3VzZSBtb3ZlIG9uIGV2ZXJ5IHN1cHBvcnRlZCBicm93c2VyLlxuICAgICAgLy8gY29uc29sZS5sb2coXCJicm93c2VyIGlzIHVzaW5nIGRyYWdvdmVyIGxpc3RlbmVyIG9uIHdpbmRvd1wiKTtcbiAgICAgIGUgPSBlIHx8IGdsb2JhbC5ldmVudDtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYnJvd3NlciBpcyB1c2luZyBkcm9wIGxpc3RlbmVyIG9uIHdpbmRvd1wiKTtcbiAgICAgIGUgPSBlIHx8IGdsb2JhbC5ldmVudDtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIEkgYnJvd3NlciBzdXBwb3J0YXRpIGVudHJhdG8gdHV0dGkgcXVpIHF1YW5kbyBzaSBkcm9wcGEgcXVhbGNvc2Egc3VsIGJvZHlcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYnJvd3NlciBpcyB1c2luZyBkcm9wIGxpc3RlbmVyIG9uIGJvZHkgdGFnXCIpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuICBpZiAoZ2xvYmFsLmRvY3VtZW50Lm9uZHJhZ3N0YXJ0KSB7XG4gICAgZ2xvYmFsLmRvY3VtZW50Lm9uZHJhZ3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImJyb3dzZXIgY2FsbGVkIG9uZHJhZ3N0YXJ0LiByZXR1cm4gZmFsc2UhXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21waWxlOiB0ZW1wbGF0ZUNvbXBpbGVyLFxuICBsb2FkOiB0ZW1wbGF0ZUxvYWRlcixcbiAgaXNDb21wYXRpYmxlOiBpc0NvbXBhdGlibGUsXG4gIGZpeFBhZ2VFdmVudHM6IGZpeFBhZ2VFdmVudHNcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxudmFyIF9jYWxsID0gZnVuY3Rpb24od2hhdFRvQ2FsbCkge1xuICByZXR1cm4gd2hhdFRvQ2FsbCgpO1xufTtcblxudmFyIGxvZ3MgPSBbXTtcblxudmFyIF90aW1lZENhbGwgPSBmdW5jdGlvbihuYW1lLCB3aGF0VG9DYWxsKSB7XG4gIHZhciByZXM7XG4gIHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gJ29iamVjdCcgJiYgY29uc29sZS50aW1lKSBjb25zb2xlLnRpbWUobmFtZSk7XG4gIHJlcyA9IF9jYWxsKHdoYXRUb0NhbGwpO1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gJ29iamVjdCcgJiYgY29uc29sZS50aW1lKSBjb25zb2xlLnRpbWVFbmQobmFtZSk7XG4gIHZhciBkaWZmID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydDtcbiAgaWYgKHR5cGVvZiBjb25zb2xlID09ICdvYmplY3QnICYmICFjb25zb2xlLnRpbWUpIGNvbnNvbGUubG9nKG5hbWUsIFwidG9va1wiLCBkaWZmLCBcIm1zXCIpO1xuICBsb2dzLnB1c2goe1xuICAgIG5hbWU6IG5hbWUsXG4gICAgdGltZTogZGlmZlxuICB9KTtcbiAgLy8gbWF4IGxvZ3NcbiAgaWYgKGxvZ3MubGVuZ3RoID4gMTAwKSBsb2dzLnVuc2hpZnQoKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0aW1lZENhbGw6IF90aW1lZENhbGwsXG4gIGxvZ3M6IGxvZ3Ncbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIHVuZG9NYW5hZ2VyID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9rbm9ja291dC11bmRvbWFuYWdlci9rbm9ja291dC11bmRvbWFuYWdlci5qc1wiKTtcbnZhciB1bmRvc2VyaWFsaXplciA9IHJlcXVpcmUoXCIuL3VuZG9zZXJpYWxpemVyLmpzXCIpO1xuXG52YXIgYWRkVW5kb1N0YWNrRXh0ZW5zaW9uTWFrZXIgPSBmdW5jdGlvbihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbih2aWV3TW9kZWwpIHtcblxuICAgIHZpZXdNb2RlbC5jb250ZW50TGlzdGVuZXJzKHZpZXdNb2RlbC5jb250ZW50TGlzdGVuZXJzKCkgKyAyKTtcblxuICAgIC8vIFRPRE8gdGhlIGxhYmVscyBzaG91bGQgYmUgY29tcHV0ZWQgb2JzZXJ2YWJsZXMgKG5lZWRzIGNoYW5nZXMgaW4gdW5kb21hbmFnZXIgcHJvamVjdHMpXG4gICAgdmFyIHVuZG9SZWRvU3RhY2sgPSB1bmRvTWFuYWdlcih2aWV3TW9kZWwuY29udGVudCwge1xuICAgICAgbGV2ZWxzOiAxMDAsXG4gICAgICB1bmRvTGFiZWw6IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkgeyByZXR1cm4gdmlld01vZGVsLnQoXCJVbmRvICgjQ09VTlQjKVwiKTsgfSksXG4gICAgICByZWRvTGFiZWw6IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkgeyByZXR1cm4gdmlld01vZGVsLnQoXCJSZWRvXCIpOyB9KVxuICAgIH0pO1xuICAgIHZpZXdNb2RlbC51bmRvID0gdW5kb1JlZG9TdGFjay51bmRvQ29tbWFuZDtcbiAgICB2aWV3TW9kZWwudW5kby5leGVjdXRlID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlci5iaW5kKHZpZXdNb2RlbCwgJ3VuZG8nLCB2aWV3TW9kZWwudW5kby5leGVjdXRlKTtcbiAgICB2aWV3TW9kZWwucmVkbyA9IHVuZG9SZWRvU3RhY2sucmVkb0NvbW1hbmQ7XG4gICAgdmlld01vZGVsLnJlZG8uZXhlY3V0ZSA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIuYmluZCh2aWV3TW9kZWwsICdyZWRvJywgdmlld01vZGVsLnJlZG8uZXhlY3V0ZSk7XG4gICAgdmlld01vZGVsLnVuZG9SZXNldCA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIuYmluZCh2aWV3TW9kZWwsICd1bmRvUmVzZXQnLCB1bmRvUmVkb1N0YWNrLnJlc2V0KTtcbiAgICB2aWV3TW9kZWwuc2V0VW5kb01vZGVNZXJnZSA9IHVuZG9SZWRvU3RhY2suc2V0TW9kZU1lcmdlO1xuICAgIHZpZXdNb2RlbC5zZXRVbmRvTW9kZU9uY2UgPSB1bmRvUmVkb1N0YWNrLnNldE1vZGVPbmNlO1xuICAgIHVuZG9SZWRvU3RhY2suc2V0TW9kZUlnbm9yZSgpO1xuICAgIHVuZG9SZWRvU3RhY2suc2V0VW5kb0FjdGlvbk1ha2VyKHVuZG9zZXJpYWxpemVyLm1ha2VVbmRvQWN0aW9uLmJpbmQodW5kZWZpbmVkLCB2aWV3TW9kZWwuY29udGVudCkpO1xuICAgIHVuZG9zZXJpYWxpemVyLndhdGNoRW5hYmxlZCh0cnVlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHVuZG9SZWRvU3RhY2suc2V0TW9kZUlnbm9yZSgpO1xuICAgICAgfSxcbiAgICAgIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHVuZG9SZWRvU3RhY2suc2V0TW9kZU9uY2UoKTtcbiAgICAgIH0sXG4gICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdW5kb1JlZG9TdGFjay5zZXRNb2RlT25jZSgpO1xuICAgICAgfSxcbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2aWV3TW9kZWwuY29udGVudExpc3RlbmVycyh2aWV3TW9kZWwuY29udGVudExpc3RlbmVycygpIC0gMik7XG4gICAgICAgIHVuZG9zZXJpYWxpemVyLndhdGNoRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIHVuZG9SZWRvU3RhY2suZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkVW5kb1N0YWNrRXh0ZW5zaW9uTWFrZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG4vLyBUaGlzIG1vZHVsZSBkZWFscyB3aXRoIHNlcmlhbGl6YXRpb24vZGVzZXJpYWxpemF0aW9uIG9mIGEgXCJ0cmVlLXBhdGhcIiByZXByZXNlbnRpbmcgdGhlIHBhdGggdG8gcmVhY2ggdGhlIGdpdmVuIGxlYWYuXG4vLyBJbiBvcmRlciB0byBiZSBjb3JyZWN0bHkgc2VyaWFsaXplZCB3ZSBoYXZlIHRvIG1vdmUgZnJvbSBcInJlZmVyZW5jZVwiIHRvIFwic3RyaW5nXCIgYW5kIHZpY2V2ZXJzYS5cblxudmFyIF9yZWZlcmVuY2UgPSBmdW5jdGlvbihtb2RlbCwgcGF0aCkge1xuICB2YXIgcCA9IDA7XG4gIHZhciBwMSwgcDI7XG4gIHZhciBtID0gbW9kZWw7XG4gIHdoaWxlIChwIDwgcGF0aC5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKHBhdGguY2hhckF0KHApKSB7XG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgaWYgKHBhdGguY2hhckF0KHAgKyAxKSA9PSAnKScpIHtcbiAgICAgICAgICBtID0gbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRPRE8gZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBwICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIHAyID0gcGF0aC5pbmRleE9mKCddJywgcCk7XG4gICAgICAgIG0gPSBtW3BhdGguc3Vic3RyaW5nKHAgKyAxLCBwMildO1xuICAgICAgICBwID0gcDIgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy4nOlxuICAgICAgICBwMSA9IHBhdGguaW5kZXhPZignKCcsIHApO1xuICAgICAgICBpZiAocDEgPT0gLTEpIHAxID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIHAyID0gcGF0aC5pbmRleE9mKCdbJywgcCk7XG4gICAgICAgIGlmIChwMiA9PSAtMSkgcDIgPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgcDIgPSBNYXRoLm1pbihwMSwgcDIpO1xuICAgICAgICBtID0gbVtwYXRoLnN1YnN0cmluZyhwICsgMSwgcDIpXTtcbiAgICAgICAgcCA9IHAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRPRE8gZXJyb3JcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG52YXIgX2dldFBhdGggPSBmdW5jdGlvbihwYXJlbnRzLCBjaGlsZCkge1xuICB2YXIgcGF0aCA9IFwiXCI7XG4gIHZhciBwO1xuICBmb3IgKHZhciBrID0gMDsgayA8PSBwYXJlbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgcCA9IGsgPCBwYXJlbnRzLmxlbmd0aCA/IHBhcmVudHNba10gOiBjaGlsZDtcbiAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHApKSBwYXRoICs9ICcoKSc7XG4gICAgaWYgKHR5cGVvZiBwLl9maWVsZE5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXRoICs9IFwiLlwiICsgcC5fZmllbGROYW1lO1xuICAgIH0gZWxzZSBpZiAoayA+IDAgJiYgdHlwZW9mIHBhcmVudHNbayAtIDFdLnBvcCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50QXJyYXkgPSBrby5pc09ic2VydmFibGUocGFyZW50c1trIC0gMV0pID8ga28udXRpbHMucGVla09ic2VydmFibGUocGFyZW50c1trIC0gMV0pIDogcGFyZW50c1trIC0gMV07XG4gICAgICB2YXIgcG9zID0ga28udXRpbHMuYXJyYXlJbmRleE9mKHBhcmVudEFycmF5LCBwKTtcbiAgICAgIGlmIChwb3MgIT0gLTEpIHtcbiAgICAgICAgcGF0aCArPSBcIltcIiArIHBvcyArIFwiXVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTk9URSB0aGlzIGhhcHBlbiwgc29tZXRpbWVzIHdoZW4gVGlueU1DRSBzZW5kcyB1cGRhdGVzIGZvciBvYmplY3RzIGFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgb2JqZWN0IG5vdCBmb3VuZCBpbiBwYXJlbnQgYXJyYXlcIiwgcGFyZW50QXJyYXksIHAsIGssIHBhcmVudHMubGVuZ3RoLCBrby50b0pTKHBhcmVudEFycmF5KSwga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShwKSk7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBvYmplY3Qgbm90IGZvdW5kIGluIHBhcmVudCBhcnJheVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBwYXJlbnQgd2l0aCBubyBfZmllbGROYW1lIGFuZCBubyBwYXJlbnQgYXJyYXlcIiwgaywgcGFyZW50cyk7XG4gICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgcGFyZW50IHdpdGggbm8gX2ZpZWxkTmFtZSBhbmQgbm8gcGFyZW50IGFycmF5XCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoO1xufTtcblxudmFyIG1ha2VEZXJlZmVyZW5jZWRVbmRvQWN0aW9uID0gZnVuY3Rpb24odW5kb0Z1bmMsIG1vZGVsLCBwYXRoLCB2YWx1ZSwgaXRlbSkge1xuICB2YXIgY2hpbGQgPSBfcmVmZXJlbmNlKG1vZGVsLCBwYXRoKTtcbiAgdW5kb0Z1bmMoY2hpbGQsIHZhbHVlLCBpdGVtKTtcbn07XG5cbnZhciBsaXN0ZW5lcjtcblxudmFyIF9zZXRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmZ1bmMpIHtcbiAgbGlzdGVuZXIgPSBsaXN0ZW5mdW5jO1xufTtcblxuLyogZGVyZWZlcmVuY2luZyBwYXRoIGFuZCBjaGFuZ2luZyB2YWx1ZSB3aXRoIFwidG9KU1wiICovXG52YXIgbWFrZVVuZG9BY3Rpb25EZXJlZmVyZW5jZWQgPSBmdW5jdGlvbihtb2RlbCwgdW5kb0Z1bmMsIHBhcmVudHMsIGNoaWxkLCBvbGRWYWwsIGl0ZW0pIHtcbiAgdHJ5IHtcbiAgICB2YXIgcGF0aCA9IF9nZXRQYXRoKHBhcmVudHMsIGNoaWxkKTtcblxuICAgIC8vIFRyYW5zZm9ybSBhY3Rpb25zIGluIHNpbXBsZSBKUyBvYmplY3RzLlxuICAgIGlmICh0eXBlb2Ygb2xkVmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2xkVmFsID09PSAnZnVuY3Rpb24nKSBvbGRWYWwgPSBrby50b0pTKG9sZFZhbCk7XG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIGl0ZW0udmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpdGVtLnZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgdmFyIG5ld0l0ZW0gPSBrby50b0pTKGl0ZW0pO1xuICAgICAgaXRlbSA9IG5ld0l0ZW07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKHBhdGgsIGNoaWxkLCBvbGRWYWwsIGl0ZW0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVuZG9zZXJpYWxpemVyIGlnbm9yaW5nIGV4Y2VwdGlvbiBpbiBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZURlcmVmZXJlbmNlZFVuZG9BY3Rpb24uYmluZCh1bmRlZmluZWQsIHVuZG9GdW5jLCBtb2RlbCwgcGF0aCwgb2xkVmFsLCBpdGVtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5PVEUgdGhpcyBoYXBwZW5zLCBmcm9tIHRpbWUgdG8gdGltZSwgd2hlbiBUaW55TUNFIHNlbmRzIHVwZGF0ZXMgZm9yIGRlbGV0ZWQgY29udGVudC5cbiAgICBjb25zb2xlLmVycm9yKFwiRXhjZXB0aW9uIHByb2Nlc3NpbmcgdW5kb1wiLCBlLCBwYXJlbnRzLCBjaGlsZCwgaXRlbSk7XG4gIH1cbn07XG5cbnZhciB3YXRjaEVuYWJsZWQ7XG52YXIgX3dhdGNoRW5hYmxlZCA9IGZ1bmN0aW9uKG5ld1ZhbCkge1xuICBpZiAodHlwZW9mIG5ld1ZhbCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgd2F0Y2hFbmFibGVkID0gbmV3VmFsO1xuICBlbHNlXG4gICAgcmV0dXJuIHdhdGNoRW5hYmxlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXJlZmVyZW5jZTogX2dldFBhdGgsXG4gIHJlZmVyZW5jZTogX3JlZmVyZW5jZSxcbiAgbWFrZVVuZG9BY3Rpb246IG1ha2VVbmRvQWN0aW9uRGVyZWZlcmVuY2VkLFxuICBzZXRMaXN0ZW5lcjogX3NldExpc3RlbmVyLFxuICB3YXRjaEVuYWJsZWQ6IF93YXRjaEVuYWJsZWRcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgcGVyZm9ybWFuY2VBd2FyZUNhbGxlciA9IHJlcXVpcmUoXCIuL3RpbWVkLWNhbGwuanNcIikudGltZWRDYWxsO1xuXG52YXIgdG9hc3RyID0gcmVxdWlyZShcIi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy90b2FzdHIvdG9hc3RyLmpzXCIpO1xudG9hc3RyLm9wdGlvbnMgPSB7XG4gIFwiY2xvc2VCdXR0b25cIjogZmFsc2UsXG4gIFwiZGVidWdcIjogZmFsc2UsXG4gIFwicG9zaXRpb25DbGFzc1wiOiBcInRvYXN0LWJvdHRvbS1mdWxsLXdpZHRoXCIsXG4gIFwidGFyZ2V0XCI6IFwiI21vLWJvZHlcIixcbiAgXCJvbmNsaWNrXCI6IG51bGwsXG4gIFwic2hvd0R1cmF0aW9uXCI6IFwiMzAwXCIsXG4gIFwiaGlkZUR1cmF0aW9uXCI6IFwiMTAwMFwiLFxuICBcInRpbWVPdXRcIjogXCI1MDAwXCIsXG4gIFwiZXh0ZW5kZWRUaW1lT3V0XCI6IFwiMTAwMFwiLFxuICBcInNob3dFYXNpbmdcIjogXCJzd2luZ1wiLFxuICBcImhpZGVFYXNpbmdcIjogXCJsaW5lYXJcIixcbiAgXCJzaG93TWV0aG9kXCI6IFwiZmFkZUluXCIsXG4gIFwiaGlkZU1ldGhvZFwiOiBcImZhZGVPdXRcIlxufTtcblxuLyogTk9URTogdHJhbnNsYXRpb25zIG1vdmVkIHRvIFwicGx1Z2luXCJcbnZhciBzdHJpbmdzID0ge1xuICAnc2hvdyBwcmV2aWV3IGFuZCBzZW5kIHRlc3QnOiAnVmlzdWFsaXp6YSB1bmEgYW50ZXByaW1hIGUgZmFpIHVuIGludmlvIGRpIHRlc3QnLFxuICAvLyBTdHJpbmdzIGZvciBhcHAuanNcbiAgJ0Rvd25sb2FkJzogJ0Rvd25sb2FkJyxcbiAgJ1Rlc3QnOiAnVGVzdCcsXG4gICdTYXZlJzogJ1NhbHZhJyxcbiAgJ0Rvd25sb2FkaW5nLi4uJzogXCJEb3dubG9hZCBpbiBjb3Jzby4uLlwiLFxuICAnSW52YWxpZCBlbWFpbCBhZGRyZXNzJzogXCJJbmRpcml6em8gZW1haWwgaW52YWxpZG9cIixcbiAgXCJUZXN0IGVtYWlsIHNlbnQuLi5cIjogXCJFbWFpbCBkaSB0ZXN0IGludmlhdGEuLi5cIixcbiAgJ1VuZXhwZWN0ZWQgZXJyb3IgdGFsa2luZyB0byBzZXJ2ZXI6IGNvbnRhY3QgdXMhJzogJ0Vycm9yZSBkaSBjb211bmljYXppb25lIGNvbiBpbCBzZXJ2ZXI6IGNvbnRhdHRhY2khJyxcbiAgJ0luc2VydCBoZXJlIHRoZSByZWNpcGllbnQgZW1haWwgYWRkcmVzcyc6ICdJbnNlcmlzY2kgcXVpIGxcXCdpbmRpcml6em8gZW1haWwgYSBjdWkgc3BlZGlyZScsXG4gIFwiVGVzdCBlbWFpbCBhZGRyZXNzXCI6IFwiSW5kaXJpenpvIGVtYWlsIGRpIHRlc3RcIixcbiAgLy8gdmlld01vZGVsXG4gICdCbG9jayByZW1vdmVkOiB1c2UgdW5kbyBidXR0b24gdG8gcmVzdG9yZSBpdC4uLic6ICdCbG9jY28gZWxpbWluYXRvOiB1c2EgaWwgcHVsc2FudGUgYW5udWxsYSBwZXIgcmVjdXBlcmFybG8uLi4nLFxuICAnTmV3IGJsb2NrIGFkZGVkIGFmdGVyIHRoZSBzZWxlY3RlZCBvbmUgKF9fcG9zX18pJzogJ051b3ZvIGJsb2NjbyBhZ2dpdW50byBzb3R0byBhIHF1ZWxsbyBzZWxlemlvbmF0byAoX19wb3NfXyknLFxuICAnTmV3IGJsb2NrIGFkZGVkIGF0IHRoZSBtb2RlbCBib3R0b20gKF9fcG9zX18pJzogJ051b3ZvIGJsb2NjbyBhZ2dpdW50byBpbiBmb25kbyBhbCBtb2RlbGxvIChfX3Bvc19fKScsXG4gIC8vIHVuZG9tYWluLmpzXG4gICdVbmRvICgjQ09VTlQjKSc6ICdBbm51bGxhICgjQ09VTlQjKScsXG4gICdSZWRvJzogJ1JpcHJpc3RpbmEnLFxuICAvLyBlZGl0b3IuanNcbiAgJ1NlbGVjdGVkIGVsZW1lbnQgaGFzIG5vIGVkaXRhYmxlIHByb3BlcnRpZXMnOiAnTFxcJ2VsZW1lbnRvIHNlbGV6aW9uYXRvIG5vbiBmb3JuaXNjZSBwcm9wcmlldMOgIGVkaXRhYmlsaScsXG4gICdUaGlzIHN0eWxlIGlzIHNwZWNpZmljIGZvciB0aGlzIGJsb2NrOiBjbGljayBoZXJlIHRvIHJlbW92ZSB0aGUgY3VzdG9tIHN0eWxlIGFuZCByZXZlcnQgdG8gdGhlIHRoZW1lIHZhbHVlJzogJ1F1ZXN0byBzdGlsZSDDqCBzcGVjaWZpY28gZGkgcXVlc3RvIGJsb2NjbzogY2xpY2NhIHF1aSBwZXIgYW5udWxsYXJlIGxvIHN0aWxlIHBlcnNvbmFsaXp6YXRvJyxcbiAgJ1N3aXRjaCBiZXR3ZWVuIGdsb2JhbCBhbmQgYmxvY2sgbGV2ZWwgc3R5bGVzIGVkaXRpbmcnOiAnUGVybWV0dGUgZGkgc3BlY2lmaWNhcmUgc2Ugc2kgdnVvbGUgbW9kaWZpY2FyZSBsbyBzdGlsZSBnZW5lcmFsZSBvIHNvbGFtZW50ZSBxdWVsbG8gc3BlY2lmaWNvIGRlbCBibG9jY28gc2VsZXppb25hdG8nLFxuICAvLyBtYWluLnRwbC5odG1sXG4gICdVbmRvIGxhc3Qgb3BlcmF0aW9uJzogJ0FubnVsbGEgdWx0aW1hIG9wZXJhemlvbmUnLFxuICAnUmVkbyBsYXN0IG9wZXJhdGlvbic6ICdSaXBldGkgb3BlcmF6aW9uZSBhbm51bGxhdGEnLFxuICAnU2hvdyBpbWFnZSBnYWxsZXJ5JzogJ1Zpc3VhbGl6emEgZ2FsbGVyaWEgaW1tYWdpbmknLFxuICAnR2FsbGVyeSc6ICdHYWxsZXJpYScsXG4gICdQcmV2aWV3JzogJ0FudGVwcmltYScsXG4gICdTaG93IGxpdmUgcHJldmlldyc6ICdNb3N0cmEgYW50ZXByaW1hIGxpdmUnLFxuICAnTGFyZ2Ugc2NyZWVuJzogJ1NjaGVybW8gZ3JhbmRlJyxcbiAgJ1RhYmxldCc6ICdUYWJsZXQnLFxuICAnU21hcnRwaG9uZSc6ICdTbWFydHBob25lJyxcbiAgJ1Nob3cgcHJldmlldyBhbmQgc2VuZCB0ZXN0JzogJ1Zpc3VhbGl6emEgdW5hIGFudGVwcmltYSBlIGZhaSB1biBpbnZpbyBkaSB0ZXN0JyxcbiAgJ0Rvd25sb2FkIHRlbXBsYXRlJzogJ1NjYXJpY2EgaWwgdGVtcGxhdGUnLFxuICAnU2F2ZSB0ZW1wbGF0ZSc6ICdTYWx2YSBpbCB0ZW1wbGF0ZScsXG4gICdTYXZlZCBtb2RlbCBpcyBvYnNvbGV0ZSc6ICdNb2RlbGxvIHNhbHZhdG8gb2Jzb2xldG8nLFxuICAnPHA+VGhlIHNhdmVkIG1vZGVsIGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBhIHByZXZpb3VzLCBub24gY29tcGxldGVseSBjb21wYXRpYmxlIHZlcnNpb24sIG9mIHRoZSB0ZW1wbGF0ZTwvcD48cD5Tb21lIGNvbnRlbnQgb3Igc3R5bGUgaW4gdGhlIG1vZGVsIDxiPkNPVUxEIEJFIExPU1Q8L2I+IGlmIHlvdSB3aWxsIDxiPnNhdmU8L2I+PC9wPjxwPkNvbnRhY3QgdXMgZm9yIG1vcmUgaW5mb3JtYXRpb25zITwvcD4nOiAnPHA+SWwgbW9kZWxsbyBzYWx2YXRvIMOoIHN0YXRvIGNyZWF0byBjb24gdW5hIHZlcnNpb25lIHByZWNlZGVudGUgZGVsIHRlbXBsYXRlIG5vbiBkZWwgdHV0dG8gY29tcGF0aWJpbGU8L3A+PHA+QWxjdW5pIGNvbnRlbnV0aSBvIHN0aWxpIGRlbCBtb2RlbGxvIDxiPlBPVFJFQkJFUk8gRVNTRVJFIFBFUlNJPC9iPiBzZSBwcm9jZWRlcmFpIGUgZGVjaWRlcmFpIGRpIDxiPnNhbHZhcmU8L2I+PC9wPjxwPkNvbnRhdHRhY2kgc2UgaGFpIGRlaSBkdWJiaSE8L3A+JyxcblxuICAvLyBUT0RPIHRoaXMgY2Fubm90IGJlIGRvbmUgaW4ga25vY2tvdXQgYXMgd2l0aCB1bmNvbXBhdGlibGUgYnJvd3NlcnMgd2UgZG9uJ3QgaW5pdGlhbGl6ZVxuICAvLyAnVXN1cHBvcnRlZCBicm93c2VyJzogJ0Jyb3dzZXIgbm9uIGNvbXBhdGliaWxlJyxcbiAgLy8gJzxwPllvdXIgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLjwvcD48cD5Vc2UgYSBkaWZmZXJlbnQgYnJvd3NlciBvciB0cnkgdXBkYXJpbmcgeW91ciBicm93c2VyLjwvcD48cD5TdXBwb3J0ZWQgYnJvd3NlcnM6IDx1bD48bGk+SW50ZXJuZXQgRXhwbG9yZXIgJmd0Oz0gMTA8L2xpPjxsaT5Hb29nbGUgQ2hyb21lICZndDs9IDMwPC9saT48bGk+QXBwbGUgU2FmYXJpICZndDs9IDU8L2xpPjxsaT5Nb3ppbGxhIEZpcmVmaXggJmd0Oz0gMjA8L2xpPjwvdWw+PC9wPic6ICc8cD5JbCB0dW8gYnJvd3NlciBub24gw6ggc3VwcG9ydGF0by48L3A+PHA+QWNjZWRpIGNvbiB1biBicm93c2VyIGRpZmZlcmVudGUgbyBwcm92YSBhZCBhZ2dpb3JuYXJlIGlsIHR1byBicm93c2VyLjwvcD48cD5Ccm93c2VyIHN1cHBvcnRhdGk6IDx1bD48bGk+SW50ZXJuZXQgRXhwbG9yZXIgJmd0Oz0gMTA8L2xpPjxsaT5Hb29nbGUgQ2hyb21lICZndDs9IDMwPC9saT48bGk+QXBwbGUgU2FmYXJpICZndDs9IDU8L2xpPjxsaT5Nb3ppbGxhIEZpcmVmaXggJmd0Oz0gMjA8L2xpPjwvdWw+PC9wPicsXG5cbiAgLy8gdG9vbGJveFxuICAnQmxvY2tzJzogJ0Jsb2NjaGknLFxuICAnQmxvY2tzIHJlYWR5IHRvIGJlIGFkZGVkIHRvIHRoZSB0ZW1wbGF0ZSc6ICdFbGVuY28gY29udGVudXRpIGFnZ2l1bmdpYmlsaSBhbCBtZXNzYWdnaW8nLFxuICAnQ29udGVudCc6ICdDb250ZW51dG8nLFxuICAnRWRpdCBjb250ZW50IG9wdGlvbnMnOiAnTW9kaWZpY2Egb3B6aW9uaSBjb250ZW51dGknLFxuICAnU3R5bGUnOiAnU3RpbGUnLFxuICAnRWRpdCBzdHlsZSBvcHRpb25zJzogJ01vZGlmaWNhIG9wemlvbmkgZ3JhZmljaGUnLFxuICAnQmxvY2sgX19uYW1lX18nOiAnQmxvY2NvIF9fbmFtZV9fJyxcbiAgJ0NsaWNrIG9yIGRyYWcgdG8gYWRkIHRoaXMgYmxvY2sgdG8gdGhlIHRlbXBsYXRlJzogJ0NsaWNjYSBvIHRyYXNjaW5hIHBlciBhZ2dpdW5nZXJlIGFsIG1lc3NhZ2dpbycsXG4gICdBZGQnOiAnQWdnaXVuZ2knLFxuICAnQnkgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgY29udGVudCBvcHRpb25zLCBpZiBhbnksIHdpbGwgc2hvdyBoZXJlJzogJ0NsaWNjYW5kbyBzdSBhbGN1bmUgcGFydGkgZGVsIG1lc3NhZ2dpbyBzZWxlemlvbmVyYWkgdW4gYmxvY2NvIGUgbGUgb3B6aW9uaSBjb250ZW51dGlzdGljaGUsIHNlIGRpc3BvbmliaWxpLCBjb21wYXJpcmFubm8gcXVpJyxcbiAgJ0J5IGNsaWNraW5nIG9uIG1lc3NhZ2UgcGFydHMgeW91IHdpbGwgc2VsZWN0IGEgYmxvY2sgYW5kIHN0eWxlIG9wdGlvbnMsIGlmIGF2YWlsYWJsZSwgd2lsbCBzaG93IGhlcmUnOiAnQ2xpY2NhbmRvIHN1IGFsY3VuZSBwYXJ0aSBkZWwgbWVzc2FnZ2lvIHNlbGV6aW9uZXJhaSB1biBibG9jY28gZSBsZSBvcHppb25pIGRpIHN0aWxlLCBzZSBkaXNwb25pYmlsaSwgY29tcGFyaXJhbm5vIHF1aScsXG4gICdDbGljayBvciBkcmFnIGZpbGVzIGhlcmUnOiAnQ2xpY2NhIG8gdHJhc2NpbmEgaSBmaWxlIHF1aSEnLFxuICAnTm8gaW1hZ2VzIHVwbG9hZGVkLCB5ZXQnOiAnTm9uIGhhaSBhbmNvcmEgY2FyaWNhdG8gaW1tYWdpbmknLFxuICAnU2hvdyBpbWFnZXMgZnJvbSB0aGUgZ2FsbGVyeSc6ICdWaXN1YWxpenphIGxlIGltbWFnaW5pIGNhcmljYXRlIG5lbGxhIHR1YSBhcmVhJyxcbiAgJ0xvYWRpbmcuLi4nOiAnQ2FyaWNhbWVudG8uLi4nLFxuICAnTG9hZCBnYWxsZXJ5JzogJ0NhcmljYSBnYWxsZXJpYScsXG4gICdMb2FkaW5nIGdhbGxlcnkuLi4nOiAnQ2FyaWNhbWVudG8gaW4gY29yc28uLi4nLFxuICAnVGhlIGdhbGxlcnkgaXMgZW1wdHknOiAnTmVzc3VuYSBpbW1hZ2luZSBuZWxsYSBnYWxsZXJpYScsXG4gIC8vIGltZy13eXNpd3lnLnRtbHBcbiAgJ1JlbW92ZSBpbWFnZSc6ICdSaW11b3ZpIGltbWFnaW5lJyxcbiAgJ09wZW4gdGhlIGltYWdlIGVkaXRpbmcgdG9vbCc6ICdBdnZpYSBzdHJ1bWVudG8gbW9kaWZpY2EgaW1tYWdpbmUnLFxuICAnVXBsb2FkIGEgbmV3IGltYWdlJzogJ0NhcmljYSB1bmEgbnVvdmEgaW1tYWdpbmUnLFxuICAnRHJvcCBhbiBpbWFnZSBoZXJlJzogJ1RyYXNjaW5hIHVuYSBpbW1hZ2luZSBxdWknLFxuICAnRHJvcCBhbiBpbWFnZSBoZXJlIG9yIGNsaWNrIHRoZSB1cGxvYWQgYnV0dG9uJzogJ1RyYXNjaW5hIHVuYSBpbW1hZ2luZSBxdWkgbyBjbGljY2Egc3VsIHB1bHNhbnRlIGRpIGNhcmljYW1lbnRvJyxcbiAgLy8gZ2FsbGVyeVxuICAnRHJhZyB0aGlzIGltYWdlIGFuZCBkcm9wIGl0IG9uIGFueSB0ZW1wbGF0ZSBpbWFnZSBwbGFjZWhvbGRlcic6ICdUcmFzY2luYSBxdWVzdGEgaW1tYWdpbmUgc3VsbGEgcG9zaXppb25lIGluIGN1aSB2dW9pIGluc2VyaXJsYScsXG4gICdHYWxsZXJ5Oic6ICdHYWxsZXJpYTonLFxuICAnU2Vzc2lvbiBpbWFnZXMnOiAnSW1tYWdpbmkgZGkgc2Vzc2lvbmUnLFxuICAnUmVjZW50cyc6ICdSZWNlbnRpJyxcbiAgJ1JlbW90ZSBnYWxsZXJ5JzogJ0dhbGxlcmlhIHJlbW90YScsXG5cbiAgLy8gY3VzdG9tc3R5bGVcbiAgJ0N1c3RvbWl6ZWQgYmxvY2suPHVsPjxsaT5JbiB0aGlzIHN0YXR1cyBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgd2lsbCBiZSBzcGVjaWZpYyB0byB0aGUgY3VycmVudCBibG9jayAoaW5zdGVhZCBvZiBiZWluZyBnbG9iYWwgdG8gYWxsIGJsb2NrcyBpbiB0aGUgc2FtZSBzZWN0aW9uKTwvbGk+PGxpPkEgPHNwYW4gY2xhc3M9XCJjdXN0b21TdHlsZWRcIj48c3Bhbj5cInNtYWxsIGN1YmVcIiA8L3NwYW4+PC9zcGFuPiBpY29uIGJlc2lkZSB0aGUgcHJvcGVydHkgd2lsbCBtYXJrIHRoZSBjdXN0b21pemF0aW9uLiBCeSBjbGlja2luZyB0aGlzIGljb24gdGhlIHByb3BlcnR5IHZhbHVlIHdpbGwgYmUgcmV2ZXJ0ZWQgdG8gdGhlIHZhbHVlIGRlZmluZWQgZm9yIHRoZSBzZWN0aW9uLjwvbGk+PC91bD4nOiAnQmxvY2NvIHBlcnNvbmFsaXp6YXRvLjx1bD48bGk+SW4gcXVlc3RhIG1vZGFsaXTDoCBzZSBjYW1iaSB1bmEgcHJvcHJpZXTDoCB2ZXJyw6AgbW9kaWZpY2F0YSBzb2xhbWVudGUgcGVyIHF1ZXN0byBzcGVjaWZpY28gYmxvY2NvIChpbnZlY2UgY2hlIHBlciB0dXR0aSBpIGJsb2NjaGkgZGVsbGEgc3Rlc3NhIHNlemlvbmUpLjwvbGk+PGxpPlBlciBzZWduYWxhcmUgbGEgcGVyc29uYWxpenphemlvbmUgYXBwYXJpcsOgIGxcXCdpY29uYSA8c3BhbiBjbGFzcz1cImN1c3RvbVN0eWxlZFwiPjxzcGFuPiBkZWwgXCJjdWJldHRvXCI8L3NwYW4+PC9zcGFuPiBhIGZpYW5jbyBkZWxsZSBwcm9wcmlldMOgLiBDbGljY2FuZG8gcXVlc3RhIGljb25hIHRvcm5lcmFpIGFsIHZhbG9yZSBjb211bmUuPC9saT48L3VsPicsXG4gIC8vIGJsb2Nrcy13eXNpd3lnXG4gICdEcm9wIGhlcmUgYmxvY2tzIGZyb20gdGhlIFwiQmxvY2tzXCIgdGFiJzogJ1RyYXNjaW5hIHF1aSBpIGJsb2NjaGkgZGFsbGEgc2NoZWRhIFxcJ0Jsb2NjaGlcXCcnLFxuICAvLyBibG9jay13eXNpd3lnXG4gICdEcmFnIHRoaXMgaGFuZGxlIHRvIG1vdmUgdGhlIGJsb2NrJzogJ1RyYXNjaW5hIHBlciBzcG9zdGFyZSBpbCBibG9jY28gYWx0cm92ZScsXG4gICdNb3ZlIHRoaXMgYmxvY2sgdXBzaWRlJzogJ1Nwb3N0YSBpbCBibG9jY28gaW4gc3UnLFxuICAnTW92ZSB0aGlzIGJsb2NrIGRvd25zaWRlJzogJ1Nwb3N0YSBpbCBibG9jY28gaW4gZ2l1JyxcbiAgJ0RlbGV0ZSBibG9jayc6ICdFbGltaW5hIGJsb2NjbycsXG4gICdEdXBsaWNhdGUgYmxvY2snOiAnRHVwbGljYSBibG9jY28nLFxuICAnU3dpdGNoIGJsb2NrIHZhcmlhbnQnOiAnQ2FtYmlhIHZhcmlhbnRlIGJsb2NjbycsXG4gIC8vIGNvbG9ycGlja2VyXG4gICdUaGVtZSBDb2xvcnMsU3RhbmRhcmQgQ29sb3JzLFdlYiBDb2xvcnMsVGhlbWUgQ29sb3JzLEJhY2sgdG8gUGFsZXR0ZSxIaXN0b3J5LE5vIGhpc3RvcnkgeWV0Lic6ICdDb2xvcmkgVGVtYSxDb2xvcmkgU3RhbmRhcmQsQ29sb3JpIFdlYixDb2xvcmkgVGVtYSxUb3JuYSBhbGxhIHRhdm9sb3p6YSxTdG9yaWNvLHN0b3JpY28gY29sb3JpIHZ1b3RvJyxcblxuICAnRHJvcCBoZXJlJzogJ1JpbGFzY2lhIHF1aScsXG5cbn07XG4qL1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRWRpdG9yKGNvbnRlbnQsIGJsb2NrRGVmcywgdGh1bWJQYXRoQ29udmVydGVyLCBnYWxsZXJ5VXJsKSB7XG5cbiAgdmFyIHZpZXdNb2RlbCA9IHtcbiAgICBnYWxsZXJ5UmVjZW50OiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgIGdhbGxlcnlSZW1vdGU6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgc2VsZWN0ZWRCbG9jazoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICBzZWxlY3RlZEl0ZW06IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgc2VsZWN0ZWRUb29sOiBrby5vYnNlcnZhYmxlKDApLFxuICAgIHNlbGVjdGVkSW1hZ2VUYWI6IGtvLm9ic2VydmFibGUoMCksXG4gICAgZHJhZ2dpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIGRyYWdnaW5nSW1hZ2U6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIGdhbGxlcnlMb2FkZWQ6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHNob3dQcmV2aWV3RnJhbWU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHByZXZpZXdNb2RlOiBrby5vYnNlcnZhYmxlKCdtb2JpbGUnKSxcbiAgICBzaG93VG9vbGJveDoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICBzaG93VGhlbWU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHNob3dHYWxsZXJ5OiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICBkZWJ1Zzoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgY29udGVudExpc3RlbmVyczoga28ub2JzZXJ2YWJsZSgwKSxcblxuICAgIGxvZ29QYXRoOiAnZGlzdC9pbWcvbW9zYWljbzMyLnBuZycsXG4gICAgbG9nb1VybDogJy4nLFxuICAgIGxvZ29BbHQ6ICdtb3NhaWNvJ1xuICB9O1xuXG4gIC8vIHZpZXdNb2RlbC5jb250ZW50ID0gY29udGVudC5faW5zdHJ1bWVudChrbywgY29udGVudCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgdmlld01vZGVsLmNvbnRlbnQgPSBjb250ZW50O1xuICB2aWV3TW9kZWwuYmxvY2tEZWZzID0gYmxvY2tEZWZzO1xuXG4gIHZpZXdNb2RlbC5ub3RpZmllciA9IHRvYXN0cjtcblxuICAvLyBEb2VzIHRva2VuIHN1YnN0aXR1dGlvbiBpbiBpMThuZXh0IHN0eWxlXG4gIHZpZXdNb2RlbC50dCA9IGZ1bmN0aW9uKGtleSwgcGFyYW1PYmopIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtT2JqICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcGFyYW1PYmopXG4gICAgICAgIGlmIChwYXJhbU9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKG5ldyBSZWdFeHAoJ19fJyArIHByb3AgKyAnX18nLCAnZycpLCBwYXJhbU9ialtwcm9wXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9O1xuXG4gIC8vIFNpbXBseSBtYXBzIHRvIHR0OiBsYW5ndWFnZSBwbHVnaW5zIGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBkZWZpbmUgdGhlaXIgb3duIGxhbmd1YWdlXG4gIC8vIGhhbmRsaW5nLlxuICAvLyBJZiB0aGlzIG1ldGhvZCBpbnZva2VzIGFuIG9ic2VydmFibGUgKGUuZzogdmlld01vZGVsLmxhbmcoKSkgdGhlbiB0aGUgVUkgbGFuZ3VhZ2Ugd2lsbCBhdXRvbWF0aWNhbGx5XG4gIC8vIHVwZGF0ZSB3aGVuIHRoZSBcImxhbmdcIiBvYnNlcnZhYmxlIGNoYW5nZXMuXG4gIHZpZXdNb2RlbC50ID0gdmlld01vZGVsLnR0O1xuXG4gIC8vIGN1cnJlbnRseSBjYWxsZWQgYnkgZWRpdG9yLmh0bWwgdG8gdHJhbnNsYXRlIHRlbXBsYXRlLWRlZmluZWQga2V5cyAobGFiZWwsIGhlbHAsIGRlc2NyaXB0aW9ucylcbiAgLy8gdGhlIGVkaXRvciBhbHdheXMgdXNlcyB0aGUgXCJ0ZW1wbGF0ZVwiIGNhdGVnb3J5IGZvciB0aGF0IHN0cmluZ3MuXG4gIC8vIHlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgeW91IGxpa2UgaW4gb3JkZXIgdG8gcHJvdmlkZSB0cmFuc2xhdGlvbiBvciBjaGFuZ2UgdGhlIHN0cmluZ3MgaW4gYW55IHdheS5cbiAgdmlld01vZGVsLnV0ID0gZnVuY3Rpb24oY2F0ZWdvcnksIGtleSkge1xuICAgIHJldHVybiBrZXk7XG4gIH07XG5cbiAgdmlld01vZGVsLnRlbXBsYXRlUGF0aCA9IHRodW1iUGF0aENvbnZlcnRlcjtcblxuICB2aWV3TW9kZWwucmVtb3RlVXJsUHJvY2Vzc29yID0gZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfTtcblxuICB2aWV3TW9kZWwucmVtb3RlRmlsZVByb2Nlc3NvciA9IGZ1bmN0aW9uKGZpbGVPYmopIHtcbiAgICBpZiAodHlwZW9mIGZpbGVPYmoudXJsICE9PSAndW5kZWZpbmVkJykgZmlsZU9iai51cmwgPSB2aWV3TW9kZWwucmVtb3RlVXJsUHJvY2Vzc29yKGZpbGVPYmoudXJsKTtcbiAgICBpZiAodHlwZW9mIGZpbGVPYmoudGh1bWJuYWlsVXJsICE9PSAndW5kZWZpbmVkJykgZmlsZU9iai50aHVtYm5haWxVcmwgPSB2aWV3TW9kZWwucmVtb3RlVXJsUHJvY2Vzc29yKGZpbGVPYmoudGh1bWJuYWlsVXJsKTtcbiAgICAvLyBkZWxldGVVcmw/XG4gICAgcmV0dXJuIGZpbGVPYmo7XG4gIH07XG5cbiAgLy8gdG9vbGJveC50bXBsLmh0bWxcbiAgdmlld01vZGVsLmxvYWRHYWxsZXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmlld01vZGVsLmdhbGxlcnlMb2FkZWQoJ2xvYWRpbmcnKTtcbiAgICB2YXIgdXJsID0gZ2FsbGVyeVVybCA/IGdhbGxlcnlVcmwgOiAnL3VwbG9hZC8nO1xuICAgIC8vIHJldHJpZXZlIHRoZSBmdWxsIGxpc3Qgb2YgcmVtb3RlIGZpbGVzXG4gICAgJC5nZXRKU09OKHVybCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZpbGVzLmxlbmd0aDsgaSsrKSBkYXRhLmZpbGVzW2ldID0gdmlld01vZGVsLnJlbW90ZUZpbGVQcm9jZXNzb3IoZGF0YS5maWxlc1tpXSk7XG4gICAgICB2aWV3TW9kZWwuZ2FsbGVyeUxvYWRlZChkYXRhLmZpbGVzLmxlbmd0aCk7XG4gICAgICAvLyBUT0RPIGRvIEkgd2FudCB0aGlzIGNhbGwgdG8gcmV0dXJuIHJlbGF0aXZlIHBhdGhzPyBPciBqdXN0IGFic29sdXRlIHBhdGhzP1xuICAgICAgdmlld01vZGVsLmdhbGxlcnlSZW1vdGUoZGF0YS5maWxlcy5yZXZlcnNlKCkpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICB2aWV3TW9kZWwuZ2FsbGVyeUxvYWRlZChmYWxzZSk7XG4gICAgICB2aWV3TW9kZWwubm90aWZpZXIuZXJyb3Iodmlld01vZGVsLnQoJ1VuZXhwZWN0ZWQgZXJyb3IgbGlzdGluZyBmaWxlcycpKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBpbWctd3lzaXd5Zy50bXBsLmh0bWxcbiAgdmlld01vZGVsLmZpbGVUb0ltYWdlID0gZnVuY3Rpb24ob2JqLCBldmVudCwgdWkpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcImZpbGVUb0ltYWdlXCIsIG9iaik7XG4gICAgcmV0dXJuIG9iai51cmw7XG4gIH07XG5cbiAgLy8gYmxvY2std3lzaXd5Zy50bXBsLmh0bWxcbiAgdmlld01vZGVsLnJlbW92ZUJsb2NrID0gZnVuY3Rpb24oZGF0YSwgcGFyZW50KSB7XG4gICAgLy8gbGV0J3MgdW5zZWxlY3QgdGhlIGJsb2NrXG4gICAgaWYgKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmlld01vZGVsLnNlbGVjdGVkQmxvY2spID09IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZGF0YSkpIHtcbiAgICAgIHZpZXdNb2RlbC5zZWxlY3RCbG9jayhudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHBhcmVudC5ibG9ja3MucmVtb3ZlKGRhdGEpO1xuICAgIC8vIFRPRE8gVGhpcyBtZXNzYWdlIHNob3VsZCBiZSBkaWZmZXJlbnQgZGVwZW5kaW5nIG9uIHVuZG8gcGx1Z2luIHByZXNlbmNlLlxuICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KCdCbG9jayByZW1vdmVkOiB1c2UgdW5kbyBidXR0b24gdG8gcmVzdG9yZSBpdC4uLicpKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIGJsb2NrLXd5c2l3eWcudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5kdXBsaWNhdGVCbG9jayA9IGZ1bmN0aW9uKGluZGV4LCBwYXJlbnQpIHtcbiAgICB2YXIgaWR4ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpbmRleCk7XG4gICAgLy8gRGVpbnN0cnVtZW50L2Rlb2JzZXJ2ZSB0aGUgb2JqZWN0XG4gICAgdmFyIHVud3JhcHBlZCA9IGtvLnRvSlMoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShwYXJlbnQuYmxvY2tzKVtpZHhdKTtcbiAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgaWQgc28gdGhhdCBhIG5ldyBvbmUgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgY2xvbmVcbiAgICBpZiAodHlwZW9mIHVud3JhcHBlZC5pZCAhPT0gJ3VuZGVmaW5lZCcpIHVud3JhcHBlZC5pZCA9ICcnO1xuICAgIC8vIGluc2VydCB0aGUgY2xvbmVkIGJsb2NrXG4gICAgcGFyZW50LmJsb2Nrcy5zcGxpY2UoaWR4ICsgMSwgMCwgdW53cmFwcGVkKTtcbiAgfTtcblxuICAvLyBibG9jay13eXNpd3lnLnRtcGwuaHRtbFxuICB2aWV3TW9kZWwubW92ZUJsb2NrID0gZnVuY3Rpb24oaW5kZXgsIHBhcmVudCwgdXApIHtcbiAgICB2YXIgaWR4ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpbmRleCk7XG4gICAgdmFyIHBhcmVudEJsb2NrcyA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocGFyZW50LmJsb2Nrcyk7XG4gICAgaWYgKCh1cCAmJiBpZHggPiAwKSB8fCAoIXVwICYmIGlkeCA8IHBhcmVudEJsb2Nrcy5sZW5ndGggLSAxKSkge1xuICAgICAgdmFyIGRlc3RJbmRleCA9IGlkeCArICh1cCA/IC0xIDogMSk7XG4gICAgICB2YXIgZGVzdEJsb2NrID0gcGFyZW50QmxvY2tzW2Rlc3RJbmRleF07XG4gICAgICB2aWV3TW9kZWwuc3RhcnRNdWx0aXBsZSgpO1xuICAgICAgcGFyZW50LmJsb2Nrcy5zcGxpY2UoZGVzdEluZGV4LCAxKTtcbiAgICAgIHBhcmVudC5ibG9ja3Muc3BsaWNlKGlkeCwgMCwgZGVzdEJsb2NrKTtcbiAgICAgIHZpZXdNb2RlbC5zdG9wTXVsdGlwbGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gdGVzdCBtZXRob2QsIGNvbW1hbmQgbGluZSB1c2Ugb25seVxuICB2aWV3TW9kZWwubG9hZERlZmF1bHRCbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjbG9uaW5nIHRoZSB3aG9sZSBcIm1haW5CbG9ja3NcIiBvYmplY3Qgc28gdGhhdCB1bmRvbWFuYWdlciB3aWxsXG4gICAgLy8gc2VlIGl0IGFzIGEgc2luZ2xlIG9wZXJhdGlvbiAobWF5YmUgSSBjb3VsZCB1c2UgXCJzdGFydE11bHRpcGxlXCIvXCJzdG9wTXVsdGlwbGVcIi5cbiAgICB2YXIgcmVzID0ga28udG9KUyh2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MpO1xuICAgIHJlcy5ibG9ja3MgPSBbXTtcbiAgICB2YXIgaW5wdXQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZpZXdNb2RlbC5ibG9ja0RlZnMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBrby50b0pTKGlucHV0W2ldKTtcbiAgICAgIC8vIGdlbmVyYXRpbmcgaWRzIGZvciBibG9ja3MsIG1heWJlIHRoaXMgd291bGQgd29yayBhbHNvIGxlYXZpbmcgaXQgZW1wdHkuXG4gICAgICBvYmouaWQgPSAnYmxvY2tfJyArIGk7XG4gICAgICByZXMuYmxvY2tzLnB1c2gob2JqKTtcbiAgICB9XG4gICAgcGVyZm9ybWFuY2VBd2FyZUNhbGxlcignc2V0TWFpbkJsb2NrcycsIHZpZXdNb2RlbC5jb250ZW50KCkubWFpbkJsb2Nrcy5fd3JhcC5iaW5kKHZpZXdNb2RlbC5jb250ZW50KCkubWFpbkJsb2NrcywgcmVzKSk7XG4gIH07XG5cbiAgLy8gZ2FsbGVyeS1pbWFnZXMudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5hZGRJbWFnZSA9IGZ1bmN0aW9uKGltZykge1xuICAgIHZhciBzZWxlY3RlZEltZyA9ICQoJyNtYWluLXd5c2l3eWctYXJlYSAuc2VsZWN0YWJsZS1pbWcuc2VsZWN0ZWRpdGVtJyk7XG4gICAgaWYgKHNlbGVjdGVkSW1nLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBpbWcgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGltZy51cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBrby5jb250ZXh0Rm9yKHNlbGVjdGVkSW1nWzBdKS5fc3JjKGltZy51cmwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gdG9vbGJveC50bXBsLmh0bWxcbiAgdmlld01vZGVsLmFkZEJsb2NrID0gZnVuY3Rpb24ob2JqLCBldmVudCkge1xuICAgIC8vIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgYmxvY2sgd2UgdHJ5IHRvIGFkZCB0aGUgYmxvY2sganVzdCBhZnRlciB0aGUgc2VsZWN0ZWQgb25lLlxuICAgIHZhciBzZWxlY3RlZCA9IHZpZXdNb2RlbC5zZWxlY3RlZEJsb2NrKCk7XG4gICAgLy8gc2VhcmNoIHRoZSBzZWxlY3RlZCBibG9jayBwb3NpdGlvbi5cbiAgICB2YXIgZm91bmQ7XG4gICAgaWYgKHNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPIFwibWFpbkJsb2Nrc1wiIGlzIGFuIGhhcmRjb2RlZCB0aGluZy5cbiAgICAgIGZvciAodmFyIGkgPSB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodmlld01vZGVsLmNvbnRlbnQoKS5tYWluQmxvY2tzKCkuYmxvY2tzKClbaV0oKSA9PSBzZWxlY3RlZCkge1xuICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcG9zO1xuICAgIGlmICh0eXBlb2YgZm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwb3MgPSBmb3VuZCArIDE7XG4gICAgICB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3Muc3BsaWNlKHBvcywgMCwgb2JqKTtcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KCdOZXcgYmxvY2sgYWRkZWQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG9uZSAoX19wb3NfXyknLCB7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdNb2RlbC5jb250ZW50KCkubWFpbkJsb2NrcygpLmJsb2Nrcy5wdXNoKG9iaik7XG4gICAgICBwb3MgPSB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKS5sZW5ndGggLSAxO1xuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmluZm8odmlld01vZGVsLnQoJ05ldyBibG9jayBhZGRlZCBhdCB0aGUgbW9kZWwgYm90dG9tIChfX3Bvc19fKScsIHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgbmV3bHkgYWRkZWQgYmxvY2sgYW5kIHNlbGVjdCBpdCFcbiAgICB2YXIgYWRkZWQgPSB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKVtwb3NdKCk7XG4gICAgdmlld01vZGVsLnNlbGVjdEJsb2NrKGFkZGVkLCB0cnVlKTtcbiAgICAvLyBwcmV2ZW50IGNsaWNrIHByb3BhZ2F0aW9uIChsb3NpbmcgdXJsIGhhc2ggLSBzZWUgIzQzKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBVc2VkIGJ5IHN0eWxlc2hlZXQuanMgdG8gY3JlYXRlIG11bHRpcGxlIHN0eWxlc1xuICB2aWV3TW9kZWwuZmluZE9iamVjdHNPZlR5cGUgPSBmdW5jdGlvbihkYXRhLCB0eXBlKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBvYmogPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEpO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB2YXIgdmFsID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvYmpbcHJvcF0pO1xuICAgICAgICAvLyBUT0RPIHRoaXMgaXMgbm90IHRoZSByaWdodCB3YXkgdG8gZGVhbCB3aXRoIFwiYmxvY2sgbGlzdFwiIG9iamVjdHMuXG4gICAgICAgIGlmIChwcm9wLm1hdGNoKC9CbG9ja3MkLykpIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbC5ibG9ja3MpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShjb250ZW50c1tpXSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGMudHlwZSkgPT0gdHlwZSkgcmVzLnB1c2goYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8gaW52ZXN0aWdhdGUgd2hpY2ggY29uZGl0aW9uIHByb3ZpZGUgYSBudWxsIHZhbHVlLlxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwgfHwga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWwudHlwZSkgPT0gdHlwZSkgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLypcbiAgdmlld01vZGVsLnBsYWNlaG9sZGVySGVscGVyID0gJ3NvcnRhYmxlLXBsYWNlaG9sZGVyJztcbiAgaWYgKGZhbHNlKSB7XG4gICAgdmlld01vZGVsLnBsYWNlaG9sZGVySGVscGVyID0ge1xuICAgICAgZWxlbWVudDogZnVuY3Rpb24oY3VycmVudEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICQoJzxkaXYgLz4nKS5yZW1vdmVDbGFzcygndWktZHJhZ2dhYmxlJykuYWRkQ2xhc3MoJ3NvcnRhYmxlLXBsYWNlaG9sZGVyJykuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpLmNzcygnd2lkdGgnLCAnMTAwJScpLmNzcygnaGVpZ2h0JywgY3VycmVudEl0ZW0uY3NzKCdoZWlnaHQnKSkuY3NzKCdvcGFjaXR5JywgJy44JylbMF07XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihjb250YWluZXIsIHApIHtcbiAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAqL1xuXG4gIC8vIEF0dGVtcHQgdG8gaW5zZXJ0IHRoZSBibG9jayBpbiB0aGUgZGVzdGluYXRpb24gbGF5b3V0IGR1cmluZyBkcmFnZ2luZ1xuICB2aWV3TW9kZWwucGxhY2Vob2xkZXJIZWxwZXIgPSB7XG4gICAgZWxlbWVudDogZnVuY3Rpb24oY3VycmVudEl0ZW0pIHtcbiAgICAgIHJldHVybiAkKGN1cnJlbnRJdGVtWzBdLm91dGVySFRNTCkucmVtb3ZlQ2xhc3MoJ3VpLWRyYWdnYWJsZScpLmFkZENsYXNzKCdzb3J0YWJsZS1wbGFjZWhvbGRlcicpLmNzcygnZGlzcGxheScsICdibG9jaycpLmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKS5jc3MoJ3dpZHRoJywgJzEwMCUnKS5jc3MoJ2hlaWdodCcsICdhdXRvJykuY3NzKCdvcGFjaXR5JywgJy44JylbMF07XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPIHRoZSB1bmR1bWFuYWdlciBzaG91bGQgYmUgcGx1Z2dhYmxlLlxuICAvLyBVc2VkIGJ5IFwibW92ZUJsb2NrXCIgYW5kIGJsb2Nrcy13eXNpd3lnLnRtcGwuaHRtbCB0byBcIm1lcmdlXCIgZHJhZy9kcm9wIG9wZXJhdGlvbnMgaW50byBhIHNpbmdsZSB1bmRvL3JlZG8gb3AuXG4gIHZpZXdNb2RlbC5zdGFydE11bHRpcGxlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3TW9kZWwuc2V0VW5kb01vZGVNZXJnZSAhPT0gJ3VuZGVmaW5lZCcpIHZpZXdNb2RlbC5zZXRVbmRvTW9kZU1lcmdlKCk7XG4gIH07XG4gIHZpZXdNb2RlbC5zdG9wTXVsdGlwbGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHZpZXdNb2RlbC5zZXRVbmRvTW9kZU9uY2UgIT09ICd1bmRlZmluZWQnKSB2aWV3TW9kZWwuc2V0VW5kb01vZGVPbmNlKCk7XG4gIH07XG5cbiAgLy8gVXNlZCBieSBjb2RlIGdlbmVyYXRlZCBieSBlZGl0b3IuanNcbiAgdmlld01vZGVsLmxvY2FsR2xvYmFsU3dpdGNoID0gZnVuY3Rpb24ocHJvcCwgZ2xvYmFsUHJvcCkge1xuICAgIHZhciBjdXJyZW50ID0gcHJvcCgpO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSBwcm9wKGdsb2JhbFByb3AoKSk7XG4gICAgZWxzZSBwcm9wKG51bGwpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBVc2VkIGJ5IGVkaXRvciBhbmQgbWFpbiBcImNvbnZlcnRlclwiIHRvIHN1cHBvcnQgaXRlbSBzZWxlY3Rpb25cbiAgdmlld01vZGVsLnNlbGVjdEl0ZW0gPSBmdW5jdGlvbih2YWx1ZUFjY2Vzc29yLCBpdGVtLCBibG9jaykge1xuICAgIHZhciB2YWwgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKTtcbiAgICBpZiAodHlwZW9mIGJsb2NrICE9PSAndW5kZWZpbmVkJykgdmlld01vZGVsLnNlbGVjdEJsb2NrKGJsb2NrLCBmYWxzZSwgdHJ1ZSk7XG4gICAgaWYgKHZhbCAhPSBpdGVtKSB7XG4gICAgICB2YWx1ZUFjY2Vzc29yKGl0ZW0pO1xuICAgICAgLy8gT24gc2VsZWN0SXRlbSBpZiB3ZSB3ZXJlIG9uIFwiQmxvY2tzXCIgdG9vbGJveCB0YWIgd2UgbW92ZSB0byBcIkNvbnRlbnRcIiB0b29sYm94IHRhYi5cbiAgICAgIGlmIChpdGVtICE9PSBudWxsICYmIHZpZXdNb2RlbC5zZWxlY3RlZFRvb2woKSA9PT0gMCkgdmlld01vZGVsLnNlbGVjdGVkVG9vbCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LmJpbmQodmlld01vZGVsLCB2aWV3TW9kZWwuc2VsZWN0ZWRJdGVtKTtcblxuICB2aWV3TW9kZWwuaXNTZWxlY3RlZEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHZpZXdNb2RlbC5zZWxlY3RlZEl0ZW0oKSA9PSBpdGVtO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5zZWxlY3RCbG9jayA9IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IsIGl0ZW0sIGRvTm90U2VsZWN0LCBkb05vdFVuc2VsZWN0SXRlbSkge1xuICAgIHZhciB2YWwgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKTtcbiAgICBpZiAoIWRvTm90VW5zZWxlY3RJdGVtKSB2aWV3TW9kZWwuc2VsZWN0SXRlbShudWxsKTtcbiAgICBpZiAodmFsICE9IGl0ZW0pIHtcbiAgICAgIHZhbHVlQWNjZXNzb3IoaXRlbSk7XG4gICAgICAvLyBoaWRlIGdhbGxlcnkgb24gYmxvY2sgc2VsZWN0aW9uXG4gICAgICB2aWV3TW9kZWwuc2hvd0dhbGxlcnkoZmFsc2UpO1xuICAgICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgIWRvTm90U2VsZWN0ICYmIHZpZXdNb2RlbC5zZWxlY3RlZFRvb2woKSA9PT0gMCkgdmlld01vZGVsLnNlbGVjdGVkVG9vbCgxKTtcbiAgICB9XG4gIH0uYmluZCh2aWV3TW9kZWwsIHZpZXdNb2RlbC5zZWxlY3RlZEJsb2NrKTtcblxuICAvLyBERUJVR1xuICB2aWV3TW9kZWwuY291bnRTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24obW9kZWwsIGRlYnVnKSB7XG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBtb2RlbClcbiAgICAgIGlmIChtb2RlbC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB2YXIgcCA9IG1vZGVsW3Byb3BdO1xuICAgICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHApKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwLl9kZWZhdWx0Q29tcHV0ZWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVidWcgIT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUubG9nKGRlYnVnICsgXCIvXCIgKyBwcm9wICsgXCIvX1wiLCBwLl9kZWZhdWx0Q29tcHV0ZWQuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkpO1xuICAgICAgICAgICAgcmVzICs9IHAuX2RlZmF1bHRDb21wdXRlZC5nZXRTdWJzY3JpcHRpb25zQ291bnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBkZWJ1ZyAhPSAndW5kZWZpbmVkJykgY29uc29sZS5sb2coZGVidWcgKyBcIi9cIiArIHByb3AgKyBcIi8tXCIsIHAuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkpO1xuICAgICAgICAgIHJlcyArPSBwLmdldFN1YnNjcmlwdGlvbnNDb3VudCgpO1xuICAgICAgICAgIHAgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcCA9PSAnb2JqZWN0JyAmJiBwICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHRvdCA9IHZpZXdNb2RlbC5jb3VudFN1YnNjcmlwdGlvbnMocCwgdHlwZW9mIGRlYnVnICE9ICd1bmRlZmluZWQnID8gZGVidWcgKyAnLycgKyBwcm9wICsgXCJAXCIgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGVidWcgIT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUubG9nKGRlYnVnICsgXCIvXCIgKyBwcm9wICsgXCJAXCIsIHRvdCk7XG4gICAgICAgICAgcmVzICs9IHRvdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gREVCVUdcbiAgdmlld01vZGVsLmxvb3BTdWJzY3JpcHRpb25zQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnQgPSB2aWV3TW9kZWwuY291bnRTdWJzY3JpcHRpb25zKHZpZXdNb2RlbC5jb250ZW50KCkpO1xuICAgIGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3Vic2NyaXB0aW9uc0NvdW50JykuaW5uZXJIVE1MID0gY291bnQ7XG4gICAgZ2xvYmFsLnNldFRpbWVvdXQodmlld01vZGVsLmxvb3BTdWJzY3JpcHRpb25zQ291bnQsIDEwMDApO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGVudCA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoXCJleHBvcnRIVE1MXCIsIHZpZXdNb2RlbC5leHBvcnRIVE1MKTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfTtcblxuICBmdW5jdGlvbiBjb25kaXRpb25hbF9yZXN0b3JlKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88cmVwbGFjZWRjY1tePl0qIGNvbmRpdGlvbj1cIihbXlwiXSopXCJbXj5dKj4oW1xcc1xcU10qPyk8XFwvcmVwbGFjZWRjYz4vZywgZnVuY3Rpb24obWF0Y2gsIGNvbmRpdGlvbiwgYm9keSkge1xuICAgICAgdmFyIGRkID0gJzwhLS1baWYgJytjb25kaXRpb24ucmVwbGFjZSgvJmFtcDsvLCAnJicpKyddPic7XG4gICAgICBkZCArPSBib2R5LnJlcGxhY2UoLzwhLS0gY2M6YmM6KFtBLVphLXo6XSopIC0tPig8XFwvY2M+KT88IS0tIGNjOmFjOlxcMSAtLT4vZywgJzwvJDE+JykgLy8gcmVzdG9yZSBjbG9zaW5nIHRhZ3MgKGluY2x1ZGluZyBsb3N0IHRhZ3MpXG4gICAgICAgICAgICAucmVwbGFjZSgvPjxcXC9jYz48IS0tIGNjOnNjIC0tPi9nLCAnLz4nKSAvLyByZXN0b3JlIHNlbGZjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tIGNjOmJvOihbQS1aYS16Ol0qKSAtLT48Y2MvZywgJzwkMScpIC8vIHJlc3RvcmUgb3BlbiB0YWdzXG4gICAgICAgICAgICAucmVwbGFjZSgvXi4qPCEtLSBjYzpzdGFydCAtLT4vLCcnKSAvLyByZW1vdmUgY29udGVudCBiZWZvcmUgc3RhcnRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tIGNjOmVuZCAtLT4uKiQvLCcnKTsgLy8gcmVtb3ZlIGNvbnRlbnQgYWZ0ZXIgZW5kXG4gICAgICBkZCArPSAnPCFbZW5kaWZdLS0+JztcbiAgICAgIHJldHVybiBkZDtcbiAgICB9KTtcbiAgfVxuXG4gIHZpZXdNb2RlbC5leHBvcnRIVE1MID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coJ3ZpZXdNb2RlbC5leHBvcnRIVE1MJylcbiAgICB2YXIgaWQgPSAnZXhwb3J0ZnJhbWUnO1xuICAgICQoJ2JvZHknKS5hcHBlbmQoJzxpZnJhbWUgaWQ9XCInICsgaWQgKyAnXCIgZGF0YS1iaW5kPVwiYmluZElmcmFtZTogJGRhdGFcIj48L2lmcmFtZT4nKTtcbiAgICB2YXIgZnJhbWVFbCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAga28uYXBwbHlCaW5kaW5ncyh2aWV3TW9kZWwsIGZyYW1lRWwpO1xuXG4gICAga28uY2xlYW5Ob2RlKGZyYW1lRWwpO1xuXG4gICAgaWYgKHZpZXdNb2RlbC5pbmxpbmUpIHZpZXdNb2RlbC5pbmxpbmUoZnJhbWVFbC5jb250ZW50V2luZG93LmRvY3VtZW50KTtcblxuICAgIC8vIE9ic29sZXRlIG1ldGhvZCBkaWRuJ3Qgd29yayBvbiBJRTExIHdoZW4gdXNpbmcgXCJIVE1MNSBkb2N0eXBlXCI6XG4gICAgLy8gdmFyIGRvY1R5cGUgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGdsb2JhbC5kb2N1bWVudC5kb2N0eXBlKTtcbiAgICB2YXIgbm9kZSA9IGZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudC5kb2N0eXBlO1xuICAgIHZhciBkb2NUeXBlID0gXCI8IURPQ1RZUEUgXCIgKyBub2RlLm5hbWUgK1xuICAgICAgKG5vZGUucHVibGljSWQgPyAnIFBVQkxJQyBcIicgKyBub2RlLnB1YmxpY0lkICsgJ1wiJyA6ICcnKSArXG4gICAgICAoIW5vZGUucHVibGljSWQgJiYgbm9kZS5zeXN0ZW1JZCA/ICcgU1lTVEVNJyA6ICcnKSArXG4gICAgICAobm9kZS5zeXN0ZW1JZCA/ICcgXCInICsgbm9kZS5zeXN0ZW1JZCArICdcIicgOiAnJykgKyAnPic7XG4gICAgdmFyIGNvbnRlbnQgPSBkb2NUeXBlICsgXCJcXG5cIiArIGZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgIGtvLnJlbW92ZU5vZGUoZnJhbWVFbCk7XG5cbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC88c2NyaXB0IChbXj5dKiApP3R5cGU9XCJ0ZXh0XFwvaHRtbFwiW14+XSo+W1xcc1xcU10qPzxcXC9zY3JpcHQ+L2dtLCAnJyk7XG4gICAgLy8gY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvPCEtLSBrbyAuKj8gLS0+L2csICcnKTsgLy8gc29tZXRpbWVzIHdlIGhhdmUgZXhwcmVzc2lvbnMgbGlrZSAoPCEtLSBrbyB2YXIgPiAyIC0tPilcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC88IS0tIGtvICgoPyEtLSkuKSo/IC0tPi9nLCAnJyk7IC8vIHRoaXMgcmVwbGFjZXMgdGhlIGFib3ZlIHdpdGggYSBtb3JlIGZvcm1hbCAoYnV0IHNsb3dlcikgc29sdXRpb25cbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC88IS0tIFxcL2tvIC0tPi9nLCAnJyk7XG4gICAgLy8gUmVtb3ZlIGRhdGEtYmluZC9kYXRhLWJsb2NrIGF0dHJpYnV0ZXNcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gZGF0YS1iaW5kPVwiW15cIl0qXCIvZ20sICcnKTtcbiAgICAvLyBSZW1vdmUgdHJhc2ggbGVmdG92ZXIgYnkgVGlueU1DRVxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyBkYXRhLW1jZS0oaHJlZnxzcmN8c3R5bGUpPVwiW15cIl0qXCIvZ20sICcnKTtcblxuICAgIC8vIFJlcGxhY2UgXCJyZXBsYWNlZHN0eWxlXCIgdG8gXCJzdHlsZVwiIGF0dHJpYnV0ZXMgKGNocm9tZSBwdXRzIHJlcGxhY2Vkc3R5bGUgYWZ0ZXIgc3R5bGUpXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIHN0eWxlPVwiW15cIl0qXCIoW14+XSopIHJlcGxhY2VkKHN0eWxlPVwiW15cIl0qXCIpL2dtLCAnJDEgJDInKTtcbiAgICAvLyBSZXBsYWNlIFwicmVwbGFjZWRzdHlsZVwiIHRvIFwic3R5bGVcIiBhdHRyaWJ1dGVzIChpZS9mZiBoYXZlIHJldmVyc2Ugb3JkZXIpXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIHJlcGxhY2VkKHN0eWxlPVwiW15cIl0qXCIpKFtePl0qKSBzdHlsZT1cIlteXCJdKlwiL2dtLCAnICQxJDInKTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gcmVwbGFjZWQoc3R5bGU9XCJbXlwiXSpcIikvZ20sICcgJDEnKTtcblxuICAgIC8vIHNhbWUgYXMgc3R5bGUsIGJ1dCBmb3IgaHR0cC1lcXVpdiAoc29tZSBicm93c2VyIGJyZWFrIGl0IGlmIHdlIGRvbid0IHJlcGxhY2UsIGJ1dCB0aGVuIHdlIGZpbmQgaXQgZHVwbGljYXRlZClcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gaHR0cC1lcXVpdj1cIlteXCJdKlwiKFtePl0qKSByZXBsYWNlZChodHRwLWVxdWl2PVwiW15cIl0qXCIpL2dtLCAnJDEgJDInKTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gcmVwbGFjZWQoaHR0cC1lcXVpdj1cIlteXCJdKlwiKShbXj5dKikgaHR0cC1lcXVpdj1cIlteXCJdKlwiL2dtLCAnICQxJDInKTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gcmVwbGFjZWQoaHR0cC1lcXVpdj1cIlteXCJdKlwiKS9nbSwgJyAkMScpO1xuXG4gICAgLy8gQ1VTVE9NIEJBQ0tFTkQ6IFJlc3RvcmUgRVNQIHRhZ3NcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZGVub3VnaC9tb3NhaWNvL2lzc3Vlcy8yXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvJmx0OyUvZywgJzwlJyk7XG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvJSZndDsvZywgJyU+Jyk7XG5cbiAgICAvLyBXZSBhbHJlYWR5IHJlcGxhY2Ugc3R5bGUgYW5kIGh0dHAtZXF1aXYgYW5kIHdlIGRvbid0IG5lZWQgdGhpcy5cbiAgICAvLyBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gcmVwbGFjZWQoW149IF0qPSkvZ20sICcgJDEnKTtcbiAgICAvLyBSZXN0b3JlIGNvbmRpdGlvbmFsIGNvbW1lbnRzXG4gICAgY29udGVudCA9IGNvbmRpdGlvbmFsX3Jlc3RvcmUoY29udGVudCk7XG4gICAgdmFyIHRyYXNoID0gY29udGVudC5tYXRjaCgvIGRhdGEtW14gPV0rKD1cIlteXCJdK1wiKT8gLykgfHwgY29udGVudC5tYXRjaCgvIHJlcGxhY2VkKFtePSBdKj0pLyk7XG4gICAgaWYgKHRyYXNoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJPdXRwdXQgSFRNTCBjb250YWlucyB1bmV4cGVjdGVkIGRhdGEtIGF0dHJpYnV0ZXMgb3IgcmVwbGFjZWQgYXR0cmlidXRlc1wiLCB0cmFzaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH07XG5cbiAgdmlld01vZGVsLmV4cG9ydEhUTUx0b1RleHRhcmVhID0gZnVuY3Rpb24odGV4dGFyZWFpZCkge1xuICAgICQodGV4dGFyZWFpZCkudmFsKHZpZXdNb2RlbC5leHBvcnRIVE1MKCkpO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnRKU09OdG9UZXh0YXJlYSA9IGZ1bmN0aW9uKHRleHRhcmVhaWQpIHtcbiAgICAkKHRleHRhcmVhaWQpLnZhbCh2aWV3TW9kZWwuZXhwb3J0SlNPTigpKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuaW1wb3J0SlNPTmZyb21UZXh0YXJlYSA9IGZ1bmN0aW9uKHRleHRhcmVhaWQpIHtcbiAgICB2aWV3TW9kZWwuaW1wb3J0SlNPTigkKHRleHRhcmVhaWQpLnZhbCgpKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuZXhwb3J0TWV0YWRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIganNvbiA9IGtvLnRvSlNPTih2aWV3TW9kZWwubWV0YWRhdGEpO1xuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnRKU09OID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGpzb24gPSBrby50b0pTT04odmlld01vZGVsLmNvbnRlbnQpO1xuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnRKUyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrby50b0pTKHZpZXdNb2RlbC5jb250ZW50KTtcbiAgfTtcblxuICB2aWV3TW9kZWwuaW1wb3J0SlNPTiA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgICB2YXIgdW53cmFwcGVkID0ga28udXRpbHMucGFyc2VKc29uKGpzb24pO1xuICAgIHZpZXdNb2RlbC5jb250ZW50Ll93cmFwKHVud3JhcHBlZCk7XG4gIH07XG5cbiAgdmlld01vZGVsLmV4cG9ydFRoZW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZsYXQgPSB7fTtcbiAgICB2YXIgbW9kID0gdmlld01vZGVsLmNvbnRlbnQoKS50aGVtZSgpO1xuXG4gICAgdmFyIF9leHBvcnQgPSBmdW5jdGlvbihwcmVmaXgsIGZsYXQsIG1vZCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBtb2QpXG4gICAgICAgIGlmIChtb2QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICB2YXIgYSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobW9kW3Byb3BdKTtcbiAgICAgICAgICBpZiAoYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgX2V4cG9ydChwcm9wICsgJy4nLCBmbGF0LCBhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhdFtwcmVmaXggKyBwcm9wXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9leHBvcnQoJycsIGZsYXQsIG1vZCk7XG5cbiAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBmbGF0KVxuICAgICAgaWYgKGZsYXQuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgcHJvcCAhPSAndHlwZScpIHtcbiAgICAgICAgb3V0cHV0ICs9IHByb3AgKyBcIjogXCIgKyBmbGF0W3Byb3BdICsgXCI7XCIgKyBcIlxcblwiO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBtb3hpZW1hbmFnZXIgKG9yIGZpbGUgYnJvd3Nlci9pbWFnZWVkaXRvcikgZXh0ZW5zaW9uIHBvaW50cy5cbiAgLy8gSnVzdCBpbXBsZW1lbnQgZWRpdEltYWdlIG9yIGxpbmtEaWFsb2cgbWV0aG9kc1xuICAvLyB2aWV3TW9kZWwuZWRpdEltYWdlID0gZnVuY3Rpb24oc3JjLCBkb25lKSB7fSA6IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBlbmFibGUgaW1hZ2UgZWRpdGluZyAoc3JjIGlzIGEgd2lydGFibGVPYnNlcnZhYmxlKS5cbiAgLy8gdmlld01vZGVsLmxpbmtEaWFsb2cgPSBmdW5jdGlvbigpIHt9OiBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdXNpbmcgXCJ0aGlzXCIgdG8gZmluZCB0aGUgaW5wdXQgZWxlbWVudCAkKHRoaXMpLnZhbCBpcyBhIHdyaXRhYmxlT2JzZXJ2YWJsZS5cblxuICB2aWV3TW9kZWwubG9hZEltYWdlID0gZnVuY3Rpb24oaW1nKSB7XG4gICAgLy8gcHVzaCBpbWFnZSBhdCB0b3Agb2YgXCJyZWNlbnRcIiBnYWxsZXJ5XG4gICAgdmlld01vZGVsLmdhbGxlcnlSZWNlbnQudW5zaGlmdChpbWcpO1xuICAgIC8vIHNlbGVjdCByZWNlbnQgZ2FsbGVyeSB0YWJcbiAgICB2aWV3TW9kZWwuc2VsZWN0ZWRJbWFnZVRhYigwKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuZGlhbG9nID0gZnVuY3Rpb24oc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAkKHNlbGVjdG9yKS5kaWFsb2cob3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gRHVtbXkgbG9nIG1ldGhvZCBvdmVycmlkZGVuIGJ5IGV4dGVuc2lvbnNcbiAgdmlld01vZGVsLmxvZyA9IGZ1bmN0aW9uKGNhdGVnb3J5LCBtc2cpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcInZpZXdNb2RlbC5sb2dcIiwgY2F0ZWdvcnksIG1zZyk7XG4gIH07XG5cbiAgLy8gQ2FuJ3Qga2VlcCB0aGF0IHBpZWNlIG9mIGNvZGU6IGludGVyZmVyZSB3aXRoIG15IG93biBsaXN0ZW5lclxuICBpZiAoZmFsc2UpIHtcblxuICAvLyBhdXRvbWF0aWNhbGx5IGxvYWQgdGhlIGdhbGxlcnkgd2hlbiB0aGUgZ2FsbGVyeSB0YWIgaXMgc2VsZWN0ZWRcbiAgdmlld01vZGVsLnNlbGVjdGVkSW1hZ2VUYWIuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5ld1ZhbHVlID09IDEgJiYgdmlld01vZGVsLmdhbGxlcnlMb2FkZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHZpZXdNb2RlbC5sb2FkR2FsbGVyeSgpO1xuICAgIH1cbiAgfSwgdmlld01vZGVsLCAnY2hhbmdlJyk7XG5cbiAgfVxuXG4gIHJldHVybiB2aWV3TW9kZWw7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0aWFsaXplRWRpdG9yO1xuIl19
