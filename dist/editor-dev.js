(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Mosaico = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var templateSystem=require("../src/js/bindings/choose-template.js");document.addEventListener("DOMContentLoaded",function(t){templateSystem.addTemplate("array","\x3c!-- ko foreach: $data --\x3e\x3c!-- ko block: $data --\x3e\x3c!-- /ko --\x3e\x3c!-- /ko --\x3e"),templateSystem.addTemplate("block-show","\x3c!-- ko block: $data, scrollIntoView: $root.selectedBlock() === $data --\x3e\x3c!-- /ko --\x3e"),templateSystem.addTemplate("block-wysiwyg",'<div class="editable block" data-drop-content="Drop here" data-bind="attr: { \'data-drop-content\': $root.t(\'Drop here\') }, click: function(obj, evt) { $root.selectBlock(obj); return true }, clickBubble: false, css: { selected: $root.selectedBlock() === $data }, scrollIntoView: $root.selectedBlock() === $data">  <div class="mo-blockselectionhelper"></div>  <div class="tools" data-bind="tooltips: {}">    \x3c!-- ko if: typeof $index != \'undefined\' --\x3e    <div title="Drag this handle to move the block" data-bind="attr: { title: $root.t(\'Drag this handle to move the block\') }"      class="tool handle"><i class="fas fa-sort"></i></div>    \x3c!-- ko if: $index() > 0 --\x3e    <div title="Move this block upside" data-bind="attr: { title: $root.t(\'Move this block upside\') }" class="tool moveup"><i        class="fas fa-sort-up" data-bind=\'click: $root.moveBlock.bind($element, $index, $parent, true)\'></i></div>    \x3c!-- /ko --\x3e    \x3c!-- ko if: $index() < $parent.blocks().length -1 --\x3e    <div title="Move this block downside" data-bind="attr: { title: $root.t(\'Move this block downside\') }" class="tool movedown"><i        class="fas fa-sort-down" data-bind=\'click: $root.moveBlock.bind($element, $index, $parent, false)\'></i></div>    \x3c!-- /ko --\x3e    <div title="Delete block" class="tool delete" data-bind="attr: { title: $root.t(\'Delete block\') }, click: $root.removeBlock.bind($element, $rawData, $parent)"><i        class="fas fa-trash"></i></div>    <div title="Duplicate block" class="tool clone" data-bind="attr: { title: $root.t(\'Duplicate block\') }, click: $root.duplicateBlock.bind($element, $index, $parent)"><i        class="fas fa-copy"></i></div>    \x3c!-- /ko --\x3e    \x3c!-- ko if: typeof $data._nextVariant != \'undefined\' --\x3e    <div title="Switch block variant" class="tool variant" data-bind="attr: { title: $root.t(\'Switch block variant\') }, click: $data._nextVariant"><i        class="fa fa-fw fa-magic"></i></div>\x3c!-- /ko --\x3e  </div>  \x3c!-- ko block: $data --\x3e  \x3c!-- /ko --\x3e</div>'),templateSystem.addTemplate("blocks-show","\x3c!-- ko template: { name: 'block-show', foreach: blocks } --\x3e\x3c!-- /ko --\x3e"),templateSystem.addTemplate("blocks-wysiwyg","<div class=\"sortable-blocks-edit\" data-drop-content=\"Drop here\" data-empty-content=\"Drop here blocks from the Blocks tab\" data-bind=\"attr: { 'data-drop-content': $root.t('Drop here'), 'data-empty-content': $root.t('Drop here blocks from the &quot;Blocks&quot; tab') }, css: { 'empty': ko.utils.unwrapObservable(blocks).length == 0 }, extsortable: { connectClass: 'sortable-blocks-edit', template: 'block-wysiwyg', data: blocks, dragging: $root.dragging, beforeMove: $root.startMultiple, afterMove: $root.stopMultiple, options: { handle: '.handle', placeholder: $root.placeholderHelper } }\"></div>"),templateSystem.addTemplate("customstyle",'<div class="customStyleHelp" data-bind="html: $root.t(\'Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class=&quot;customStyled&quot;><span>&quot;small cube&quot; </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul>\')">Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class="customStyled"><span>"small cube" </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul></div>'),templateSystem.addTemplate("empty",""),templateSystem.addTemplate("error",'[<div style="background-color: #fff0f0" data-bind="text: ko.toJS($data)"></div>]'),templateSystem.addTemplate("img-wysiwyg",'<table tabfocus="0" cellspacing="0" cellpadding="0" data-drop-content="Drop here" data-bind="style: _stylebind, click: function(obj, evt) { $root.selectItem(_item, _data); return true; }, clickBubble: false, fudroppable: { activeClass: \'ui-state-highlight\', hoverClass: \'ui-state-draghover\' }, extdroppable: { options: { accept: \'.image\', activeClass: \'ui-state-highlight\', hoverClass: \'ui-state-draghover\' }, data: _src, dragged: $root.fileToImage }, css: { selecteditem: $root.isSelectedItem(_item) }, scrollIntoView: $root.isSelectedItem(_item), attr: { \'data-drop-content\': $root.t(\'Drop here\'), width: _width, height: _height, align: _align }"  class="img-wysiwyg selectable-img" style="display: table;">  <tr>    <td class="uploadzone">      <div class="mo-imgselectionhelper"></div>      <div class="mo-uploadzone"></div>      <div class="img-size" data-bind="text: _size">size</div>      <div class="midtools" data-bind="tooltips: {}">        \x3c!-- ko if: _src() != \'\' --\x3e        <div title="Remove image" class="tool delete" data-bind="attr: { title: $root.t(\'Remove image\') }, click: _src.bind(_src, \'\'), clickBubble: false"><i            class="fa fa-fw fa-trash-o"></i></div>        \x3c!-- ko if: typeof $root.editImage !== \'undefined\' --\x3e        <div title="Open the image editing tool" class="tool edit" data-bind="attr: { title: $root.t(\'Open the image editing tool\') }, click: $root.editImage.bind($element, _src), clickBubble: false"><i            class="fa fa-fw fa-pencil"></i></div>        \x3c!-- /ko --\x3e        \x3c!-- /ko --\x3e        \x3c!-- ko if: _src() == \'\' --\x3e        <div title="Upload a new image" data-bind="attr: { title: $root.t(\'Upload a new image\') }" class="tool upload" style="position: relative; overflow: hidden;"><i            class="fas fa-upload"></i>          <input class="fileupload nofile" type="file" name="files[]" data-bind="fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.loadMailingImage, canvasPreview: true }"            style="z-index: 20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-size: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block">        </div>        \x3c!-- ko if: typeof $root.selectImage !== \'undefined\' --\x3e        <div title="Select from gallery" class="tool gallery" data-bind="attr: { title: $root.t(\'Select from gallery\') }, click: $root.selectImage.bind($element, _src), clickBubble: true"><i            class="fas fa-image"></i></div>        \x3c!-- /ko --\x3e        \x3c!-- /ko --\x3e      </div>      \x3c!-- ko template: _template --\x3e      \x3c!-- /ko --\x3e      \x3c!-- ko if: _src() == \'\' --\x3e      \x3c!--    <img style="display: block;" class="imgplaceholder" width="200" src="" alt="Insert an image here" data-bind="wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }" />    --\x3e      <span class="fileuploadtext" style="text-align: center; display: -ms-flexbox; display: flex; align-items: center; flex-align: center; justify-content: center; padding: 1em; position: absolute; top: 0; left: 0; right: 0; bottom: 0;"><span          class="textMiddle" style=" text-shadow: 1px 1px 0 #FFFFFF, 0 0 10px #FFFFFF; font-weight: bold;" data-bind="text: $root.t(\'Drop an image here\')">Drop          an image here</span></span>      \x3c!-- /ko --\x3e      \x3c!-- ko if: _src() != \'\' --\x3e      \x3c!--    <img style="display: block;" width="200" src="" data-bind="preloader: _src, wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }" />    --\x3e      \x3c!-- /ko --\x3e      \x3c!-- pulsante per la cancellazione --\x3e      <div title="Drop an image here or click the upload button" data-bind="attr: { title: $root.t(\'Drop an image here or click the upload button\') }, tooltips: {}"        class="workzone" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden;">        \x3c!-- ko if: _src.preloaded && _src() != _src.preloaded() --\x3ePRELOADING....        \x3c!-- /ko --\x3e        \x3c!-- ko if: _src() != \'\' --\x3e        <input class="fileupload withfile" type="file" name="files[]" data-bind="fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.mailingGallery.unshift.bind($root.mailingGallery), canvasPreview: true }"          style="z-index: -20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-zie: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block">        \x3c!-- /ko --\x3e        <div class="progress" style="opacity: .5; width: 80%; margin-left: 10%; position: absolute; bottom: 30%; height: 20px; border: 2px solid black;">          <div class="progress-bar progress-bar-success" style="height: 20px; background-color: black; "></div>        </div>      </div></table>'),templateSystem.addTemplate("main",'<div id="page" style="display: none;" data-bind="visible: true, css: { withToolbox: $root.showToolbox, withPreviewFrame: showPreviewFrame }">  <div id="main-edit-area" data-bind="click: function(obj, evt) { $root.selectBlock(null); return true; }, clickBubble: false">    \x3c!-- ko withProperties: { templateMode: \'wysiwyg\', templateModeFallback: \'show\' } --\x3e    <div id="main-wysiwyg-area" data-bind="wysiwygScrollfix: true, scrollable: true, fudroppable: { active: draggingImage }, css: { isdragging: dragging, isdraggingimg: draggingImage }, block: content"></div>    \x3c!-- /ko --\x3e  </div>  <div id="toolbar" class="mo" data-bind="tooltips: {}">    \x3c!-- ko if: typeof $root.undo != \'undefined\' --\x3e    <span data-bind="buttonset: { }" class="leftButtons">      <a class="toolbar__button toolbar__button--undo" title="Undo last operation" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Undo last operation\') }, click: $root.undo.execute, clickBubble: false, button: { disabled: !$root.undo.enabled(), icons: { primary: \'fas fa-reply\' }, label: $root.undo.name, text: true }">UNDO</a>      <a class="toolbar__button toolbar__button--redo" title="Redo last operation" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Redo last operation\') }, click: $root.redo.execute, clickBubble: false, button: { disabled: !$root.redo.enabled(), icons: { primary: \'fas fa-share\' }, label: $root.redo.name, text: true }">REDO</a>    </span>    \x3c!-- ko if: $root.debug --\x3e    <a href="javascript:void(0)" data-bind="click: $root.undoReset, clickBubble: false, button: { disabled: !$root.undo.enabled() && !$root.redo.enabled(), label: \'reset\', text: true }">RESET</a>    \x3c!-- /ko --\x3e    \x3c!-- /ko --\x3e    <span>      <input id="showGallery" type="checkbox" data-bind="checked: $root.showGallery, button: { refreshOn: $root.showGallery,    icons: { primary: \'fas fa-image\', secondary: null }, text: true, label: $root.t(\'Gallery\') }"><label title="Show image gallery"        for="showGallery" data-bind="attr: { title: $root.t(\'Show image gallery\') }">show gallery</label></input>    </span>    \x3c!-- ko template: {name: \'edit-name\' } --\x3e# mailing name #    \x3c!-- /ko --\x3e    <input id="previewFrameToggle" type="checkbox" data-bind="checked: $root.showPreviewFrame, button: { refreshOn: $root.showPreviewFrame, icons: { primary: null , secondary: null }, text: false, label: $root.t(\'Preview\') }"    />    <label for="previewFrameToggle" title="Show live preview" data-bind="attr: { title: $root.t(\'Show live preview\') }">      PREVIEW    </label>    \x3c!-- ko if: $root.debug --\x3e    <a href="javascript:void(0)" data-bind="click: $root.export, clickBubble: false, button: { label: \'export\', text: true }">EXPORT</a>    <input type="checkbox" data-bind="checked: $root.debug" /> debug    <a href="javascript:void(0)" data-bind="click: $root.loadDefaultBlocks, clickBubble: false, button: { icons: { primary: \'fas fa-upload\' }, label: \'Default\', text: true }">LOAD      BLOCKS    </a>    [<a id="subscriptionsCount" href="javascript:viewModel.loopSubscriptionsCount()">subs</a>]    \x3c!-- /ko --\x3e    <span data-bind="visible: false">      <input type="checkbox" data-bind="checked: $root.showToolbox" /> toolbox    </span>    <div class="rightButtons">      \x3c!-- ko if: typeof $root.save !== \'undefined\' --\x3e      <a class="toolbar__button toolbar__button--save" title="Save template" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Save template\') }, click: $root.save.execute, clickBubble: false, button: { disabled: !$root.save.enabled(), icons: { primary: \'fas fa-save\' }, label: $root.t($root.save.name), text: true }">SALVA</a>      \x3c!-- /ko --\x3e      \x3c!-- ko if: typeof $root.test !== \'undefined\' --\x3e      <a class="toolbar__button" title="Show preview and send test" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Show preview and send test\') }, click: $root.test.execute, clickBubble: false, button: { disabled: !$root.test.enabled(), icons: { primary: \'fas fa-paper-plane\' }, label: $root.t($root.test.name), text: true }">TEST</a>      \x3c!-- /ko --\x3e      \x3c!-- ko template: {name: \'download-button\' } --\x3e# download button #      \x3c!-- /ko --\x3e    </div>  </div>  \x3c!-- ko template: {name: \'dialog-select-image\' } --\x3e# dialog image selection #  \x3c!-- /ko --\x3e  \x3c!-- ko if: $root.showToolbox --\x3e  <div id="main-toolbox" class="mo" data-bind="scrollable: true, withProperties: { templateMode: \'edit\' }">    <div data-bind="template: { name: \'toolbox\' }"></div>  </div>  \x3c!-- /ko --\x3e  <div id="main-preview" class="mo" data-bind="scrollable: true, if: $root.showPreviewFrame">    <div id="preview-toolbar">      <div data-bind="visible: $root.showPreviewFrame, buttonset: { }" style="display: inline-block">        <input id="previewLarge" type="radio" name="previewMode" value="large" data-bind="checked: $root.previewMode, button: { text: false, label: \'large\', icons: { primary: \'fas fa-desktop\' } }"        />        <label for="previewLarge" title="Large screen" data-bind="attr: { title: $root.t(\'Large screen\') }">Large screen</label>        <input id="previewDesktop" type="radio" name="previewMode" value="desktop" data-bind="checked: $root.previewMode, button: { text: false, label: \'desktop\', icons: { primary: \'fas fa-tablet-alt\' } }"        />        <label for="previewDesktop" title="Tablet" data-bind="attr: { title: $root.t(\'Tablet\') }">Tablet</label>        <input id="previewMobile" type="radio" name="previewMode" value="mobile" data-bind="checked: $root.previewMode, button: { text: false, label: \'mobile\', icons: { primary: \'fas fa-mobile-alt\' } }"        />        <label for="previewMobile" title="Smartphone" data-bind="attr: { title: $root.t(\'Smartphone\') }">Smartphone</label>      </div>    </div>    <div id="frame-container" data-bind="css: { desktop: $root.previewMode() == \'desktop\', mobile: $root.previewMode() == \'mobile\', large: $root.previewMode() == \'large\' }">      <iframe data-bind="bindIframe: $data"></iframe>    </div>  </div>  <div class="mo" id="mo-body"></div>  <div id="incompatible-template" title="Saved model is obsolete" style="display: none" data-bind="attr: { title: $root.t(\'Saved model is obsolete\') }, html: $root.t(\'<p>The saved model has been created with a previous, non completely compatible version, of the template</p><p>Some content or style in the model <b>COULD BE LOST</b> if you will <b>save</b></p><p>Contact us for more informations!</p>\')">    Incompatible template  </div>  <div id="fake-image-editor" title="Fake image editor" style="display: none" data-bind="attr: { title: $root.t(\'Fake image editor\') }, html: $root.t(\'<p>Fake image editor</p>\')">    <p>Fake image editor</p>  </div></div>\x3c!-- ko if: $root.logoPath --\x3e<div id="loading" class="loading" style="display: block; width: 300px; text-align: center; height: 32px; position: absolute; top:0; bottom: 0; left: 0; right: 0;  margin: auto;"  data-bind="attr: { style: \'position: absolute; top: 5px; left: 6px; z-index: 150;\'}, css: { loading: false }">  <a href="/" data-bind="attr: { href: $root.logoUrl, alt: $root.logoAlt }"><img data-bind="attr: { src: $root.logoPath }"      width="32" height="32" alt="mosaico" border="0" /></a>  <div style="opacity: 0" data-bind="visible: false">Oppps... !!</div></div>\x3c!-- /ko --\x3e\x3c!-- ko template: {name: \'home-icon\' } --\x3e# home-icon #\x3c!-- /ko --\x3e'),templateSystem.addTemplate("toolbox",'<div id="tooltabs" class="tabs_horizontal button_color" data-bind="tabs: { active: $root.selectedTool }">  <ul>    <li data-bind="tooltips: {}"><a title="Blocks ready to be added to the template" data-local="true" href="#toolblocks"        data-bind="attr: { title: $root.t(\'Blocks ready to be added to the template\') }"><i class="fas fa-cubes"></i>        <span data-bind="html: $root.t(\'Blocks\')">Blocks</span></a></li>    <li data-bind="tooltips: {}"><a title="Edit content options" href="#toolcontents" data-local="true" data-bind="attr: { title: $root.t(\'Edit content options\') }"><i          class="fas fa-pencil-alt"></i> <span data-bind="html: $root.t(\'Content\')">Content</span></a></li>    <li data-bind="tooltips: {}"><a title="Edit style options" href="#toolstyles" data-local="true" data-bind="attr: { title: $root.t(\'Edit style options\') }"><i          class="fas fa-paint-brush"></i> <span data-bind="html: $root.t(\'Style\')">Style</span></a></li>  </ul>  <div id="toolblocks" data-bind="scrollable: true">    <div class="block-list" data-bind="foreach: blockDefs" style="text-align: center">      <div class="draggable-item" data-bind="withProperties: { templateMode: \'show\' }">        <div class="block" data-bind="extdraggable: { connectClass: \'sortable-blocks-edit\', data: $data, dropContainer: \'#main-wysiwyg-area\', dragging: $root.dragging, \'options\': { handle: \'.handle\', distance: 10, \'appendTo\': \'#page\' } }, click: $root.addBlock"          style="position: relative;">          <div title="Click or drag to add this block to the template" class="handle" data-bind="attr: { title: $root.t(\'Click or drag to add this block to the template\') }, tooltips: {}"></div>          <img data-bind="attr: { alt: $root.t(\'Block __name__\', { name: ko.utils.unwrapObservable(type) }), src: $root.templatePath(\'edres/\'+ko.utils.unwrapObservable(type)+\'.png\') }"            alt="Block __name__" />        </div>        <a href="javascript:void(0)" class="addblockbutton" data-bind="click: $root.addBlock, button: { label: $root.t(\'Add\') }">Add</a>      </div>    </div>  </div>  <div id="toolcontents" data-bind="scrollable: true">    \x3c!-- ko if: $root.selectedBlock() !== null --\x3e    <div data-bind="block: $root.selectedBlock"></div>    \x3c!-- /ko --\x3e    \x3c!-- ko if: $root.selectedBlock() == null --\x3e    <div class="noSelectedBlock" data-bind="text: $root.t(\'By clicking on message parts you will select a block and content options, if any, will show here\')">By      clicking on message parts you will select a block and content options, if any, will show here</div>    \x3c!-- /ko --\x3e    \x3c!-- ko block: content --\x3e    \x3c!-- /ko --\x3e  </div>  <div id="toolstyles" data-bind="scrollable: true, withProperties: { templateMode: \'styler\' }">    \x3c!-- ko if: typeof $root.content().theme === \'undefined\' || typeof $root.content().theme().scheme === \'undefined\' || $root.content().theme().scheme() === \'custom\' --\x3e    \x3c!-- ko if: $root.selectedBlock() !== null --\x3e    <div data-bind="block: $root.selectedBlock, css: { workLocal: $root.selectedBlock().customStyle, workGlobal: typeof $root.selectedBlock().customStyle === \'undefined\' || !$root.selectedBlock().customStyle() }"></div>    \x3c!-- /ko --\x3e    \x3c!-- ko if: $root.selectedBlock() == null --\x3e    <div class="noSelectedBlock" data-bind="text: $root.t(\'By clicking on message parts you will select a block and style options, if available, will show here\')">By      clicking on message parts you will select a block and style options, if available, will show here</div>    \x3c!-- /ko --\x3e    <div class="workGlobalContent">      \x3c!-- ko block: content --\x3e      \x3c!-- /ko --\x3e    </div>    \x3c!-- /ko --\x3e  </div></div><div id="toolimages" class="slidebar" data-bind="scrollable: true, css: { hidden: $root.showGallery() === false }">  <div class="close" data-bind="click: $root.showGallery.bind($element, false);">X</div>  <span class="pane-title" data-bind="text: $root.t(\'gallery-title\')">Galleries:</span>  \x3c!-- ko if: $root.showGallery() --\x3e  <div id="toolimagestab" class="tabs_horizontal" data-bind="tabs: { active: $root.selectedImageTab }">    <ul>      <li data-bind="tooltips: {}"><a title="gallery-mailing" data-local="true" href="#toolimagesgallery" data-bind="attr: { title: $root.t(\'gallery-mailing\') }, text: $root.t(\'gallery-mailing\')">gallery-mailing</a></li>      <li data-bind="tooltips: {}"><a title="gallery-template" data-local="true" href="#toolimagesgallerytemplate" data-bind="attr: { title: $root.t(\'gallery-template\') }, text: $root.t(\'gallery-template\')">gallery-template</a></li>    </ul>    <div id="toolimagesgallery" class="gallery-panel">      \x3c!-- ko template: {name: \'gallery-upload\', data: { type: \'mailing\' } } --\x3e# mailing gallery fileupload #      \x3c!-- /ko --\x3e      \x3c!-- ko if: $root.mailingGalleryStatus() === false --\x3e<a class="loadbutton" title="Show images from the gallery" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Show images from the gallery\') }, click: $root.loadMailingGallery, button: { disabled: $root.mailingGalleryStatus, icons: { primary: \'fas fa-image\' }, label: $root.mailingGalleryStatus() == \'loading\' ? $root.t(\'Loading...\') : $root.t(\'Load gallery\'), text: true }">#        load gallery #</a>\x3c!-- /ko --\x3e      \x3c!-- ko if: $root.mailingGalleryStatus() === \'loading\' --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-loading\')">Loading mailing gallery…</div>\x3c!-- /ko --\x3e      \x3c!-- ko if: $root.mailingGalleryStatus() === 0 --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-empty\')">The mailing gallery is empty</div>\x3c!-- /ko --\x3e      \x3c!-- ko template: {name: \'gallery-images\', data: { items: mailingGallery, type: \'mailing\' } } --\x3e# mailing gallery #      \x3c!-- /ko --\x3e    </div>    <div id="toolimagesgallerytemplate" class="gallery-panel">      \x3c!-- ko template: {name: \'gallery-upload\', data: { type: \'template\' } } --\x3e# mailing template fileupload #      \x3c!-- /ko --\x3e      \x3c!-- ko if: $root.templateGalleryStatus() === false --\x3e<a class="loadbutton" title="Show images from the gallery" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Show images from the gallery\') }, click: $root.loadTemplateGallery, button: { disabled: $root.templateGalleryStatus, icons: { primary: \'fas fa-image\' }, label: $root.templateGalleryStatus() == \'loading\' ? $root.t(\'Loading...\') : $root.t(\'Load gallery\'), text: true }">#        load gallery #</a>\x3c!-- /ko --\x3e      \x3c!-- ko if: $root.templateGalleryStatus() === \'loading\' --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-loading\')">Loading template gallery...</div>\x3c!-- /ko --\x3e      \x3c!-- ko if: $root.templateGalleryStatus() === 0 --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-empty\')">The template gallery is empty</div>\x3c!-- /ko --\x3e      \x3c!-- ko template: {name: \'gallery-images\', data: { items: templateGallery, type: \'template\' } } --\x3e# template gallery #      \x3c!-- /ko --\x3e    </div>  </div>  \x3c!-- /ko --\x3e</div><div id="tooldebug" class="slidebar" data-bind="css: { hidden: $root.debug() === false }">  <div class="close" data-bind="click: $root.debug.bind($element, false);">X</div>  \x3c!-- ko if: $root.debug --\x3e  Content:  <pre data-bind=\'text: ko.toJSON(content, null, 2)\' style="overflow: auto; height: 20%"></pre> BlockDefs:  <pre data-bind=\'text: ko.toJSON(blockDefs, null, 2)\' style="overflow: auto; height: 20%"></pre>  \x3c!-- /ko --\x3e  <a href="javascript:void(0)" data-bind="click: $root.exportHTMLtoTextarea.bind($element, \'#outputhtml\'); clickBubble: false, button: { text: true, label:\'Generate\' }">Output</a>  <a href="javascript:void(0)" data-bind="click: $root.exportJSONtoTextarea.bind($element, \'#outputhtml\'); clickBubble: false, button: { text: true, label:\'Export\' }">Export</a>  <a href="javascript:void(0)" data-bind="click: $root.importJSONfromTextarea.bind($element, \'#outputhtml\'); clickBubble: false, button: { text: true, label:\'Import\' }">Import</a>  <textarea id="outputhtml" rows="10" style="width: 100%;"></textarea></div><div id="tooltheme" class="ui-widget slidebar" data-bind="css: { hidden: $root.showTheme() === false }">  <div class="close" data-bind="click: $root.showTheme.bind($element, false);">X</div>  \x3c!-- ko withProperties: { templateMode: \'styler\' } --\x3e  \x3c!-- ko if: $root.showTheme --\x3e  \x3c!-- ko block: $root.content().theme --\x3e  \x3c!-- /ko --\x3e  \x3c!-- /ko --\x3e  \x3c!-- /ko --\x3e</div>'),templateSystem.addTemplate("dialog-select-image",'\x3c!-- ko if: $root.showDialogGallery() --\x3e\x3c!-- should use ui-dialog --\x3e<aside id="dialogGallery" class="mo">  <div class="tabs_horizontal" data-bind="tabs: { active: $root.selectedImageTab }">    <div class="close" data-bind="click: $root.closeDialogGallery;">X</div>    <ul>      <li data-bind="tooltips: {}"><a title="gallery-mailing" data-local="true" href="#dialoggallerymailing" data-bind="attr: { title: $root.t(\'gallery-mailing\') }, text: $root.t(\'gallery-mailing\')">gallery-mailing</a></li>      <li data-bind="tooltips: {}"><a title="gallery-template" data-local="true" href="#dialoggallerytemplate" data-bind="attr: { title: $root.t(\'gallery-template\') }, text: $root.t(\'gallery-template\')">gallery-template</a></li>    </ul>    <div id="dialoggallerymailing" class="gallery-panel">      \x3c!-- ko template: {name: \'gallery-upload\', data: { type: \'mailing\' } } --\x3e# mailing gallery fileupload #      \x3c!-- /ko --\x3e      \x3c!-- ko if: $root.mailingGalleryStatus() === false --\x3e<a class="loadbutton" title="Show images from the gallery" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Show images from the gallery\') }, click: $root.loadMailingGallery, button: { disabled: $root.mailingGalleryStatus, icons: { primary: \'fas fa-image\' }, label: $root.mailingGalleryStatus() == \'loading\' ? $root.t(\'Loading...\') : $root.t(\'Load gallery\'), text: true }">#        load gallery #</a>\x3c!-- /ko --\x3e      \x3c!-- ko if: $root.mailingGalleryStatus() === \'loading\' --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-loading\')">Loading mailing gallery…</div>      \x3c!-- /ko --\x3e      \x3c!-- ko if: $root.mailingGalleryStatus() === 0 --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-empty\')">The mailing gallery is empty</div>      \x3c!-- /ko --\x3e      <div class="dialog-gallery-wrapper">        <ul data-bind="foreach: mailingGallery">          \x3c!-- ko if: typeof thumbnailUrl != \'undefined\' --\x3e          <li data-bind="click: $root.setBgImage.bind($element, name);">            <img style="display: block;" data-bind="attr: { src: thumbnailUrl }" />          </li>          \x3c!-- /ko --\x3e        </ul>      </div>    </div>    <div id="dialoggallerytemplate" class="gallery-panel">      \x3c!-- ko template: {name: \'gallery-upload\', data: { type: \'template\' } } --\x3e# mailing template fileupload #      \x3c!-- /ko --\x3e      \x3c!-- ko if: $root.templateGalleryStatus() === false --\x3e<a class="loadbutton" title="Show images from the gallery" href="javascript:void(0)" data-bind="attr: { title: $root.t(\'Show images from the gallery\') }, click: $root.loadTemplateGallery, button: { disabled: $root.templateGalleryStatus, icons: { primary: \'fas fa-image\' }, label: $root.templateGalleryStatus() == \'loading\' ? $root.t(\'Loading...\') : $root.t(\'Load gallery\'), text: true }">#        load gallery #</a>\x3c!-- /ko --\x3e      \x3c!-- ko if: $root.templateGalleryStatus() === \'loading\' --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-loading\')">Loading template gallery...</div>      \x3c!-- /ko --\x3e      \x3c!-- ko if: $root.templateGalleryStatus() === 0 --\x3e      <div class="galleryEmpty" data-bind="text: $root.t(\'gallery-mailing-empty\')">The template gallery is empty</div>      \x3c!-- /ko --\x3e      <div class="dialog-gallery-wrapper">        <ul data-bind="foreach: templateGallery">          \x3c!-- ko if: typeof thumbnailUrl != \'undefined\' --\x3e          <li data-bind="click: $root.setBgImage.bind($element, name);">            <img style="display: block;" data-bind="attr: { src: thumbnailUrl }" />          </li>          \x3c!-- /ko --\x3e        </ul>      </div>    </div>  </div></aside>\x3c!-- /ko --\x3e'),templateSystem.addTemplate("download-button",'\x3c!-- ko if: typeof $root.download !== \'undefined\' --\x3e<form id="downloadForm" class="download" action="#" method="POST">  <input type="hidden" name="action" value="download" />  <input type="hidden" name="filename" value="email.html" id="downloadHtmlFilename" />  <input type="hidden" name="html" id="downloadHtmlTextarea" />  <button type="button" class="toolbar__button download__button" title="Download template" data-bind="attr: { title: $root.t(\'Download template\') }">    <i class="fas fa-file-archive" aria-hidden="true"></i>    <span data-bind="text: $root.t($root.download.name)">DOWNLOAD</span>  </button>  <div class="download__panel">    <a class="download__panel_action" href="javascript:void(0)" data-bind="click: $root.download.execute.bind($element, \'image\'), clickBubble: false, button: { disabled: !$root.download.enabled(), label: $root.t(\'download-with-images\'), text: true }">DOWNLOAD</a>    <a class="download__panel_action" href="javascript:void(0)" data-bind="click: $root.download.execute.bind($element, \'cdn\'), clickBubble: false, button: { disabled: !$root.download.enabled(), label: $root.t(\'download-cdn\'), text: true }">DOWNLOAD</a>  </div></form>\x3c!-- /ko --\x3e'),templateSystem.addTemplate("edit-name",'\x3c!-- ko if: $root.titleMode() == \'edit\' || $root.titleMode() == \'saving\' --\x3e<form class="mailing-name" data-bind="submit: saveEditMailingName, submitBubble: false">  <input type="text" data-bind="value: $root.metadata.name, disable: $root.titleMode() == \'saving\', hasFocus: $root.titleMode() == \'edit\'"/>  <button type="button" data-bind="click: cancelEditMailingName, clickBubble: false, disable: $root.titleMode() == \'saving\',  button: { refreshOn: $root.showPreviewFrame, icons: { primary: \'fa fa-fw fa-times\', secondary: null }, text: false, label: $root.t(\'edit-title-cancel\') }">cancel</button>  <button type="submit" data-bind="disable: $root.titleMode() == \'saving\',    button: { refreshOn: $root.showPreviewFrame, icons: { primary: \'fa fa-fw fa-check-circle\', secondary: null }, text: false, label: $root.t(\'edit-title-save\') }">save</button></form>\x3c!-- /ko --\x3e\x3c!-- ko if: $root.titleMode() == \'show\' --\x3e<div class="mailing-name">  <p class="ui-button" data-bind="event: { dblclick: enableEditMailingName }, dblclickBubble: false,    attr: { title: $root.t(\'edit-title-double-click\') }">    <span class="ui-button-text" data-bind="text: $root.mailingName"></span>  </p></div>\x3c!-- /ko --\x3e'),templateSystem.addTemplate("gallery-images",'<aside class="gallery-thumbs gallery-thumbs--custom" data-bind="attr: {\'data-type\': type}">  <div data-bind="foreach: items">    <div class="draggable-item" data-bind="if: typeof thumbnailUrl != \'undefined\'">      <button class="gallery-thumbs__remove" data-bind="click: $root.removeImage.bind($data, $data, $parent.type)">        <i class="fa fa-times"></i>      </button>      <div class="draggable image" data-bind="click: $root.addImage, extdraggable: { data: $data, dropContainer: \'#main-wysiwyg-area\', dragging: $root.draggingImage, \'options\': { \'appendTo\': \'#page\' } }, style: { backgroundImage: \'url(\\\'\' + thumbnailUrl + \'\\\')\' }">        <img title="Drag this image and drop it on any template image placeholder" style="display: block;" data-bind="tooltips: {}, attr: { src: thumbnailUrl, \'title\': $root.t(\'Drag this image and drop it on any template image placeholder\') }"/>      </div>    </div>  </div></aside>'),templateSystem.addTemplate("gallery-upload",'<div data-drop-content="Drop here" class="img-dropzone pane uploadzone" data-bind="attr: { \'data-drop-content\': $root.t(\'Drop here\') }, fudroppable: { activeClass: \'ui-state-highlight\', hoverClass: \'ui-state-draghover\' }">  <div class="mo-uploadzone">    \x3c!-- ko if: type === \'mailing\' --\x3e      <input class="fileupload" type="file" multiple name="files[]" data-bind="fileupload: { onerror: $root.notifier.error, onfile: $root.loadMailingImage }">    \x3c!-- /ko --\x3e    \x3c!-- ko if: type === \'template\' --\x3e      <input class="fileupload" type="file" multiple name="files[]" data-bind="fileupload: { onerror: $root.notifier.error, onfile: $root.loadTemplateImage, uploadToTemplate: true }">    \x3c!-- /ko --\x3e    <span data-bind="text: $root.t(\'Click or drag files here\')">Click or drag files here</span>      <div class="workzone">        <div class="progress">          <div class="progress-bar progress-bar-success"></div>        </div>      </div>  </div></div>'),templateSystem.addTemplate("home-icon",'<div id="loading" class="loading" data-bind="css: { loading: false }">  <a href="/" id="home-button" alt="mosaic-backend" data-bind="attr: { alt: $root.brandName }">    <i class="fas fa-home fa-lg" aria-hidden="true"></i>  </a>  <div style="opacity: 0" data-bind="visible: false">Oppps... !!</div></div>')});

},{"../src/js/bindings/choose-template.js":46}],2:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":35}],3:[function(require,module,exports){
(function (global){
/*global window, global*/
var util = require("util")
var assert = require("assert")
var now = require("date-now")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"assert":2,"date-now":4,"util":35}],4:[function(require,module,exports){
module.exports = now

function now() {
    return new Date().getTime()
}

},{}],5:[function(require,module,exports){
/*
 evol-colorpicker 3.3.1
 ColorPicker widget for jQuery UI

 https://github.com/evoluteur/colorpicker
 (c) 2017 Olivier Giulieri

 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */

(function( $, undefined ) {

var _idx=0,
	ua=window.navigator.userAgent,
	isIE=ua.indexOf("MSIE ")>0,
	_ie=isIE?'-ie':'',
	isMoz=isIE?false:/mozilla/.test(ua.toLowerCase()) && !/webkit/.test(ua.toLowerCase()),
	history=[],
	baseThemeColors=['ffffff','000000','eeece1','1f497d','4f81bd','c0504d','9bbb59','8064a2','4bacc6','f79646'],
	subThemeColors=['f2f2f2','7f7f7f','ddd9c3','c6d9f0','dbe5f1','f2dcdb','ebf1dd','e5e0ec','dbeef3','fdeada',
		'd8d8d8','595959','c4bd97','8db3e2','b8cce4','e5b9b7','d7e3bc','ccc1d9','b7dde8','fbd5b5',
		'bfbfbf','3f3f3f','938953','548dd4','95b3d7','d99694','c3d69b','b2a2c7','92cddc','fac08f',
		'a5a5a5','262626','494429','17365d','366092','953734','76923c','5f497a','31859b','e36c09',
		'7f7f7f','0c0c0c','1d1b10','0f243e','244061','632423','4f6128','3f3151','205867','974806'],
	standardColors=['c00000','ff0000','ffc000','ffff00','92d050','00b050','00b0f0','0070c0','002060','7030a0'],
	webColors=[
		['003366','336699','3366cc','003399','000099','0000cc','000066'],
		['006666','006699','0099cc','0066cc','0033cc','0000ff','3333ff','333399'],
		['669999','009999','33cccc','00ccff','0099ff','0066ff','3366ff','3333cc','666699'],
		['339966','00cc99','00ffcc','00ffff','33ccff','3399ff','6699ff','6666ff','6600ff','6600cc'],
		['339933','00cc66','00ff99','66ffcc','66ffff','66ccff','99ccff','9999ff','9966ff','9933ff','9900ff'],
		['006600','00cc00','00ff00','66ff99','99ffcc','ccffff','ccccff','cc99ff','cc66ff','cc33ff','cc00ff','9900cc'],
		['003300','009933','33cc33','66ff66','99ff99','ccffcc','ffffff','ffccff','ff99ff','ff66ff','ff00ff','cc00cc','660066'],
		['333300','009900','66ff33','99ff66','ccff99','ffffcc','ffcccc','ff99cc','ff66cc','ff33cc','cc0099','993399'],
		['336600','669900','99ff33','ccff66','ffff99','ffcc99','ff9999','ff6699','ff3399','cc3399','990099'],
		['666633','99cc00','ccff33','ffff66','ffcc66','ff9966','ff6666','ff0066','d60094','993366'],
		['a58800','cccc00','ffff00','ffcc00','ff9933','ff6600','ff0033','cc0066','660033'],
		['996633','cc9900','ff9900','cc6600','ff3300','ff0000','cc0000','990033'],
		['663300','996600','cc3300','993300','990000','800000','993333']
	],
	transColor='#0000ffff',
	int2Hex=function(i){
		var h=i.toString(16);
		if(h.length==1){
			h='0'+h;
		}
		return h;
	},
	st2Hex=function(s){
		return int2Hex(Number(s));
	},
	int2Hex3=function(i){
		var h=int2Hex(i);
		return h+h+h;
	},
	toHex3=function(c){
		if(c.length>10){ // IE9
			var p1=1+c.indexOf('('),
				p2=c.indexOf(')'),
				cs=c.substring(p1,p2).split(',');
			return ['#',st2Hex(cs[0]),st2Hex(cs[1]),st2Hex(cs[2])].join('');
		}else{
			return c;
		}
	};

$.widget( "evol.colorpicker", {

	version: '3.3.1',
	
	options: {
		color: null, // example:'#31859B'
		customTheme: null, // example: ["#ff0000", "#00ff00", "blue"],
		showOn: 'both', // possible values: 'focus','button','both'
		hideButton: false,
		displayIndicator: true,
		transparentColor: false,
		history: true,
		defaultPalette: 'theme', // possible values: 'theme', 'web'
		strings: 'Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.'
	},

	// this is only true while showing the palette until color is chosen
	_active: false,

	_create: function() {
		var that=this;
		this._paletteIdx=this.options.defaultPalette=='theme'?1:2;
		this._id='evo-cp'+_idx++;
		this._enabled=true;
		this.options.showOn=this.options.hideButton?'focus':this.options.showOn;
		switch(this.element.get(0).tagName){
			case 'INPUT':
				var color=this.options.color,
					e=this.element,
					css=((this.options.showOn==='focus')?'':'evo-pointer ')+'evo-colorind'+(isMoz?'-ff':_ie)+(this.options.hideButton?' evo-hidden-button':''),
					style='';
				this._isPopup=true;
				this._palette=null;
				var v=e.val();
				if(color!==null){
					if (color != v) e.val(color).change();
				}else{
					if(v!==''){
						color=this.options.color=v;
					}
				}
				if(color===transColor){
					css+=' evo-transparent';
				}else{
					style=(color!==null)?('background-color:'+color):'';
				}
				e.addClass('colorPicker '+this._id)
					.wrap('<div style="width:'+(this.options.hideButton?this.element.width():this.element.width()+32)+'px;'+
						(isIE?'margin-bottom:-21px;':'')+
						(isMoz?'padding:1px 0;':'')+
						'" class="evo-cp-wrap"></div>')
					.after('<div class="'+css+'" style="'+style+'"></div>')
					.on('keyup onpaste', function(evt){
						var c=$(this).val();
						if(c!=that.options.color){
							that._setValue(c, true);
						}
					});
				var showOn=this.options.showOn;
				if(showOn==='both' || showOn==='focus'){
					e.on('focus', function(){
						that.showPalette();
					});
				}
				if(showOn==='both' || showOn==='button'){
					e.next().on('click', function(evt){
						evt.stopPropagation();
						that.showPalette();
						return false;
					});
				}
				break;
			default:
				this._isPopup=false;
				this._palette=this.element.html(this._paletteHTML())
					.attr('aria-haspopup','true');
				this._bindColors();
		}
		if(this.options.history){
			if(color){
				this._add2History(color);
			}
			if (this.options.initialHistory) {
				var c = this.options.initialHistory;
				for (var i in c){
					this._add2History(c[i]);
				}
			}
		}
	},

	_paletteHTML: function() {
		var pIdx=this._paletteIdx=Math.abs(this._paletteIdx),
			opts=this.options,
			labels=opts.strings.split(',');

		var h='<div class="evo-pop'+_ie+' ui-widget ui-widget-content ui-corner-all"'+
			(this._isPopup?' style="position:absolute"':'')+'>'+
			// palette
			'<span>'+this['_paletteHTML'+pIdx]()+'</span>'+
			// links
			'<div class="evo-more"><a href="javascript:void(0)">'+labels[1+pIdx]+'</a>';
		if(opts.history){
			h+='<a href="javascript:void(0)" class="evo-hist">'+labels[5]+'</a>';
		}
		h+='</div>';
		// indicator
		if(opts.displayIndicator){
			h+=this._colorIndHTML(this.options.color)+this._colorIndHTML('');
		}
		h+='</div>';
		return h;
	},

	_colorIndHTML: function(c) {
		var css=isIE?'evo-colorbox-ie ':'',
			style='';

		if(c){
			if(c===transColor){
				css+='evo-transparent';
			}else{
				style='background-color:'+c;
			}
		}else{
			style='display:none';
		}
		return '<div class="evo-color" style="float:left">'+
			'<div style="'+style+'" class="'+css+'"></div><span>'+ // class="evo-colortxt-ie"
			(c?c:'')+'</span></div>';
	},

	_paletteHTML1: function() {
		var opts=this.options,
			labels=opts.strings.split(','),
			oTD='<td style="background-color:',
			cTD=isIE?'"><div style="width:2px;"></div></td>':'"><span/></td>',
			oTRTH='<tr><th colspan="10" class="ui-widget-content">',
			i;

		var h='<table class="evo-palette'+_ie+'">'+oTRTH+labels[0]+'</th></tr><tr>';

		if (opts.customTheme) {
			for (i=0, ml=opts.customTheme.length;i<ml;i++) {
				h+=oTD+opts.customTheme[i]+cTD;
			}
		} else {
			oTD+='#';
			// base theme colors
			for(i=0;i<10;i++){ 
				h+=oTD+baseThemeColors[i]+cTD;
			}
			h+='</tr>';
			if(!isIE){
				h+='<tr><th colspan="10"></th></tr>';
			}
			h+='<tr class="top">';
			// theme colors
			for(i=0;i<10;i++){ 
				h+=oTD+subThemeColors[i]+cTD;
			}
			for(var r=1;r<4;r++){
				h+='</tr><tr class="in">';
				for(i=0;i<10;i++){ 
					h+=oTD+subThemeColors[r*10+i]+cTD;
				}
			}
			h+='</tr><tr class="bottom">';
			for(i=40;i<50;i++){ 
				h+=oTD+subThemeColors[i]+cTD;
			}
			h+='</tr>'+oTRTH;
			// transparent color
			if(opts.transparentColor){
				h+='<div class="evo-transparent evo-tr-box"></div>';
			}
			h+=labels[1]+'</th></tr><tr>';
			// standard colors
			for(i=0;i<10;i++){ 
				h+=oTD+standardColors[i]+cTD;
			}
		}
		h+='</tr></table>';
		return h; 
	},

	_paletteHTML2: function() {
		var i, iMax,
			oTD='<td style="background-color:#',
			cTD=isIE?'"><div style="width:5px;"></div></td>':'"><span/></td>',
			oTableTR='<table class="evo-palette2'+_ie+'"><tr>',
			cTableTR='</tr></table>';

		var h='<div class="evo-palcenter">';
		// hexagon colors
		for(var r=0,rMax=webColors.length;r<rMax;r++){
			h+=oTableTR;
			var cs=webColors[r];
			for(i=0,iMax=cs.length;i<iMax;i++){ 
				h+=oTD+cs[i]+cTD;
			}
			h+=cTableTR;
		}
		h+='<div class="evo-sep"/>';
		// gray scale colors
		var h2='';
		h+=oTableTR;
		for(i=255;i>10;i-=10){
			h+=oTD+int2Hex3(i)+cTD;
			i-=10;
			h2+=oTD+int2Hex3(i)+cTD;
		}
		h+=cTableTR+oTableTR+h2+cTableTR+'</div>';
		return h;
	},

	_switchPalette: function(link) {
		if(this._enabled){
			var idx, 
				content, 
				label,
				opts=this.options,
				labels=opts.strings.split(',');
			if($(link).hasClass('evo-hist')){
				// history
				var h='<table class="evo-palette"><tr><th class="ui-widget-content">'+
					labels[5]+'</th></tr></tr></table>'+
					'<div class="evo-cHist">';
				if(history.length===0){
					h+='<p>&nbsp;'+labels[6]+'</p>';
				}else{
					for(var i=history.length-1;i>-1;i--){
						if(history[i].length===9){
							if(opts.transparentColor){
								h+='<div class="evo-transparent"></div>';
							}
						}else{
							h+='<div style="background-color:'+history[i]+'"></div>';
						}
					}
				}
				h+='</div>';
				idx=-this._paletteIdx;
				content=h;
				label=labels[4];
			}else{
				// palette
				if(this._paletteIdx<0){
					idx=-this._paletteIdx;
					this._palette.find('.evo-hist').show();
				}else{
					idx=(this._paletteIdx==2)?1:2;
				}
				content=this['_paletteHTML'+idx]();
				label=labels[idx+1];
				this._paletteIdx=idx;
			}
			this._paletteIdx=idx;
			var e=this._palette.find('.evo-more')
				.prev().html(content).end()
				.children().eq(0).html(label);
			if(idx<0){
				e.next().hide();
			}
		}
	},

	_downOrUpPositioning: function() {
		var el = this.element,
			i = 0;
		while (el !== null && i < 100) {
			// Look up the first parent with non-visibile overflow and compute the relative position
			if (el.css('overflow') != 'visible') {
				var bott = this._palette.offset().top + this._palette.height(),
					pBott = el.offset().top + el.height(),
					top = this._palette.offset().top - this._palette.height() - this.element.outerHeight(),
					pTop = el.offset().top,
					openUp = bott > pBott && top > pTop;
				if (openUp) {
					this._palette.css({ bottom: this.element.outerHeight()+'px' });
				} else {
					this._palette.css({ bottom: 'auto' });
				}
				break;
			}
			if (el[0].tagName == 'HTML') break;
			else el = el.offsetParent();
			i++;
		}
	},

	showPalette: function() {
		if(this._enabled){
			this._active=true;
			$('.colorPicker').not('.'+this._id).colorpicker('hidePalette');
			if(this._palette===null){
				this._palette=this.element.next()
					.after(this._paletteHTML()).next()
					.on('click',function(evt){
						evt.stopPropagation();
						return false;
					});
				this._bindColors();
				var that=this;
				if(this._isPopup){
					this._downOrUpPositioning();
					$(document.body).on('click.'+that._id, function(evt){
						if(evt.target!=that.element.get(0)){
							that.hidePalette();
						}
					}).on('keyup.'+that._id, function(evt){
						if(evt.keyCode===27){
							that.hidePalette();
						}
					});
				}
			}
		}
		return this;
	},

	hidePalette: function() {
		if(this._isPopup && this._palette){
			$(document.body).off('click.'+this._id);
			var that=this;
			this._palette.off('mouseover click', 'td,.evo-transparent')
				.fadeOut(function(){
					that._palette.remove();
					that._palette=that._cTxt=null;
				})
				.find('.evo-more a').off('click');
		}
		return this;
	},

	_bindColors: function() {
		var that=this,
			opts=this.options,
			es=this._palette.find('div.evo-color'),
			sel=opts.history?'td,.evo-cHist>div':'td';

		if(opts.transparentColor){
			sel+=',.evo-transparent';
		}
		this._cTxt1=es.eq(0).children().eq(0);
		this._cTxt2=es.eq(1).children().eq(0);
		this._palette
			.on('click', sel, function(evt){
				if(that._enabled){
					var $this=$(this);
					that._setValue($this.hasClass('evo-transparent')?transColor:toHex3($this.attr('style').substring(17)));
					that._active=false;
				}
			})
			.on('mouseover', sel, function(evt){
				if(that._enabled){
					var $this=$(this),
						c=$this.hasClass('evo-transparent')?transColor:toHex3($this.attr('style').substring(17));
					if(that.options.displayIndicator){
						that._setColorInd(c,2);
					}
					if(that._active){
						that.element.trigger('mouseover.color', c);
					}
				}
			})
			.find('.evo-more a').on('click', function(){
				that._switchPalette(this);
			});
	},

	val: function(value) {
		if (typeof value=='undefined') {
			return this.options.color;
		}else{
			this._setValue(value);
			return this;
		}
	},

	_setValue: function(c, noHide) {
		c = c.replace(/ /g,'');
		this.options.color=c;
		if(this._isPopup){
			if(!noHide){
				this.hidePalette();
			}
			this._setBoxColor(this.element.val(c).change().next(), c);
		}else{
			this._setColorInd(c,1);
		}
		if(this.options.history && this._paletteIdx>0){
			this._add2History(c);
		}
		this.element.trigger('change.color', c);
	},

	_setColorInd: function(c, idx) {
		var $box=this['_cTxt'+idx];
		this._setBoxColor($box, c);
		$box.next().html(c);
	},

	_setBoxColor: function($box, c) {
		if(c===transColor){
			$box.addClass('evo-transparent')
				.removeAttr('style');
		}else{
			$box.removeClass('evo-transparent')
				.attr('style','background-color:'+c);
		}
	},

	_setOption: function(key, value) {
		if(key=='color'){
			this._setValue(value, true);
		}else{
			this.options[key]=value;
		}
	},

	_add2History: function(c) {
		var iMax=history.length;
		// skip color if already in history
		for(var i=0;i<iMax;i++){
			if(c==history[i]){
				return;
			}
		}
		// limit of 28 colors in history
		if(iMax>27){
			history.shift();
		}
		// add to history
		history.push(c);
	},

	clear: function(){
		this.hidePalette().val('');
	},

	enable: function() {
		var e=this.element;
		if(this._isPopup){
			e.removeAttr('disabled');
		}else{
			e.css({
				'opacity': '1', 
				'pointer-events': 'auto'
			});
		}
		if(this.options.showOn!=='focus'){
			this.element.next().addClass('evo-pointer');
		}
		e.removeAttr('aria-disabled');
		this._enabled=true;
		return this;
	},

	disable: function() {
		var e=this.element;
		if(this._isPopup){
			e.attr('disabled', 'disabled');
		}else{
			this.hidePalette();
			e.css({
				'opacity': '0.3', 
				'pointer-events': 'none'
			});
		}
		if(this.options.showOn!=='focus'){
			this.element.next().removeClass('evo-pointer');
		}
		e.attr('aria-disabled','true');
		this._enabled=false;
		return this;
	},

	isDisabled: function() {
		return !this._enabled;
	},

	destroy: function() {
		$(document.body).off('click.'+this._id);
		if(this._palette){
			this._palette.off('mouseover click', 'td,.evo-cHist>div,.evo-transparent')
				.find('.evo-more a').off('click');
			if(this._isPopup){
				this._palette.remove();
			}
			this._palette=this._cTxt=null;
		}
		if(this._isPopup){
			this.element
				.next().off('click').remove()
				.end().off('focus').unwrap();
		}
		this.element.removeClass('colorPicker '+this.id).empty();
		$.Widget.prototype.destroy.call(this);
	}

});

})(jQuery);

},{}],6:[function(require,module,exports){
//     JavaScript Expression Parser (JSEP) 0.3.4
//     JSEP may be freely distributed under the MIT License
//     http://jsep.from.so/

/*global module: true, exports: true, console: true */
(function (root) {
	'use strict';
	// Node Types
	// ----------

	// This is the full set of types that any JSEP node can be.
	// Store them here to save space when minified
	var COMPOUND = 'Compound',
		IDENTIFIER = 'Identifier',
		MEMBER_EXP = 'MemberExpression',
		LITERAL = 'Literal',
		THIS_EXP = 'ThisExpression',
		CALL_EXP = 'CallExpression',
		UNARY_EXP = 'UnaryExpression',
		BINARY_EXP = 'BinaryExpression',
		LOGICAL_EXP = 'LogicalExpression',
		CONDITIONAL_EXP = 'ConditionalExpression',
		ARRAY_EXP = 'ArrayExpression',

		PERIOD_CODE = 46, // '.'
		COMMA_CODE  = 44, // ','
		SQUOTE_CODE = 39, // single quote
		DQUOTE_CODE = 34, // double quotes
		OPAREN_CODE = 40, // (
		CPAREN_CODE = 41, // )
		OBRACK_CODE = 91, // [
		CBRACK_CODE = 93, // ]
		QUMARK_CODE = 63, // ?
		SEMCOL_CODE = 59, // ;
		COLON_CODE  = 58, // :

		throwError = function(message, index) {
			var error = new Error(message + ' at character ' + index);
			error.index = index;
			error.description = message;
			throw error;
		},

	// Operations
	// ----------

	// Set `t` to `true` to save space (when minified, not gzipped)
		t = true,
	// Use a quickly-accessible map to store all of the unary operators
	// Values are set to `true` (it really doesn't matter)
		unary_ops = {'-': t, '!': t, '~': t, '+': t},
	// Also use a map for the binary operations but set their values to their
	// binary precedence for quick reference:
	// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
		binary_ops = {
			'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,
			'==': 6, '!=': 6, '===': 6, '!==': 6,
			'<': 7,  '>': 7,  '<=': 7,  '>=': 7,
			'<<':8,  '>>': 8, '>>>': 8,
			'+': 9, '-': 9,
			'*': 10, '/': 10, '%': 10
		},
	// Get return the longest key length of any object
		getMaxKeyLen = function(obj) {
			var max_len = 0, len;
			for(var key in obj) {
				if((len = key.length) > max_len && obj.hasOwnProperty(key)) {
					max_len = len;
				}
			}
			return max_len;
		},
		max_unop_len = getMaxKeyLen(unary_ops),
		max_binop_len = getMaxKeyLen(binary_ops),
	// Literals
	// ----------
	// Store the values to return for the various literals we may encounter
		literals = {
			'true': true,
			'false': false,
			'null': null
		},
	// Except for `this`, which is special. This could be changed to something like `'self'` as well
		this_str = 'this',
	// Returns the precedence of a binary operator or `0` if it isn't a binary operator
		binaryPrecedence = function(op_val) {
			return binary_ops[op_val] || 0;
		},
	// Utility function (gets called from multiple places)
	// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
		createBinaryExpression = function (operator, left, right) {
			var type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;
			return {
				type: type,
				operator: operator,
				left: left,
				right: right
			};
		},
		// `ch` is a character code in the next three functions
		isDecimalDigit = function(ch) {
			return (ch >= 48 && ch <= 57); // 0...9
		},
		isIdentifierStart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator
		},
		isIdentifierPart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 48 && ch <= 57) || // 0...9
                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator
		},

		// Parsing
		// -------
		// `expr` is a string with the passed in expression
		jsep = function(expr) {
			// `index` stores the character number we are currently at while `length` is a constant
			// All of the gobbles below will modify `index` as we move along
			var index = 0,
				charAtFunc = expr.charAt,
				charCodeAtFunc = expr.charCodeAt,
				exprI = function(i) { return charAtFunc.call(expr, i); },
				exprICode = function(i) { return charCodeAtFunc.call(expr, i); },
				length = expr.length,

				// Push `index` up to the next non-space character
				gobbleSpaces = function() {
					var ch = exprICode(index);
					// space or tab
					while(ch === 32 || ch === 9 || ch === 10 || ch === 13) {
						ch = exprICode(++index);
					}
				},

				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function() {
					var test = gobbleBinaryExpression(),
						consequent, alternate;
					gobbleSpaces();
					if(exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if(!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if(exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if(!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},

				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function() {
					gobbleSpaces();
					var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
					while(tc_len > 0) {
						// Don't accept a binary op when it is an identifier.
						// Binary ops that start with a identifier-valid character must be followed
						// by a non identifier-part valid character
						if(binary_ops.hasOwnProperty(to_check) && (
							!isIdentifierStart(exprICode(index)) ||
							(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))
						)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},

				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function() {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if(!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop)};

					right = gobbleToken();
					if(!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while((biop = gobbleBinaryOp())) {
						prec = binaryPrecedence(biop);

						if(prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if(!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while(i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);
						i -= 2;
					}
					return node;
				},

				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function() {
					var ch, to_check, tc_len;

					gobbleSpaces();
					ch = exprICode(index);

					if(isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while(tc_len > 0) {
						// Don't accept an unary op when it is an identifier.
						// Unary ops that start with a identifier-valid character must be followed
						// by a non identifier-part valid character
							if(unary_ops.hasOwnProperty(to_check) && (
								!isIdentifierStart(exprICode(index)) ||
								(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))
							)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}

						if (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis
							// `foo`, `bar.baz`
							return gobbleVariable();
						}
					}

					return false;
				},
				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function() {
					var number = '', ch, chCode;
					while(isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker
						number += exprI(index++);

						while(isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}

					ch = exprI(index);
					if(ch === 'e' || ch === 'E') { // exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if(ch === '+' || ch === '-') { // exponent sign
							number += exprI(index++);
						}
						while(isDecimalDigit(exprICode(index))) { //exponent itself
							number += exprI(index++);
						}
						if(!isDecimalDigit(exprICode(index-1)) ) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}


					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if(isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' +
									number + exprI(index) + ')', index);
					} else if(chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},

				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function() {
					var str = '', quote = exprI(index++), closed = false, ch;

					while(index < length) {
						ch = exprI(index++);
						if(ch === quote) {
							closed = true;
							break;
						} else if(ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch(ch) {
								case 'n': str += '\n'; break;
								case 'r': str += '\r'; break;
								case 't': str += '\t'; break;
								case 'b': str += '\b'; break;
								case 'f': str += '\f'; break;
								case 'v': str += '\x0B'; break;
								default : str += ch;
							}
						} else {
							str += ch;
						}
					}

					if(!closed) {
						throwError('Unclosed quote after "'+str+'"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},

				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function() {
					var ch = exprICode(index), start = index, identifier;

					if(isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while(index < length) {
						ch = exprICode(index);
						if(isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if(literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if(identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},

				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function(termination) {
					var ch_i, args = [], node, closed = false;
					while(index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if(ch_i === termination) { // done parsing
							closed = true;
							index++;
							break;
						} else if (ch_i === COMMA_CODE) { // between expressions
							index++;
						} else {
							node = gobbleExpression();
							if(!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					if (!closed) {
						throwError('Expected ' + String.fromCharCode(termination), index);
					}
					return args;
				},

				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function() {
					var ch_i, node;
					ch_i = exprICode(index);

					if(ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if(ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if(ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if(ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if(ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},

				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function() {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if(exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},

				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function() {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},

				nodes = [], ch_i, node;

			while(index < length) {
				ch_i = exprICode(index);

				// Expressions can be separated by semicolons, commas, or just inferred without any
				// separators
				if(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
					index++; // ignore separators
				} else {
					// Try to gobble each expression individually
					if((node = gobbleExpression())) {
						nodes.push(node);
					// If we weren't able to find a binary expression and are out of room, then
					// the expression passed in probably has too much
					} else if(index < length) {
						throwError('Unexpected "' + exprI(index) + '"', index);
					}
				}
			}

			// If there's only one expression just try returning the expression
			if(nodes.length === 1) {
				return nodes[0];
			} else {
				return {
					type: COMPOUND,
					body: nodes
				};
			}
		};

	// To be filled in by the template
	jsep.version = '0.3.4';
	jsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };

	/**
	 * @method jsep.addUnaryOp
	 * @param {string} op_name The name of the unary op to add
	 * @return jsep
	 */
	jsep.addUnaryOp = function(op_name) {
		max_unop_len = Math.max(op_name.length, max_unop_len);
		unary_ops[op_name] = t; return this;
	};

	/**
	 * @method jsep.addBinaryOp
	 * @param {string} op_name The name of the binary op to add
	 * @param {number} precedence The precedence of the binary op (can be a float)
	 * @return jsep
	 */
	jsep.addBinaryOp = function(op_name, precedence) {
		max_binop_len = Math.max(op_name.length, max_binop_len);
		binary_ops[op_name] = precedence;
		return this;
	};

	/**
	 * @method jsep.addLiteral
	 * @param {string} literal_name The name of the literal to add
	 * @param {*} literal_value The value of the literal
	 * @return jsep
	 */
	jsep.addLiteral = function(literal_name, literal_value) {
		literals[literal_name] = literal_value;
		return this;
	};

	/**
	 * @method jsep.removeUnaryOp
	 * @param {string} op_name The name of the unary op to remove
	 * @return jsep
	 */
	jsep.removeUnaryOp = function(op_name) {
		delete unary_ops[op_name];
		if(op_name.length === max_unop_len) {
			max_unop_len = getMaxKeyLen(unary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeAllUnaryOps
	 * @return jsep
	 */
	jsep.removeAllUnaryOps = function() {
		unary_ops = {};
		max_unop_len = 0;

		return this;
	};

	/**
	 * @method jsep.removeBinaryOp
	 * @param {string} op_name The name of the binary op to remove
	 * @return jsep
	 */
	jsep.removeBinaryOp = function(op_name) {
		delete binary_ops[op_name];
		if(op_name.length === max_binop_len) {
			max_binop_len = getMaxKeyLen(binary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeAllBinaryOps
	 * @return jsep
	 */
	jsep.removeAllBinaryOps = function() {
		binary_ops = {};
		max_binop_len = 0;

		return this;
	};

	/**
	 * @method jsep.removeLiteral
	 * @param {string} literal_name The name of the literal to remove
	 * @return jsep
	 */
	jsep.removeLiteral = function(literal_name) {
		delete literals[literal_name];
		return this;
	};

	/**
	 * @method jsep.removeAllLiterals
	 * @return jsep
	 */
	jsep.removeAllLiterals = function() {
		literals = {};

		return this;
	};

	// In desktop environments, have a way to restore the old value for `jsep`
	if (typeof exports === 'undefined') {
		var old_jsep = root.jsep;
		// The star of the show! It's a function!
		root.jsep = jsep;
		// And a courteous function willing to move out of the way for other similarly-named objects!
		jsep.noConflict = function() {
			if(root.jsep === jsep) {
				root.jsep = old_jsep;
			}
			return jsep;
		};
	} else {
		// In Node.JS environments
		if (typeof module !== 'undefined' && module.exports) {
			exports = module.exports = jsep;
		} else {
			exports.parse = jsep;
		}
	}
}(this));

},{}],7:[function(require,module,exports){
'use strict';

var utils = require('./utils');

module.exports = function makeJuiceClient(juiceClient) {

juiceClient.ignoredPseudos = ['hover', 'active', 'focus', 'visited', 'link'];
juiceClient.widthElements = ['TABLE', 'TD', 'IMG'];
juiceClient.heightElements = ['TABLE', 'TD', 'IMG'];
juiceClient.tableElements = ['TABLE', 'TD', 'TH', 'TR', 'TD', 'CAPTION', 'COLGROUP', 'COL', 'THEAD', 'TBODY', 'TFOOT'];
juiceClient.nonVisualElements = [ 'HEAD', 'TITLE', 'BASE', 'LINK', 'STYLE', 'META', 'SCRIPT', 'NOSCRIPT' ];
juiceClient.styleToAttribute = {
  'background-color': 'bgcolor',
  'background-image': 'background',
  'text-align': 'align',
  'vertical-align': 'valign'
};
juiceClient.excludedProperties = [];

juiceClient.juiceDocument = juiceDocument;
juiceClient.inlineDocument = inlineDocument;

function inlineDocument($, css, options) {

  options = options || {};
  var rules = utils.parseCSS(css);
  var editedElements = [];
  var styleAttributeName = 'style';

  if (options.styleAttributeName) {
    styleAttributeName = options.styleAttributeName;
  }

  rules.forEach(handleRule);
  editedElements.forEach(setStyleAttrs);

  if (options.inlinePseudoElements) {
    editedElements.forEach(inlinePseudoElements);
  }

  if (options.applyWidthAttributes) {
    editedElements.forEach(function(el) {
      setDimensionAttrs(el, 'width');
    });
  }

  if (options.applyHeightAttributes) {
    editedElements.forEach(function(el) {
      setDimensionAttrs(el, 'height');
    });
  }

  if (options.applyAttributesTableElements) {
    editedElements.forEach(setAttributesOnTableElements);
  }

  if (options.insertPreservedExtraCss && options.extraCss) {
    var preservedText = utils.getPreservedText(options.extraCss, {
      mediaQueries: options.preserveMediaQueries,
      fontFaces: options.preserveFontFaces,
      keyFrames: options.preserveKeyFrames
    });
    if (preservedText) {
      var $appendTo = null;
      if (options.insertPreservedExtraCss !== true) {
        $appendTo = $(options.insertPreservedExtraCss);
      } else {
        $appendTo = $('head');
        if (!$appendTo.length) { $appendTo = $('body'); }
        if (!$appendTo.length) { $appendTo = $.root(); }
      }

      $appendTo.first().append('<style>' + preservedText + '</style>');
    }
  }

  function handleRule(rule) {
    var sel = rule[0];
    var style = rule[1];
    var selector = new utils.Selector(sel);
    var parsedSelector = selector.parsed();
    var pseudoElementType = getPseudoElementType(parsedSelector);

    // skip rule if the selector has any pseudos which are ignored
    for (var i = 0; i < parsedSelector.length; ++i) {
      var subSel = parsedSelector[i];
      if (subSel.pseudos) {
        for (var j = 0; j < subSel.pseudos.length; ++j) {
          var subSelPseudo = subSel.pseudos[j];
          if (juiceClient.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {
            return;
          }
        }
      }
    }

    if (pseudoElementType) {
      var last = parsedSelector[parsedSelector.length - 1];
      var pseudos = last.pseudos;
      last.pseudos = filterElementPseudos(last.pseudos);
      sel = parsedSelector.toString();
      last.pseudos = pseudos;
    }

    var els;
    try {
      els = $(sel);
    } catch (err) {
      // skip invalid selector
      return;
    }

    els.each(function() {
      var el = this;

      if (el.name && juiceClient.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {
        return;
      }

      if (pseudoElementType) {
        var pseudoElPropName = 'pseudo' + pseudoElementType;
        var pseudoEl = el[pseudoElPropName];
        if (!pseudoEl) {
          pseudoEl = el[pseudoElPropName] = $('<span />').get(0);
          pseudoEl.pseudoElementType = pseudoElementType;
          pseudoEl.pseudoElementParent = el;
          el[pseudoElPropName] = pseudoEl;
        }
        el = pseudoEl;
      }

      if (!el.styleProps) {
        el.styleProps = {};

        // if the element has inline styles, fake selector with topmost specificity
        if ($(el).attr(styleAttributeName)) {
          var cssText = '* { ' + $(el).attr(styleAttributeName) + ' } ';
          addProps(utils.parseCSS(cssText)[0][1], new utils.Selector('<style>', true));
        }

        // store reference to an element we need to compile style="" attr for
        editedElements.push(el);
      }

      // go through the properties
      function addProps(style, selector) {
        for (var i = 0, l = style.length; i < l; i++) {
          if (style[i].type == 'property') {
            var name = style[i].name;
            var value = style[i].value;
            var important = style[i].value.match(/!important$/) !== null;
            if (important && !options.preserveImportant) value = value.replace(/\s*!important$/, '');
            // adds line number and column number for the properties as "additionalPriority" to the
            // properties because in CSS the position directly affect the priority.
            var additionalPriority = [style[i].position.start.line, style[i].position.start.col];
            var prop = new utils.Property(name, value, selector, important ? 2 : 0, additionalPriority);
            var existing = el.styleProps[name];

            // if property name is not in the excluded properties array
            if (juiceClient.excludedProperties.indexOf(name) < 0) {
              if (existing && existing.compare(prop) === prop || !existing) {
                // deleting a property let us change the order (move it to the end in the setStyleAttrs loop)
                if (existing && existing.selector !== selector) {
                  delete el.styleProps[name];
                } else if (existing) {
                  // make "prop" a special composed property.
                  prop.nextProp = existing;
                }

                el.styleProps[name] = prop;
              }
            }
          }
        }
      }

      addProps(style, selector);
    });
  }

  function setStyleAttrs(el) {
    var l = Object.keys(el.styleProps).length;
    var props = [];
    // Here we loop each property and make sure to "expand"
    // linked "nextProp" properties happening when the same property
    // is declared multiple times in the same selector.
    Object.keys(el.styleProps).forEach(function(key) {
      var np = el.styleProps[key];
      while (typeof np !== 'undefined') {
        props.push(np);
        np = np.nextProp;
      }
    });
    // sort properties by their originating selector's specificity so that
    // props like "padding" and "padding-bottom" are resolved as expected.
    props.sort(function(a, b) {
      return a.compareFunc(b);
    });
    var string = props
      .filter(function(prop) {
        // Content becomes the innerHTML of pseudo elements, not used as a
        // style property
        return prop.prop !== 'content';
      })
      .map(function(prop) {
        return prop.prop + ': ' + prop.value.replace(/["]/g, '\'') + ';';
      })
      .join(' ');
    if (string) {
      $(el).attr(styleAttributeName, string);
    }
  }

  function inlinePseudoElements(el) {
    if (el.pseudoElementType && el.styleProps.content) {
      var parsed = parseContent(el.styleProps.content.value);
      if (parsed.img) {
        el.name = 'img';
        $(el).attr('src', parsed.img);
      } else {
        $(el).text(parsed);
      }
      var parent = el.pseudoElementParent;
      if (el.pseudoElementType === 'before') {
        $(parent).prepend(el);
      } else {
        $(parent).append(el);
      }
    }
  }

  function setDimensionAttrs(el, dimension) {
    if (!el.name) { return; }
    var elName = el.name.toUpperCase();
    if (juiceClient[dimension + 'Elements'].indexOf(elName) > -1) {
      for (var i in el.styleProps) {
        if (el.styleProps[i].prop === dimension) {
          if (el.styleProps[i].value.match(/px/)) {
            var pxSize = el.styleProps[i].value.replace('px', '');
            $(el).attr(dimension, pxSize);
            return;
          }
          if (juiceClient.tableElements.indexOf(elName) > -1 && el.styleProps[i].value.match(/\%/)) {
            $(el).attr(dimension, el.styleProps[i].value);
            return;
          }
        }
      }
    }
  }

  function extractBackgroundUrl(value) {
    return value.indexOf('url(') !== 0
      ? value
      : value.replace(/^url\((["'])?([^"']+)\1\)$/, '$2');
  }

  function setAttributesOnTableElements(el) {
    if (!el.name) { return; }
    var elName = el.name.toUpperCase();
    var styleProps = Object.keys(juiceClient.styleToAttribute);

    if (juiceClient.tableElements.indexOf(elName) > -1) {
      for (var i in el.styleProps) {
        if (styleProps.indexOf(el.styleProps[i].prop) > -1) {
          var prop = juiceClient.styleToAttribute[el.styleProps[i].prop];
          var value = el.styleProps[i].value;
          if (prop === 'background') {
            value = extractBackgroundUrl(value)
          }
          $(el).attr(prop, value);
        }
      }
    }
  }
}

function parseContent(content) {
  if (content === 'none' || content === 'normal') {
    return '';
  }

  var imageUrlMatch = content.match(/^\s*url\s*\(\s*(.*?)\s*\)\s*$/i);
  if (imageUrlMatch) {
    var url = imageUrlMatch[1].replace(/^['"]|['"]$/g, '');
    return { img: url };
  }

  // Naive parsing, assume well-formed value
  content = content.slice(1, content.length - 1);
  // Naive unescape, assume no unicode char codes
  content = content.replace(/\\/g, '');
  return content;
}

// Return "before" or "after" if the given selector is a pseudo element (e.g.,
// a::after).
function getPseudoElementType(selector) {
  if (selector.length === 0) {
    return;
  }

  var pseudos = selector[selector.length - 1].pseudos;
  if (!pseudos) {
    return;
  }

  for (var i = 0; i < pseudos.length; i++) {
    if (isPseudoElementName(pseudos[i])) {
      return pseudos[i].name;
    }
  }
}

function isPseudoElementName(pseudo) {
  return pseudo.name === 'before' || pseudo.name === 'after';
}

function filterElementPseudos(pseudos) {
  return pseudos.filter(function(pseudo) {
    return !isPseudoElementName(pseudo);
  });
}

function juiceDocument($, options) {
  options = utils.getDefaultOptions(options);
  var css = extractCssFromDocument($, options);
  css += '\n' + options.extraCss;
  inlineDocument($, css, options);
  return $;
}

function getStylesData($, options) {
  var results = [];
  var stylesList = $('style');
  var styleDataList, styleData, styleElement;
  stylesList.each(function() {
    styleElement = this;
    styleDataList = styleElement.childNodes;
    if (styleDataList.length !== 1) {
      return;
    }
    styleData = styleDataList[0].data;
    if (options.applyStyleTags && $(styleElement).attr('data-embed') === undefined) {
      results.push(styleData);
    }
    if (options.removeStyleTags && $(styleElement).attr('data-embed') === undefined) {
      var preservedText = utils.getPreservedText(styleElement.childNodes[0].nodeValue, {
        mediaQueries: options.preserveMediaQueries,
        fontFaces: options.preserveFontFaces,
        keyFrames: options.preserveKeyFrames
      });
      if (preservedText) {
        styleElement.childNodes[0].nodeValue = preservedText;
      } else {
        $(styleElement).remove();
      }
    }
    $(styleElement).removeAttr('data-embed');
  });
  return results;
}

function extractCssFromDocument($, options) {
  var results = getStylesData($, options);
  var css = results.join('\n');
  return css;
}

return juiceClient;

};

},{"./utils":10}],8:[function(require,module,exports){
'use strict';

module.exports = exports = Property;

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * CSS property constructor.
 *
 * @param {String} property
 * @param {String} value
 * @param {Selector} selector the property originates from
 * @param {Integer} priority 0 for normal properties, 2 for !important properties.
 * @param {Array} additional array of integers representing more detailed priorities (sorting)
 * @api public
 */

function Property(prop, value, selector, priority, additionalPriority) {
  this.prop = prop;
  this.value = value;
  this.selector = selector;
  this.priority = priority || 0;
  this.additionalPriority = additionalPriority || [];
}

/**
 * Compares with another Property based on Selector#specificity.
 *
 * @api public
 */

Property.prototype.compareFunc = function(property) {
  var a = [];
  a.push.apply(a, this.selector.specificity());
  a.push.apply(a, this.additionalPriority);
  a[0] += this.priority;
  var b = [];
  b.push.apply(b, property.selector.specificity());
  b.push.apply(b, property.additionalPriority);
  b[0] += property.priority;
  return utils.compareFunc(a, b);
};

Property.prototype.compare = function(property) {
  var winner = this.compareFunc(property);
  if (winner === 1) {
    return this;
  }
  return property;
};


/**
 * Returns CSS property
 *
 * @api public
 */

Property.prototype.toString = function() {
  return this.prop + ': ' + this.value.replace(/['"]+/g, '') + ';';
};

},{"./utils":10}],9:[function(require,module,exports){
'use strict';

var parser = require('slick/parser');

module.exports = exports = Selector;

/**
 * CSS selector constructor.
 *
 * @param {String} selector text
 * @param {Array} optionally, precalculated specificity
 * @api public
 */

function Selector(text, styleAttribute) {
  this.text = text;
  this.spec = undefined;
  this.styleAttribute = styleAttribute || false;
}

/**
 * Get parsed selector.
 *
 * @api public
 */

Selector.prototype.parsed = function() {
  if (!this.tokens) { this.tokens = parse(this.text); }
  return this.tokens;
};

/**
 * Lazy specificity getter
 *
 * @api public
 */

Selector.prototype.specificity = function() {
  var styleAttribute = this.styleAttribute;
  if (!this.spec) { this.spec = specificity(this.text, this.parsed()); }
  return this.spec;

  function specificity(text, parsed) {
    var expressions = parsed || parse(text);
    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];
    var nots = [];

    for (var i = 0; i < expressions.length; i++) {
      var expression = expressions[i];
      var pseudos = expression.pseudos;

      // id awards a point in the second column
      if (expression.id) { spec[1]++; }

      // classes and attributes award a point each in the third column
      if (expression.attributes) { spec[2] += expression.attributes.length; }
      if (expression.classList) { spec[2] += expression.classList.length; }

      // tag awards a point in the fourth column
      if (expression.tag && expression.tag !== '*') { spec[3]++; }

      // pseudos award a point each in the fourth column
      if (pseudos) {
        spec[3] += pseudos.length;

        for (var p = 0; p < pseudos.length; p++) {
          if (pseudos[p].name === 'not') {
            nots.push(pseudos[p].value);
            spec[3]--;
          }
        }
      }
    }

    for (var ii = nots.length; ii--;) {
      var not = specificity(nots[ii]);
      for (var jj = 4; jj--;) { spec[jj] += not[jj]; }
    }

    return spec;
  }
};

/**
 * Parses a selector and returns the tokens.
 *
 * @param {String} selector
 * @api private.
 */

function parse(text) {
  try {
    return parser(text)[0];
  } catch (e) {
    return [];
  }
}

},{"slick/parser":26}],10:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var mensch = require('mensch');
var own = {}.hasOwnProperty;
var Selector = require('./selector');
var Property = require('./property');

exports.Selector = Selector;
exports.Property = Property;

/**
 * Returns an array of the selectors.
 *
 * @license Sizzle CSS Selector Engine - MIT
 * @param {String} selectorText from mensch
 * @api public
 */

exports.extract = function extract(selectorText) {
  var attr = 0;
  var sels = [];
  var sel = '';

  for (var i = 0, l = selectorText.length; i < l; i++) {
    var c = selectorText.charAt(i);

    if (attr) {
      if (']' === c || ')' === c) { attr--; }
      sel += c;
    } else {
      if (',' === c) {
        sels.push(sel);
        sel = '';
      } else {
        if ('[' === c || '(' === c) { attr++; }
        if (sel.length || (c !== ',' && c !== '\n' && c !== ' ')) { sel += c; }
      }
    }
  }

  if (sel.length) {
    sels.push(sel);
  }

  return sels;
};

/**
 * Returns a parse tree for a CSS source.
 * If it encounters multiple selectors separated by a comma, it splits the
 * tree.
 *
 * @param {String} css source
 * @api public
 */

exports.parseCSS = function(css) {
  var parsed = mensch.parse(css, {position: true, comments: true});
  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
  var ret = [];

  for (var i = 0, l = rules.length; i < l; i++) {
    if (rules[i].type == 'rule') {
      var rule = rules[i];
      var selectors = rule.selectors;

      for (var ii = 0, ll = selectors.length; ii < ll; ii++) {
        ret.push([selectors[ii], rule.declarations]);
      }
    }
  }

  return ret;
};

/**
 * Returns preserved text for a CSS source.
 *
 * @param {String} css source
 * @param {Object} options
 * @api public
 */

exports.getPreservedText = function(css, options) {
  var parsed = mensch.parse(css, {position: true, comments: true});
  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
  var preserved = [];
  var lastStart = null;

  for (var i = rules.length - 1; i >= 0; i--) {
    if ((options.fontFaces && rules[i].type === 'font-face') ||
        (options.mediaQueries && rules[i].type === 'media') ||
        (options.keyFrames && rules[i].type === 'keyframes')) {
      preserved.unshift(
        mensch.stringify(
          { stylesheet: { rules: [ rules[i] ] }},
          { comments: false, indentation: '  ' }
        )
      );
    }
    lastStart = rules[i].position.start;
  }

  if (preserved.length === 0) {
    return false;
  }
  return '\n' + preserved.join('\n') + '\n';
};

exports.normalizeLineEndings = function(text) {
  return text.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n');
};


/**
 * Compares two specificity vectors, returning the winning one.
 *
 * @param {Array} vector a
 * @param {Array} vector b
 * @return {Array}
 * @api public
 */

exports.compareFunc = function(a, b) {
  var min = Math.min(a.length, b.length);
  for (var i = 0; i < min; i++) {
    if (a[i] === b[i]) { continue; }
    if (a[i] > b[i]) { return 1; }
    return -1;
  }

  return a.length - b.length;
};

exports.compare = function(a, b) {
  return exports.compareFunc(a, b) == 1 ? a : b;
};

exports.extend = function(obj, src) {
  for (var key in src) {
    if (own.call(src, key)) {
      obj[key] = src[key];
    }
  }
  return obj;
};

exports.getDefaultOptions = function(options) {
  var result = exports.extend({
    extraCss: '',
    insertPreservedExtraCss: true,
    applyStyleTags: true,
    removeStyleTags: true,
    preserveMediaQueries: true,
    preserveFontFaces: true,
    preserveKeyFrames: true,
    applyWidthAttributes: true,
    applyHeightAttributes: true,
    applyAttributesTableElements: true,
    url: ''
  }, options);

  result.webResources = result.webResources || {};

  return result;
};

},{"./property":8,"./selector":9,"mensch":16}],11:[function(require,module,exports){
(function (global){
// knockout-sortable 1.1.0 | (c) 2017 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
;(function(factory) {
    if (typeof define === "function" && define.amd) {
        // AMD anonymous module
        define(["knockout", "jquery", "jquery-ui/ui/widgets/sortable", "jquery-ui/ui/widgets/draggable", "jquery-ui/ui/widgets/droppable"], factory);
    } else if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // CommonJS module
        var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null),
            jQuery = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
        (typeof window !== "undefined" ? window['jQuery']['ui']['sortable'] : typeof global !== "undefined" ? global['jQuery']['ui']['sortable'] : null);
        (typeof window !== "undefined" ? window['jQuery']['ui']['draggable'] : typeof global !== "undefined" ? global['jQuery']['ui']['draggable'] : null);
        (typeof window !== "undefined" ? window['jQuery']['ui']['droppable'] : typeof global !== "undefined" ? global['jQuery']['ui']['droppable'] : null);
        factory(ko, jQuery);
    } else {
        // No module loader (plain <script> tag) - put directly in global namespace
        factory(window.ko, window.jQuery);
    }
})(function(ko, $) {
    var ITEMKEY = "ko_sortItem",
        INDEXKEY = "ko_sourceIndex",
        LISTKEY = "ko_sortList",
        PARENTKEY = "ko_parentList",
        DRAGKEY = "ko_dragItem",
        unwrap = ko.utils.unwrapObservable,
        dataGet = ko.utils.domData.get,
        dataSet = ko.utils.domData.set,
        version = $.ui && $.ui.version,
        //1.8.24 included a fix for how events were triggered in nested sortables. indexOf checks will fail if version starts with that value (0 vs. -1)
        hasNestedSortableFix = version && version.indexOf("1.6.") && version.indexOf("1.7.") && (version.indexOf("1.8.") || version === "1.8.24");

    //internal afterRender that adds meta-data to children
    var addMetaDataAfterRender = function(elements, data) {
        ko.utils.arrayForEach(elements, function(element) {
            if (element.nodeType === 1) {
                dataSet(element, ITEMKEY, data);
                dataSet(element, PARENTKEY, dataGet(element.parentNode, LISTKEY));
            }
        });
    };

    //prepare the proper options for the template binding
    var prepareTemplateOptions = function(valueAccessor, dataName) {
        var result = {},
            options = unwrap(valueAccessor()) || {},
            actualAfterRender;

        //build our options to pass to the template engine
        if (options.data) {
            result[dataName] = options.data;
            result.name = options.template;
        } else {
            result[dataName] = valueAccessor();
        }

        ko.utils.arrayForEach(["afterAdd", "afterRender", "as", "beforeRemove", "includeDestroyed", "templateEngine", "templateOptions", "nodes"], function (option) {
            if (options.hasOwnProperty(option)) {
                result[option] = options[option];
            } else if (ko.bindingHandlers.sortable.hasOwnProperty(option)) {
                result[option] = ko.bindingHandlers.sortable[option];
            }
        });

        //use an afterRender function to add meta-data
        if (dataName === "foreach") {
            if (result.afterRender) {
                //wrap the existing function, if it was passed
                actualAfterRender = result.afterRender;
                result.afterRender = function(element, data) {
                    addMetaDataAfterRender.call(data, element, data);
                    actualAfterRender.call(data, element, data);
                };
            } else {
                result.afterRender = addMetaDataAfterRender;
            }
        }

        //return options to pass to the template binding
        return result;
    };

    var updateIndexFromDestroyedItems = function(index, items) {
        var unwrapped = unwrap(items);

        if (unwrapped) {
            for (var i = 0; i < index; i++) {
                //add one for every destroyed item we find before the targetIndex in the target array
                if (unwrapped[i] && unwrap(unwrapped[i]._destroy)) {
                    index++;
                }
            }
        }

        return index;
    };

    //remove problematic leading/trailing whitespace from templates
    var stripTemplateWhitespace = function(element, name) {
        var templateSource,
            templateElement;

        //process named templates
        if (name) {
            templateElement = document.getElementById(name);
            if (templateElement) {
                templateSource = new ko.templateSources.domElement(templateElement);
                templateSource.text($.trim(templateSource.text()));
            }
        }
        else {
            //remove leading/trailing non-elements from anonymous templates
            $(element).contents().each(function() {
                if (this && this.nodeType !== 1) {
                    element.removeChild(this);
                }
            });
        }
    };

    //connect items with observableArrays
    ko.bindingHandlers.sortable = {
        init: function(element, valueAccessor, allBindingsAccessor, data, context) {
            var $element = $(element),
                value = unwrap(valueAccessor()) || {},
                templateOptions = prepareTemplateOptions(valueAccessor, "foreach"),
                sortable = {},
                startActual, updateActual;

            stripTemplateWhitespace(element, templateOptions.name);

            //build a new object that has the global options with overrides from the binding
            $.extend(true, sortable, ko.bindingHandlers.sortable);
            if (value.options && sortable.options) {
                ko.utils.extend(sortable.options, value.options);
                delete value.options;
            }
            ko.utils.extend(sortable, value);

            //if allowDrop is an observable or a function, then execute it in a computed observable
            if (sortable.connectClass && (ko.isObservable(sortable.allowDrop) || typeof sortable.allowDrop == "function")) {
                ko.computed({
                    read: function() {
                        var value = unwrap(sortable.allowDrop),
                            shouldAdd = typeof value == "function" ? value.call(this, templateOptions.foreach) : value;
                        ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, shouldAdd);
                    },
                    disposeWhenNodeIsRemoved: element
                }, this);
            } else {
                ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, sortable.allowDrop);
            }

            //wrap the template binding
            ko.bindingHandlers.template.init(element, function() { return templateOptions; }, allBindingsAccessor, data, context);

            //keep a reference to start/update functions that might have been passed in
            startActual = sortable.options.start;
            updateActual = sortable.options.update;

            //ensure draggable table row cells maintain their width while dragging (unless a helper is provided)
            if ( !sortable.options.helper ) {
                sortable.options.helper = function(e, ui) {
                    if (ui.is("tr")) {
                        ui.children().each(function() {
                            $(this).width($(this).width());
                        });
                    }
                    return ui;
                };
            }

            //initialize sortable binding after template binding has rendered in update function
            var createTimeout = setTimeout(function() {
                var dragItem;
                var originalReceive = sortable.options.receive;

                $element.sortable(ko.utils.extend(sortable.options, {
                    start: function(event, ui) {
                        //track original index
                        var el = ui.item[0];
                        dataSet(el, INDEXKEY, ko.utils.arrayIndexOf(ui.item.parent().children(), el));

                        //make sure that fields have a chance to update model
                        ui.item.find("input:focus").change();
                        if (startActual) {
                            startActual.apply(this, arguments);
                        }
                    },
                    receive: function(event, ui) {
                        //optionally apply an existing receive handler
                        if (typeof originalReceive === "function") {
                            originalReceive.call(this, event, ui);
                        }

                        dragItem = dataGet(ui.item[0], DRAGKEY);
                        if (dragItem) {
                            //copy the model item, if a clone option is provided
                            if (dragItem.clone) {
                                dragItem = dragItem.clone();
                            }

                            //configure a handler to potentially manipulate item before drop
                            if (sortable.dragged) {
                                dragItem = sortable.dragged.call(this, dragItem, event, ui) || dragItem;
                            }
                        }
                    },
                    update: function(event, ui) {
                        var sourceParent, targetParent, sourceIndex, targetIndex, arg,
                            el = ui.item[0],
                            parentEl = ui.item.parent()[0],
                            item = dataGet(el, ITEMKEY) || dragItem;

                        if (!item) {
                            $(el).remove();
                        }
                        dragItem = null;

                        //make sure that moves only run once, as update fires on multiple containers
                        if (item && (this === parentEl) || (!hasNestedSortableFix && $.contains(this, parentEl))) {
                            //identify parents
                            sourceParent = dataGet(el, PARENTKEY);
                            sourceIndex = dataGet(el, INDEXKEY);
                            targetParent = dataGet(el.parentNode, LISTKEY);
                            targetIndex = ko.utils.arrayIndexOf(ui.item.parent().children(), el);

                            //take destroyed items into consideration
                            if (!templateOptions.includeDestroyed) {
                                sourceIndex = updateIndexFromDestroyedItems(sourceIndex, sourceParent);
                                targetIndex = updateIndexFromDestroyedItems(targetIndex, targetParent);
                            }

                            //build up args for the callbacks
                            if (sortable.beforeMove || sortable.afterMove) {
                                arg = {
                                    item: item,
                                    sourceParent: sourceParent,
                                    sourceParentNode: sourceParent && ui.sender || el.parentNode,
                                    sourceIndex: sourceIndex,
                                    targetParent: targetParent,
                                    targetIndex: targetIndex,
                                    cancelDrop: false
                                };

                                //execute the configured callback prior to actually moving items
                                if (sortable.beforeMove) {
                                    sortable.beforeMove.call(this, arg, event, ui);
                                }
                            }

                            //call cancel on the correct list, so KO can take care of DOM manipulation
                            if (sourceParent) {
                                $(sourceParent === targetParent ? this : ui.sender || this).sortable("cancel");
                            }
                            //for a draggable item just remove the element
                            else {
                                $(el).remove();
                            }

                            //if beforeMove told us to cancel, then we are done
                            if (arg && arg.cancelDrop) {
                                return;
                            }

                            //if the strategy option is unset or false, employ the order strategy involving removal and insertion of items
                            if (!sortable.hasOwnProperty("strategyMove") || sortable.strategyMove === false) {
                                //do the actual move
                                if (targetIndex >= 0) {
                                    if (sourceParent) {
                                        sourceParent.splice(sourceIndex, 1);

                                        //if using deferred updates plugin, force updates
                                        if (ko.processAllDeferredBindingUpdates) {
                                            ko.processAllDeferredBindingUpdates();
                                        }

                                        //if using deferred updates on knockout 3.4, force updates
                                        if (ko.options && ko.options.deferUpdates) {
                                            ko.tasks.runEarly();
                                        }
                                    }

                                    targetParent.splice(targetIndex, 0, item);
                                }

                                //rendering is handled by manipulating the observableArray; ignore dropped element
                                dataSet(el, ITEMKEY, null);
                            }
                            else { //employ the strategy of moving items
                                if (targetIndex >= 0) {
                                    if (sourceParent) {
                                        if (sourceParent !== targetParent) {
                                            // moving from one list to another

                                            sourceParent.splice(sourceIndex, 1);
                                            targetParent.splice(targetIndex, 0, item);

                                            //rendering is handled by manipulating the observableArray; ignore dropped element
                                            dataSet(el, ITEMKEY, null);
                                            ui.item.remove();
                                        }
                                        else {
                                            // moving within same list
                                            var underlyingList = unwrap(sourceParent);

                                            // notify 'beforeChange' subscribers
                                            if (sourceParent.valueWillMutate) {
                                                sourceParent.valueWillMutate();
                                            }

                                            // move from source index ...
                                            underlyingList.splice(sourceIndex, 1);
                                            // ... to target index
                                            underlyingList.splice(targetIndex, 0, item);

                                            // notify subscribers
                                            if (sourceParent.valueHasMutated) {
                                                sourceParent.valueHasMutated();
                                            }
                                        }
                                    }
                                    else {
                                        // drop new element from outside
                                        targetParent.splice(targetIndex, 0, item);

                                        //rendering is handled by manipulating the observableArray; ignore dropped element
                                        dataSet(el, ITEMKEY, null);
                                        ui.item.remove();
                                    }
                                }
                            }

                            //if using deferred updates plugin, force updates
                            if (ko.processAllDeferredBindingUpdates) {
                                ko.processAllDeferredBindingUpdates();
                            }

                            //allow binding to accept a function to execute after moving the item
                            if (sortable.afterMove) {
                                sortable.afterMove.call(this, arg, event, ui);
                            }
                        }

                        if (updateActual) {
                            updateActual.apply(this, arguments);
                        }
                    },
                    connectWith: sortable.connectClass ? "." + sortable.connectClass : false
                }));

                //handle enabling/disabling sorting
                if (sortable.isEnabled !== undefined) {
                    ko.computed({
                        read: function() {
                            $element.sortable(unwrap(sortable.isEnabled) ? "enable" : "disable");
                        },
                        disposeWhenNodeIsRemoved: element
                    });
                }
            }, 0);

            //handle disposal
            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
                //only call destroy if sortable has been created
                if ($element.data("ui-sortable") || $element.data("sortable")) {
                    $element.sortable("destroy");
                }

                ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, false);

                //do not create the sortable if the element has been removed from DOM
                clearTimeout(createTimeout);
            });

            return { 'controlsDescendantBindings': true };
        },
        update: function(element, valueAccessor, allBindingsAccessor, data, context) {
            var templateOptions = prepareTemplateOptions(valueAccessor, "foreach");

            //attach meta-data
            dataSet(element, LISTKEY, templateOptions.foreach);

            //call template binding's update with correct options
            ko.bindingHandlers.template.update(element, function() { return templateOptions; }, allBindingsAccessor, data, context);
        },
        connectClass: 'ko_container',
        allowDrop: true,
        afterMove: null,
        beforeMove: null,
        options: {}
    };

    //create a draggable that is appropriate for dropping into a sortable
    ko.bindingHandlers.draggable = {
        init: function(element, valueAccessor, allBindingsAccessor, data, context) {
            var value = unwrap(valueAccessor()) || {},
                options = value.options || {},
                draggableOptions = ko.utils.extend({}, ko.bindingHandlers.draggable.options),
                templateOptions = prepareTemplateOptions(valueAccessor, "data"),
                connectClass = value.connectClass || ko.bindingHandlers.draggable.connectClass,
                isEnabled = value.isEnabled !== undefined ? value.isEnabled : ko.bindingHandlers.draggable.isEnabled;

            value = "data" in value ? value.data : value;

            //set meta-data
            dataSet(element, DRAGKEY, value);

            //override global options with override options passed in
            ko.utils.extend(draggableOptions, options);

            //setup connection to a sortable
            draggableOptions.connectToSortable = connectClass ? "." + connectClass : false;

            //initialize draggable
            $(element).draggable(draggableOptions);

            //handle enabling/disabling sorting
            if (isEnabled !== undefined) {
                ko.computed({
                    read: function() {
                        $(element).draggable(unwrap(isEnabled) ? "enable" : "disable");
                    },
                    disposeWhenNodeIsRemoved: element
                });
            }

            //handle disposal
            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
                $(element).draggable("destroy");
            });

            return ko.bindingHandlers.template.init(element, function() { return templateOptions; }, allBindingsAccessor, data, context);
        },
        update: function(element, valueAccessor, allBindingsAccessor, data, context) {
            var templateOptions = prepareTemplateOptions(valueAccessor, "data");

            return ko.bindingHandlers.template.update(element, function() { return templateOptions; }, allBindingsAccessor, data, context);
        },
        connectClass: ko.bindingHandlers.sortable.connectClass,
        options: {
            helper: "clone"
        }
    };

    // Simple Droppable Implementation
    // binding that updates (function or observable)
    ko.bindingHandlers.droppable = {
        init: function(element, valueAccessor, allBindingsAccessor, data, context) {
            var value = unwrap(valueAccessor()) || {},
                options = value.options || {},
                droppableOptions = ko.utils.extend({}, ko.bindingHandlers.droppable.options),
                isEnabled = value.isEnabled !== undefined ? value.isEnabled : ko.bindingHandlers.droppable.isEnabled;

            //override global options with override options passed in
            ko.utils.extend(droppableOptions, options);

            //get reference to drop method
            value = "data" in value ? value.data : valueAccessor();

            //set drop method
            droppableOptions.drop = function(event, ui) {
                var droppedItem = dataGet(ui.draggable[0], DRAGKEY) || dataGet(ui.draggable[0], ITEMKEY);
                value(droppedItem);
            };

            //initialize droppable
            $(element).droppable(droppableOptions);

            //handle enabling/disabling droppable
            if (isEnabled !== undefined) {
                ko.computed({
                    read: function() {
                        $(element).droppable(unwrap(isEnabled) ? "enable": "disable");
                    },
                    disposeWhenNodeIsRemoved: element
                });
            }

            //handle disposal
            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
                $(element).droppable("destroy");
            });
        },
        options: {
            accept: "*"
        }
    };
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],12:[function(require,module,exports){
(function (global){
/*! ko-reactor v1.4.0
 * The MIT License (MIT)
 * Copyright (c) 2018 Ziad Jeeroburkhan */
!function(e){"function"==typeof require&&"object"==typeof exports&&"object"==typeof module?e((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null)):"function"==typeof define&&define.amd?define(["knockout"],e):e(window.ko)}(function(e){e.subscribable.fn.watch=function(t,a,n,r){var o=typeof t;return"boolean"===o||"undefined"===o?e.watch(this,{enabled:!1!==t}):"function"!==o||e.isSubscribable(t)?e.watch(t,a,n,r||this):e.watch(this,a||{},t,r||this),this},e.watch=function(t,a,n,r){function o(c,u,f,s,b,h){if(c&&0!==a.depth&&(-1===a.depth||f.length<(a.depth||1))){if(a.watchedOnly&&!c.watchable&&c!=t)return;if(!1!==a.enabled&&!0!==a.enabled||(c.watchable=a.enabled),!1===c.watchable)return;!0===a.seal&&(c.watchable=!1);var d=typeof c;if("object"===d||"function"===d){if(c._watcher===r)return;if(a.hide&&e.utils.arrayIndexOf(a.hide,c)>-1)return;var p=[].concat(f,u&&u!==t?u:[]);if("function"!==d){if("[object Object]"===Object.prototype.toString.call(c))e.utils.objectForEach(c,function(t,n){if(n=a.getter?a.getter.call(r,p,c,t):n){if(a.wrap){var i=Object.prototype.toString.call(n);"[object Function]"!==i&&"[object Object]"!==i&&(a.beforeWrap&&!1===a.beforeWrap.call(r,p,c,n)||(n=c[t]="[object Array]"===i?e.observableArray(n):e.observable(n)))}a.unloop&&(n._watcher=s?void 0:r);var l=o(n,b?null:c,p,s,null,t);a.tagFields&&void 0===n._fieldName&&(l||"parentsOnly"!==a.tagFields&&"function"==typeof n||"object"==typeof n)&&(n._fieldName=t)}});else if(!0!==a.hideArrays)for(var y=0;y<c.length;y++)o(c[y],b?null:c,p,s);return!0}if("function"==typeof c.notifySubscribers&&n){if(!0===a.enabled&&!1===c.watchable)return;if(s||!a.beforeWatch||!1!==a.beforeWatch.call(r,p,c,h)){var v="function"==typeof c.pop;if(s?i(c):l(c,v,p,b),v)return o(c(),b?null:c,p,s,!0),!0;if(!0!==a.hideWrappedValues)return o(c(),b?null:c,p,s,!0)}}}}}function i(e){var t=e[c];if(!t)throw"Subscriptions field (."+c+") not defined for observable child "+(e._fieldName||"");if(t.change)for(n=t.change.length-1;n>=0;n--)t.change[n]._watcher===r&&t.change[n].dispose();if(t.beforeChange&&(a.mutable||a.oldValues>0))for(n=t.beforeChange.length-1;n>=0;n--)t.beforeChange[n]._watcher===r&&t.beforeChange[n].dispose();if(t.arrayChange)for(var n=t.arrayChange.length-1;n>=0;n--)t.arrayChange[n]._watcher===r&&t.arrayChange[n].dispose()}function l(t,i,l,c){i?t.subscribe(function(i){var u;!1===a.splitArrayChanges&&void 0!==(u=n.call(r,l,t,i))&&r(u),e.utils.arrayForEach(i,function(e){if(!1!==a.splitArrayChanges){var i=n.call(r,l,t,e);void 0!==i&&r(i)}e.moved||(!1===a.async?o(e.value,c?null:t,l,"deleted"===e.status):setTimeout(function(){o(e.value,c?null:t,l,"deleted"===e.status)}))})},void 0,"arrayChange")._watcher=r:(t.subscribe(function(){if(!1!==t.watchable){var e=n.call(r,l,t);void 0!==e&&r(e),a.mutable&&"object"==typeof t()&&(!1===a.async?o(t(),c?null:t,l,!1,!0):setTimeout(function(){o(t(),c?null:t,l,!1,!0)}))}},null,"change")._watcher=r,(a.oldValues>0||a.mutable)&&(t.subscribe(function(e){if(a.oldValues>0){var n=t.oldValues?t.oldValues:t.oldValues=[];for(n.unshift(e);n.length>a.oldValues;)n.pop()}a.mutable&&"object"==typeof e&&o(e,c?null:t,l,!0,!0)},null,"beforeChange")._watcher=r))}"function"==typeof a&&(r=r||n,n=a,a={}),r=r||this;var c;switch("function"==typeof e.subscription||e.version){case!0:c="_subscriptions";break;case"3.0.0":c="F";break;case"3.1.0":c="H";break;case"3.2.0":c="M";break;case"3.3.0":c="G";break;case"3.4.0":case"3.4.1":c="K";break;case"3.4.2":c="F";break;case"3.5.0-beta":c="S";break;default:throw"Unsupported Knockout version. Only v3.0.0 to v3.5.0-beta are supported when minified. Current version is "+e.version}return"function"!=typeof t||e.isSubscribable(t)?(o(t,null,[]),{dispose:function(){o(t,null,[],!0)}}):e.computed(t,n,a)}});window.foo = "1.4.0";
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = find;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],15:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return basePickBy(object, props, function(value, key) {
    return key in object;
  });
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, props, predicate) {
  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = baseRest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = omit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(require,module,exports){
module.exports = {
    lex  : require('./lib/lexer'),
    parse: require('./lib/parser'),
    stringify: require('./lib/stringify')
};

},{"./lib/lexer":18,"./lib/parser":19,"./lib/stringify":20}],17:[function(require,module,exports){
(function (process){
exports = module.exports = debug;

function debug(label) {
  return _debug.bind(null, label);
}

function _debug(label) {
  var args = [].slice.call(arguments, 1);
  args.unshift('[' + label + ']');
  process.stderr.write(args.join(' ') + '\n');
}
}).call(this,require('_process'))

},{"_process":21}],18:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `lex()` and print the results.

var debug = require('./debug')('lex');

exports = module.exports = lex;

/**
 * Convert a CSS string into an array of lexical tokens.
 *
 * @param {String} css CSS
 * @returns {Array} lexical tokens
 */
function lex(css) {
  var start; // Debug timer start.

  var buffer = '';      // Character accumulator
  var ch;               // Current character
  var column = 0;       // Current source column number
  var cursor = -1;      // Current source cursor position
  var depth = 0;        // Current nesting depth
  var line = 1;         // Current source line number
  var state = 'before-selector'; // Current state
  var stack = [state];  // State stack
  var token = {};       // Current token
  var tokens = [];      // Token accumulator

  // Supported @-rules, in roughly descending order of usage probability.
  var atRules = [
    'media',
    'keyframes',
    { name: '-webkit-keyframes', type: 'keyframes', prefix: '-webkit-' },
    { name: '-moz-keyframes', type: 'keyframes', prefix: '-moz-' },
    { name: '-ms-keyframes', type: 'keyframes', prefix: '-ms-' },
    { name: '-o-keyframes', type: 'keyframes', prefix: '-o-' },
    'font-face',
    { name: 'import', state: 'before-at-value' },
    { name: 'charset', state: 'before-at-value' },
    'supports',
    'viewport',
    { name: 'namespace', state: 'before-at-value' },
    'document',
    { name: '-moz-document', type: 'document', prefix: '-moz-' },
    'page'
  ];

  // -- Functions ------------------------------------------------------------

  /**
   * Advance the character cursor and return the next character.
   *
   * @returns {String} The next character.
   */
  function getCh() {
    skip();
    return css[cursor];
  }

  /**
   * Return the state at the given index in the stack.
   * The stack is LIFO so indexing is from the right.
   *
   * @param {Number} [index=0] Index to return.
   * @returns {String} state
   */
  function getState(index) {
    return index ? stack[stack.length - 1 - index] : state;
  }

  /**
   * Look ahead for a string beginning from the next position. The string
   * being looked for must start at the next position.
   *
   * @param {String} str The string to look for.
   * @returns {Boolean} Whether the string was found.
   */
  function isNextString(str) {
    var start = cursor + 1;
    return (str === css.slice(start, start + str.length));
  }

  /**
   * Find the start position of a substring beginning from the next
   * position. The string being looked for may begin anywhere.
   *
   * @param {String} str The substring to look for.
   * @returns {Number|false} The position, or `false` if not found.
   */
  function find(str) {
    var pos = css.slice(cursor).indexOf(str);

    return pos > 0 ? pos : false;
  }

  /**
   * Determine whether a character is next.
   *
   * @param {String} ch Character.
   * @returns {Boolean} Whether the character is next.
   */
  function isNextChar(ch) {
    return ch === peek(1);
  }

  /**
   * Return the character at the given cursor offset. The offset is relative
   * to the cursor, so negative values move backwards.
   *
   * @param {Number} [offset=1] Cursor offset.
   * @returns {String} Character.
   */
  function peek(offset) {
    return css[cursor + (offset || 1)];
  }

  /**
   * Remove the current state from the stack and set the new current state.
   *
   * @returns {String} The removed state.
   */
  function popState() {
    var removed = stack.pop();
    state = stack[stack.length - 1];

    return removed;
  }

  /**
   * Set the current state and add it to the stack.
   *
   * @param {String} newState The new state.
   * @returns {Number} The new stack length.
   */
  function pushState(newState) {
    state = newState;
    stack.push(state);

    return stack.length;
  }

  /**
   * Replace the current state with a new state.
   *
   * @param {String} newState The new state.
   * @returns {String} The replaced state.
   */
  function replaceState(newState) {
    var previousState = state;
    stack[stack.length - 1] = state = newState;

    return previousState;
  }

  /**
   * Move the character cursor. Positive numbers move the cursor forward.
   * Negative numbers are not supported!
   *
   * @param {Number} [n=1] Number of characters to skip.
   */
  function skip(n) {
    if ((n || 1) == 1) {
      if (css[cursor] == '\n') {
        line++;
        column = 1;
      } else {
        column++;
      }
      cursor++;
    } else {
      var skipStr = css.slice(cursor, cursor + n).split('\n');
      if (skipStr.length > 1) {
        line += skipStr.length - 1;
        column = 1;
      }
      column += skipStr[skipStr.length - 1].length;
      cursor = cursor + n;
    }
  }

  /**
   * Add the current token to the pile and reset the buffer.
   */
  function addToken() {
    token.end = {
      line: line,
      col: column
    };

    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));

    tokens.push(token);

    buffer = '';
    token = {};
  }

  /**
   * Set the current token.
   *
   * @param {String} type Token type.
   */
  function initializeToken(type) {
    token = {
      type: type,
      start: {
        line: line,
        col : column
      }
    };
  }

  // -- Main Loop ------------------------------------------------------------

  /*
  The main loop is a state machine that reads in one character at a time,
  and determines what to do based on the current state and character.
  This is implemented as a series of nested `switch` statements and the
  case orders have been mildly optimized based on rough probabilities
  calculated by processing a small sample of real-world CSS.

  Further optimization (such as a dispatch table) shouldn't be necessary
  since the total number of cases is very low.
  */

  TIMER && (start = Date.now());

  while (ch = getCh()) {
    DEBUG && debug(ch, getState());

    // column += 1;

    switch (ch) {
    // Space
    case ' ':
      switch (getState()) {
      case 'selector':
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'at-value':
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;
      }
      break;

    // Newline or tab
    case '\n':
    case '\t':
    case '\r':
    case '\f':
      switch (getState()) {
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'comment':
      case 'single-string':
      case 'double-string':
      case 'selector':
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule if a semi-colon was omitted.
        if ('\n' === ch) {
          token.value = buffer.trim();
          addToken();
          popState();
        }
        break;
      }

      // if ('\n' === ch) {
      //   column = 0;
      //   line += 1;
      // }
      break;

    case ':':
      switch (getState()) {
      case 'name':
        token.name = buffer.trim();
        buffer = '';

        replaceState('before-value');
        break;

      case 'before-selector':
        buffer += ch;

        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case ';':
      switch (getState()) {
      case 'name':
      case 'before-value':
      case 'value':
        // Tokenize a declaration
        // if value is empty skip the declaration
        if (buffer.trim().length > 0) {
          token.value = buffer.trim(),
          addToken();
        }
        replaceState('before-name');
        break;

      case 'value-paren':
        // Insignificant semi-colon
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule
        token.value = buffer.trim();
        addToken();
        popState();
        break;

      case 'before-name':
        // Extraneous semi-colon
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case '{':
      switch (getState()) {
      case 'selector':
        // If the sequence is `\{` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        // Tokenize a selector
        token.text = buffer.trim();
        addToken();
        replaceState('before-name');
        depth = depth + 1;
        break;

      case 'at-group':
        // Tokenize an @-group
        token.name = buffer.trim();

        // XXX: @-rules are starting to get hairy
        switch (token.type) {
        case 'font-face':
        case 'viewport' :
        case 'page'     :
          pushState('before-name');
          break;

        default:
          pushState('before-selector');
        }

        addToken();
        depth = depth + 1;
        break;

      case 'name':
      case 'at-rule':
        // Tokenize a declaration or an @-rule
        token.name = buffer.trim();
        addToken();
        pushState('before-name');
        depth = depth + 1;
        break;

      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore braces in comments and strings
        buffer += ch;
        break;
      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;
      }

      break;

    case '}':
      switch (getState()) {
      case 'before-name':
      case 'name':
      case 'before-value':
      case 'value':
        // If the buffer contains anything, it is a value
        if (buffer) {
          token.value = buffer.trim();
        }

        // If the current token has a name and a value it should be tokenized.
        if (token.name && token.value) {
          addToken();
        }

        // Leave the block
        initializeToken('end');
        addToken();
        popState();

        // We might need to leave again.
        // XXX: What about 3 levels deep?
        if ('at-group' === getState()) {
          initializeToken('at-group-end');
          addToken();
          popState();
        }
        
        if (depth > 0) {
          depth = depth - 1;
        }

        break;

      case 'at-group':
      case 'before-selector':
      case 'selector':
        // If the sequence is `\}` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        if (depth > 0) {
          // Leave block if in an at-group
          if ('at-group' === getState(1)) {
            initializeToken('at-group-end');
            addToken();
          }
        }

        if (depth > 1) {
          popState();
        }

        if (depth > 0) {
          depth = depth - 1;
        }
        break;

      case 'double-string':
      case 'single-string':
      case 'comment':
        // Ignore braces in comments and strings.
        buffer += ch;
        break;
      }

      break;

    // Strings
    case '"':
    case "'":
      switch (getState()) {
      case 'double-string':
        if ('"' === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'single-string':
        if ("'" === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'before-at-value':
        replaceState('at-value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'before-value':
        replaceState('value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'comment':
        // Ignore strings within comments.
        break;

      default:
        if ('\\' !== peek(-1)) {
          pushState('"' === ch ? 'double-string' : 'single-string');
        }
      }

      buffer += ch;
      break;

    // Comments
    case '/':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore
        buffer += ch;
        break;

      case 'before-value':
      case 'selector':
      case 'name':
      case 'value':
        if (isNextChar('*')) {
          // Ignore comments in selectors, properties and values. They are
          // difficult to represent in the AST.
          var pos = find('*/');

          if (pos) {
            skip(pos + 1);
          }
        } else {
          if (getState() == 'before-value') replaceState('value');
          buffer += ch;
        }
        break;

      default:
        if (isNextChar('*')) {
          // Create a comment token
          initializeToken('comment');
          pushState('comment');
          skip();
        }
        else {
          buffer += ch;
        }
        break;
      }
      break;

    // Comment end or universal selector
    case '*':
      switch (getState()) {
      case 'comment':
        if (isNextChar('/')) {
          // Tokenize a comment
          token.text = buffer; // Don't trim()!
          skip();
          addToken();
          popState();
        }
        else {
          buffer += ch;
        }
        break;

      case 'before-selector':
        buffer += ch;
        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        buffer += ch;
      }
      break;

    // @-rules
    case '@':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;
      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        // Iterate over the supported @-rules and attempt to tokenize one.
        var tokenized = false;
        var name;
        var rule;

        for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
          rule = atRules[j];
          name = rule.name || rule;

          if (!isNextString(name)) { continue; }

          tokenized = true;

          initializeToken(name);
          pushState(rule.state || 'at-group');
          skip(name.length);

          if (rule.prefix) {
            token.prefix = rule.prefix;
          }

          if (rule.type) {
            token.type = rule.type;
          }
        }

        if (!tokenized) {
          // Keep on truckin' America!
          buffer += ch;
        }
        break;
      }
      break;

    // Parentheses are tracked to disambiguate semi-colons, such as within a
    // data URI.
    case '(':
      switch (getState()) {
      case 'value':
        pushState('value-paren');
        break;
      case 'before-value':
        replaceState('value');
        break;
      }

      buffer += ch;
      break;

    case ')':
      switch (getState()) {
      case 'value-paren':
        popState();
        break;
      case 'before-value':
        replaceState('value');
        break;
      }

      buffer += ch;
      break;

    default:
      switch (getState()) {
      case 'before-selector':
        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-name':
        initializeToken('property');
        replaceState('name');
        break;

      case 'before-value':
        replaceState('value');
        break;

      case 'before-at-value':
        replaceState('at-value');
        break;
      }

      buffer += ch;
      break;
    }
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return tokens;
}

},{"./debug":17}],19:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `parse()` and print the results.

var debug = require('./debug')('parse');
var lex = require('./lexer');

exports = module.exports = parse;

var _comments;   // Whether comments are allowed.
var _depth;      // Current block nesting depth.
var _position;   // Whether to include line/column position.
var _tokens;     // Array of lexical tokens.

/**
 * Convert a CSS string or array of lexical tokens into a `stringify`-able AST.
 *
 * @param {String} css CSS string or array of lexical token
 * @param {Object} [options]
 * @param {Boolean} [options.comments=false] allow comment nodes in the AST
 * @returns {Object} `stringify`-able AST
 */
function parse(css, options) {
  var start; // Debug timer start.

  options || (options = {});
  _comments = !!options.comments;
  _position = !!options.position;

  _depth = 0;

  // Operate on a copy of the given tokens, or the lex()'d CSS string.
  _tokens = Array.isArray(css) ? css.slice() : lex(css);

  var rule;
  var rules = [];
  var token;

  TIMER && (start = Date.now());

  while ((token = next())) {
    rule = parseToken(token);
    rule && rules.push(rule);
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return {
    type: "stylesheet",
    stylesheet: {
      rules: rules
    }
  };
}

// -- Functions --------------------------------------------------------------

/**
 * Build an AST node from a lexical token.
 *
 * @param {Object} token lexical token
 * @param {Object} [override] object hash of properties that override those
 *   already in the token, or that will be added to the token.
 * @returns {Object} AST node
 */
function astNode(token, override) {
  override || (override = {});

  var key;
  var keys = ['type', 'name', 'value'];
  var node = {};

  // Avoiding [].forEach for performance reasons.
  for (var i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (token[key]) {
      node[key] = override[key] || token[key];
    }
  }

  keys = Object.keys(override);

  for (i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (!node[key]) {
      node[key] = override[key];
    }
  }

  if (_position) {
    node.position = {
      start: token.start,
      end: token.end
    };
  }

  DEBUG && debug('astNode:', JSON.stringify(node, null, 2));

  return node;
}

/**
 * Remove a lexical token from the stack and return the removed token.
 *
 * @returns {Object} lexical token
 */
function next() {
  var token = _tokens.shift();
  DEBUG && debug('next:', JSON.stringify(token, null, 2));
  return token;
}

// -- Parse* Functions ---------------------------------------------------------

/**
 * Convert an @-group lexical token to an AST node.
 *
 * @param {Object} token @-group lexical token
 * @returns {Object} @-group AST node
 */
function parseAtGroup(token) {
  _depth = _depth + 1;

  // As the @-group token is assembled, relevant token values are captured here
  // temporarily. They will later be used as `tokenize()` overrides.
  var overrides = {};

  switch (token.type) {
  case 'font-face':
  case 'viewport' :
    overrides.declarations = parseDeclarations();
    break;

  case 'page':
    overrides.prefix = token.prefix;
    overrides.declarations = parseDeclarations();
    break;

  default:
    overrides.prefix = token.prefix;
    overrides.rules = parseRules();
  }

  return astNode(token, overrides);
}

/**
 * Convert an @import lexical token to an AST node.
 *
 * @param {Object} token @import lexical token
 * @returns {Object} @import AST node
 */
function parseAtImport(token) {
  return astNode(token);
}

/**
 * Convert an @charset token to an AST node.
 *
 * @param {Object} token @charset lexical token
 * @returns {Object} @charset node
 */
function parseCharset(token) {
  return astNode(token);
}

/**
 * Convert a comment token to an AST Node.
 *
 * @param {Object} token comment lexical token
 * @returns {Object} comment node
 */
function parseComment(token) {
  return astNode(token, {text: token.text});
}

function parseNamespace(token) {
  return astNode(token);
}

/**
 * Convert a property lexical token to a property AST node.
 *
 * @returns {Object} property node
 */
function parseProperty(token) {
  return astNode(token);
}

/**
 * Convert a selector lexical token to a selector AST node.
 *
 * @param {Object} token selector lexical token
 * @returns {Object} selector node
 */
function parseSelector(token) {
  function trim(str) {
    return str.trim();
  }

  return astNode(token, {
    type: 'rule',
    selectors: token.text.split(',').map(trim),
    declarations: parseDeclarations(token)
  });
}

/**
 * Convert a lexical token to an AST node.
 *
 * @returns {Object|undefined} AST node
 */
function parseToken(token) {
  switch (token.type) {
  // Cases are listed in roughly descending order of probability.
  case 'property': return parseProperty(token);

  case 'selector': return parseSelector(token);

  case 'at-group-end': _depth = _depth - 1; return;

  case 'media'     :
  case 'keyframes' :return parseAtGroup(token);

  case 'comment': if (_comments) { return parseComment(token); } break;

  case 'charset': return parseCharset(token);
  case 'import': return parseAtImport(token);

  case 'namespace': return parseNamespace(token);

  case 'font-face':
  case 'supports' :
  case 'viewport' :
  case 'document' :
  case 'page'     : return parseAtGroup(token);
  }

  DEBUG && debug('parseToken: unexpected token:', JSON.stringify(token));
}

// -- Parse Helper Functions ---------------------------------------------------

/**
 * Iteratively parses lexical tokens from the stack into AST nodes until a
 * conditional function returns `false`, at which point iteration terminates
 * and any AST nodes collected are returned.
 *
 * @param {Function} conditionFn
 *   @param {Object} token the lexical token being parsed
 *   @returns {Boolean} `true` if the token should be parsed, `false` otherwise
 * @return {Array} AST nodes
 */
function parseTokensWhile(conditionFn) {
  var node;
  var nodes = [];
  var token;

  while ((token = next()) && (conditionFn && conditionFn(token))) {
    node = parseToken(token);
    node && nodes.push(node);
  }

  // Place an unused non-`end` lexical token back onto the stack.
  if (token && token.type !== 'end') {
    _tokens.unshift(token);
  }

  return nodes;
}

/**
 * Convert a series of tokens into a sequence of declaration AST nodes.
 *
 * @returns {Array} declaration nodes
 */
function parseDeclarations() {
  return parseTokensWhile(function (token) {
    return (token.type === 'property' || token.type === 'comment');
  });
}

/**
 * Convert a series of tokens into a sequence of rule nodes.
 *
 * @returns {Array} rule nodes
 */
function parseRules() {
  return parseTokensWhile(function () { return _depth; });
}

},{"./debug":17,"./lexer":18}],20:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `stringify()` and print the results.

var debug = require('./debug')('stringify');

var _comments;      // Whether comments are allowed in the stringified CSS.
var _compress;      // Whether the stringified CSS should be compressed.
var _indentation;   // Indentation option value.
var _n;             // Compression-aware newline character.
var _s;             // Compression-aware space character.

exports = module.exports = stringify;

/**
 * Convert a `stringify`-able AST into a CSS string.
 *
 * @param {Object} `stringify`-able AST
 * @param {Object} [options]
 * @param {Boolean} [options.comments=false] allow comments in the CSS
 * @param {Boolean} [options.compress=false] compress whitespace
 * @param {String} [options.indentation=''] indentation sequence
 * @returns {String} CSS
 */
function stringify(ast, options) {
  var start; // Debug timer start.

  options || (options = {});
  _indentation = options.indentation || '';
  _compress = !!options.compress;
  _comments = !!options.comments;

  if (_compress) {
    _n = _s = '';
  } else {
    _n = '\n';
    _s = ' ';
  }

  TIMER && (start = Date.now());

  var css = reduce(ast.stylesheet.rules, stringifyNode).join('\n').trim();

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return css;
}

// -- Functions --------------------------------------------------------------

/**
 * Modify the indentation level, or return a compression-aware sequence of
 * spaces equal to the current indentation level.
 *
 * @param {Number} [level=undefined] indentation level modifier
 * @returns {String} sequence of spaces
 */
function indent(level) {
  this.level || (this.level = 1);

  if (level) {
    this.level += level;
    return;
  }

  if (_compress) { return ''; }

  return Array(this.level).join(_indentation || '');
}

// -- Stringify Functions ------------------------------------------------------

/**
 * Stringify an @-rule AST node.
 *
 * Use `stringifyAtGroup()` when dealing with @-groups that may contain blocks
 * such as @media.
 *
 * @param {String} type @-rule type. E.g., import, charset
 * @returns {String} Stringified @-rule
 */
function stringifyAtRule(node) {
  return '@' + node.type + ' ' + node.value + ';' + _n;
}

/**
 * Stringify an @-group AST node.
 *
 * Use `stringifyAtRule()` when dealing with @-rules that may not contain blocks
 * such as @import.
 *
 * @param {Object} node @-group AST node
 * @returns {String}
 */
function stringifyAtGroup(node) {
  var label = '';
  var prefix = node.prefix || '';

  if (node.name) {
    label = ' ' + node.name;
  }

  // FIXME: @-rule conditional logic is leaking everywhere.
  var chomp = node.type !== 'page';

  return '@' + prefix + node.type + label + _s + stringifyBlock(node, chomp) + _n;
}

/**
 * Stringify a comment AST node.
 *
 * @param {Object} node comment AST node
 * @returns {String}
 */
function stringifyComment(node) {
  if (!_comments) { return ''; }

  return '/*' + (node.text || '') + '*/' + _n;
}

/**
 * Stringify a rule AST node.
 *
 * @param {Object} node rule AST node
 * @returns {String}
 */
function stringifyRule(node) {
  var label;

  if (node.selectors) {
    label = node.selectors.join(',' + _n);
  } else {
    label = '@' + node.type;
    label += node.name ? ' ' + node.name : '';
  }

  return indent() + label + _s + stringifyBlock(node) + _n;
}


// -- Stringify Helper Functions -----------------------------------------------

/**
 * Reduce an array by applying a function to each item and retaining the truthy
 * results.
 *
 * When `item.type` is `'comment'` `stringifyComment` will be applied instead.
 *
 * @param {Array} items array to reduce
 * @param {Function} fn function to call for each item in the array
 *   @returns {Mixed} Truthy values will be retained, falsy values omitted
 * @returns {Array} retained results
 */
function reduce(items, fn) {
  return items.reduce(function (results, item) {
    var result = (item.type === 'comment') ? stringifyComment(item) : fn(item);
    result && results.push(result);
    return results;
  }, []);
}

/**
 * Stringify an AST node with the assumption that it represents a block of
 * declarations or other @-group contents.
 *
 * @param {Object} node AST node
 * @returns {String}
 */
// FIXME: chomp should not be a magic boolean parameter
function stringifyBlock(node, chomp) {
  var children = node.declarations;
  var fn = stringifyDeclaration;

  if (node.rules) {
    children = node.rules;
    fn = stringifyRule;
  }

  children = stringifyChildren(children, fn);
  children && (children = _n + children + (chomp ? '' : _n));

  return '{' + children + indent() + '}';
}

/**
 * Stringify an array of child AST nodes by calling the given stringify function
 * once for each child, and concatenating the results.
 *
 * @param {Array} children `node.rules` or `node.declarations`
 * @param {Function} fn stringify function
 * @returns {String}
 */
function stringifyChildren(children, fn) {
  if (!children) { return ''; }

  indent(1);
  var results = reduce(children, fn);
  indent(-1);

  if (!results.length) { return ''; }

  return results.join(_n);
}

/**
 * Stringify a declaration AST node.
 *
 * @param {Object} node declaration AST node
 * @returns {String}
 */
function stringifyDeclaration(node) {
  if (node.type === 'property') {
    return stringifyProperty(node);
  }

  DEBUG && debug('stringifyDeclaration: unexpected node:', JSON.stringify(node));
}

/**
 * Stringify an AST node.
 *
 * @param {Object} node AST node
 * @returns {String}
 */
function stringifyNode(node) {
  switch (node.type) {
  // Cases are listed in roughly descending order of probability.
  case 'rule': return stringifyRule(node);

  case 'media'    :
  case 'keyframes': return stringifyAtGroup(node);

  case 'comment': return stringifyComment(node);

  case 'import'   :
  case 'charset'  :
  case 'namespace': return stringifyAtRule(node);

  case 'font-face':
  case 'supports' :
  case 'viewport' :
  case 'document' :
  case 'page'     : return stringifyAtGroup(node);
  }

  DEBUG && debug('stringifyNode: unexpected node: ' + JSON.stringify(node));
}

/**
 * Stringify an AST property node.
 *
 * @param {Object} node AST property node
 * @returns {String}
 */
function stringifyProperty(node) {
  var name = node.name ? node.name + ':' + _s : '';

  return indent() + name + node.value + ';';
}

},{"./debug":17}],21:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],22:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],25:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":23,"./encode":24}],26:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],27:[function(require,module,exports){
module.exports = require('./lib/speakingurl');

},{"./lib/speakingurl":28}],28:[function(require,module,exports){
(function (root) {
    'use strict';

    /**
     * charMap
     * @type {Object}
     */
    var charMap = {

        // latin
        'À': 'A',
        'Á': 'A',
        'Â': 'A',
        'Ã': 'A',
        'Ä': 'Ae',
        'Å': 'A',
        'Æ': 'AE',
        'Ç': 'C',
        'È': 'E',
        'É': 'E',
        'Ê': 'E',
        'Ë': 'E',
        'Ì': 'I',
        'Í': 'I',
        'Î': 'I',
        'Ï': 'I',
        'Ð': 'D',
        'Ñ': 'N',
        'Ò': 'O',
        'Ó': 'O',
        'Ô': 'O',
        'Õ': 'O',
        'Ö': 'Oe',
        'Ő': 'O',
        'Ø': 'O',
        'Ù': 'U',
        'Ú': 'U',
        'Û': 'U',
        'Ü': 'Ue',
        'Ű': 'U',
        'Ý': 'Y',
        'Þ': 'TH',
        'ß': 'ss',
        'à': 'a',
        'á': 'a',
        'â': 'a',
        'ã': 'a',
        'ä': 'ae',
        'å': 'a',
        'æ': 'ae',
        'ç': 'c',
        'è': 'e',
        'é': 'e',
        'ê': 'e',
        'ë': 'e',
        'ì': 'i',
        'í': 'i',
        'î': 'i',
        'ï': 'i',
        'ð': 'd',
        'ñ': 'n',
        'ò': 'o',
        'ó': 'o',
        'ô': 'o',
        'õ': 'o',
        'ö': 'oe',
        'ő': 'o',
        'ø': 'o',
        'ù': 'u',
        'ú': 'u',
        'û': 'u',
        'ü': 'ue',
        'ű': 'u',
        'ý': 'y',
        'þ': 'th',
        'ÿ': 'y',
        'ẞ': 'SS',

        // language specific

        // Arabic
        'ا': 'a',
        'أ': 'a',
        'إ': 'i',
        'آ': 'aa',
        'ؤ': 'u',
        'ئ': 'e',
        'ء': 'a',
        'ب': 'b',
        'ت': 't',
        'ث': 'th',
        'ج': 'j',
        'ح': 'h',
        'خ': 'kh',
        'د': 'd',
        'ذ': 'th',
        'ر': 'r',
        'ز': 'z',
        'س': 's',
        'ش': 'sh',
        'ص': 's',
        'ض': 'dh',
        'ط': 't',
        'ظ': 'z',
        'ع': 'a',
        'غ': 'gh',
        'ف': 'f',
        'ق': 'q',
        'ك': 'k',
        'ل': 'l',
        'م': 'm',
        'ن': 'n',
        'ه': 'h',
        'و': 'w',
        'ي': 'y',
        'ى': 'a',
        'ة': 'h',
        'ﻻ': 'la',
        'ﻷ': 'laa',
        'ﻹ': 'lai',
        'ﻵ': 'laa',

        // Persian additional characters than Arabic
        'گ': 'g',
        'چ': 'ch',
        'پ': 'p',
        'ژ': 'zh',
        'ک': 'k',
        'ی': 'y',

        // Arabic diactrics
        'َ': 'a',
        'ً': 'an',
        'ِ': 'e',
        'ٍ': 'en',
        'ُ': 'u',
        'ٌ': 'on',
        'ْ': '',

        // Arabic numbers
        '٠': '0',
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',

        // Persian numbers
        '۰': '0',
        '۱': '1',
        '۲': '2',
        '۳': '3',
        '۴': '4',
        '۵': '5',
        '۶': '6',
        '۷': '7',
        '۸': '8',
        '۹': '9',

        // Burmese consonants
        'က': 'k',
        'ခ': 'kh',
        'ဂ': 'g',
        'ဃ': 'ga',
        'င': 'ng',
        'စ': 's',
        'ဆ': 'sa',
        'ဇ': 'z',
        'စျ': 'za',
        'ည': 'ny',
        'ဋ': 't',
        'ဌ': 'ta',
        'ဍ': 'd',
        'ဎ': 'da',
        'ဏ': 'na',
        'တ': 't',
        'ထ': 'ta',
        'ဒ': 'd',
        'ဓ': 'da',
        'န': 'n',
        'ပ': 'p',
        'ဖ': 'pa',
        'ဗ': 'b',
        'ဘ': 'ba',
        'မ': 'm',
        'ယ': 'y',
        'ရ': 'ya',
        'လ': 'l',
        'ဝ': 'w',
        'သ': 'th',
        'ဟ': 'h',
        'ဠ': 'la',
        'အ': 'a',
        // consonant character combos
        'ြ': 'y',
        'ျ': 'ya',
        'ွ': 'w',
        'ြွ': 'yw',
        'ျွ': 'ywa',
        'ှ': 'h',
        // independent vowels
        'ဧ': 'e',
        '၏': '-e',
        'ဣ': 'i',
        'ဤ': '-i',
        'ဉ': 'u',
        'ဦ': '-u',
        'ဩ': 'aw',
        'သြော': 'aw',
        'ဪ': 'aw',
        // numbers
        '၀': '0',
        '၁': '1',
        '၂': '2',
        '၃': '3',
        '၄': '4',
        '၅': '5',
        '၆': '6',
        '၇': '7',
        '၈': '8',
        '၉': '9',
        // virama and tone marks which are silent in transliteration
        '္': '',
        '့': '',
        'း': '',

        // Czech
        'č': 'c',
        'ď': 'd',
        'ě': 'e',
        'ň': 'n',
        'ř': 'r',
        'š': 's',
        'ť': 't',
        'ů': 'u',
        'ž': 'z',
        'Č': 'C',
        'Ď': 'D',
        'Ě': 'E',
        'Ň': 'N',
        'Ř': 'R',
        'Š': 'S',
        'Ť': 'T',
        'Ů': 'U',
        'Ž': 'Z',

        // Dhivehi
        'ހ': 'h',
        'ށ': 'sh',
        'ނ': 'n',
        'ރ': 'r',
        'ބ': 'b',
        'ޅ': 'lh',
        'ކ': 'k',
        'އ': 'a',
        'ވ': 'v',
        'މ': 'm',
        'ފ': 'f',
        'ދ': 'dh',
        'ތ': 'th',
        'ލ': 'l',
        'ގ': 'g',
        'ޏ': 'gn',
        'ސ': 's',
        'ޑ': 'd',
        'ޒ': 'z',
        'ޓ': 't',
        'ޔ': 'y',
        'ޕ': 'p',
        'ޖ': 'j',
        'ޗ': 'ch',
        'ޘ': 'tt',
        'ޙ': 'hh',
        'ޚ': 'kh',
        'ޛ': 'th',
        'ޜ': 'z',
        'ޝ': 'sh',
        'ޞ': 's',
        'ޟ': 'd',
        'ޠ': 't',
        'ޡ': 'z',
        'ޢ': 'a',
        'ޣ': 'gh',
        'ޤ': 'q',
        'ޥ': 'w',
        'ަ': 'a',
        'ާ': 'aa',
        'ި': 'i',
        'ީ': 'ee',
        'ު': 'u',
        'ޫ': 'oo',
        'ެ': 'e',
        'ޭ': 'ey',
        'ޮ': 'o',
        'ޯ': 'oa',
        'ް': '',

        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        'ა': 'a',
        'ბ': 'b',
        'გ': 'g',
        'დ': 'd',
        'ე': 'e',
        'ვ': 'v',
        'ზ': 'z',
        'თ': 't',
        'ი': 'i',
        'კ': 'k',
        'ლ': 'l',
        'მ': 'm',
        'ნ': 'n',
        'ო': 'o',
        'პ': 'p',
        'ჟ': 'zh',
        'რ': 'r',
        'ს': 's',
        'ტ': 't',
        'უ': 'u',
        'ფ': 'p',
        'ქ': 'k',
        'ღ': 'gh',
        'ყ': 'q',
        'შ': 'sh',
        'ჩ': 'ch',
        'ც': 'ts',
        'ძ': 'dz',
        'წ': 'ts',
        'ჭ': 'ch',
        'ხ': 'kh',
        'ჯ': 'j',
        'ჰ': 'h',

        // Greek
        'α': 'a',
        'β': 'v',
        'γ': 'g',
        'δ': 'd',
        'ε': 'e',
        'ζ': 'z',
        'η': 'i',
        'θ': 'th',
        'ι': 'i',
        'κ': 'k',
        'λ': 'l',
        'μ': 'm',
        'ν': 'n',
        'ξ': 'ks',
        'ο': 'o',
        'π': 'p',
        'ρ': 'r',
        'σ': 's',
        'τ': 't',
        'υ': 'y',
        'φ': 'f',
        'χ': 'x',
        'ψ': 'ps',
        'ω': 'o',
        'ά': 'a',
        'έ': 'e',
        'ί': 'i',
        'ό': 'o',
        'ύ': 'y',
        'ή': 'i',
        'ώ': 'o',
        'ς': 's',
        'ϊ': 'i',
        'ΰ': 'y',
        'ϋ': 'y',
        'ΐ': 'i',
        'Α': 'A',
        'Β': 'B',
        'Γ': 'G',
        'Δ': 'D',
        'Ε': 'E',
        'Ζ': 'Z',
        'Η': 'I',
        'Θ': 'TH',
        'Ι': 'I',
        'Κ': 'K',
        'Λ': 'L',
        'Μ': 'M',
        'Ν': 'N',
        'Ξ': 'KS',
        'Ο': 'O',
        'Π': 'P',
        'Ρ': 'R',
        'Σ': 'S',
        'Τ': 'T',
        'Υ': 'Y',
        'Φ': 'F',
        'Χ': 'X',
        'Ψ': 'PS',
        'Ω': 'O',
        'Ά': 'A',
        'Έ': 'E',
        'Ί': 'I',
        'Ό': 'O',
        'Ύ': 'Y',
        'Ή': 'I',
        'Ώ': 'O',
        'Ϊ': 'I',
        'Ϋ': 'Y',

        // Latvian
        'ā': 'a',
        // 'č': 'c', // duplicate
        'ē': 'e',
        'ģ': 'g',
        'ī': 'i',
        'ķ': 'k',
        'ļ': 'l',
        'ņ': 'n',
        // 'š': 's', // duplicate
        'ū': 'u',
        // 'ž': 'z', // duplicate
        'Ā': 'A',
        // 'Č': 'C', // duplicate
        'Ē': 'E',
        'Ģ': 'G',
        'Ī': 'I',
        'Ķ': 'k',
        'Ļ': 'L',
        'Ņ': 'N',
        // 'Š': 'S', // duplicate
        'Ū': 'U',
        // 'Ž': 'Z', // duplicate

        // Macedonian
        'Ќ': 'Kj',
        'ќ': 'kj',
        'Љ': 'Lj',
        'љ': 'lj',
        'Њ': 'Nj',
        'њ': 'nj',
        'Тс': 'Ts',
        'тс': 'ts',

        // Polish
        'ą': 'a',
        'ć': 'c',
        'ę': 'e',
        'ł': 'l',
        'ń': 'n',
        // 'ó': 'o', // duplicate
        'ś': 's',
        'ź': 'z',
        'ż': 'z',
        'Ą': 'A',
        'Ć': 'C',
        'Ę': 'E',
        'Ł': 'L',
        'Ń': 'N',
        'Ś': 'S',
        'Ź': 'Z',
        'Ż': 'Z',

        // Ukranian
        'Є': 'Ye',
        'І': 'I',
        'Ї': 'Yi',
        'Ґ': 'G',
        'є': 'ye',
        'і': 'i',
        'ї': 'yi',
        'ґ': 'g',

        // Romanian
        'ă': 'a',
        'Ă': 'A',
        'ș': 's',
        'Ș': 'S',
        // 'ş': 's', // duplicate
        // 'Ş': 'S', // duplicate
        'ț': 't',
        'Ț': 'T',
        'ţ': 't',
        'Ţ': 'T',

        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO

        'а': 'a',
        'б': 'b',
        'в': 'v',
        'г': 'g',
        'д': 'd',
        'е': 'e',
        'ё': 'yo',
        'ж': 'zh',
        'з': 'z',
        'и': 'i',
        'й': 'i',
        'к': 'k',
        'л': 'l',
        'м': 'm',
        'н': 'n',
        'о': 'o',
        'п': 'p',
        'р': 'r',
        'с': 's',
        'т': 't',
        'у': 'u',
        'ф': 'f',
        'х': 'kh',
        'ц': 'c',
        'ч': 'ch',
        'ш': 'sh',
        'щ': 'sh',
        'ъ': '',
        'ы': 'y',
        'ь': '',
        'э': 'e',
        'ю': 'yu',
        'я': 'ya',
        'А': 'A',
        'Б': 'B',
        'В': 'V',
        'Г': 'G',
        'Д': 'D',
        'Е': 'E',
        'Ё': 'Yo',
        'Ж': 'Zh',
        'З': 'Z',
        'И': 'I',
        'Й': 'I',
        'К': 'K',
        'Л': 'L',
        'М': 'M',
        'Н': 'N',
        'О': 'O',
        'П': 'P',
        'Р': 'R',
        'С': 'S',
        'Т': 'T',
        'У': 'U',
        'Ф': 'F',
        'Х': 'Kh',
        'Ц': 'C',
        'Ч': 'Ch',
        'Ш': 'Sh',
        'Щ': 'Sh',
        'Ъ': '',
        'Ы': 'Y',
        'Ь': '',
        'Э': 'E',
        'Ю': 'Yu',
        'Я': 'Ya',

        // Serbian
        'ђ': 'dj',
        'ј': 'j',
        // 'љ': 'lj',  // duplicate
        // 'њ': 'nj', // duplicate
        'ћ': 'c',
        'џ': 'dz',
        'Ђ': 'Dj',
        'Ј': 'j',
        // 'Љ': 'Lj', // duplicate
        // 'Њ': 'Nj', // duplicate
        'Ћ': 'C',
        'Џ': 'Dz',

        // Slovak
        'ľ': 'l',
        'ĺ': 'l',
        'ŕ': 'r',
        'Ľ': 'L',
        'Ĺ': 'L',
        'Ŕ': 'R',

        // Turkish
        'ş': 's',
        'Ş': 'S',
        'ı': 'i',
        'İ': 'I',
        // 'ç': 'c', // duplicate
        // 'Ç': 'C', // duplicate
        // 'ü': 'u', // duplicate, see langCharMap
        // 'Ü': 'U', // duplicate, see langCharMap
        // 'ö': 'o', // duplicate, see langCharMap
        // 'Ö': 'O', // duplicate, see langCharMap
        'ğ': 'g',
        'Ğ': 'G',

        // Vietnamese
        'ả': 'a',
        'Ả': 'A',
        'ẳ': 'a',
        'Ẳ': 'A',
        'ẩ': 'a',
        'Ẩ': 'A',
        'đ': 'd',
        'Đ': 'D',
        'ẹ': 'e',
        'Ẹ': 'E',
        'ẽ': 'e',
        'Ẽ': 'E',
        'ẻ': 'e',
        'Ẻ': 'E',
        'ế': 'e',
        'Ế': 'E',
        'ề': 'e',
        'Ề': 'E',
        'ệ': 'e',
        'Ệ': 'E',
        'ễ': 'e',
        'Ễ': 'E',
        'ể': 'e',
        'Ể': 'E',
        'ỏ': 'o',
        'ọ': 'o',
        'Ọ': 'o',
        'ố': 'o',
        'Ố': 'O',
        'ồ': 'o',
        'Ồ': 'O',
        'ổ': 'o',
        'Ổ': 'O',
        'ộ': 'o',
        'Ộ': 'O',
        'ỗ': 'o',
        'Ỗ': 'O',
        'ơ': 'o',
        'Ơ': 'O',
        'ớ': 'o',
        'Ớ': 'O',
        'ờ': 'o',
        'Ờ': 'O',
        'ợ': 'o',
        'Ợ': 'O',
        'ỡ': 'o',
        'Ỡ': 'O',
        'Ở': 'o',
        'ở': 'o',
        'ị': 'i',
        'Ị': 'I',
        'ĩ': 'i',
        'Ĩ': 'I',
        'ỉ': 'i',
        'Ỉ': 'i',
        'ủ': 'u',
        'Ủ': 'U',
        'ụ': 'u',
        'Ụ': 'U',
        'ũ': 'u',
        'Ũ': 'U',
        'ư': 'u',
        'Ư': 'U',
        'ứ': 'u',
        'Ứ': 'U',
        'ừ': 'u',
        'Ừ': 'U',
        'ự': 'u',
        'Ự': 'U',
        'ữ': 'u',
        'Ữ': 'U',
        'ử': 'u',
        'Ử': 'ư',
        'ỷ': 'y',
        'Ỷ': 'y',
        'ỳ': 'y',
        'Ỳ': 'Y',
        'ỵ': 'y',
        'Ỵ': 'Y',
        'ỹ': 'y',
        'Ỹ': 'Y',
        'ạ': 'a',
        'Ạ': 'A',
        'ấ': 'a',
        'Ấ': 'A',
        'ầ': 'a',
        'Ầ': 'A',
        'ậ': 'a',
        'Ậ': 'A',
        'ẫ': 'a',
        'Ẫ': 'A',
        // 'ă': 'a', // duplicate
        // 'Ă': 'A', // duplicate
        'ắ': 'a',
        'Ắ': 'A',
        'ằ': 'a',
        'Ằ': 'A',
        'ặ': 'a',
        'Ặ': 'A',
        'ẵ': 'a',
        'Ẵ': 'A',
        "⓪": "0",
        "①": "1",
        "②": "2",
        "③": "3",
        "④": "4",
        "⑤": "5",
        "⑥": "6",
        "⑦": "7",
        "⑧": "8",
        "⑨": "9",
        "⑩": "10",
        "⑪": "11",
        "⑫": "12",
        "⑬": "13",
        "⑭": "14",
        "⑮": "15",
        "⑯": "16",
        "⑰": "17",
        "⑱": "18",
        "⑲": "18",
        "⑳": "18",

        "⓵": "1",
        "⓶": "2",
        "⓷": "3",
        "⓸": "4",
        "⓹": "5",
        "⓺": "6",
        "⓻": "7",
        "⓼": "8",
        "⓽": "9",
        "⓾": "10",

        "⓿": "0",
        "⓫": "11",
        "⓬": "12",
        "⓭": "13",
        "⓮": "14",
        "⓯": "15",
        "⓰": "16",
        "⓱": "17",
        "⓲": "18",
        "⓳": "19",
        "⓴": "20",

        "Ⓐ": "A",
        "Ⓑ": "B",
        "Ⓒ": "C",
        "Ⓓ": "D",
        "Ⓔ": "E",
        "Ⓕ": "F",
        "Ⓖ": "G",
        "Ⓗ": "H",
        "Ⓘ": "I",
        "Ⓙ": "J",
        "Ⓚ": "K",
        "Ⓛ": "L",
        "Ⓜ": "M",
        "Ⓝ": "N",
        "Ⓞ": "O",
        "Ⓟ": "P",
        "Ⓠ": "Q",
        "Ⓡ": "R",
        "Ⓢ": "S",
        "Ⓣ": "T",
        "Ⓤ": "U",
        "Ⓥ": "V",
        "Ⓦ": "W",
        "Ⓧ": "X",
        "Ⓨ": "Y",
        "Ⓩ": "Z",

        "ⓐ": "a",
        "ⓑ": "b",
        "ⓒ": "c",
        "ⓓ": "d",
        "ⓔ": "e",
        "ⓕ": "f",
        "ⓖ": "g",
        "ⓗ": "h",
        "ⓘ": "i",
        "ⓙ": "j",
        "ⓚ": "k",
        "ⓛ": "l",
        "ⓜ": "m",
        "ⓝ": "n",
        "ⓞ": "o",
        "ⓟ": "p",
        "ⓠ": "q",
        "ⓡ": "r",
        "ⓢ": "s",
        "ⓣ": "t",
        "ⓤ": "u",
        "ⓦ": "v",
        "ⓥ": "w",
        "ⓧ": "x",
        "ⓨ": "y",
        "ⓩ": "z",

        // symbols
        '“': '"',
        '”': '"',
        '‘': "'",
        '’': "'",
        '∂': 'd',
        'ƒ': 'f',
        '™': '(TM)',
        '©': '(C)',
        'œ': 'oe',
        'Œ': 'OE',
        '®': '(R)',
        '†': '+',
        '℠': '(SM)',
        '…': '...',
        '˚': 'o',
        'º': 'o',
        'ª': 'a',
        '•': '*',
        '၊': ',',
        '။': '.',

        // currency
        '$': 'USD',
        '€': 'EUR',
        '₢': 'BRN',
        '₣': 'FRF',
        '£': 'GBP',
        '₤': 'ITL',
        '₦': 'NGN',
        '₧': 'ESP',
        '₩': 'KRW',
        '₪': 'ILS',
        '₫': 'VND',
        '₭': 'LAK',
        '₮': 'MNT',
        '₯': 'GRD',
        '₱': 'ARS',
        '₲': 'PYG',
        '₳': 'ARA',
        '₴': 'UAH',
        '₵': 'GHS',
        '¢': 'cent',
        '¥': 'CNY',
        '元': 'CNY',
        '円': 'YEN',
        '﷼': 'IRR',
        '₠': 'EWE',
        '฿': 'THB',
        '₨': 'INR',
        '₹': 'INR',
        '₰': 'PF',
        '₺': 'TRY',
        '؋': 'AFN',
        '₼': 'AZN',
        'лв': 'BGN',
        '៛': 'KHR',
        '₡': 'CRC',
        '₸': 'KZT',
        'ден': 'MKD',
        'zł': 'PLN',
        '₽': 'RUB',
        '₾': 'GEL'

    };

    /**
     * special look ahead character array
     * These characters form with consonants to become 'single'/consonant combo
     * @type [Array]
     */
    var lookAheadCharArray = [
        // burmese
        '်',

        // Dhivehi
        'ް'
    ];

    /**
     * diatricMap for languages where transliteration changes entirely as more diatrics are added
     * @type {Object}
     */
    var diatricMap = {
        // Burmese
        // dependent vowels
        'ာ': 'a',
        'ါ': 'a',
        'ေ': 'e',
        'ဲ': 'e',
        'ိ': 'i',
        'ီ': 'i',
        'ို': 'o',
        'ု': 'u',
        'ူ': 'u',
        'ေါင်': 'aung',
        'ော': 'aw',
        'ော်': 'aw',
        'ေါ': 'aw',
        'ေါ်': 'aw',
        '်': '်', // this is special case but the character will be converted to latin in the code
        'က်': 'et',
        'ိုက်': 'aik',
        'ောက်': 'auk',
        'င်': 'in',
        'ိုင်': 'aing',
        'ောင်': 'aung',
        'စ်': 'it',
        'ည်': 'i',
        'တ်': 'at',
        'ိတ်': 'eik',
        'ုတ်': 'ok',
        'ွတ်': 'ut',
        'ေတ်': 'it',
        'ဒ်': 'd',
        'ိုဒ်': 'ok',
        'ုဒ်': 'ait',
        'န်': 'an',
        'ာန်': 'an',
        'ိန်': 'ein',
        'ုန်': 'on',
        'ွန်': 'un',
        'ပ်': 'at',
        'ိပ်': 'eik',
        'ုပ်': 'ok',
        'ွပ်': 'ut',
        'န်ုပ်': 'nub',
        'မ်': 'an',
        'ိမ်': 'ein',
        'ုမ်': 'on',
        'ွမ်': 'un',
        'ယ်': 'e',
        'ိုလ်': 'ol',
        'ဉ်': 'in',
        'ံ': 'an',
        'ိံ': 'ein',
        'ုံ': 'on',

        // Dhivehi
        'ައް': 'ah',
        'ަށް': 'ah'
    };

    /**
     * langCharMap language specific characters translations
     * @type   {Object}
     */
    var langCharMap = {
        'en': {}, // default language

        'az': { // Azerbaijani
            'ç': 'c',
            'ə': 'e',
            'ğ': 'g',
            'ı': 'i',
            'ö': 'o',
            'ş': 's',
            'ü': 'u',
            'Ç': 'C',
            'Ə': 'E',
            'Ğ': 'G',
            'İ': 'I',
            'Ö': 'O',
            'Ş': 'S',
            'Ü': 'U'
        },

        'cs': { // Czech
            'č': 'c',
            'ď': 'd',
            'ě': 'e',
            'ň': 'n',
            'ř': 'r',
            'š': 's',
            'ť': 't',
            'ů': 'u',
            'ž': 'z',
            'Č': 'C',
            'Ď': 'D',
            'Ě': 'E',
            'Ň': 'N',
            'Ř': 'R',
            'Š': 'S',
            'Ť': 'T',
            'Ů': 'U',
            'Ž': 'Z'
        },

        'fi': { // Finnish
            // 'å': 'a', duplicate see charMap/latin
            // 'Å': 'A', duplicate see charMap/latin
            'ä': 'a', // ok
            'Ä': 'A', // ok
            'ö': 'o', // ok
            'Ö': 'O' // ok
        },

        'hu': { // Hungarian
            'ä': 'a', // ok
            'Ä': 'A', // ok
            // 'á': 'a', duplicate see charMap/latin
            // 'Á': 'A', duplicate see charMap/latin
            'ö': 'o', // ok
            'Ö': 'O', // ok
            // 'ő': 'o', duplicate see charMap/latin
            // 'Ő': 'O', duplicate see charMap/latin
            'ü': 'u',
            'Ü': 'U',
            'ű': 'u',
            'Ű': 'U'
        },

        'lt': { // Lithuanian
            'ą': 'a',
            'č': 'c',
            'ę': 'e',
            'ė': 'e',
            'į': 'i',
            'š': 's',
            'ų': 'u',
            'ū': 'u',
            'ž': 'z',
            'Ą': 'A',
            'Č': 'C',
            'Ę': 'E',
            'Ė': 'E',
            'Į': 'I',
            'Š': 'S',
            'Ų': 'U',
            'Ū': 'U'
        },

        'lv': { // Latvian
            'ā': 'a',
            'č': 'c',
            'ē': 'e',
            'ģ': 'g',
            'ī': 'i',
            'ķ': 'k',
            'ļ': 'l',
            'ņ': 'n',
            'š': 's',
            'ū': 'u',
            'ž': 'z',
            'Ā': 'A',
            'Č': 'C',
            'Ē': 'E',
            'Ģ': 'G',
            'Ī': 'i',
            'Ķ': 'k',
            'Ļ': 'L',
            'Ņ': 'N',
            'Š': 'S',
            'Ū': 'u',
            'Ž': 'Z'
        },

        'pl': { // Polish
            'ą': 'a',
            'ć': 'c',
            'ę': 'e',
            'ł': 'l',
            'ń': 'n',
            'ó': 'o',
            'ś': 's',
            'ź': 'z',
            'ż': 'z',
            'Ą': 'A',
            'Ć': 'C',
            'Ę': 'e',
            'Ł': 'L',
            'Ń': 'N',
            'Ó': 'O',
            'Ś': 'S',
            'Ź': 'Z',
            'Ż': 'Z'
        },

        'sv': { // Swedish
            // 'å': 'a', duplicate see charMap/latin
            // 'Å': 'A', duplicate see charMap/latin
            'ä': 'a', // ok
            'Ä': 'A', // ok
            'ö': 'o', // ok
            'Ö': 'O' // ok
        },

        'sk': { // Slovak
            'ä': 'a',
            'Ä': 'A'
        },

        'sr': { // Serbian
            'љ': 'lj',
            'њ': 'nj',
            'Љ': 'Lj',
            'Њ': 'Nj',
            'đ': 'dj',
            'Đ': 'Dj'
        },

        'tr': { // Turkish
            'Ü': 'U',
            'Ö': 'O',
            'ü': 'u',
            'ö': 'o'
        }
    };

    /**
     * symbolMap language specific symbol translations
     * translations must be transliterated already
     * @type   {Object}
     */
    var symbolMap = {
        'ar': {
            '∆': 'delta',
            '∞': 'la-nihaya',
            '♥': 'hob',
            '&': 'wa',
            '|': 'aw',
            '<': 'aqal-men',
            '>': 'akbar-men',
            '∑': 'majmou',
            '¤': 'omla'
        },

        'az': {},

        'ca': {
            '∆': 'delta',
            '∞': 'infinit',
            '♥': 'amor',
            '&': 'i',
            '|': 'o',
            '<': 'menys que',
            '>': 'mes que',
            '∑': 'suma dels',
            '¤': 'moneda'
        },

        'cs': {
            '∆': 'delta',
            '∞': 'nekonecno',
            '♥': 'laska',
            '&': 'a',
            '|': 'nebo',
            '<': 'mensi nez',
            '>': 'vetsi nez',
            '∑': 'soucet',
            '¤': 'mena'
        },

        'de': {
            '∆': 'delta',
            '∞': 'unendlich',
            '♥': 'Liebe',
            '&': 'und',
            '|': 'oder',
            '<': 'kleiner als',
            '>': 'groesser als',
            '∑': 'Summe von',
            '¤': 'Waehrung'
        },

        'dv': {
            '∆': 'delta',
            '∞': 'kolunulaa',
            '♥': 'loabi',
            '&': 'aai',
            '|': 'noonee',
            '<': 'ah vure kuda',
            '>': 'ah vure bodu',
            '∑': 'jumula',
            '¤': 'faisaa'
        },

        'en': {
            '∆': 'delta',
            '∞': 'infinity',
            '♥': 'love',
            '&': 'and',
            '|': 'or',
            '<': 'less than',
            '>': 'greater than',
            '∑': 'sum',
            '¤': 'currency'
        },

        'es': {
            '∆': 'delta',
            '∞': 'infinito',
            '♥': 'amor',
            '&': 'y',
            '|': 'u',
            '<': 'menos que',
            '>': 'mas que',
            '∑': 'suma de los',
            '¤': 'moneda'
        },

        'fa': {
            '∆': 'delta',
            '∞': 'bi-nahayat',
            '♥': 'eshgh',
            '&': 'va',
            '|': 'ya',
            '<': 'kamtar-az',
            '>': 'bishtar-az',
            '∑': 'majmooe',
            '¤': 'vahed'
        },

        'fi': {
            '∆': 'delta',
            '∞': 'aarettomyys',
            '♥': 'rakkaus',
            '&': 'ja',
            '|': 'tai',
            '<': 'pienempi kuin',
            '>': 'suurempi kuin',
            '∑': 'summa',
            '¤': 'valuutta'
        },

        'fr': {
            '∆': 'delta',
            '∞': 'infiniment',
            '♥': 'Amour',
            '&': 'et',
            '|': 'ou',
            '<': 'moins que',
            '>': 'superieure a',
            '∑': 'somme des',
            '¤': 'monnaie'
        },

        'ge': {
            '∆': 'delta',
            '∞': 'usasruloba',
            '♥': 'siqvaruli',
            '&': 'da',
            '|': 'an',
            '<': 'naklebi',
            '>': 'meti',
            '∑': 'jami',
            '¤': 'valuta'
        },

        'gr': {},

        'hu': {
            '∆': 'delta',
            '∞': 'vegtelen',
            '♥': 'szerelem',
            '&': 'es',
            '|': 'vagy',
            '<': 'kisebb mint',
            '>': 'nagyobb mint',
            '∑': 'szumma',
            '¤': 'penznem'
        },

        'it': {
            '∆': 'delta',
            '∞': 'infinito',
            '♥': 'amore',
            '&': 'e',
            '|': 'o',
            '<': 'minore di',
            '>': 'maggiore di',
            '∑': 'somma',
            '¤': 'moneta'
        },

        'lt': {
            '∆': 'delta',
            '∞': 'begalybe',
            '♥': 'meile',
            '&': 'ir',
            '|': 'ar',
            '<': 'maziau nei',
            '>': 'daugiau nei',
            '∑': 'suma',
            '¤': 'valiuta'
        },

        'lv': {
            '∆': 'delta',
            '∞': 'bezgaliba',
            '♥': 'milestiba',
            '&': 'un',
            '|': 'vai',
            '<': 'mazak neka',
            '>': 'lielaks neka',
            '∑': 'summa',
            '¤': 'valuta'
        },

        'my': {
            '∆': 'kwahkhyaet',
            '∞': 'asaonasme',
            '♥': 'akhyait',
            '&': 'nhin',
            '|': 'tho',
            '<': 'ngethaw',
            '>': 'kyithaw',
            '∑': 'paungld',
            '¤': 'ngwekye'
        },

        'mk': {},

        'nl': {
            '∆': 'delta',
            '∞': 'oneindig',
            '♥': 'liefde',
            '&': 'en',
            '|': 'of',
            '<': 'kleiner dan',
            '>': 'groter dan',
            '∑': 'som',
            '¤': 'valuta'
        },

        'pl': {
            '∆': 'delta',
            '∞': 'nieskonczonosc',
            '♥': 'milosc',
            '&': 'i',
            '|': 'lub',
            '<': 'mniejsze niz',
            '>': 'wieksze niz',
            '∑': 'suma',
            '¤': 'waluta'
        },

        'pt': {
            '∆': 'delta',
            '∞': 'infinito',
            '♥': 'amor',
            '&': 'e',
            '|': 'ou',
            '<': 'menor que',
            '>': 'maior que',
            '∑': 'soma',
            '¤': 'moeda'
        },

        'ro': {
            '∆': 'delta',
            '∞': 'infinit',
            '♥': 'dragoste',
            '&': 'si',
            '|': 'sau',
            '<': 'mai mic ca',
            '>': 'mai mare ca',
            '∑': 'suma',
            '¤': 'valuta'
        },

        'ru': {
            '∆': 'delta',
            '∞': 'beskonechno',
            '♥': 'lubov',
            '&': 'i',
            '|': 'ili',
            '<': 'menshe',
            '>': 'bolshe',
            '∑': 'summa',
            '¤': 'valjuta'
        },

        'sk': {
            '∆': 'delta',
            '∞': 'nekonecno',
            '♥': 'laska',
            '&': 'a',
            '|': 'alebo',
            '<': 'menej ako',
            '>': 'viac ako',
            '∑': 'sucet',
            '¤': 'mena'
        },

        'sr': {},

        'tr': {
            '∆': 'delta',
            '∞': 'sonsuzluk',
            '♥': 'ask',
            '&': 've',
            '|': 'veya',
            '<': 'kucuktur',
            '>': 'buyuktur',
            '∑': 'toplam',
            '¤': 'para birimi'
        },

        'uk': {
            '∆': 'delta',
            '∞': 'bezkinechnist',
            '♥': 'lubov',
            '&': 'i',
            '|': 'abo',
            '<': 'menshe',
            '>': 'bilshe',
            '∑': 'suma',
            '¤': 'valjuta'
        },

        'vn': {
            '∆': 'delta',
            '∞': 'vo cuc',
            '♥': 'yeu',
            '&': 'va',
            '|': 'hoac',
            '<': 'nho hon',
            '>': 'lon hon',
            '∑': 'tong',
            '¤': 'tien te'
        }
    };

    var uricChars = [';', '?', ':', '@', '&', '=', '+', '$', ',', '/'].join('');

    var uricNoSlashChars = [';', '?', ':', '@', '&', '=', '+', '$', ','].join('');

    var markChars = ['.', '!', '~', '*', "'", '(', ')'].join('');

    /**
     * getSlug
     * @param  {string} input input string
     * @param  {object|string} opts config object or separator string/char
     * @api    public
     * @return {string}  sluggified string
     */
    var getSlug = function getSlug(input, opts) {
        var separator = '-';
        var result = '';
        var diatricString = '';
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars = '';

        if (typeof input !== 'string') {
            return '';
        }

        if (typeof opts === 'string') {
            separator = opts;
        }

        symbol = symbolMap.en;
        langChar = langCharMap.en;

        if (typeof opts === 'object') {
            maintainCase = opts.maintainCase || false;
            customReplacements = (opts.custom && typeof opts.custom === 'object') ? opts.custom : customReplacements;
            truncate = (+opts.truncate > 1 && opts.truncate) || false;
            uricFlag = opts.uric || false;
            uricNoSlashFlag = opts.uricNoSlash || false;
            markFlag = opts.mark || false;
            convertSymbols = (opts.symbols === false || opts.lang === false) ? false : true;
            separator = opts.separator || separator;

            if (uricFlag) {
                allowedChars += uricChars;
            }

            if (uricNoSlashFlag) {
                allowedChars += uricNoSlashChars;
            }

            if (markFlag) {
                allowedChars += markChars;
            }

            symbol = (opts.lang && symbolMap[opts.lang] && convertSymbols) ?
                symbolMap[opts.lang] : (convertSymbols ? symbolMap.en : {});

            langChar = (opts.lang && langCharMap[opts.lang]) ?
                langCharMap[opts.lang] :
                opts.lang === false || opts.lang === true ? {} : langCharMap.en;

            // if titleCase config is an Array, rewrite to object format
            if (opts.titleCase && typeof opts.titleCase.length === 'number' && Array.prototype.toString.call(opts.titleCase)) {
                opts.titleCase.forEach(function (v) {
                    customReplacements[v + ''] = v + '';
                });

                titleCase = true;
            } else {
                titleCase = !!opts.titleCase;
            }

            // if custom config is an Array, rewrite to object format
            if (opts.custom && typeof opts.custom.length === 'number' && Array.prototype.toString.call(opts.custom)) {
                opts.custom.forEach(function (v) {
                    customReplacements[v + ''] = v + '';
                });
            }

            // custom replacements
            Object.keys(customReplacements).forEach(function (v) {
                var r;

                if (v.length > 1) {
                    r = new RegExp('\\b' + escapeChars(v) + '\\b', 'gi');
                } else {
                    r = new RegExp(escapeChars(v), 'gi');
                }

                input = input.replace(r, customReplacements[v]);
            });

            // add all custom replacement to allowed charlist
            for (ch in customReplacements) {
                allowedChars += ch;
            }
        }

        allowedChars += separator;

        // escape all necessary chars
        allowedChars = escapeChars(allowedChars);

        // trim whitespaces
        input = input.replace(/(^\s+|\s+$)/g, '');

        lastCharWasSymbol = false;
        lastCharWasDiatric = false;

        for (i = 0, l = input.length; i < l; i++) {
            ch = input[i];

            if (isReplacedCustomChar(ch, customReplacements)) {
                // don't convert a already converted char
                lastCharWasSymbol = false;
            } else if (langChar[ch]) {
                // process language specific diactrics chars conversion
                ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? ' ' + langChar[ch] : langChar[ch];

                lastCharWasSymbol = false;
            } else if (ch in charMap) {
                // the transliteration changes entirely when some special characters are added
                if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
                    diatricString += ch;
                    ch = '';
                } else if (lastCharWasDiatric === true) {
                    ch = diatricMap[diatricString] + charMap[ch];
                    diatricString = '';
                } else {
                    // process diactrics chars
                    ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? ' ' + charMap[ch] : charMap[ch];
                }

                lastCharWasSymbol = false;
                lastCharWasDiatric = false;
            } else if (ch in diatricMap) {
                diatricString += ch;
                ch = '';
                // end of string, put the whole meaningful word
                if (i === l - 1) {
                    ch = diatricMap[diatricString];
                }
                lastCharWasDiatric = true;
            } else if (
                // process symbol chars
                symbol[ch] && !(uricFlag && uricChars
                    .indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars
                    // .indexOf(ch) !== -1) && !(markFlag && markChars
                    .indexOf(ch) !== -1)) {
                ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
                ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : '';

                lastCharWasSymbol = true;
            } else {
                if (lastCharWasDiatric === true) {
                    ch = diatricMap[diatricString] + ch;
                    diatricString = '';
                    lastCharWasDiatric = false;
                } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
                    // process latin chars
                    ch = ' ' + ch;
                }
                lastCharWasSymbol = false;
            }

            // add allowed chars
            result += ch.replace(new RegExp('[^\\w\\s' + allowedChars + '_-]', 'g'), separator);
        }

        if (titleCase) {
            result = result.replace(/(\w)(\S*)/g, function (_, i, r) {
                var j = i.toUpperCase() + (r !== null ? r : '');
                return (Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0) ? j : j.toLowerCase();
            });
        }

        // eliminate duplicate separators
        // add separator
        // trim separators from start and end
        result = result.replace(/\s+/g, separator)
            .replace(new RegExp('\\' + separator + '+', 'g'), separator)
            .replace(new RegExp('(^\\' + separator + '+|\\' + separator + '+$)', 'g'), '');

        if (truncate && result.length > truncate) {
            lucky = result.charAt(truncate) === separator;
            result = result.slice(0, truncate);

            if (!lucky) {
                result = result.slice(0, result.lastIndexOf(separator));
            }
        }

        if (!maintainCase && !titleCase) {
            result = result.toLowerCase();
        }

        return result;
    };

    /**
     * createSlug curried(opts)(input)
     * @param   {object|string} opts config object or input string
     * @return  {Function} function getSlugWithConfig()
     **/
    var createSlug = function createSlug(opts) {

        /**
         * getSlugWithConfig
         * @param   {string} input string
         * @return  {string} slug string
         */
        return function getSlugWithConfig(input) {
            return getSlug(input, opts);
        };
    };

    /**
     * escape Chars
     * @param   {string} input string
     */
    var escapeChars = function escapeChars(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, '\\$&');
    };

    /**
     * check if the char is an already converted char from custom list
     * @param   {char} ch character to check
     * @param   {object} customReplacements custom translation map
     */
    var isReplacedCustomChar = function (ch, customReplacements) {
        for (var c in customReplacements) {
            if (customReplacements[c] === ch) {
                return true;
            }
        }
    };

    if (typeof module !== 'undefined' && module.exports) {

        // export functions for use in Node
        module.exports = getSlug;
        module.exports.createSlug = createSlug;
    } else if (typeof define !== 'undefined' && define.amd) {

        // export function for use in AMD
        define([], function () {
            return getSlug;
        });
    } else {

        // don't overwrite global if exists
        try {
            if (root.getSlug || root.createSlug) {
                throw 'speakingurl: globals exists /(getSlug|createSlug)/';
            } else {
                root.getSlug = getSlug;
                root.createSlug = createSlug;
            }
        } catch (e) {}
    }
})(this);
},{}],29:[function(require,module,exports){
// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);

},{}],30:[function(require,module,exports){
(function (global){
/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 */
/* global define */
(function (define) {
    define(['jquery'], function ($) {
        return (function () {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: 'error',
                info: 'info',
                success: 'success',
                warning: 'warning'
            };

            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: '2.1.4',
                warning: warning
            };

            var previousToast;

            return toastr;

            ////////////////

            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function getContainer(options, create) {
                if (!options) { options = getOptions(); }
                $container = $('#' + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }

            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function subscribe(callback) {
                listener = callback;
            }

            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }

            function remove($toastElement) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if ($toastElement && $(':focus', $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }

            // internal functions

            function clearContainer (options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }

            function clearToast ($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function () { removeToast($toastElement); }
                    });
                    return true;
                }
                return false;
            }

            function createContainer(options) {
                $container = $('<div/>')
                    .attr('id', options.containerId)
                    .addClass(options.positionClass);

                $container.appendTo($(options.target));
                return $container;
            }

            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: 'toast',
                    containerId: 'toast-container',
                    debug: false,

                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: 'swing', //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: 'fadeOut',
                    hideDuration: 1000,
                    hideEasing: 'swing',
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,
                    closeOnHover: true,

                    extendedTimeOut: 1000,
                    iconClasses: {
                        error: 'toast-error',
                        info: 'toast-info',
                        success: 'toast-success',
                        warning: 'toast-warning'
                    },
                    iconClass: 'toast-info',
                    positionClass: 'toast-top-right',
                    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                    titleClass: 'toast-title',
                    messageClass: 'toast-message',
                    escapeHtml: false,
                    target: 'body',
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: 'toast-close-button',
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false,
                    progressClass: 'toast-progress',
                    rtl: false
                };
            }

            function publish(args) {
                if (!listener) { return; }
                listener(args);
            }

            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;

                if (typeof (map.optionsOverride) !== 'undefined') {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }

                if (shouldExit(options, map)) { return; }

                toastId++;

                $container = getContainer(options, true);

                var intervalId = null;
                var $toastElement = $('<div/>');
                var $titleElement = $('<div/>');
                var $messageElement = $('<div/>');
                var $progressElement = $('<div/>');
                var $closeElement = $(options.closeHtml);
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: 'visible',
                    startTime: new Date(),
                    options: options,
                    map: map
                };

                personalizeToast();

                displayToast();

                handleEvents();

                publish(response);

                if (options.debug && console) {
                    console.log(response);
                }

                return $toastElement;

                function escapeHtml(source) {
                    if (source == null) {
                        source = '';
                    }

                    return source
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }

                function personalizeToast() {
                    setIcon();
                    setTitle();
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setRTL();
                    setSequence();
                    setAria();
                }

                function setAria() {
                    var ariaValue = '';
                    switch (map.iconClass) {
                        case 'toast-success':
                        case 'toast-info':
                            ariaValue =  'polite';
                            break;
                        default:
                            ariaValue = 'assertive';
                    }
                    $toastElement.attr('aria-live', ariaValue);
                }

                function handleEvents() {
                    if (options.closeOnHover) {
                        $toastElement.hover(stickAround, delayedHideToast);
                    }

                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }

                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function (event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }

                            if (options.onCloseClick) {
                                options.onCloseClick(event);
                            }

                            hideToast(true);
                        });
                    }

                    if (options.onclick) {
                        $toastElement.click(function (event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }

                function displayToast() {
                    $toastElement.hide();

                    $toastElement[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                    );

                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }

                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }

                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }

                function setTitle() {
                    if (map.title) {
                        var suffix = map.title;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.title);
                        }
                        $titleElement.append(suffix).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }

                function setMessage() {
                    if (map.message) {
                        var suffix = map.message;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.message);
                        }
                        $messageElement.append(suffix).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }

                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass(options.closeClass).attr('role', 'button');
                        $toastElement.prepend($closeElement);
                    }
                }

                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass(options.progressClass);
                        $toastElement.prepend($progressElement);
                    }
                }

                function setRTL() {
                    if (options.rtl) {
                        $toastElement.addClass('rtl');
                    }
                }

                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }

                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ?
                        options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(':focus', $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function () {
                            removeToast($toastElement);
                            clearTimeout(intervalId);
                            if (options.onHidden && response.state !== 'hidden') {
                                options.onHidden();
                            }
                            response.state = 'hidden';
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }

                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }

                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing}
                    );
                }

                function updateProgress() {
                    var percentage = ((progressBar.hideEta - (new Date().getTime())) / progressBar.maxHideTime) * 100;
                    $progressElement.width(percentage + '%');
                }
            }

            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }

            function removeToast($toastElement) {
                if (!$container) { $container = getContainer(); }
                if ($toastElement.is(':visible')) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }

        })();
    });
}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
    if (typeof module !== 'undefined' && module.exports) { //Node
        module.exports = factory((typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null));
    } else {
        window.toastr = factory(window.jQuery);
    }
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":32,"punycode":22,"querystring":25}],32:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],33:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],34:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],35:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":34,"_process":21,"inherits":33}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = isByteLength;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString2.default)(str);
  var min = void 0;
  var max = void 0;
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }
  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}
module.exports = exports['default'];
},{"./util/assertString":40}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isEmail;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

var _merge = require('./util/merge');

var _merge2 = _interopRequireDefault(_merge);

var _isByteLength = require('./isByteLength');

var _isByteLength2 = _interopRequireDefault(_isByteLength);

var _isFQDN = require('./isFQDN');

var _isFQDN2 = _interopRequireDefault(_isFQDN);

var _isIP = require('./isIP');

var _isIP2 = _interopRequireDefault(_isIP);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_email_options = {
  allow_display_name: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true
};

/* eslint-disable max-len */
/* eslint-disable no-control-regex */
var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var gmailUserPart = /^[a-z\d]+$/;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/* eslint-enable max-len */
/* eslint-enable no-control-regex */

function isEmail(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_email_options);

  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(displayName);
    if (display_email) {
      str = display_email[1];
    } else if (options.require_display_name) {
      return false;
    }
  }

  var parts = str.split('@');
  var domain = parts.pop();
  var user = parts.join('@');

  var lower_domain = domain.toLowerCase();

  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
    /*
      Previously we removed dots for gmail addresses before validating.
      This was removed because it allows `multiple..dots@gmail.com`
      to be reported as valid, but it is not.
      Gmail only normalizes single dots, removing them from here is pointless,
      should be done in normalizeEmail
    */
    user = user.toLowerCase();

    // Removing sub-address from username before gmail validation
    var username = user.split('+')[0];

    // Dots are not included in gmail length restriction
    if (!(0, _isByteLength2.default)(username.replace('.', ''), { min: 6, max: 30 })) {
      return false;
    }

    var _user_parts = username.split('.');
    for (var i = 0; i < _user_parts.length; i++) {
      if (!gmailUserPart.test(_user_parts[i])) {
        return false;
      }
    }
  }

  if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 254 })) {
    return false;
  }

  if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
    if (!options.allow_ip_domain) {
      return false;
    }

    if (!(0, _isIP2.default)(domain)) {
      if (!domain.startsWith('[') || !domain.endsWith(']')) {
        return false;
      }

      var noBracketdomain = domain.substr(1, domain.length - 2);

      if (noBracketdomain.length === 0 || !(0, _isIP2.default)(noBracketdomain)) {
        return false;
      }
    }
  }

  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }

  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

  var user_parts = user.split('.');
  for (var _i = 0; _i < user_parts.length; _i++) {
    if (!pattern.test(user_parts[_i])) {
      return false;
    }
  }

  return true;
}
module.exports = exports['default'];
},{"./isByteLength":36,"./isFQDN":38,"./isIP":39,"./util/assertString":40,"./util/merge":41}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isFQDN;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

var _merge = require('./util/merge');

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false
};

function isFQDN(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_fqdn_options);

  /* Remove the optional trailing dot before checking validity */
  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }
  var parts = str.split('.');
  for (var i = 0; i < parts.length; i++) {
    if (parts[i].length > 63) {
      return false;
    }
  }
  if (options.require_tld) {
    var tld = parts.pop();
    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    }
    // disallow spaces
    if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
      return false;
    }
  }
  for (var part, _i = 0; _i < parts.length; _i++) {
    part = parts[_i];
    if (options.allow_underscores) {
      part = part.replace(/_/g, '');
    }
    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    }
    // disallow full-width chars
    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }
    if (part[0] === '-' || part[part.length - 1] === '-') {
      return false;
    }
  }
  return true;
}
module.exports = exports['default'];
},{"./util/assertString":40,"./util/merge":41}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isIP;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
var ipv6Block = /^[0-9A-F]{1,4}$/i;

function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  (0, _assertString2.default)(str);
  version = String(version);
  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  } else if (version === '4') {
    if (!ipv4Maybe.test(str)) {
      return false;
    }
    var parts = str.split('.').sort(function (a, b) {
      return a - b;
    });
    return parts[3] <= 255;
  } else if (version === '6') {
    var blocks = str.split(':');
    var foundOmissionBlock = false; // marker to indicate ::

    // At least some OS accept the last 32 bits of an IPv6 address
    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
    // and '::a.b.c.d' is deprecated, but also valid.
    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

    if (blocks.length > expectedNumberOfBlocks) {
      return false;
    }
    // initial or final ::
    if (str === '::') {
      return true;
    } else if (str.substr(0, 2) === '::') {
      blocks.shift();
      blocks.shift();
      foundOmissionBlock = true;
    } else if (str.substr(str.length - 2) === '::') {
      blocks.pop();
      blocks.pop();
      foundOmissionBlock = true;
    }

    for (var i = 0; i < blocks.length; ++i) {
      // test for a :: which can not be at the string start/end
      // since those cases have been handled above
      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
        if (foundOmissionBlock) {
          return false; // multiple :: in address
        }
        foundOmissionBlock = true;
      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
        // it has been checked before that the last
        // block is a valid IPv4 address
      } else if (!ipv6Block.test(blocks[i])) {
        return false;
      }
    }
    if (foundOmissionBlock) {
      return blocks.length >= 1;
    }
    return blocks.length === expectedNumberOfBlocks;
  }
  return false;
}
module.exports = exports['default'];
},{"./util/assertString":40}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertString;
function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    throw new TypeError('This library (validator.js) validates strings only');
  }
}
module.exports = exports['default'];
},{}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;
function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments[1];

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }
  return obj;
}
module.exports = exports['default'];
},{}],42:[function(require,module,exports){
"use strict";var getSlug=require("speakingurl"),extReg=/\.[0-9a-z]+$/;function slugFilename(e){var t=e.toLowerCase().trim();if(!extReg.test(t))return console.log("[SLUGFILENAME] impossible to slug",e),!1;var r=extReg.exec(t)[0];return t=t.replace(r,""),t=getSlug(t.trim())+r}module.exports=slugFilename;

},{"speakingurl":27}],43:[function(require,module,exports){
(function (global){
"use strict";var url=require("url"),console=require("console-browserify"),ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,templateLoader=require("./template-loader.js");require("./ko-bindings.js");var performanceAwareCaller=require("./timed-call.js").timedCall,addUndoStackExtensionMaker=require("./undomanager/undomain.js"),colorPlugin=require("./ext/color.js"),utilPlugin=require("./ext/util.js"),inlinerPlugin=require("./ext/inliner.js"),localStorageLoader=require("./ext/localstorage.js");if(void 0===ko)throw"Cannot find knockout.js library!";if(void 0===$)throw"Cannot find jquery library!";var initFromLocalStorage,start=function(e,i,t,o,n){templateLoader.fixPageEvents();var a=[function(i){e&&e.strings&&(i.t=function(t,o){var n=e.strings[t];return void 0===n&&(console.warn("Missing translation string for",t,": using default string"),n=t),i.tt(n,o)})},addUndoStackExtensionMaker(performanceAwareCaller),colorPlugin,utilPlugin,inlinerPlugin];if(void 0!==n)for(var l=0;l<n.length;l++)a.push(n[l]);a.push(function(i){var t={messages:{unknownError:i.t("Unknown error"),uploadedBytes:i.t("Uploaded bytes exceed file size"),maxNumberOfFiles:i.t("Maximum number of files exceeded"),acceptFileTypes:i.t("File type not allowed"),maxFileSize:i.t("File is too large"),minFileSize:i.t("File is too small"),post_max_size:i.t("The uploaded file exceeds the post_max_size directive in php.ini"),max_file_size:i.t("File is too big"),min_file_size:i.t("File is too small"),accept_file_types:i.t("Filetype not allowed"),max_number_of_files:i.t("Maximum number of files exceeded"),max_width:i.t("Image exceeds maximum width"),min_width:i.t("Image requires a minimum width"),max_height:i.t("Image exceeds maximum height"),min_height:i.t("Image requires a minimum height"),abort:i.t("File upload aborted"),image_resize:i.t("Failed to resize image"),generic:i.t("Unexpected upload error")}};e&&e.fileuploadConfig&&(t=$.extend(!0,t,e.fileuploadConfig)),ko.bindingHandlers.fileupload.extendOptions=t});var r=e.fileuploadConfig?e.fileuploadConfig.url:"/upload/";applyBindingOptions(e,ko),$("\x3c!-- ko template: 'main' --\x3e\x3c!-- /ko --\x3e").appendTo(global.document.body),void 0===i&&void 0!==t&&(i=t.template),templateLoader.load(performanceAwareCaller,i,t,o,a,r)},applyBindingOptions=$.noop,customExt=require("./ext/custom-extensions"),init=function(e,i){return console.info("CUSTOM MOSAICO – init"),console.log(e),!!(e&&e.metadata&&e.data)&&(customExt.extendViewModel(e,i),customExt.extendKnockout(e),start(e,void 0,e.metadata,e.data,i),!0)};module.exports={isCompatible:templateLoader.isCompatible,init:init,start:start};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ext/color.js":76,"./ext/custom-extensions":78,"./ext/inliner.js":84,"./ext/localstorage.js":85,"./ext/util.js":86,"./ko-bindings.js":87,"./template-loader.js":88,"./timed-call.js":89,"./undomanager/undomain.js":90,"console-browserify":3,"url":31}],44:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify"),addScriptTemplate=function(e,t,n){var o=e.createElement("script");return o.setAttribute("type","text/html"),o.setAttribute("id",t),o.text=n,e.body.appendChild(o),o};ko.bindingHandlers.bindIframe={tpl:'<!DOCTYPE html>\r\n<html>\r\n<head>\r\n</head>\r\n<body><div data-bind="block: content"></div></body>\r\n</html>\r\n',init:function(e,t){!function(n){try{var o=e.contentDocument;o.open(),o.write(ko.bindingHandlers.bindIframe.tpl),o.close();try{var r=o.body;if(r){for(var i=e.contentWindow.parent.document.getElementsByTagName("script"),d=0;d<i.length;d++)"text/html"==i[d].getAttribute("type")&&i[d].getAttribute("id")&&addScriptTemplate(o,i[d].getAttribute("id"),i[d].innerHTML);var a=o.getElementsByTagName("HTML");ko.utils.domNodeDisposal.addDisposeCallback(e,function(){ko.cleanNode(a[0]||r)}),ko.applyBindings(t(),a[0]||r)}else console.log("no iframedoc",n)}catch(e){throw console.log("error reading iframe.body",e,n),e}}catch(e){throw console.log("error reading iframe contentDocument",e,n),e}}("first call")}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],45:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");ko.bindingHandlers.withProperties={init:function(e,n,o,t,l){var a=l.createChildContext(l.$rawData,null,function(e){ko.utils.extend(e,n())});return ko.applyBindingsToDescendants(a,e),{controlsDescendantBindings:!0}}},ko.virtualElements.allowedBindings.withProperties=!0,ko.bindingHandlers.log={init:function(e,n,o,t,l){console.log("log",n())}},ko.bindingHandlers.block={templateExists:function(e){return!!global.document.getElementById(e)},_chooseTemplate:function(e,n,o,t){var l=n+"-"+o;if(ko.bindingHandlers.block.templateExists(l))return l;if(null!=t)return ko.bindingHandlers.block._chooseTemplate(e,n,t);var a=e?"array":"object-"+o;if(ko.bindingHandlers.block.templateExists(a))return a;throw"cannot find template for "+l+"/"+a},_displayMode:function(e,n){var o=void 0!==e.type?ko.utils.unwrapObservable(e.type):"notablock-"+typeof e,t=void 0!==e.splice,l=n.templateMode?n.templateMode:"show";return ko.bindingHandlers.block._chooseTemplate(t,o,l,n.templateModeFallback)},_makeTemplateValueAccessor:function(e,n){return function(){var o,t,l=e(),a=ko.utils.peekObservable(l);if(!a||"object"!=typeof a.data&&"function"!=typeof a.data)o=l;else if(o=a.data,void 0!==a.template){var i=ko.utils.unwrapObservable(a.template),r=n.templateMode?n.templateMode:"show";t=ko.bindingHandlers.block._chooseTemplate(!1,i,r,n.templateModeFallback)}var s=ko.utils.unwrapObservable(o);if(ko.isObservable(s)&&console.log("doubleObservable",s),void 0===t)if(void 0===o)t="empty";else try{t=ko.bindingHandlers.block._displayMode(s,n)}catch(e){throw console.log(e,s,n.$data,n.templateMode),e}return{name:t,data:o,templateEngine:ko.nativeTemplateEngine.instance}}},init:function(e,n,o,t,l){void 0===n()&&console.log("found a null block: check ending commas in arrays defs in IE");var a=ko.bindingHandlers.block._makeTemplateValueAccessor(n,l);return ko.bindingHandlers.template.init(e,a)},update:function(e,n,o,t,l){var a=ko.bindingHandlers.block._makeTemplateValueAccessor(n,l);return ko.bindingHandlers.template.update(e,a,o,t,l)}},ko.expressionRewriting.bindingRewriteValidators.block=!1,ko.virtualElements.allowedBindings.block=!0;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],46:[function(require,module,exports){
"use strict";module.exports=require("./string-template.js");

},{"./string-template.js":61}],47:[function(require,module,exports){
(function (global){
"use strict";require("evol-colorpicker");var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,kojqui="undefined"!=typeof window?window.kojqui:"undefined"!=typeof global?global.kojqui:null,ColorPicker=function(){kojqui.BindingHandler.call(this,"colorpicker")};ColorPicker.prototype=kojqui.utils.createObject(kojqui.BindingHandler.prototype),ColorPicker.prototype.constructor=ColorPicker,ColorPicker.prototype.init=function(o,e,i){var r=e(),n=r.color,l=ko.computed({read:n,write:n,disposeWhenNodeIsRemoved:o});ko.bindingHandlers.value.init(o,function(){return l},i);var t=function(o,e){void 0!==e&&l(e)};$(o).on("change.color",t),ko.computed({read:function(){var e={color:ko.utils.unwrapObservable(l),showOn:"button"};for(var i in r)"color"!==i&&r.hasOwnProperty(i)&&(e[i]=ko.utils.unwrapObservable(r[i]));$(o).colorpicker(e)},disposeWhenNodeIsRemoved:o}),ko.utils.domNodeDisposal.addDisposeCallback(o,function(){$(o).off("change.color",t),$(o).colorpicker("destroy")})},kojqui.utils.register(ColorPicker);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"evol-colorpicker":5}],48:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null;ko.bindingHandlers.cssText={update:function(e,n,t){var o=ko.utils.unwrapObservable(n());try{e.innerText=o}catch(n){e.styleSheet||(e.innerHTML="a{}"),e.styleSheet.cssText=o}}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,console=require("console-browserify");ko.bindingHandlers.focusable={focus:function(){},blur:function(){},init:function(o){ko.utils.domNodeDisposal.addDisposeCallback(o,function(){$(o).off("focusin",ko.bindingHandlers.focusable.focus),$(o).off("focusout",ko.bindingHandlers.focusable.blur)}),$(o).on("focusin",ko.bindingHandlers.focusable.focus),$(o).on("focusout",ko.bindingHandlers.focusable.blur)}},ko.bindingHandlers.scrollable={scroll:function(){},init:function(o){ko.utils.domNodeDisposal.addDisposeCallback(o,function(){$(o).off("scroll",ko.bindingHandlers.scrollable.scroll)}),$(o).on("scroll",ko.bindingHandlers.scrollable.scroll)}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],50:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null;!function(e,o){e.utils.unwrapObservable;var n=e.utils.domData.get;e.utils.domData.set,e.bindingHandlers.extdroppable={init:function(t,d,a,l,i){var s,p=o(t),r=e.utils.unwrapObservable(d())||{},u={};o.extend(!0,u,e.bindingHandlers.extdroppable),r.data?(r.options&&u.options&&(e.utils.extend(u.options,r.options),delete r.options),e.utils.extend(u,r)):u.data=r,s=u.options.drop,p.droppable(e.utils.extend(u.options,{drop:function(e,o){var t=o.draggable[0],d=n(t,"ko_sortItem")||n(t,"ko_dragItem");d&&(d.clone&&(d=d.clone()),u.dragged&&(d=u.dragged.call(this,d,e,o)||d),u.data&&u.data(d)),s&&s.apply(this,arguments)}})),void 0!==u.isEnabled&&e.computed({read:function(){p.droppable(e.utils.unwrapObservable(u.isEnabled)?"enable":"disable")},disposeWhenNodeIsRemoved:t})},update:function(e,o,n,t,d){},targetIndex:null,afterMove:null,beforeMove:null,options:{}}}(ko,$);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],51:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null;ko.extenders.paging=function(e,n){var t=ko.observable(n||10),o=ko.observable(1);return e.pageSize=ko.computed({read:t,write:function(e){t(e>0?e:10)}}),e.currentPage=ko.computed({read:o,write:function(n){n>e.pageCount()?o(e.pageCount()):o(n<=0?1:n)}}),e.pageCount=ko.computed(function(){return Math.ceil(e().length/e.pageSize())||1}),e.currentPageData=ko.computed(function(){var n=t(),r=o(),u=n*(r-1),a=n*r;return e().slice(u,a)}),e.moveFirst=function(){e.currentPage(1)},e.movePrevious=function(){e.currentPage(e.currentPage()-1)},e.moveNext=function(){e.currentPage(e.currentPage()+1)},e.moveLast=function(){e.currentPage(e.pageCount())},e};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],52:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,sortable="undefined"!=typeof window?window.jQuery.ui.sortable:"undefined"!=typeof global?global.jQuery.ui.sortable:null,draggable="undefined"!=typeof window?window.jQuery.ui.draggable:"undefined"!=typeof global?global.jQuery.ui.draggable:null,console=require("console-browserify");if(require("knockout-sortable"),void 0===sortable)throw"Cannot find jquery-ui sortable widget dependency!";if(void 0===draggable)throw"Cannot find jquery-ui sortable widget dependency!";var isDraggingHelper=function(e,n){e()?n.type==e()+"stop"&&e(!1):"dragstart"!=n.type&&"sortstart"!=n.type||e(n.type.substring(0,4))},makeExtendedValueAccessor=function(e){return function(){var n=e();ko.utils.peekObservable(n);ko.utils.unwrapObservable(n),"undefined"==n.options&&(n.options={});var o=n.options.start;n.options.start=function(e,r){if(void 0!==n.dragging&&ko.isWritableObservable(n.dragging)&&isDraggingHelper(n.dragging,e),void 0!==n.dropContainer&&(n.scrollInterval=global.setInterval(function(){var e=$(n.dropContainer).scrollTop();$(n.dropContainer).scrollTop(e+n.adding)},20)),void 0!==o)return o(e,r)};var r=n.options.stop;n.options.stop=function(e,o){if(void 0!==n.dragging&&ko.isWritableObservable(n.dragging)&&isDraggingHelper(n.dragging,e),void 0!==n.dropContainer&&global.clearInterval(n.scrollInterval),void 0!==r)return r(e,o)};var i=n.options.drag;return n.options.drag=function(e,o){if(void 0!==n.dropContainer){var r=e.pageY-$(n.dropContainer).offset().top,t=r-$(n.dropContainer).height();n.adding=r<-20?-20:r<0?-10:r<10?-5:t>20?20:t>0?10:t>-10?5:0}if(void 0!==i)return i(e,o)},n}};ko.bindingHandlers.extsortable={init:function(e,n,o,r,i){return ko.bindingHandlers.sortable.init(e,makeExtendedValueAccessor(n),o,r,i)},update:function(e,n,o,r,i){return ko.bindingHandlers.sortable.update(e,makeExtendedValueAccessor(n),o,r,i)}},ko.bindingHandlers.extdraggable={init:function(e,n,o,r,i){return ko.bindingHandlers.draggable.init(e,makeExtendedValueAccessor(n),o,r,i)},update:function(e,n,o,r,i){return ko.bindingHandlers.draggable.update(e,makeExtendedValueAccessor(n),o,r,i)}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3,"knockout-sortable":11}],53:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");ko.bindingHandlers.fudroppable={init:function(e,i){var o=i()||{},l={},r=function(e,i,o,l,r,a){e[i]?global.clearTimeout(e[i]):(void 0!==l&&o.classList.add(l),ko.isWriteableObservable(r)&&!r()&&r(!0));var n=function(){e[i]=null,void 0!==l&&o.classList.remove(l),ko.isWriteableObservable(r)&&r()&&r(!1)};"dragleave"==a.type?n():e[i]=global.setTimeout(n,500)};(o.active||o.activeClass)&&ko.utils.registerEventHandler(global,"dragover",r.bind(void 0,l,"activeTimeout",e,o.activeClass,o.active)),o.hoverClass&&ko.utils.registerEventHandler(e,"dragover dragenter dragleave",r.bind(void 0,l,"hoverTimeout",e,o.hoverClass,void 0))}},ko.bindingHandlers.fileupload={extendOptions:{},init:function(e,i){ko.utils.domNodeDisposal.addDisposeCallback(e,function(){$(e).fileupload("destroy")}),!("WebkitAppearance"in global.document.documentElement.style)||"webkitNbspMode"in global.document.documentElement.style||"StyleMedia"in global?$(e).attr("title",""):$(e).attr("title"," ")},update:function(e,i){var o=i()||{},l=$(e),r=l.parents(".uploadzone"),a=o.data;o.data=void 0;var n=o.canvasPreview;ko.utils.extend(o,{url:"/upload/",dataType:"json",dropZone:r.find(".mo-uploadzone")[0],autoUpload:!0,acceptFileTypes:/(\.|\/)(gif|jpe?g|png)$/i,maxFileSize:1048576,disableImageResize:/Android(?!.*Chrome)|Opera/.test(global.navigator.userAgent),previewMaxWidth:200,previewMaxHeight:200,previewCrop:!1,replaceFileInput:!1,messages:{unknownError:"Unknown error",uploadedBytes:"Uploaded bytes exceed file size",maxNumberOfFiles:"Maximum number of files exceeded",acceptFileTypes:"File type not allowed",maxFileSize:"File is too large",minFileSize:"File is too small",post_max_size:"The uploaded file exceeds the post_max_size directive in php.ini",max_file_size:"File is too big",min_file_size:"File is too small",accept_file_types:"Filetype not allowed",max_number_of_files:"Maximum number of files exceeded",max_width:"Image exceeds maximum width",min_width:"Image requires a minimum width",max_height:"Image exceeds maximum height",min_height:"Image requires a minimum height",abort:"File upload aborted",image_resize:"Failed to resize image",generic:"Unexpected upload error"}}),ko.utils.extend(o,ko.bindingHandlers.fileupload.extendOptions);var s=0,t="",d=function(){0==--s&&(a&&a(t),t="",n&&(r.find("img").show(),r.find("canvas").remove()),r.removeClass("uploading"),r.find(".progress-bar").css("width",0))},u=function(e){if("object"==typeof o.messages&&null!==o.messages){var i=e.match(/^([^ ]+)(.*)$/);if(i&&void 0!==o.messages[i[1]])return o.messages[i[1]]+i[2]}return e};o.uploadToTemplate?o.url=ko.bindingHandlers.fileupload.extendOptions.url.template:o.url=ko.bindingHandlers.fileupload.extendOptions.url.mailing,l.fileupload(o);for(var p=["fileuploadadd","fileuploadprocessalways","fileuploadprogressall","fileuploaddone","fileuploadfail"],f=function(e,i){if("fileuploadadd"==e.type&&s++,"fileuploadfail"==e.type&&(console.log("fileuploadfail",e,i),o.onerror&&(""===i.errorThrown&&"error"==i.textStatus?o.onerror(u("generic")):o.onerror(u("generic ("+i.errorThrown+")"))),d()),"fileuploaddone"==e.type)if(void 0!==i.result.files[0].url){if(o.onfile)for(var l=0;l<i.result.files.length;l++)i.result.files[l]=ko.bindingHandlers.fileupload.remoteFilePreprocessor(i.result.files[l]),o.onfile(i.result.files[l]);if(""===t&&(t=i.result.files[0].url),n){var a=new Image;a.onload=d,a.onerror=d,a.src=i.result.files[0].url}else d()}else void 0!==i.result.files[0].error?(console.log("remote error",e,i),o.onerror&&o.onerror(u(i.result.files[0].error)),d()):(console.log("unexpected error",e,i),o.onerror&&o.onerror(u("generic (Unexpected Error retrieving uploaded file)")),d());if("fileuploadprocessalways"==e.type){var p=i.index,f=i.files[p];if(f.preview&&0===p&&0===r.find("canvas").length){if(n){var m=$(f.preview).css("width","100%");r.find("img").hide(),r.prepend(m)}r.addClass("uploading"),r.find(".progress-bar").css("width",0)}f.error&&(o.onerror&&o.onerror(u(f.error)),d())}if("fileuploadprogressall"==e.type){var g=parseInt(i.loaded/i.total*100,10);r.find(".progress-bar").css("width",g+"%")}},m=p.length-1;m>=0;m--){var g=p[m];l.on(g,f)}$.support.fileInput||l.prop("disabled",!0).parent().addClass("disabled")}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],54:[function(require,module,exports){
(function (global){
"use strict";var beforeSubscriptionProp,afterSubscriptionProp,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");if(ko.bindingHandlers.ifSubs={cloneNodes:function(o,e){for(var i=0,n=o.length,r=[];i<n;i++){var s=o[i].cloneNode(!0);r.push(e?ko.cleanNode(s):s)}return r},init:function(o,e,i,n,r){var s,t,u=e();return void 0===u.data.subsCount&&ko.extenders.subscriptionsCount(u.data),ko.computed(function(){var i,n,b=ko.utils.unwrapObservable(e().data.subsCount),p=!t;n=-(void 0!==e().gutter?e().gutter:1),i=b+(s?n:0)>=ko.utils.unwrapObservable(u.threshold),void 0!==e().not&&e().not&&(i=!i),(p||i!==s)&&(p&&ko.computedContext.getDependenciesCount()&&(t=ko.bindingHandlers.ifSubs.cloneNodes(ko.virtualElements.childNodes(o),!0)),i?(p||ko.virtualElements.setDomNodeChildren(o,ko.bindingHandlers.ifSubs.cloneNodes(t)),ko.applyBindingsToDescendants(r,o)):ko.virtualElements.emptyNode(o),s=i)},null,{disposeWhenNodeIsRemoved:o}),{controlsDescendantBindings:!0}}},ko.virtualElements.allowedBindings.ifSubs=!0,"function"==typeof ko.subscription&&void 0!==ko.isWritableObservable)beforeSubscriptionProp="beforeSubscriptionAdd",afterSubscriptionProp="afterSubscriptionRemove";else if("3.2.0"==ko.version)beforeSubscriptionProp="va",afterSubscriptionProp="nb";else if("3.3.0"==ko.version)beforeSubscriptionProp="ja",afterSubscriptionProp="ua";else if("3.4.0"==ko.version)beforeSubscriptionProp="sa",afterSubscriptionProp="Ia";else if("3.4.1"==ko.version)beforeSubscriptionProp="sa",afterSubscriptionProp="Ia";else if("3.4.2"==ko.version)beforeSubscriptionProp="ua",afterSubscriptionProp="Ka";else{if("3.5.0-beta"!=ko.version)throw"Unsupported minimized Knockout version "+ko.version+" (supported DEBUG or minimized 3.2.0 ... 3.5.0-beta)";beforeSubscriptionProp="Pa",afterSubscriptionProp="ab"}ko.extenders.subscriptionsCount=function(o,e,i){if(void 0===o.subsCount){o.subsCount=ko.observable(o.getSubscriptionsCount()).extend({notify:"always"});var n=o[beforeSubscriptionProp],r=o[afterSubscriptionProp];o[beforeSubscriptionProp]=function(r){n&&n.call(o,r);var s=o.getSubscriptionsCount()+1;void 0!==e&&s!=e&&void 0!==i&&s!=i||o.subsCount(s)},o[afterSubscriptionProp]=function(n){r&&r.call(o,n);var s=o.getSubscriptionsCount();void 0!==e&&s!=e&&void 0!==i&&s!=i||o.subsCount(s)}}else console.log("already applied subscriptionCount to observable");return null};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],55:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,spinner="undefined"!=typeof window?window.jQuery.ui.spinner:"undefined"!=typeof global?global.jQuery.ui.spinner:null,console=require("console-browserify");if(void 0===spinner)throw"Cannot find jquery-ui spinner widget dependency!";$.widget("ui.spinner",spinner,{_adjustValue:function(n){this._super(n);var e=this.options;return n=parseFloat(n.toFixed(this._precision())),null!==e.max&&n>e.max?e.max:null!==e.min&&n<e.min?e.min:n}});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],56:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,console=require("console-browserify"),tabs="undefined"!=typeof window?window.jQuery.ui.tabs:"undefined"!=typeof global?global.jQuery.ui.tabs:null;if(void 0===tabs)throw"Cannot find jquery-ui tabs widget dependency!";$.widget("ui.tabs",tabs,{_isLocal:function(e){return"true"==e.getAttribute("data-local")||this._superApply(arguments)}});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],57:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null;ko.bindingHandlers.preloader={init:function(e,o){var d=o();if(void 0===d.preloaded){d.preloaded=ko.observable("");var n=function(e){if(e!=d.preloaded())if(""!==e){var o=new Image;o.onload=function(){d.preloaded(e)},o.onerror=function(){d.preloaded(e)},o.src=e}else d.preloaded(e)};d.subscribe(n),n(d())}}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],58:[function(require,module,exports){
(function (global){
"use strict";function pushTemplate(e,t){var n=global.document.createElement("script");n.setAttribute("type","text/html"),n.setAttribute("id",e),n.text=t,global.document.body.appendChild(n)}function removeTemplate(e){var t=global.document.getElementById(e);t&&t.parentNode.removeChild(t)}function init(){}function getTemplateContent(e){var t=global.document.getElementById(e);return t?t.innerHTML:void 0}module.exports={init:init,addTemplate:pushTemplate,removeTemplate:removeTemplate,getTemplateContent:getTemplateContent};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
(function (global){
"use strict";var timeout,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,console=require("console-browserify"),tinymce="undefined"!=typeof window?window.tinymce:"undefined"!=typeof global?global.tinymce:null,render=function(){if(timeout=void 0,void 0!==tinymce.activeEditor&&null!==tinymce.activeEditor&&void 0!==tinymce.activeEditor.theme&&null!==tinymce.activeEditor.theme&&void 0!==tinymce.activeEditor.theme.panel&&null!==tinymce.activeEditor.theme.panel){(void 0!==tinymce.activeEditor.theme.panel._visible&&tinymce.activeEditor.theme.panel._visible&&tinymce.activeEditor.theme.panel._fixed||void 0!==tinymce.activeEditor.theme.panel.state&&tinymce.activeEditor.theme.panel.state.get("visible")&&tinymce.activeEditor.theme.panel.state.get("fixed"))&&tinymce.activeEditor.theme.panel.fixed(!1);var e=void 0!==tinymce.activeEditor.bodyElement?tinymce.activeEditor.bodyElement:tinymce.activeEditor.dom.settings.root_element;null!==e&&void 0!==e.classList&&e.classList.contains("mce-edit-focus")&&(tinymce.activeEditor.nodeChanged(),tinymce.activeEditor.theme.panel.visible(!0),tinymce.activeEditor.theme.panel.layoutRect().y<=40&&tinymce.activeEditor.theme.panel.moveBy(0,40-tinymce.activeEditor.theme.panel.layoutRect().y))}};ko.bindingHandlers.wysiwygScrollfix={scroll:function(e){timeout&&global.clearTimeout(timeout),timeout=global.setTimeout(render,50)},init:function(e){ko.utils.domNodeDisposal.addDisposeCallback(e,function(){$(e).off("scroll",ko.bindingHandlers.wysiwygScrollfix.scroll)}),$(e).on("scroll",ko.bindingHandlers.wysiwygScrollfix.scroll)}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],60:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify"),_scrollIntoView=function(o,e,l,n){var i=l.scrollTop(),t=i-n-(e?20:-20);if(void 0!==l[0].nodeType){var r={scrollTop:Math.round(t)+"px"},s=Math.round(Math.abs(t-i));l.stop().animate(r,s)}else l.scrollTop(t)};ko.bindingHandlers.scrollIntoView={update:function(o,e,l,n,i){if(ko.utils.unwrapObservable(e()))try{for(;8===o.nodeType;)o=o.nextSibling;if(8!==o.nodeType){var t,r=$(o).scrollParent(),s=!1;9==r[0].nodeType?(r=$(r[0].defaultView),t=0,s=!0):t=r.offset().top;var a=r.height(),d=r.scrollTop(),c=t+a,f=$(o),w=f.offset().top;s&&(w-=d);var p=f.height(),u=w+p;w>t&&w+p<c||(p<a?(w<t&&_scrollIntoView(o,!0,r,t-w),u>c&&_scrollIntoView(o,!1,r,c-u)):(w<t&&u<c&&_scrollIntoView(o,!1,r,c-u),w>t&&u>c&&_scrollIntoView(o,!0,r,t-w)))}}catch(o){console.log("TODO exception scrolling into view",o)}}},ko.virtualElements.allowedBindings.scrollIntoView=!0;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],61:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,origTemplateSystem=require("./script-template.js"),templates={};function createStringTemplateEngine(e){var t=e.makeTemplateSource;return e.makeTemplateSource=function(e){return void 0!==templates[e]?new ko.templateSources.stringTemplate(e,templates[e]):t(e)},e}function pushTemplate(e,t){templates[e]=t}function removeTemplate(e){void 0!==templates[e]?templates[e]=void 0:origTemplateSystem.removeTemplate(e)}function init(){ko.setTemplateEngine(createStringTemplateEngine(new ko.nativeTemplateEngine))}function getTemplateContent(e){return void 0!==templates[e]?templates[e]:origTemplateSystem.getTemplateContent(e)}ko.templateSources.stringTemplate=function(e,t){this.templateName=e,this.template=t,this._data={}},ko.utils.extend(ko.templateSources.stringTemplate.prototype,{data:function(e,t){if(1===arguments.length)return this._data[e];this._data[e]=t},text:function(e){if(0===arguments.length)return this.template;this.template=e}}),module.exports={init:init,addTemplate:pushTemplate,removeTemplate:removeTemplate,getTemplateContent:getTemplateContent};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./script-template.js":58}],62:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,kojqui="undefined"!=typeof window?window.kojqui:"undefined"!=typeof global?global.kojqui:null,console=require("console-browserify"),extendValueAccessor=function(o,n){return function(){return ko.utils.extend(n,o()),n}},options={show:{delay:500},track:!0,items:'[title][title!=""][title!=" "]'};ko.bindingHandlers.tooltips={init:function(o,n,i,e,t){if(void 0!==$.fn.tooltip&&void 0!==ko.bindingHandlers.tooltip)return ko.bindingHandlers.tooltip.init(o,extendValueAccessor(n,options),i,e,t)},update:function(o,n,i,e,t){if(void 0!==$.fn.tooltip&&void 0!==ko.bindingHandlers.tooltip)return ko.bindingHandlers.tooltip.update(o,extendValueAccessor(n,options),i,e,t)}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],63:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");ko.bindingHandlers.validatedValue={init:function(e,n,i){var o=n;if(void 0!==e.pattern){var t=new RegExp("^(?:"+e.pattern+")$"),a=ko.computed({read:function(){var i=ko.utils.unwrapObservable(n());return null===i||""===i||t.test(i)?e.classList.remove("invalid"):e.classList.add("invalid"),i},write:ko.isWriteableObservable(n())&&function(i){ko.selectExtensions.writeValue(e,i);var o=ko.selectExtensions.readValue(e);n()(o)},disposeWhenNodeIsRemoved:e});o=function(){return a}}ko.bindingHandlers.value.init(e,o,i)}},ko.expressionRewriting._twoWayBindings.validatedValue=!0;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],64:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");ko.bindingHandlers.uniqueId={currentIndex:0,init:function(e,n){var t=ko.utils.unwrapObservable(n())||{};if(""===t.id()){var i,l,r;r="ko_"+(void 0!==t.type?ko.utils.unwrapObservable(t.type):"block");do{i=r+"_"+ ++ko.bindingHandlers.uniqueId.currentIndex,l=global.document.getElementById(i)}while(l);t.id(i)}}},ko.virtualElements.allowedBindings.uniqueId=!0,ko.bindingHandlers.virtualAttr={update:function(e,n){8!==e.nodeType&&ko.bindingHandlers.attr.update(e,n)}},ko.virtualElements.allowedBindings.virtualAttr=!0,ko.bindingHandlers.virtualAttrStyle={update:function(e,n,t,i,l){if(8!==e.nodeType){var r=["style"];(void 0===l.templateMode||"wysiwyg"!=l.templateMode)&&r.push("replacedstyle");for(var o=ko.utils.unwrapObservable(n()),d=0;d<r.length;d++){var a=r[d];!1===o||null==o?e.removeAttribute(a):e.setAttribute(a,o.toString())}}}},ko.virtualElements.allowedBindings.virtualAttrStyle=!0,ko.bindingHandlers.virtualStyle={update:function(e,n){8!==e.nodeType&&ko.bindingHandlers.style.update(e,n)}},ko.virtualElements.allowedBindings.virtualStyle=!0,ko.bindingHandlers.virtualHtml={init:ko.bindingHandlers.html.init,update:function(e,n){if(8===e.nodeType){var t=ko.utils.unwrapObservable(n());if(ko.virtualElements.emptyNode(e),null!=t){"string"!=typeof t&&(t=t.toString());var i=ko.utils.parseHtmlFragment(t);if(i)for(var l=e.nextSibling,r=0,o=i.length;r<o;r++)l.parentNode.insertBefore(i[r],l)}}else ko.bindingHandlers.html.update(e,n);return{controlsDescendantBindings:!0}}},ko.virtualElements.allowedBindings.virtualHtml=!0;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],65:[function(require,module,exports){
(function (global){
"use strict";var tinymce="undefined"!=typeof window?window.tinymce:"undefined"!=typeof global?global.tinymce:null,$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");require("./eventable.js"),ko.bindingHandlers.wysiwygOrHtml={init:function(e,i,n,t,o){return void 0===o.templateMode||"wysiwyg"!=o.templateMode?ko.bindingHandlers.virtualHtml.init():ko.bindingHandlers.wysiwyg.init(e,i,n,t,o)},update:function(e,i,n,t,o){if(void 0===o.templateMode||"wysiwyg"!=o.templateMode)return ko.bindingHandlers.virtualHtml.update(e,i,n,t,o)}},ko.virtualElements.allowedBindings.wysiwygOrHtml=!0,ko.bindingHandlers.wysiwygHref={init:function(e,i,n,t,o){if(8!==e.nodeType){i();if(void 0===o.templateMode||"wysiwyg"!=o.templateMode)e.setAttribute("target","_new");else void 0!==n().wysiwygOrHtml?e.setAttribute("href","javascript:void(0)"):(e.removeAttribute("href"),e.setAttribute("disabledhref","#"))}},update:function(e,i,n,t,o){if(8!==e.nodeType){var l=void 0===o.templateMode||"wysiwyg"!=o.templateMode,s=ko.utils.unwrapObservable(i());l&&(!1===s||null==s?e.removeAttribute("href"):e.setAttribute("href",s.toString()))}}},ko.virtualElements.allowedBindings.wysiwygHref=!0,ko.bindingHandlers.wysiwygSrc={convertedUrl:function(e,i,n,t){var o=-1==e.indexOf("?")?"?":"&";return e+o+"method="+i+"&width="+n+(null!==t?"&height="+t:"")},placeholderUrl:function(e,i,n){},update:function(e,i,n,t,o){var l=ko.utils.unwrapObservable(i()),s=ko.utils.unwrapObservable(l.src),r=ko.utils.unwrapObservable(l.placeholder),a=ko.utils.unwrapObservable(l.width),d=ko.utils.unwrapObservable(l.height);if(!1===s||null==s||""===s)"object"==typeof r&&null!==r?e.setAttribute("src",ko.bindingHandlers.wysiwygSrc.placeholderUrl(r.width,r.height,r.text)):e.removeAttribute("src");else{var g=ko.utils.unwrapObservable(l.method);g||(g=a>0&&d>0?"cover":"resize");var u=ko.bindingHandlers.wysiwygSrc.convertedUrl(s.toString(),g,a,d);e.setAttribute("src",u)}null!=a?e.setAttribute("width",a):e.removeAttribute("width"),null!=d?e.setAttribute("height",d):e.removeAttribute("height")}},ko.bindingHandlers.wysiwygId={init:function(e,i,n,t,o){void 0===o.templateMode||"wysiwyg"!=o.templateMode||e.setAttribute("id",ko.utils.unwrapObservable(i()))},update:function(e,i,n,t,o){void 0===o.templateMode||"wysiwyg"!=o.templateMode||e.setAttribute("id",ko.utils.unwrapObservable(i()))}},ko.virtualElements.allowedBindings.wysiwygId=!0,ko.bindingHandlers.wysiwygClick={init:function(e,i,n,t,o){void 0===o.templateMode||"wysiwyg"!=o.templateMode||ko.bindingHandlers.click.init(e,i,n,t,o)}},ko.virtualElements.allowedBindings.wysiwygClick=!0,ko.bindingHandlers.wysiwygCss={update:function(e,i,n,t,o){void 0===o.templateMode||"wysiwyg"!=o.templateMode||ko.bindingHandlers.css.update(e,i,n,t,o)}},ko.virtualElements.allowedBindings.wysiwygCss=!0,ko.bindingHandlers.wysiwygImg={makeTemplateValueAccessor:function(e,i){return function(){var n=void 0!==i.templateMode&&"wysiwyg"==i.templateMode,t=e(),o=ko.utils.peekObservable(t);return ko.utils.unwrapObservable(t),{name:n?o._editTemplate:o._template,templateEngine:ko.nativeTemplateEngine.instance}}},init:function(e,i,n,t,o){return ko.bindingHandlers.template.init(e,ko.bindingHandlers.wysiwygImg.makeTemplateValueAccessor(i,o))},update:function(e,i,n,t,o){return o=o.extend(i()),ko.bindingHandlers.template.update(e,ko.bindingHandlers.wysiwygImg.makeTemplateValueAccessor(i,o),n,t,o)}},ko.virtualElements.allowedBindings.wysiwygImg=!0;var _catchingFire=function(e,i){try{return this.originalFire.apply(this,arguments)}catch(i){console.warn("Cought tinymce exception while firing editor event",e,i)}};ko.bindingHandlers.wysiwyg={debug:!1,getContentOptions:{format:"raw"},useTarget:!1,currentIndex:0,standardOptions:{},initializingClass:"wysiwyg-loading",removeSelectionOnBlur:!0,emptyClass:void 0,fullOptions:{toolbar1:"bold italic forecolor backcolor hr styleselect removeformat | link unlink | pastetext code",plugins:["link hr paste lists textcolor code"]},init:function(e,i,n,t,o){ko.bindingHandlers.focusable.init(e);var l,s=ko.bindingHandlers.wysiwyg.debug&&"function"==typeof console.debug;ko.bindingHandlers.wysiwyg.useTarget?l="@target_"+ ++ko.bindingHandlers.wysiwyg.currentIndex:(l=e.getAttribute("id"))||(l="wysiwyg_"+ ++ko.bindingHandlers.wysiwyg.currentIndex,e.setAttribute("id",l)),ko.bindingHandlers.wysiwyg.initializingClass&&e.classList.add(ko.bindingHandlers.wysiwyg.initializingClass),ko.utils.domNodeDisposal.addDisposeCallback(e,function(){s&&console.debug("Editor for selector",l,"is being removed..."),tinymce.remove("#"+e.getAttribute("id")),s&&console.debug("Editor for selector",l,"has been removed.")});var r=i();if(!ko.isObservable(r))throw"Wysiwyg binding called with non observable";if(8===e.nodeType)throw"Wysiwyg binding called on virtual node, ignoring...."+e.innerHTML;var a,d="DIV"==e.tagName||"TD"==e.tagName,g=!1,u=!1,w={inline:!0,hidden_input:!1,plugins:["paste"],toolbar1:"bold italic",toolbar2:"",preview_styles:!1,paste_as_text:!0,language:"en",schema:"html5",extended_valid_elements:"strong/b,em/i,*[*]",menubar:!1,skin:"gray-flat",forced_root_block:d?"p":"",init_instance_callback:function(i){if(s&&console.debug("Editor for selector",l,"is now initialized."),ko.bindingHandlers.wysiwyg.initializingClass&&e.classList.remove(ko.bindingHandlers.wysiwyg.initializingClass),"function"==typeof console.debug){var n=e.currentStyle?e.currentStyle.display:global.getComputedStyle(e,null).display;"inline"==n&&console.debug("Initializing an editor on an inline element: please note that while it may work, this is unsupported because of a multitude of browser issues",e.tagName,n,l)}},setup:function(i){s&&console.debug("Editor for selector",l,"is now in the setup phase.");var n=function(){0==(e.textContent||e.innerText||"").trim().length?e.classList.add(ko.bindingHandlers.wysiwyg.emptyClass):e.classList.remove(ko.bindingHandlers.wysiwyg.emptyClass)};i.on("change redo undo",function(){if(!g)try{u=!0,r(i.getContent(ko.bindingHandlers.wysiwyg.getContentOptions))}catch(e){console.warn("Unexpected error setting content value for",l,e)}finally{u=!1}ko.bindingHandlers.wysiwyg.emptyClass&&n()}),ko.bindingHandlers.wysiwyg.emptyClass&&i.on("keyup",function(){n()}),i.on("focus",function(){i.nodeChanged(),i.getElement().click()}),ko.bindingHandlers.wysiwyg.removeSelectionOnBlur&&i.on("blur",function(e){global.getSelection().removeAllRanges()}),i.on("BeforeSetContent",function(e){e.initial&&(e.format="raw")}),void 0===i.originalFire&&(i.originalFire=i.fire,i.fire=_catchingFire),a=i}};return ko.bindingHandlers.wysiwyg.useTarget?w.target=e:w.selector="#"+l,ko.utils.extend(w,ko.bindingHandlers.wysiwyg.standardOptions),d&&ko.utils.extend(w,ko.bindingHandlers.wysiwyg.fullOptions),global.setTimeout(function(){s&&console.debug("Editor for selector",l,"is being inizialized ...");var e=tinymce.init(w);s&&console.debug("Editor for selector",l,"init has just been called returning",e),e.then(function(){s&&console.debug("Editor for selector",l,"init promise has resolved.")},function(e){console.log("Editor for selector",l,"init promise has failed.",e)})}),ko.computed(function(){var n=ko.utils.unwrapObservable(i());if(!u){try{g=!0,void 0!==a?a.setContent(n,{format:"raw"}):ko.utils.setHtml(e,n)}catch(e){console.warn("Exception setting content to editable element",typeof a,e)}g=!1}},null,{disposeWhenNodeIsRemoved:e}),{controlsDescendantBindings:!0}}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./eventable.js":49,"console-browserify":3}],66:[function(require,module,exports){
"use strict";var console=require("console-browserify"),checkModel=function(e,o,t,n,l){var i,f,r,a=0;if(void 0===l&&(l=!1),void 0!==o&&"function"==typeof o.splice)for(i={},f=0;f<o.length;f++)i[o[f].type]=o[f];else i=o;for(var p in e)if(e.hasOwnProperty(p))if(r=void 0!==n?n+"."+p:p,t.hasOwnProperty(p))if(typeof t[p]!=typeof e[p])null!==t[p]&&null!==e[p]&&("string"==typeof t[p]?String(e[p])!=e[p]&&(console.log("TODO Different type 1 ",r,typeof t[p],typeof e[p],t[p],e[p]),a=Math.max(a,2)):"number"==typeof t[p]?Number(e[p])!=e[p]&&(console.log("TODO Different type 2 ",r,typeof t[p],typeof e[p],t[p],e[p]),a=Math.max(a,2)):(console.log("TODO Different type 3 ",r,typeof t[p],typeof e[p],t[p],e[p]),a=Math.max(a,2)));else if("object"==typeof e[p])if(null!==e[p])if(void 0!==e[p].splice){if(e[p].length>0)if(t[p].length>0){var c=0;for(f=0;f<t[p].length;f++)if("string"==typeof t[p][f].type){for(;c<e[p].length&&e[p][c].type!==t[p][f].type;)console.log("ignoring ",r,e[p][c].type," block type in reference not found in model"),c++;if(c>=e[p].length){console.log("WARN cannot find ",r,t[p][f].type," block in reference"),a=Math.max(a,2);break}a=Math.max(a,checkModel(e[p][c],void 0,t[p][f],r+"["+f+"."+t[p][f].type+"]"))}}else for(f=0;f<e[p].length;f++)"string"!=typeof e[p][f].type?(console.log("TODO found an object with no type",r,e[p][f]),a=Math.max(a,2)):i.hasOwnProperty(e[p][f].type)?a=Math.max(a,checkModel(i[e[p][f].type],i,e[p][f],r+"["+f+"."+e[p][f].type+"]")):(console.warn("TODO the model uses a block type not defined by the template. REMOVING IT!!",r,e[p][f]),e[p].splice(f,1),f--,a=Math.max(a,2))}else null===t[p]?l?(console.log("WARN Null object in model ",r,"instead of",e[p],"deleting it"),a=Math.max(a,2),delete e[p]):(console.log("INFO Null object in model ",r,"instead of",e[p],"cloning it from the reference"),a=Math.max(a,1),t[p]=e[p]):a=Math.max(a,checkModel(e[p],i,t[p],r,l));else null!==t[p]&&(console.log("TODO Null in reference but not null in model",r,t[p]),a=Math.max(a,2));else"string"!=typeof e[p]&&"boolean"!=typeof e[p]&&"number"!=typeof e[p]&&(console.log("TODO unsupported type",r,typeof e[p]),a=Math.max(a,2));else l?(console.warn("WARN Property ",r,"found in model is not defined by template: removing it!"),a=Math.max(a,2),delete e[p]):(console.log("INFO Property ",r,"missing in model, cloning from reference!"),a=Math.max(a,1),t[p]=e[p]);return l||(a=Math.max(a,checkModel(t,o,e,void 0!==n?n+"!R":"!R",!0))),a};module.exports=checkModel;

},{"console-browserify":3}],67:[function(require,module,exports){
"use strict";var converterUtils=require("./utils.js"),cssParse=require("mensch/lib/parser.js"),console=require("console-browserify"),domutils=require("./domutils.js"),_declarationValueLookup=function(e,t,r){for(var l=e.length-1;l>=0;l--)if("property"==e[l].type&&e[l].name==t)return _declarationValueUrlPrefixer(e[l].value,r);return null},_propToCamelCase=function(e){return e.replace(/-([a-z])/g,function(e,t,r,l){return t.toUpperCase()})},_declarationValueUrlPrefixer=function(e,t){return e.match(/url\(.*\)/)?e.replace(/(url\()([^\)]*)(\))/g,function(e,r,l,i){var n=l.trim(),o=l.trim().charAt(0);"'"==o||'"'==o?n=n.substr(1,n.length-2):o="";var a=t(n);return null!==a?r+o+a+o+i:e}):e},elaborateDeclarations=function(e,t,r,l,i,n,o){var a="object"==typeof n&&null!==n?n:{},u=null,s=0;void 0===t&&(t=cssParse("#{\n"+e+"}",{comments:!0,position:!0}).stylesheet.rules[0].declarations,s=1);for(var v=t.length-1;v>=0;v--)if("property"==t[v].type)if(!0===o&&"display"==t[v].name&&"none"==t[v].value)null===u&&(u=e),u=converterUtils.removeStyle(u,t[v].position.start,t[v].position.end,s,0,0,"");else{var d=t[v].name.match(/^-ko-(bind-|attr-)?([a-z0-9-]*?)(-if|-ifnot)?$/);if(null!==d){null===u&&void 0!==e&&(u=e);var c,f,p,m="attr-"==d[1],y="bind-"==d[1],h=d[2],b="-if"==d[3]||"-ifnot"==d[3];if(b){if(c=t[v].name.substr(0,t[v].name.length-d[3].length),null===_declarationValueLookup(t,c,r))throw"Unable to find declaration "+c+" for "+t[v].name}else{if((m||y)&&void 0===i&&void 0!==e)throw"Attributes and bind declarations are only allowed in inline styles!";var S,g=!0;if(m?(p=domutils.getAttribute(i,h),g=!1,S="virtualAttr"):y?(S=null,"text"==h?void 0!==i?p=domutils.getInnerText(i):g=!1:"html"==h&&void 0!==i?p=domutils.getInnerHtml(i):g=!1):((g=void 0!==e)&&(p=_declarationValueLookup(t,h,r)),S="virtualStyle"),g&&null===p)throw console.error("Cannot find default value for",t[v].name,t),"Cannot find default value for "+t[v].name+": "+t[v].value+" in "+i+" ("+typeof e+"/"+h+")";var w=p,U=y||m?-1!=h.indexOf("-")?"'"+h+"'":h:_propToCamelCase(h);try{f=converterUtils.expressionBinding(t[v].value,l,w)}catch(e){throw console.error("Model ensure path failed",e.stack,"name",t[v].name,"value",t[v].value,"default",p,"element",i),e}null!==S&&void 0===a[S]&&(a[S]={}),"virtualAttr"==S&&"href"==U&&(S=null,U="wysiwygHref",null!=i&&domutils.removeAttribute(i,"href"));var x=_declarationValueLookup(t,t[v].name+"-if",r),_=!1;if(null===x)x=_declarationValueLookup(t,t[v].name+"-ifnot",r),_=!0;else if(null!==_declarationValueLookup(t,t[v].name+"-ifnot",r))throw"Unexpected error: cannot use both -if and -ifnot property conditions";if(null!==x)try{f=(_?"!":"")+"("+converterUtils.conditionBinding(x,l)+") ? "+f+" : null"}catch(e){throw console.error("Unable to deal with -ko style binding condition",x,t[v].name),e}null!==S?a[S][U]=f:a[U]=f}if(null!==u)try{if(null!=i)u=converterUtils.removeStyle(u,t[v].position.start,t[v].position.end,s,0,0,"");else{var A="";b||(A=h+": \x3c!-- ko text: "+f+" --\x3e"+p+"\x3c!-- /ko --\x3e"),u=converterUtils.removeStyle(u,t[v].position.start,t[v].position.end,s,0,0,A)}}catch(e){throw console.warn("Remove style failed",e,"name",t[v]),e}}else{var k=_declarationValueUrlPrefixer(t[v].value,r);if(k!=t[v].value&&(null===u&&void 0!==e&&(u=e),null!==u))try{u=converterUtils.removeStyle(u,t[v].position.start,t[v].position.end,s,0,0,t[v].name+": "+k)}catch(e){throw console.log("Remove style failed replacing url",e,"name",t[v]),e}var C=_propToCamelCase(t[v].name),V="virtualAttrStyle",P=void 0!==a.virtualStyle?a.virtualStyle[C]:void 0,j=" ";void 0===a[V]&&(a[V]="''",j=""),void 0!==P?(a[V]="'"+t[v].name+": '+("+P+")+';"+j+"'+"+a[V],delete a.virtualStyle[C]):a[V]="'"+t[v].name+": "+converterUtils.addSlashes(k)+";"+j+"'+"+a[V]}}if(null!=i){for(var z in a.virtualStyle)if(a.virtualStyle.hasOwnProperty(z))throw console.log("Unexpected virtualStyle binding after conversion to virtualAttr.style",z,a.virtualStyle[z],e),"Unexpected virtualStyle binding after conversion to virtualAttr.style for "+z;delete a.virtualStyle;var L=domutils.getAttribute(i,"data-bind"),q=(null!==L?L+", ":"")+_bindingSerializer(a);domutils.setAttribute(i,"data-bind",q)}if(void 0===e){var O=!1;for(var T in a.virtualStyle)if(a.virtualStyle.hasOwnProperty(T)){O=!0;break}if(O){if(void 0!==a.virtualAttrStyle){var B=a.virtualAttrStyle;delete a.virtualAttrStyle,a.virtualAttrStyle=B}}else delete a.virtualStyle;return _bindingSerializer(a)}return u},_bindingSerializer=function(e){var t=[];for(var r in e)e.hasOwnProperty(r)&&("object"==typeof e[r]?t.push(r+": { "+_bindingSerializer(e[r])+" }"):t.push(r+": "+e[r]));return t.reverse().join(", ")};module.exports=elaborateDeclarations;

},{"./domutils.js":68,"./utils.js":74,"console-browserify":3,"mensch/lib/parser.js":19}],68:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null;function _extend(e,t){if(t)for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}var objExtend=function(e,t){return"function"==typeof $.extend?$.extend(!0,e,t):_extend(e,JSON.parse(JSON.stringify(t)))},getAttribute=function(e,t){var n=$(e).attr(t);return void 0===n&&(n=null),n},setAttribute=function(e,t,n){$(e).attr(t,n)},removeAttribute=function(e,t){$(e).removeAttr(t)},getInnerText=function(e){return $(e).text()},getInnerHtml=function(e){return $(e).html()},getLowerTagName=function(e){return""===e.tagName&&"string"==typeof e.name?e.name.toLowerCase():""!==e.tagName?e.tagName.toLowerCase():$(e).prop("tagName").toLowerCase()},setContent=function(e,t){$(e).html(t)},replaceHtml=function(e,t){$(e).replaceWith(t)},removeElements=function(e,t){t&&void 0!==e.detach&&e.detach(),e.remove()};module.exports={getAttribute:getAttribute,setAttribute:setAttribute,removeAttribute:removeAttribute,getInnerText:getInnerText,getInnerHtml:getInnerHtml,getLowerTagName:getLowerTagName,setContent:setContent,replaceHtml:replaceHtml,removeElements:removeElements,objExtend:objExtend};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],69:[function(require,module,exports){
"use strict";var console=require("console-browserify"),elaborateDeclarations=require("./declarations.js"),utils=require("./utils.js"),modelDef=require("./model.js"),_getOptionsObject=function(e){for(var t=e.split("|"),o={},i=0;i<t.length;i++){var l=t[i].split("=");o[l[0].trim()]=l.length>1?l[1].trim():l[0].trim()}return o},_filterProps=function(e,t,o){var i=[];for(var l in e)if(!l.match(/^customStyle$/)&&!l.match(/^_/)&&e.hasOwnProperty(l)){var a=null!==e[l]&&void 0!==e[l]._category&&"style"==e[l]._category;if("id"==l||"type"==l||l.match(/Blocks$/));else if("styler"==t)(a||o>0)&&i.push(l);else if("edit"==t){null!==e[l]&&void 0!==e[l]._category&&"content"==e[l]._category&&(void 0===e[l]._context||"block"!=e[l]._context)&&i.push(l)}else void 0===t&&i.push(l)}return i},_propInput=function(e,t,o,i,l){var a,n="";if(null!==e&&void 0!==e._widget&&(a=e._widget),void 0===a)throw"Unknown data type for "+t;var s="focusable: true";if("edit"==i&&(s+=", event: { focus: function(ui, event) { $($element).click(); } } "),n+='<label class="data-'+a+'"'+("boolean"==a?" data-bind=\"event: { mousedown: function(ui, evt) { if (evt.button == 0) { var input = $($element).find('input'); var ch = input.prop('checked'); setTimeout(function() { input.click(); input.prop('checked', !ch); input.trigger('change'); }, 0); } } }, click: function(ui, evt) { evt.preventDefault(); }, clickBubble: false\"":"")+">",void 0!==l&&void 0!==l[a]){var d=l[a],r={};if(void 0!==d.parameters)for(var c in d.parameters)d.parameters.hasOwnProperty(c)&&void 0!==e["_"+c]&&(r[c]=e["_"+c]);n+=d.html(o,s,r)}else if("boolean"==a)n+='<input type="checkbox" value="nothing" data-bind="checked: '+o+", "+s+'" />',n+='<span class="checkbox-replacer" ></span>';else if("color"==a)n+='<input size="7" type="text" data-bind="colorpicker: { color: '+o+", strings: $root.t('Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.') }, , "+s+'" />';else if("select"==a){if(void 0!==e._options){var p=_getOptionsObject(e._options);for(var v in n+='<select data-bind="value: '+o+", "+s+'">',p)p.hasOwnProperty(v)&&(n+='<option value="'+v+"\" data-bind=\"text: $root.ut('template', '"+utils.addSlashes(p[v])+"')\">"+p[v]+"</option>");n+="</select>"}}else if("font"==a)n+='<select type="text" data-bind="value: '+o+", "+s+'">',n+='<optgroup label="Sans-Serif Fonts">',n+='<option value="Arial,Helvetica,sans-serif">Arial</option>',n+="<option value=\"'Comic Sans MS',cursive,sans-serif\">Comic Sans MS</option>",n+='<option value="Impact,Charcoal,sans-serif">Impact</option>',n+="<option value=\"'Trebuchet MS',Helvetica,sans-serif\">Trebuchet MS</option>",n+='<option value="Verdana,Geneva,sans-serif">Verdana</option>',n+="</optgroup>",n+='<optgroup label="Serif Fonts">',n+='<option value="Georgia,serif">Georgia</option>',n+="<option value=\"'Times New Roman',Times,serif\">Times New Roman</option>",n+="</optgroup>",n+='<optgroup label="Monospace Fonts">',n+="<option value=\"'Courier New',Courier,monospace\">Courier New</option>",n+="</optgroup>",n+="</select>";else if("url"==a)n+='<div class="ui-textbutton">',n+='<input class="ui-textbutton-input" size="7" type="url" pattern="(mailto:.+@.+|https?://.+\\..+|\\[.*\\].*)" value="nothing" data-bind="css: { withButton: typeof $root.linkDialog !== \'undefined\' }, validatedValue: '+o+", "+s+'" />',n+="<a class=\"ui-textbutton-button\" data-bind=\"visible: typeof $root.linkDialog !== 'undefined', click: typeof $root.linkDialog !== 'undefined' ? $root.linkDialog.bind($element.previousSibling) : false, button: { icons: { primary: 'fa fa-fw fa-ellipsis-h' }, label: 'Opzioni', text: false }\">Opzioni</a>",n+="</div>";else if("integer"==a){var u=0,b=1e3;null!==e&&void 0!==e._max&&(b=e._max),null!==e&&void 0!==e._min&&(u=e._min);var f=b-u>=100?10:1;n+='<input class="number-spinner" size="7" step="'+f+'" type="number" value="-1" data-bind="spinner: { min: '+u+", max: "+b+", page: "+5*f+", value: "+o+" }, valueUpdate: ['change', 'spin'], "+s+'" />'}else n+='<input size="7" type="text" value="nothing" data-bind="value: '+o+", "+s+'" />';return n+="</label>"},_getGlobalStyleProp=function(e,t,o,i){var l;return"object"==typeof t&&null!==t&&void 0===t._widget||void 0!==o&&void 0!==i&&i.length>0&&"object"==typeof e&&void 0!==e[i]&&(l=e[i]),l},_propEditor=function(e,t,o,i,l,a,n,s,d,r,c,p,v,u,b){if(void 0===d&&(d=0),void 0!==n&&"object"==typeof i&&null!==i&&void 0===i._usecount)return"function"==typeof console.debug&&console.debug("Ignoring",a,"property because it is not used by the template","prop:",n,"type:",s,"level:",d,e._templateName),"";var f,h=void 0!==p?n+"._defaultComputed":n,m="",g=h,_=1,y=1;if("object"==typeof i&&null!==i&&void 0===i._widget||void 0===p&&(_+=1),void 0===p&&void 0!==r&&(y+=r),void 0!==n&&v&&(m+="\x3c!-- ko ifSubs: { data: "+g+", threshold: "+y+", gutter: "+_+" } --\x3e"),void 0===n||null!==i&&void 0!==i._name||console.log("Missing label for property ",n),void 0===n&&null!==i&&void 0===i._name&&"theme"!==i.type&&console.log("Missing label for object ",i.type),"object"==typeof i&&null!==i&&void 0===i._widget){var k=_filterProps(i,s,d),x="styler"==s&&null!==i&&void 0!==i.customStyle&&void 0!==p,S="",w="";void 0!==n&&"edit"==s&&(S=", click: function(obj, evt) { $root.selectItem("+n+", $data); return false }, clickBubble: false, css: { selecteditem: $root.isSelectedItem("+n+") }, scrollIntoView: $root.isSelectedItem("+n+"), ",w+=" selectable"),x&&(w+=" supportsCustomStyles"),m+='<div class="objEdit level'+d+w+'" data-bind="tooltips: {}'+S+'">';var $,j,D,B=null!==i&&void 0!==i._name?i._name:void 0!==n?"["+n+"]":"";if(x){var E="Stile";null!=l&&void 0!==l._name?E=l._name:console.log("Missing label for theme section ",n,null!==i?i.type:"-"),B="<span class=\"blockSelectionMethod\" data-bind=\"text: customStyle() ? $root.ut('template', '"+utils.addSlashes(B)+"') : $root.ut('template', '"+utils.addSlashes(E)+"')\">Block</span>"}else B="<span data-bind=\"text: $root.ut('template', '"+utils.addSlashes(B)+"')\">"+B+"</span>";if(m+="<span"+(f=null!==i&&void 0!==i._help?' title="'+utils.addSlashes(i._help)+"\" data-bind=\"attr: { title: $root.ut('template', '"+utils.addSlashes(i._help)+"') }\"":"")+' class="objLabel level'+d+'">'+B+"</span>","edit"==s&&void 0!==i._blockDescription&&(m+="<div class=\"blockDescription\" data-bind=\"html: $root.ut('template', '"+utils.addSlashes(i._blockDescription)+"')\">"+i._blockDescription+"</div>"),x&&(m+='<label class="data-boolean blockCheck" data-bind="tooltips: { }">',m+='<input type="checkbox" value="nothing" data-bind="focusable: true, checked: customStyle" />',m+='<span title="Switch between global and block level styles editing" data-bind="attr: { title: $root.t(\'Switch between global and block level styles editing\') }" class="checkbox-replacer checkbox-replacer-onoff"></span>',m+="</label>",m+="\x3c!-- ko template: { name: 'customstyle', if: customStyle } --\x3e\x3c!-- /ko --\x3e"),void 0!==n)if(m+="\x3c!-- ko with: "+n+" --\x3e",1==d&&void 0!==n)if(void 0!==i._previewBindings&&void 0!==e)void 0!==u&&(m+='\x3c!-- ko with: $root.content() --\x3e<div class="objPreview" data-bind="'+u+'"></div>\x3c!-- /ko --\x3e'),void 0!==b&&(m+='\x3c!-- ko with: $parent --\x3e<div class="objPreview" data-bind="'+b+'"></div>\x3c!-- /ko --\x3e'),m+='<div class="objPreview"><div class="objPreviewInner" data-bind="'+elaborateDeclarations(void 0,i._previewBindings,o,e.bind(this,a+"."))+'"></div></div>';0===d&&void 0!==i._previewBindings&&($=elaborateDeclarations(void 0,i._previewBindings,o,e.bind(this,a.length>0?a+".":"")));var C,I=m.length;for(j=0;j<k.length;j++)D=a.length>0?a+"."+k[j]:k[j],"object"==typeof i[k[j]]&&null!==i[k[j]]&&void 0===i[k[j]]._widget||(C=void 0,0===d&&"theme"==k[j]?m+=_propEditor(e,t,o,i[k[j]],void 0,D,k[j],s,0,r,void 0,void 0,v,u):(C=_getGlobalStyleProp(c,i[k[j]],k[j],D),m+=_propEditor(e,t,o,i[k[j]],void 0,D,k[j],s,d+1,r,c,C,v,u,$)));for(j=0;j<k.length;j++)D=a.length>0?a+"."+k[j]:k[j],"object"==typeof i[k[j]]&&null!==i[k[j]]&&void 0===i[k[j]]._widget&&(C=void 0,0===d&&"theme"==k[j]?m+=_propEditor(e,t,o,i[k[j]],void 0,D,k[j],s,0,r,void 0,void 0,v,u):(C=_getGlobalStyleProp(c,i[k[j]],k[j],D),m+=_propEditor(e,t,o,i[k[j]],void 0,D,k[j],s,d+1,r,c,C,v,u,$)));if(0===m.length-I){if("object"==typeof i&&null!==i&&"template"==i._context)return"";m+='<div class="objEmpty" data-bind="html: $root.t(\'Selected element has no editable properties\')">Selected element has no editable properties</div>'}void 0!==n&&(m+="\x3c!-- /ko --\x3e"),m+="</div>"}else{var P=!0;if(void 0===c&&(P=!1),null===i||"object"!=typeof i||void 0!==i._widget){var M=[];void 0!==p&&M.push("css: { notnull: "+n+"() !== null }"),(f=null!==i&&void 0!==i._help?' title="'+utils.addSlashes(i._help)+"\" data-bind=\"attr: { title: $root.ut('template', '"+utils.addSlashes(i._help)+"') }\"":"").length>0&&M.push("tooltips: {}"),m+='<div class="propEditor '+(P?"checkboxes":"")+'"'+(M.length>0?'data-bind="'+utils.addSlashes(M.join())+'"':"")+">";var T=null!==i&&void 0!==i._name?i._name:void 0!==n?"["+n+"]":"";m+="<span"+f+' class="propLabel">'+(T="<span data-bind=\"text: $root.ut('template', '"+utils.addSlashes(T)+"')\">"+T+"</span>")+"</span>",m+='<div class="propInput '+(void 0!==c?"local":"")+'" data-bind="css: { default: '+n+'() === null }">',m+=_propInput(i,n,h,s,t),m+="</div>",void 0!==p&&(m+='<div class="propInput global" data-bind="css: { overridden: '+n+'() !== null }">',m+=_propInput(i,n,p,s,t),m+="</div>",P&&(m+='<div class="propCheck"><label data-bind="tooltips: {}"><input type="checkbox" data-bind="focusable: true, click: function(evt, obj) { $root.localGlobalSwitch('+n+", "+p+"); return true; }, checked: "+n+'() !== null">',m+='<span class="checkbox-replacer" data-bind="css: { checked: '+n+"() !== null }, attr: { title: $root.t('This style is specific for this block: click here to remove the custom style and revert to the theme value') }\"></span>",m+="</label></div>")),m+="</div>"}else m+=null===i||"object"!=typeof i?'<div class="propEditor unknown">[A|'+n+"|"+typeof i+"]</div>":'<div class="propEditor unknown">[B|'+n+"|"+typeof i+"]</div>"}return void 0!==n&&v&&(m+="\x3c!-- /ko --\x3e",m+="\x3c!-- ko ifSubs: { not: true, data: "+g+", threshold: "+y+", gutter: 0 } --\x3e",m+='<span class="label notused">('+n+")</span>",m+="\x3c!-- /ko --\x3e"),m},createBlockEditor=function(e,t,o,i,l,a,n,s,d,r,c,p){void 0===c&&(c=!0);var v,u=modelDef.getDef(e,a),b=modelDef.getDef(e,l);void 0!==b._previewBindings&&"thaeme"!=a&&"styler"==n&&(v=elaborateDeclarations(void 0,b._previewBindings,i,modelDef.getBindValue.bind(void 0,e,o,l,l,"")));var f,h=void 0!==r&&r?e[a]._globalStyles:void 0,m=void 0!==r&&r?e[a]._globalStyle:void 0;void 0!==m&&(f=modelDef.getDef(e,"theme")[m.replace(/^(\$theme|_theme_)\./,"")]);var g=modelDef.getBindValue.bind(void 0,e,o,l,a);g._templateName=a;var _='<div class="editor">';_+='<div class="blockType'+(void 0!==h?" withdefaults":"")+'">'+u.type+"</div>";var y=_propEditor(g,t,i,u,f,"",void 0,n,p,d,h,m,c,v);y.length>0&&(_+=y),s(_+="</div>",a,n)},createBlockEditors=function(e,t,o,i,l,a,n,s){createBlockEditor(e,t,o,i,l,a,"edit",n,s),createBlockEditor(e,t,o,i,l,a,"styler",n,s,!0)},generateEditors=function(e,t,o,i,l){var a,n=e._defs,s=e.templateName,d=e._blocks,r=[];for(a=0;a<d.length;a++)void 0!==d[a].container&&r.push(modelDef.generateModel(n,d[a].block)),createBlockEditors(n,t,void 0,o,d[a].root,d[a].block,i,l);return void 0!==n.theme&&createBlockEditor(n,t,void 0,o,s,"theme","styler",i,void 0,!1,!1,-1),r};module.exports=generateEditors;

},{"./declarations.js":67,"./model.js":71,"./utils.js":74,"console-browserify":3}],70:[function(require,module,exports){
"use strict";var modelDef=require("./model.js"),wrappedResultModel=function(e){var r=e._defs,t=e.templateName,l=modelDef.getDef(r,t),a=modelDef.generateResultModel(e);return require("./wrapper.js")(a,l,r)},translateTemplate=function(){var e=require("./parser.js");return e.apply(e,arguments)},generateEditors=function(){var e=require("./editor.js");return e.apply(e,arguments)},checkModel=function(){var e=require("./checkmodel.js");return e.apply(e,arguments)};module.exports={translateTemplate:translateTemplate,wrappedResultModel:wrappedResultModel,generateResultModel:modelDef.generateResultModel,generateEditors:generateEditors,checkModel:checkModel};

},{"./checkmodel.js":66,"./editor.js":69,"./model.js":71,"./parser.js":72,"./wrapper.js":75}],71:[function(require,module,exports){
"use strict";var objExtend=require("./domutils.js").objExtend,console=require("console-browserify"),_valueSet=function(e,t,o,l){var r=o.indexOf(".");if(-1==r)if(void 0===t[o])console.log("Undefined prop "+o+" while setting value "+l+" in model._valueSet");else if(null===t[o])"object"==typeof l&&null!==l&&void 0===l.push&&console.log("nullpropobjectvalue",o,l),t[o]=l;else if("object"==typeof t[o]&&"function"==typeof t[o].push){var n;if("string"==typeof l){var i=l.match(/^\[(.*)\]$/);if(null===i)throw"Unexpected default value for array property "+o+": "+l;n=i[1].split(",")}else{if("object"!=typeof l||void 0===l.push)throw"Unexpected default value for array property "+o+": "+l+" typeof "+typeof l;n=l}for(var a=[],d=0;d<n.length;d++)"@"==n[d].substr(0,1)?a.push(_generateModel(e,n[d].substr(1))):n[d].length>0&&a.push(n[d]);t[o]=a}else"string"==typeof t[o]||"boolean"==typeof t[o]?t[o]=l:"object"==typeof t[o]&&null!==t[o]&&void 0!==t[o]._widget?("object"==typeof l&&null!==l&&console.log("objectvalue",o,t[o]._widget,l),t[o]=l):console.log("setting",typeof t[o],t[o],o,l);else{var f=o.substr(0,r);_valueSet(e,t[f],o.substr(r+1),l)}},_modelCreateOrUpdateBlockDef=function(e,t,o,l){if(void 0!==e[t]&&e[t]._initialized&&!e[t]._writeable)throw console.log("_modelCreateOrUpdateBlockDef",e,t,o,l),"Trying to alter non writeable model: "+t+" / "+o;if(void 0===e[t]&&(e[t]={_writeable:!0},void 0===l&&(l={}),void 0===l.category&&void 0===e[t]._category&&(t.match(/(^t|.T)heme$/)||t.match(/(^s|.S)tyle$/)||t.match(/(^c|.C)olor$/)||t.match(/(^r|.R)adius$/)?l.category="style":l.category="content")),void 0!==l){if(void 0!==l.name&&(e[t]._name=l.name),void 0!==l.themeOverride&&(e[t]._themeOverride=l.themeOverride),void 0!==l.globalStyle){e[t]._globalStyle=l.globalStyle;var r=l.globalStyle.replace(/^(\$theme|_theme_)\./,""),n=r.indexOf("."),i=-1!=n?r.substr(0,n):r;_modelCreateOrUpdateBlockDef(e,"theme",i),(void 0===e[t]._themeOverride||e[t]._themeOverride)&&_modelCreateOrUpdateBlockDef(e,t,"customStyle=false")}void 0!==l.contextName&&(e[t]._context=l.contextName,"block"==l.contextName&&void 0===e[t]._globalStyle&&(e[t]._globalStyle="_theme_.bodyTheme",_modelCreateOrUpdateBlockDef(e,"theme","bodyTheme"),(void 0===e[t]._themeOverride||e[t]._themeOverride)&&_modelCreateOrUpdateBlockDef(e,t,"customStyle=false"))),void 0!==l.extend&&(e[t].type=l.extend)}for(var a in l)l.hasOwnProperty(a)&&void 0!==l[a]&&-1==["name","extend","contextName","globalStyle","themeOverride"].indexOf(a)&&(e[t]["_"+a]=l[a]);void 0!==o&&o.length>0&&(e[t]._props=void 0!==e[t]._props&&e[t]._props.length>0?e[t]._props+" "+o:o)},_removePrefix=function(e){var t=e.match(/^[^A-Z]+([A-Z])(.*)$/);return null!==t?t[1].toLowerCase()+t[2]:null},_generateModelFromDef=function(e,t){var o={};for(var l in e)if(!l.match(/^_.*/)&&e.hasOwnProperty(l)){var r=e[l];if("object"==typeof r&&null!==r&&void 0!==r._complex&&r._complex)o[l]=_generateModelFromDef(r,t);else if("type"==l)o[l]=r;else{if("object"!=typeof r)throw console.error("Unexpected model def",l,r,e),"Unexpected model def ["+l+"]="+r;o[l]=null}}if(void 0!==e._defaultValues){var n=e._defaultValues;for(var i in n)n.hasOwnProperty(i)&&_valueSet(t,o,i,n[i])}return o},_generateModel=function(e,t){var o=_getModelDef(e,t,!1,!0);return _generateModelFromDef(o,e)},_getDef=function(e,t){return _getModelDef(e,t,!1,!0)},_getModelDef=function(e,t,o,l){if(void 0===e[t]){if(-1!=t.indexOf(" "))return null;var r=_removePrefix(t);return null!==r?_getModelDef(e,r,o,l):null}var n=e[t];if("object"!=typeof n)throw"Block definition must be an object: found "+n+" for "+t;if(void 0===n._initialized){if(void 0===n.type&&(-1==t.indexOf(" ")?n.type=t:n.type=t.substr(t.indexOf(" ")+1)),n.type!=t&&void 0===n._widget){var i=_getModelDef(e,n.type,!0);n=objExtend(i,n),e[t]=n}else void 0===n._widget&&void 0===n._props&&n._complex;n._writeable=!0,n._initialized=!0}if(void 0!==n._props){var a=n._props;if((a=a.split(" ")).length>0&&void 0===n._writeable)throw console.error("Altering a non writable object ",t,a,n),"Altering a non writable object: "+t+" def: "+a;void 0===n._processedDefs&&(n._processedDefs={}),void 0===n._globalStyles&&(n._globalStyles={}),void 0===n._defaultValues&&(n._defaultValues={});for(var d=0;d<a.length;d++){var f=a[d];if(0!==f.length){var s=f,u=null,c=f.match(/^([^=\[\]]+)(\[\])?(=?)(.*)$/);if(null!==c&&(f=c[1],"[]"==c[2]&&(void 0===n[f]&&(n[f]=[]),u=[]),"="==c[3]&&(u=f.match(/(^v|V)isible$/)?"true"==String(c[4]).toLowerCase():f.match(/^customStyle$/)?"true"==String(c[4]).toLowerCase():c[4])),null!==u&&void 0===n._defaultValues[f]&&(n._defaultValues[f]=u),void 0===n[f]){var _=_getModelDef(e,t+" "+f,!0);null===_&&(_=_getModelDef(e,f,!0)),n[f]=_}n._processedDefs[f]=s,n._complex=!0}}delete n._props}if(o)return n._writeable=!1,objExtend({},n);if(l)return n._writeable=!1,n;if(void 0===n._writeable||!1===n._writeable)throw"Retrieving non writeable object definition: "+t;return n},_increaseUseCount=function(e,t){if(e){if(void 0===t._usecount)throw console.error("ERROR trying to bind an unused property while readonly",t),"ERROR trying to bind an unused property"}else void 0===t._usecount&&(t._usecount=0),t._usecount++},ensureGlobalStyle=function(e,t,o,l,r,n,i,a){var d=o(n,i,a);if(void 0===e[l]._globalStyles[r]){if(t)throw"Cannot find _globalStyle for "+r+" in "+l+"!";(-1!=r.indexOf(".")||"object"==typeof e[l][r]&&void 0!==e[l][r]._widget)&&(e[l]._globalStyles[r]=d)}else if(e[l]._globalStyles[r]!=d)throw"Unexpected conflicting globalStyle [2] for "+l+"/"+r+": old="+e[l]._globalStyles[r]+" new="+d},modelEnsurePathAndGetBindValue=function(e,t,o,l,r,n,i,a,d,f){var s,u,c;if("$"==i.substr(0,1)){console.warn("DEPRECATED $ in bindingProvider: ",i,r);var _=i.indexOf(".");if(-1==_)throw"Unexpected fullPath: "+i+"/"+n+"/"+r+"/"+a+"/"+d;if(s=i.substr(1,_-1),c=i.substr(_+1),"theme"!=s)throw"Unexpected $ sequence: "+s+" in "+i;var v=c.indexOf(".");u="$root.content().theme()."+(s=c.substr(0,v))+"()."+(c=c.substr(v+1)).replace(new RegExp("\\.","g"),"().")}else if("#"==i.substr(0,1))console.warn("DEPRECATED # in bindingProvider: ",i,r),s=l,u="$root.content()."+(c=i.substr(1)).replace(new RegExp("\\.","g"),"().");else if("_theme_."==i.substr(0,8)){var p=i.indexOf(".",8);u="$root.content().theme()."+(s=i.substr(8,p-8))+"()."+(c=i.substr(p+1)).replace(new RegExp("\\.","g"),"().")}else"_root_."==i.substr(0,7)?(s=l,u="$root.content()."+(c=i.substr(7)).replace(new RegExp("\\.","g"),"().")):(s=r,c=n+i,u=i.replace(new RegExp("\\.","g"),"()."));if(void 0===t[s])throw"Cannot find model def for ["+s+"]";var g,b=c.indexOf("."),h=-1==b?c:c.substr(0,b);if(-1!=s.indexOf("-"))throw console.error("ERROR cannot use - for block names",s),"ERROR unexpected char in block name: "+s;if(-1!=h.indexOf("-"))throw console.error("ERROR cannot use - for property names",h),"ERROR unexpected char in property name: "+s;if(e)return void 0!==t[s]._globalStyle&&void 0!==t[s][h]&&"style"==t[s][h]._category&&(u+="._defaultComputed"),u;if(e){if(void 0!==a)throw"Cannot use defaultValue in readonly mode!";if(d)throw"Cannot use overrideDefault in readonly mode for "+s+"/"+c+"/"+d+"!";if(void 0!==f)throw"Cannot set category for "+s+"/"+c+"/"+f+" in readonly mode!";g=_getModelDef(t,s,!1,!0)}else!1===t[s]._writeable&&console.log("TODO debug use cases for this condition",s,c),g=_getModelDef(t,s,!1===t[s]._writeable);if(null===g)throw"Unexpected model for ["+s+"]";if(void 0===g[h]){if(e)throw"Cannot find path "+h+" for "+s+"!";_modelCreateOrUpdateBlockDef(t,s,h),g=_getModelDef(t,s,!1)}void 0!==t[s]._globalStyle&&void 0!==t[s][h]&&null!==t[s][h]&&"style"==t[s][h]._category&&(u+="._defaultComputed");var y=g;try{if(_increaseUseCount(e,y),-1!=b){var m=c;do{var w=m.substr(0,b);if(void 0===y[w])throw"Found an unexpected prop "+w+" for model "+s+" for "+c;y=y[w],_increaseUseCount(e,y),b=(m=m.substr(b+1)).indexOf(".")}while(-1!=b);if(void 0===y[m]||null===y[m])throw"Found an unexpected path termination "+m+" for model "+s+" for "+c;y=y[m]}else y=y[c];if(null==y)throw"Unexpected null model for "+s+"/"+n+"/"+i;void 0!==f&&(y._category=f),_increaseUseCount(e,y)}catch(e){throw console.error("TODO ERROR Property lookup exception",e,s,c,r,i,t),e}if(void 0!==t[s]._globalStyle&&"object"==typeof t[s][h]&&null!==t[s][h]&&void 0!==t[s][h]._category&&"style"==t[s][h]._category){var x=modelEnsurePathAndGetBindValue.bind(void 0,e,t,o,l,r,""),O=-1!=c.indexOf(".")?c.substr(c.indexOf(".")):"";if(-1!=O.indexOf(".",1))throw"TODO unsupported object nesting! "+c;var D=t[s]._globalStyle+"."+h;"object"==typeof t[s][h]&&null!==t[s][h]&&void 0!==t[s][h]._globalStyle&&(D=t[s][h]._globalStyle),ensureGlobalStyle(t,e,x,s,h,D,void 0,!1);var S=D+O;if(void 0===a&&null!==t[s]._defaultValues[c]&&(a=t[s]._defaultValues[c]),ensureGlobalStyle(t,e,x,s,c,S,a,d),void 0!==a){if(e)throw console.error("Cannot set a new theme default value",S.substr(7),a,"while in readonly mode"),"Cannot set a new theme default value ("+a+") for "+S.substr(7)+" while in readonly mode!";o("default",S.substr(7),a)}a=null}if(void 0!==a)if(void 0===t[s]._defaultValues[c]||void 0!==d&&d){if(e)throw"Cannot set new _defaultValues [1] for "+c+" in "+s+"!";t[s]._defaultValues[c]=a}else if(null===a){if(e&&null!==t[s]._defaultValues[c])throw"Cannot set new _defaultValues [2] for "+c+" in "+s+"!";t[s]._defaultValues[c]=null}else if(t[s]._defaultValues[c]!=a)throw console.error("TODO error!!! Trying to set a new default value for "+s+" "+c+" while it already exists (current: "+t[s]._defaultValues[c]+", new: "+a+")"),"Trying to set a new default value for "+s+" "+c+" while it already exists (current: "+t[s].defaultValues[c]+", new: "+a+")";return u},generateResultModel=function(e){var t=e._defs,o=e.templateName,l=_generateModel(t,o);return void 0!==t.theme&&(l.theme=_generateModel(t,"theme")),l};module.exports={ensurePathAndGetBindValue:modelEnsurePathAndGetBindValue.bind(void 0,!1),getBindValue:modelEnsurePathAndGetBindValue.bind(void 0,!0),generateModel:_generateModel,generateResultModel:generateResultModel,getDef:_getDef,createOrUpdateBlockDef:_modelCreateOrUpdateBlockDef};

},{"./domutils.js":68,"console-browserify":3}],72:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,console=require("console-browserify"),converterUtils=require("./utils.js"),elaborateDeclarations=require("./declarations.js"),processStylesheetRules=require("./stylesheet.js"),modelDef=require("./model.js"),domutils=require("./domutils.js"),wrapElementWithCondition=function(e,t,o){var a=domutils.getAttribute(t,e);try{var i=converterUtils.conditionBinding(a,o);$(t).before("\x3c!-- ko if: "+i+" --\x3e"),$(t).after("\x3c!-- /ko --\x3e"),domutils.removeAttribute(t,e)}catch(o){throw console.warn("Model ensure path failed in if/variant",t,a,e),o}},replacedAttributes=function(e,t){domutils.setAttribute(e,t,domutils.getAttribute(e,"replaced"+t))},processStyle=function(e,t,o,a){var i,r=domutils.getAttribute(e,"replacedstyle"),l=null;a&&(i={uniqueId:"$data",attr:{id:"id"}});var d=null!==domutils.getAttribute(e,"data-ko-display");null===(l=elaborateDeclarations(r,void 0,t,o,e,i,d))?l=r:domutils.removeAttribute(e,"replacedstyle"),null!==l&&(l.trim().length>0?domutils.setAttribute(e,"style",l):domutils.removeAttribute(e,"style"))},_fixRelativePath=function(e,t,o,a){var i=t(domutils.getAttribute(a,e));null!==i&&domutils.setAttribute(a,e,i)},processBlock=function(e,t,o,a,i,r,l,d,s,c){try{var n;if("block"==r)n=domutils.getAttribute(e,"data-ko-block"),domutils.removeAttribute(e,"data-ko-block");else{if("template"!=r)throw"Unexpected context name while processing block: "+r;n=l}$("[data-ko-remove]",e).remove();for(var u=$("[data-ko-block]",e).replaceWith("<replacedblock>"),m=["href","src","data-ko-placeholder-src","background"],h=0;h<m.length;h++){var p=_fixRelativePath.bind(void 0,m[h],i);$("["+m[h]+"]",e).each(p)}var b=domutils.getAttribute(e,"data-ko-properties");null===b&&(b=""),$("[data-ko-properties]",e).each(function(e,t){b.length>0&&(b+=" "),b+=domutils.getAttribute(t,"data-ko-properties"),domutils.removeAttribute(t,"data-ko-properties")}),modelDef.createOrUpdateBlockDef(t,n,b,{contextName:r});var v=modelDef.ensurePathAndGetBindValue.bind(void 0,t,o,l,n,"");"block"==r&&v("id",""),$("style",e).each(function(e,a){var r=domutils.getInnerHtml(a),d=modelDef.createOrUpdateBlockDef.bind(void 0,t),s=modelDef.ensurePathAndGetBindValue.bind(void 0,t,o,l),u=processStylesheetRules(r,void 0,s,d,o,i,l,n);if(u!=r)if(""!==u.trim()){var m=c(u);domutils.setAttribute(a,"data-bind","template: { name: '"+m+"' }"),domutils.setContent(a,"")}else domutils.removeElements($(a))}),processStyle(e,i,v,s);for(var f=["data-ko-display","data-ko-editable","data-ko-wrap","href"],k=0;k<f.length;k++){if(domutils.getAttribute(e,f[k]))throw console.warn("ERROR: Unsupported "+f[k]+" used together with data-ko-block",e),"ERROR: Unsupported "+f[k]+" used together with data-ko-block"}return $("[data-ko-link]",e).each(function(e,t){var o=domutils.getAttribute(t,"data-ko-link"),a=domutils.getAttribute(t,"replacedstyle");null==a&&(a=""),a=""!==a?"-ko-attr-href: @"+o+"; "+a:"-ko-attr-href: @"+o,domutils.setAttribute(t,"replacedstyle",a),domutils.setAttribute(t,"data-ko-wrap",o),domutils.removeAttribute(t,"data-ko-link")}),$("[replacedstyle]",e).each(function(e,t){processStyle(t,i,v,!1)}),$("[replacedhttp-equiv]",e).each(function(e,t){replacedAttributes(t,"http-equiv")}),$("[data-ko-display]",e).each(function(e,t){wrapElementWithCondition("data-ko-display",t,v)}),$("[data-ko-editable]",e).each(function(e,t){var o,a,i,r,l,d,s=domutils.getAttribute(t,"data-ko-editable");if(s.lastIndexOf(".")>0){var n=s.substr(0,s.lastIndexOf("."));l=v(n)}else l=v(s);if(d="wysiwygClick: function(obj, evt) { $root.selectItem("+l+", $data); return false }, clickBubble: false, wysiwygCss: { selecteditem: $root.isSelectedItem("+l+") }, scrollIntoView: $root.isSelectedItem("+l+")","img"!=domutils.getLowerTagName(t)){a=domutils.getInnerHtml(t);var u=v(s,a,!0,"wysiwyg");if(o="",domutils.getAttribute(t,"id")||(o+="wysiwygId: id()+'_"+s.replace(".","_")+"', "),void 0!==d&&(o+=d+", "),o+="wysiwygOrHtml: "+u,"td"==domutils.getLowerTagName(t)){var m=$('<div data-ko-wrap="false" style="width: 100%; height: 100%"></div>')[0];domutils.setAttribute(m,"data-bind",o);var h=domutils.getInnerHtml($("<div></div>").append(m));domutils.setContent(t,h)}else r=(null!==(i=domutils.getAttribute(t,"data-bind"))?i+", ":"")+o,domutils.setAttribute(t,"data-bind",r),domutils.setContent(t,"");domutils.removeAttribute(t,"data-ko-editable")}else{var p=domutils.getAttribute(t,"width");if(""===p&&(p=null),null===p)throw console.error("ERROR: data-ko-editable images must declare a WIDTH attribute!",t),"ERROR: data-ko-editable images must declare a WIDTH attribute!";var b=domutils.getAttribute(t,"height");""===b&&(b=null);var f=domutils.getAttribute(t,"align"),k=(i=domutils.getAttribute(t,"data-bind"))&&i.match(/virtualAttr: {[^}]* height: ([^,}]*)[,}]/);k&&(b=k[1]);var g=i&&i.match(/virtualAttr: {[^}]* width: ([^,}]*)[,}]/);g&&(p=g[1]);var w,A,y="";(a=domutils.getAttribute(t,"data-ko-placeholder-src"))?y=domutils.getAttribute(t,"src"):a=domutils.getAttribute(t,"src"),p&&b?w=p+"+'x'+"+b:b?p||(w="'h'+"+b+"+''"):w="'w'+"+p+"+''";var x=b||domutils.getAttribute(t,"data-ko-placeholder-height"),_=p||domutils.getAttribute(t,"data-ko-placeholder-width");if(domutils.removeAttribute(t,"src"),domutils.removeAttribute(t,"data-ko-editable"),domutils.removeAttribute(t,"data-ko-placeholder-height"),domutils.removeAttribute(t,"data-ko-placeholder-width"),domutils.removeAttribute(t,"data-ko-placeholder-src"),a&&(A="{ width: "+_+", height: "+x+", text: "+w+"}"),!_||!x)throw console.error("IMG data-ko-editable must declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height",t),"ERROR: IMG data-ko-editable MUST declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height";var D=v(s,y,!1,"wysiwyg");r=(null!==i?i+", ":"")+(o="wysiwygSrc: { width: "+p+", height: "+b+", src: "+D+", placeholder: "+A+" }"),domutils.setAttribute(t,"data-bind",r);var I=c(t),R="{ width: "+p;"left"==f?R+=", float: 'left'":"right"==f?R+=", float: 'right'":"center"==f&&("function"==typeof console.debug?console.debug("Ignoring align=center on an img tag: we don't know how to emulate this alignment in the editor!"):"top"==f?R+=", verticalAlign: 'top'":"middle"==f?R+=", verticalAlign: 'middle'":"bottom"==f&&(R+=", verticalAlign: 'bottom'")),R+="}",$(t).before("\x3c!-- ko wysiwygImg: { _data: $data, _item: "+l+", _template: '"+I+"', _editTemplate: 'img-wysiwyg', _src: "+D+", _width: "+p+", _height: "+b+", _align: "+(null===f?void 0:"'"+f+"'")+", _size: "+w+", _method: "+void 0+", _placeholdersrc: "+A+", _stylebind: "+R+" } --\x3e"),$(t).after("\x3c!-- /ko --\x3e")}}),$("[href]",e).each(function(e,t){var o=domutils.getAttribute(t,"href"),a="wysiwygHref: '"+converterUtils.addSlashes(o)+"'",i=domutils.getAttribute(t,"data-bind"),r=(null!==i?i+", ":"")+a;domutils.setAttribute(t,"data-bind",r)}),$("replacedblock",e).each(function(e,r){var s=u[e],m=processBlock(s,t,o,a,i,"block",n,d,!0,c),h=modelDef.ensurePathAndGetBindValue(t,o,l,n,"",m);$(r).before("\x3c!-- ko block: { data: "+converterUtils.addSlashes(h)+", template: 'block' } --\x3e"),$(r).after("\x3c!-- /ko --\x3e"),$(r).remove()}),$($("[data-ko-wrap]",e).get().reverse(),e).each(function(e,t){var o=domutils.getAttribute(t,"data-ko-wrap");if(void 0===o||""===o||"true"===o)throw"Unsupported empty value for data-ko-wrap: use false value if you want to always remove the tag";var a,i,r=converterUtils.conditionBinding(o,v),l=domutils.getAttribute(t,"data-bind");if(""!==l&&null!==l&&l.match(/(block|wysiwygOrHtml):/)){var d="\x3c!-- ko "+l+" --\x3e"+domutils.getInnerHtml(t)+"\x3c!-- /ko --\x3e";a=c(d),domutils.removeAttribute(t,"data-ko-wrap"),i=c(t),domutils.replaceHtml(t,"\x3c!-- ko template: /* special */ (typeof templateMode != 'undefined' && templateMode == 'wysiwyg') || "+r+" ? '"+i+"' : '"+a+"' --\x3e\x3c!-- /ko --\x3e")}else a=c(domutils.getInnerHtml(t)),domutils.removeAttribute(t,"data-ko-wrap"),domutils.setContent(t,"\x3c!-- ko template: '"+a+"' --\x3e\x3c!-- /ko --\x3e"),i=c(t),domutils.replaceHtml(t,"\x3c!-- ko template: (typeof templateMode != 'undefined' && templateMode == 'wysiwyg') || "+r+" ? '"+i+"' : '"+a+"' --\x3e\x3c!-- /ko --\x3e")}),c(e,n,"show"),a(l,n,r,d),n}catch(t){throw console.error("Exception while parsing the template",t,e),t}};function conditional_replace(e){return e.replace(/<!--\[if ([^\]]*)\]>((?:(?!--)[\s\S])*?)<!\[endif\]-->/g,function(e,t,o){var a="\x3c!-- cc:start --\x3e";a+=o.replace(/<([A-Za-z:]+)/g,"\x3c!-- cc:bo:$1 --\x3e<cc").replace(/<\/([A-Za-z:]+)>/g,"\x3c!-- cc:bc:$1 --\x3e</cc>\x3c!-- cc:ac:$1 --\x3e").replace(/\/>/g,"/>\x3c!-- cc:sc --\x3e"),a+="\x3c!-- cc:end --\x3e";var i='<replacedcc condition="'+t+'" style="display: none">';return i+=$("<div>").append($(a)).html().replace(/^<!-- cc:start -->/,"").replace(/<!-- cc:end -->$/,""),i+="</replacedcc>"})}var translateTemplate=function(e,t,o,a){var i={},r=conditional_replace(t.replace(/(<[^>]+\s)(style|http-equiv)(="[^"]*"[^>]*>)/gi,function(e,t,o,a){return t+"replaced"+o+a})),l="function"==typeof $.parseHTML?$($.parseHTML(r,!1)):$(r),d=l[0],s=[],c=function(e,t,o,a){s.push({root:e,block:t,context:o,container:a})},n=function(e,t,o){if(void 0===i.themes&&(i.themes={}),void 0===i.themes[e]&&(i.themes[e]={}),void 0===i.themes[e][t]||null===i.themes[e][t])i.themes[e][t]=o;else if(null!=o){var a=i.themes[e][t];a!=o&&console.log("Error setting a new default for property "+t+" in theme "+e+". old:"+a+" new:"+o+"!")}},u=$("[data-ko-container]",l),m={};u.each(function(e,t){var o=domutils.getAttribute(t,"data-ko-container")+"Blocks";domutils.removeAttribute(t,"data-ko-container"),domutils.setAttribute(t,"data-bind","block: "+o);var a=$("> [data-ko-block]",t);domutils.removeElements(a,!0),m[o]=a}),modelDef.createOrUpdateBlockDef(i,"id"),modelDef.createOrUpdateBlockDef(i,"bodyTheme"),modelDef.createOrUpdateBlockDef(i,"blocks","blocks[]"),modelDef.createOrUpdateBlockDef(i,"text"),processBlock(d,i,n,c,o,"template",e,void 0,!1,a);var h=function(t,r,l){processBlock(l,i,n,c,o,"block",e,t,!0,a)};for(var p in m)if(m.hasOwnProperty(p)){var b=m[p],v=p;modelDef.ensurePathAndGetBindValue(i,n,e,e,"",v+".blocks","[]"),b.each(h.bind(void 0,v))}var f={_defs:i,templateName:e,_blocks:s};return void 0!==i[e]._version&&(f.version=i[e]._version),f};module.exports=translateTemplate;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./declarations.js":67,"./domutils.js":68,"./model.js":71,"./stylesheet.js":73,"./utils.js":74,"console-browserify":3}],73:[function(require,module,exports){
"use strict";var cssParse=require("mensch/lib/parser.js"),console=require("console-browserify"),converterUtils=require("./utils.js"),elaborateDeclarations=require("./declarations.js"),_removeOptionalQuotes=function(e){return"'"!=e[0]&&'"'!=e[0]||e[e.length-1]!=e[0]?e:e.substr(1,e.length-2).replace(/\\([\s\S])/gm,"$1")},_processStyleSheetRules_processBlockDef=function(e,t){for(var o,s,r,l=0;l<t.length;l++)if("rule"==t[l].type){for(var n=t[l].selectors,i=!1,a=!1,c=0;c<n.length;c++)n[c].match(/:preview$/)?a=!0:i=!0;if(a&&i)throw console.log("cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs ",n),"Cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs";if(!a&&!i)throw console.log("cannot find known selectors in @supports -ko-blockdefs ",n),"Cannot find known selectors in @supports -ko-blockdefs";if(i){o="",s={},r=t[l].declarations;for(var p,u=0;u<r.length;u++)"property"==r[u].type&&(p=_removeOptionalQuotes(r[u].value),"label"==r[u].name?s.name=p:"context"==r[u].name?s.contextName=p:"properties"==r[u].name?o=p:"theme"==r[u].name?s.globalStyle="_theme_."+p:"themeOverride"==r[u].name?s.themeOverride="true"==String(p).toLowerCase():s[r[u].name]=p);for(var d=0;d<n.length;d++)e(n[d],o,s)}if(a)for(var f=0;f<n.length;f++){e(n[f].substr(0,n[f].indexOf(":")),void 0,{previewBindings:t[l].declarations})}}},processStylesheetRules=function(e,t,o,s,r,l,n,i){var a,c=e,p=null;if(void 0===t){var u=cssParse(e,{comments:!0,position:!0});if("stylesheet"!=u.type||void 0===u.stylesheet)throw console.log("unable to process styleSheet",u),"Unable to parse stylesheet";t=u.stylesheet.rules}for(var d=t.length-1;d>=0;d--){if("supports"==t[d].type&&"-ko-blockdefs"==t[d].name)_processStyleSheetRules_processBlockDef(s,t[d].rules),c=converterUtils.removeStyle(c,t[d].position.start,p,0,0,0,"");else if("media"==t[d].type||"supports"==t[d].type)c=processStylesheetRules(c,t[d].rules,o,s,r,l,n,i);else if("comment"==t[d].type);else if("rule"==t[d].type){for(var f=t[d].selectors,h="",m=null,v=0;v<f.length;v++){h.length>0&&(h+=", ");var y=f[v].match(/\[data-ko-block=([^ ]*)\]/);if(null!==y){if(null!==m&&m!=y[1])throw"Found multiple block-match attribute selectors: cannot translate it ("+m+" vs "+y[1]+")";m=y[1]}h+="\x3c!-- ko text: templateMode =='wysiwyg' ? '#main-wysiwyg-area ' : '' --\x3e\x3c!-- /ko --\x3e"+f[v]}if(m){var k="\x3c!-- ko foreach: $root.findObjectsOfType($data, '"+m+"') --\x3e",x=p,g=" ";t[d].declarations.length>0&&(t[d].declarations[0].position.start.line!=t[d].position.end.line&&(g="\n"+new Array(t[d].position.start.col).join(" ")),x=t[d].declarations[t[d].declarations.length-1].position.end),null===x?c+=g+"\x3c!-- /ko --\x3e":c=x==p?converterUtils.removeStyle(c,x,p,0,0,0,g+"\x3c!-- /ko --\x3e"):converterUtils.removeStyle(c,x,p,0,0,0,g+"}"+g+"\x3c!-- /ko --\x3e"),h=k+g+h.replace(new RegExp("\\[data-ko-block="+m+"\\]","g"),"\x3c!-- ko text: '#'+id() --\x3e"+m+"\x3c!-- /ko --\x3e"),s(m,"",{contextName:"block"})}var b=m||i;a=o.bind(this,b,"");var w=elaborateDeclarations(c,t[d].declarations,l,a);null!==w&&(c=w),c=converterUtils.removeStyle(c,t[d].position.start,t[d].position.end,0,0,0,h)}else console.log("Unknown rule type",t[d].type,"while parsing <style> rules");p=t[d].position.start}return c};module.exports=processStylesheetRules;

},{"./declarations.js":67,"./utils.js":74,"console-browserify":3,"mensch/lib/parser.js":19}],74:[function(require,module,exports){
"use strict";var console=require("console-browserify"),jsep=require("jsep");jsep.addBinaryOp("or",1),jsep.addBinaryOp("and",2),jsep.addBinaryOp("eq",6),jsep.addBinaryOp("neq",6),jsep.addBinaryOp("lt",7),jsep.addBinaryOp("lte",7),jsep.addBinaryOp("gt",7),jsep.addBinaryOp("gte",7);var addSlashes=function(e){return e.replace(/[\\"'\r\n\t\v\f\b]/g,"\\$&").replace(/\u0000/g,"\\0")},removeStyle=function(e,r,n,t,o,i,a){for(var s=e.split("\n"),p=o,l=i,u=1+t;u<r.line;u++)p+=s[u-1-t].length+1;if(p+=r.col,null!==n){for(var d=1+t;d<n.line;d++)l+=s[d-1-t].length+1;l+=n.col}else l+=e.length+1;return e.substr(0,p-1)+a+e.substr(l-1)},expressionGenerator=function(e,r,n){return function e(r,n,t,o){if(void 0===t&&(t=!0),void 0!==o&&"Identifier"!==r.type&&"MemberExpression"!==r.type&&"function"==typeof console.debug&&console.debug("Cannot apply default value to variable when using expressions"),"BinaryExpression"===r.type||"LogicalExpression"===r.type)return"("+e(r.left,n,t)+" "+function(e){switch(e){case"or":return"||";case"and":return"&&";case"lt":return"<";case"lte":return"<=";case"gt":return">";case"gte":return">=";case"eq":return"==";case"neq":return"!=";default:return e}}(r.operator)+" "+e(r.right,n,t)+")";if("CallExpression"===r.type){var i=r.arguments.map(function(r){return e(r,n,t)});return e(r.callee,n,t)+"("+i.join(", ")+")"}if("UnaryExpression"===r.type)return r.operator+e(r.argument,n,t);if("MemberExpression"==r.type&&r.computed)throw"Unexpected computed member expression";if("MemberExpression"!=r.type||r.computed){if("Literal"===r.type)return r.raw;if("Identifier"===r.type){var a=r.name;return t?n(a,o)+"()":a}if("ConditionalExpression"===r.type)return"("+e(r.test,n,t)+" ? "+e(r.consequent,n,t)+" : "+e(r.alternate,n,t)+")";throw"Compound"===r.type?"Syntax error in expression: operator expected after "+e(r.body[0],n,!1):"Found an unsupported expression type: "+r.type}var s=e(r.object,n,!1)+"."+e(r.property,n,!1);return t&&"Math"!==r.object.name&&"Color"!==r.object.name&&"Util"!==r.object.name?n(s,o)+"()":s}(e,r,void 0,n)},expressionBinding=function(e,r,n){var t;if(null!=n){var o=e.trim().replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b/g,"###var###");if("###var###"==(o=o.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")))t=[null,n];else if(o="^"+o.replace(/###var###/g,"(.+)")+"$",!(t=n.trim().match(new RegExp(o))))throw console.log("Cannot find matches",t,"for",n,e,o,e),"Cannot find default value for "+e+" in "+n}try{var i=0,a="'"+e.replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b|(')/g,function(e,n,o,a){if(a)return"\\"+a;i++;var s,p=n||o;if(t&&(void 0!==t[i]?s=t[i].trim():console.log("ABZZZ Cannot find default value for",p,"in",t,"as",i)),n){var l=jsep(n);return"'+"+expressionGenerator(l,r,s)+"+'"}return"'+"+r(p,s)+"()+'"})+"'";return a=a.replace(/(^|[^\\])''\+/g,"$1").replace(/\+''/g,""),0===i&&"false"!==a&&"true"!==a&&console.error("Unexpected expression with no valid @variable references",e),a}catch(r){throw"Exception parsing expression "+e+" "+r}},conditionBinding=function(e,r){var n=jsep(e);return expressionGenerator(n,r)};module.exports={addSlashes:addSlashes,removeStyle:removeStyle,conditionBinding:conditionBinding,expressionBinding:expressionBinding};

},{"console-browserify":3,"jsep":6}],75:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");function wrap(e){var t=typeof e;if("object"===t&&(e?e.constructor==Date?t="date":"[object Array]"==Object.prototype.toString.call(e)&&(t="array"):t="null"),"array"==t){var n=ko.observableArray();if(!e||0===e.length)return n;for(var o=0,r=e.length;o<r;++o)n.push(wrap(e[o]));return n}if("object"==t){var a={};for(var i in e){var l=e[i];a[i]=wrap(l)}return ko.observable(a)}if("function"==t)return e;var s=ko.observable();return s(e),s}var _getOptionsObjectKeys=function(e){for(var t=e.split("|"),n=[],o=0;o<t.length;o++){var r=t[o].split("=");n.push(r[0].trim())}return n},_makeComputed=function(e,t,n,o,r,a){return ko.computed({read:function(){var n=e();if(null===n){var i=ko.utils.unwrapObservable(o);return void 0===i||"custom"==i?ko.utils.unwrapObservable(t):a[i][r]}return n},write:function(i){var l,s=ko.utils.unwrapObservable(o);if(l=void 0===s||"custom"==s?ko.utils.peekObservable(t):a[s][r],n)e(i==l?null:i);else{var u=ko.utils.peekObservable(e);i==l&&null===u||e(i)}}})},_nextVariantFunction=function(e,t,n){for(var o=e.utils.unwrapObservable(t),r=0;r<n.length&&e.utils.peekObservable(n[r])!=o;r++);r==n.length&&(console.warn("Didn't find a variant!",t,o,n),r=n.length-1);var a=r+1;a==n.length&&(a=0),t(e.utils.peekObservable(n[a]))},_getVariants=function(e){var t=e._variant;if("object"!=typeof e[t]||void 0===e[t]._widget||"string"!=typeof e[t]._options&&"boolean"!==e[t]._widget)throw console.error("Unexpected variant declaration",t,e[t]),"Unexpected variant declaration: cannot find property "+t+" or its _options string and it is not a boolean";return"string"==typeof e[t]._options?_getOptionsObjectKeys(e[t]._options):[!0,!1]},_makeComputedFunction=function(e,t,n,o,r,a,i){if(void 0===e){if(void 0===o.utils.unwrapObservable(i).type)throw console.log("TODO ERROR Found a non-typed def ",e,i),"Found a non-typed def "+e;var l=o.utils.unwrapObservable(o.utils.unwrapObservable(i).type);"object"!=typeof(e=t[l])&&console.log("TODO ERROR Found a non-object def ",e,"for",l)}void 0===r&&void 0!==a&&a&&(r=i);var s="$root.content().",u=e._globalStyles;if(void 0!==u)for(var p in u)if(u.hasOwnProperty(p)){var b,c,v,d="$root.content().theme().scheme";if(u[p].substr(0,s.length)!=s)throw"UNEXPECTED globalStyle path ("+u[p]+") outside selfPath ("+s+")";v=u[p].substr(s.length),c=r,d.substr(0,s.length)==s?b=d.substr(s.length):(console.log("IS THIS CORRECT?",d,s),b=d);for(var f=c,h=v.split("()."),_="",g=!0,k=0;k<h.length;k++)c=o.utils.unwrapObservable(c)[h[k]],g?"theme"==h[k]&&(g=!1):(_.length>0&&(_+="."),_+=h[k]);for(var w=b.split("()."),m=0;m<w.length;m++)f=o.utils.unwrapObservable(f)[w[m]];for(var O=p.split("."),y=i,R=0;R<O.length;R++)y=o.utils.unwrapObservable(y)[O[R]];if(!o.isObservable(y))throw"Unexpected non observable target "+p+"/"+_;y._defaultComputed=_makeComputed(y,c,!0,f,_,n)}if(void 0!==e._variant){for(var F=e._variant.split("."),S=i,j=o.utils.unwrapObservable(i),C=0;C<F.length;C++)S=o.utils.unwrapObservable(S)[F[C]];if(void 0!==S._defaultComputed&&(console.log("Found variant on a style property: beware variants should be only used on content properties because they don't match the theme fallback behaviour",e._variant),S=S._defaultComputed),void 0===S)throw console.log("ERROR looking for variant target",e._variant,i),"ERROR looking for variant target "+e._variant;j._nextVariant=_nextVariantFunction.bind(S,o,S,_getVariants(e))}for(var x in e)if(e.hasOwnProperty(x)){var P=e[x];if("object"==typeof P&&null!==P&&void 0!==P._context&&"block"==P._context){var B=r[x](),E=_makeComputedFunction(t[x],t,n,o,r,a,B);i[x](E)}else if("object"==typeof P&&null!==P&&"blocks"==P.type){for(var D,I,T,A=r[x](),V=A.blocks(),U=0;U<V.length;U++)D=o.utils.unwrapObservable(V[U]),I=o.utils.unwrapObservable(D.type),T=_makeComputedFunction(t[I],t,n,o,r,a,D),V[U](T);var W=A.blocks;_augmentBlocksObservable(W,_blockInstrumentFunction.bind(A,void 0,t,n,o,void 0,r,a)),r[x]._wrap=_makeBlocksWrap.bind(r[x],W._instrumentBlock),r[x]._unwrap=_unwrap.bind(r[x])}}return i},_augmentBlocksObservable=function(e,t){e._instrumentBlock=t,void 0===e.origPush&&(e.origPush=e.push,e.push=_makePush.bind(e),e.origSplice=e.splice,e.splice=_makeSplice.bind(e))},_makeBlocksWrap=function(e,t){var n=ko.toJS(t),o=n.blocks;n.blocks=[];var r=wrap(n)();_augmentBlocksObservable(r.blocks,e);for(var a=0;a<o.length;a++){var i=ko.toJS(o[a]);i.id="block_"+a,r.blocks.push(i)}this(r)},_makePush=function(){if(arguments.length>1)throw"Array push with multiple arguments not implemented";if(arguments.length>0&&ko.isObservable(arguments[0])&&("function"==typeof arguments[0]._unwrap?arguments[0]=arguments[0]._unwrap():console.log("WARN: pushing observable with no _unwrap function (TODO remove me, expected condition)")),ko.isObservable(arguments[0]))return this.origPush.apply(this,arguments);var e=this._instrumentBlock(arguments[0]);return this.origPush.apply(this,[e])},_makeSplice=function(){if(arguments.length>3)throw"Array splice with multiple objects not implemented";if(arguments.length>2&&ko.isObservable(arguments[2])&&("function"==typeof arguments[2]._unwrap?arguments[2]=arguments[2]._unwrap():console.log("WARN: splicing observable with no _unwrap function (TODO remove me, expected condition)")),arguments.length>2&&!ko.isObservable(arguments[2])){var e=this._instrumentBlock(arguments[2]);return this.origSplice.apply(this,[arguments[0],arguments[1],e])}return this.origSplice.apply(this,arguments)},_blockInstrumentFunction=function(e,t,n,o,r,a,i,l){void 0===r&&(r=l);var s=wrap(r);return s(_makeComputedFunction(e,t,n,o,a,i,s())),s._unwrap=_unwrap.bind(s),s},_wrap=function(e,t){this(ko.utils.unwrapObservable(e(ko,t,void 0,!0)))},_unwrap=function(){return ko.toJS(this)},_modelInstrument=function(e,t,n){var o=_blockInstrumentFunction.bind(void 0,t,n,n.themes),r=o(ko,e,void 0,!0);return r._wrap=_wrap.bind(r,o),r._unwrap=_unwrap.bind(r),r};module.exports=_modelInstrument;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],76:[function(require,module,exports){
(function (global){
var tinycolor=require("tinycolor2");function Color(t){this.getBrightness=function(n){return t(n).getBrightness()},this.isLight=function(n){return t(n).isLight()},this.isDark=function(n){return t(n).isDark()},this.getLuminance=function(n){return t(n).getLuminance()},this.lighten=function(n,i){return t(n).lighten(i).toHexString()},this.brighten=function(n,i){return t(n).brighten(i).toHexString()},this.darken=function(n,i){return t(n).darken(i).toHexString()},this.desaturate=function(n,i){return t(n).desaturate(i).toHexString()},this.saturate=function(n,i){return t(n).saturate(i).toHexString()},this.greyscale=function(n){return t(n).greyscale().toHexString()},this.spin=function(n,i){return t(n).spin(i).toHexString()},this.complement=function(n){return t(n).complement().toHexString()},this.mix=t.mix,this.readability=t.readability,this.isReadable=t.isReadable,this.mostReadable=t.mostReadable}var colorPlugin=function(t){global.Color=new Color(tinycolor)};module.exports=colorPlugin;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"tinycolor2":29}],77:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify");function handleMailingName(e){var a;e.titleMode=ko.observable("show"),e.metadata.name=ko.observable(e.metadata.name),e.mailingName=ko.computed(function(){return e.metadata.name()},e),e.enableEditMailingName=function(t,n){console.log("enableEditMailingName",t),a=e.metadata.name(),e.titleMode("edit")},e.cancelEditMailingName=function(t,n){console.log("cancelEditMailingName"),e.metadata.name(a),a="",e.titleMode("show")},e.saveEditMailingName=function(t,n){console.log("saveEditMailingName",e.metadata.name()),e.titleMode("saving"),e.notifier.info(e.t("edit-title-ajax-pending")),$.ajax({method:"POST",url:e.metadata.url.update,data:{name:e.metadata.name()},success:function(a){e.metadata.name(a.meta.name),e.notifier.success(e.t("edit-title-ajax-success"))},error:function(){e.notifier.error(e.t("edit-title-ajax-fail"))},complete:function(){a="",e.titleMode("show")}})}}module.exports=handleMailingName;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],78:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,url=require("url"),slugFilename=require("../../../shared/slug-filename.js"),serverStorage=require("./custom-server-storage"),editTitle=require("./custom-edit-title"),textEditor=require("./custom-text-editor"),gallery=require("./custom-gallery"),removeImage=require("./custom-remove-gallery-image"),widgetBgimage=require("./custom-widget-bgimage"),setEditorIcon=function(e){return function(t){t.logoPath=!1,t.logoUrl=!1,t.logoAlt=!1,t.brandName=e.brandName}};function extendViewModel(e,t){t.push(serverStorage),t.push(setEditorIcon(e)),t.push(editTitle),t.push(gallery(e)),t.push(removeImage),t.push(widgetBgimage(e))}function templateUrlConverter(e){var t=e.metadata.assets||{};return function(r){if(!r)return null;if(console.log("customTemplateUrlConverter",r),/\]$/.test(r))return null;if(/^http/.test(r))return null;if(/<%/.test(r))return null;return r=/([^\/]*)$/.exec(r)[1],/\.[0-9a-z]+$/.test(r)?(console.log("customTemplateUrlConverter",r),r=slugFilename(r),r=t[r]?e.imgProcessorBackend+t[r]:null):null}}function extendKnockout(e){"fr"===e.lang&&(textEditor.language_url="/tinymce-langs/fr_FR.js",textEditor.language="fr_FR",tinymce.util.I18n.add("fr_FR",{Cancel:"Annuler","in pixel":"en pixel","Enter a font-size":"Entrez une taille de police","Letter spacing":"Interlettrage","Font size":"Taille de police","Font size: ":"Taille : ","minimum size: 8px":"taille minimum : 8px","no decimals":"pas de décimales"})),textEditor=$.extend({convert_urls:!1},textEditor,e.tinymce),ko.bindingHandlers.wysiwyg.fullOptions=textEditor,ko.bindingHandlers.wysiwyg.standardOptions={convert_urls:!1,external_plugins:{paste:textEditor.external_plugins.paste},theme_url:textEditor.theme_url,skin_url:textEditor.skin_url},ko.bindingHandlers.wysiwygSrc.templateUrlConverter=templateUrlConverter(e);var t=url.parse(e.imgProcessorBackend);ko.bindingHandlers.fileupload.remoteFilePreprocessor=function(e){console.info("REMOTE FILE PREPROCESSOR"),console.log(e);var r=url.format({protocol:t.protocol,host:t.host,pathname:t.pathname});return e.url=url.resolve(r,url.parse(e.url).pathname),e},ko.bindingHandlers.wysiwygSrc.convertedUrl=function(t,r,n,l){var o=url.parse(t).pathname;o||console.warn("no pathname for image",t),console.info("CONVERTED URL",o,r,n,l),o=o.replace("/img/","");var i=e.basePath+"/"+r;return i=i+"/"+n+"x"+l+"/"+o},ko.bindingHandlers.wysiwygSrc.placeholderUrl=function(t,r,n){return e.basePath+"/placeholder/"+t+"x"+r+".png"}}module.exports={extendViewModel:extendViewModel,extendKnockout:extendKnockout};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../shared/slug-filename.js":42,"./custom-edit-title":77,"./custom-gallery":79,"./custom-remove-gallery-image":80,"./custom-server-storage":81,"./custom-text-editor":82,"./custom-widget-bgimage":83,"url":31}],79:[function(require,module,exports){
(function (global){
"use strict";var console=require("console-browserify"),$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,_find=require("lodash.find");function galleryLoader(e){var l=e.fileuploadConfig.url;return function(e){function a(a){var r=l[a],n=e[a+"Gallery"],o=e[a+"GalleryStatus"];return function(){o("loading"),$.getJSON(r,function(l){for(var a=0;a<l.files.length;a++)l.files[a]=e.remoteFileProcessor(l.files[a]);o(l.files.length),n(l.files.reverse())}).fail(function(){o(!1),e.notifier.error(e.t("Unexpected error listing files"))})}}function r(l){var a=e[l+"Gallery"],r=e[l+"GalleryStatus"];return function(e){var l=e.name;_find(a(),function(e){return e.name===l})||!1!==r()&&(a.unshift(e),r(a().length))}}e.mailingGallery=ko.observableArray([]),e.templateGallery=ko.observableArray([]),e.mailingGalleryStatus=ko.observable(!1),e.templateGalleryStatus=ko.observable(!1),e.loadMailingGallery=a("mailing"),e.loadTemplateGallery=a("template"),e.loadMailingImage=r("mailing"),e.loadTemplateImage=r("template");var n=e.showGallery.subscribe(function(l){!0===l&&!1===e.mailingGalleryStatus()&&(e.loadMailingGallery(),n.dispose())}),o=e.selectedImageTab.subscribe(function(l){1===l&&!1===e.templateGalleryStatus()&&(e.loadTemplateGallery(),o.dispose())},e,"change")}}module.exports=galleryLoader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3,"lodash.find":14}],80:[function(require,module,exports){
(function (global){
"use strict";var console=require("console-browserify"),$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null;function removeGalleryImage(e){e.removeImage=function(o,l,r){var n=o.deleteUrl;$.ajax({url:n,method:"DELETE",type:"DELETE",success:function(o){e.notifier.success(e.t("gallery-remove-image-success"));var r=e[l+"Gallery"];(0,e[l+"GalleryStatus"])(o.files.length),r(o.files.reverse())},error:function(o){console.log(o),e.notifier.error(e.t("gallery-remove-image-fail"))}})}}module.exports=removeGalleryImage;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],81:[function(require,module,exports){
(function (global){
"use strict";var console=require("console-browserify"),$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,_omit=require("lodash.omit"),isEmail=require("validator/lib/isEmail");function getData(e){var o=_omit(ko.toJS(e.metadata),["urlConverter","template"]);return o.data=e.exportJS(),o}var loader=function(e){console.info("init server storage (save, test, download)");var o={name:"Save",enabled:ko.observable(!0),execute:function(){o.enabled(!1);var t=getData(e);console.info("SAVE DATA"),console.log(t),$.ajax({url:window.location.href,method:"POST",contentType:"application/json",data:JSON.stringify(t),success:function(o,t,a){console.log("save success"),e.notifier.success(e.t("save-message-success"))},error:function(o,t,a){console.log("save error"),console.log(a),e.notifier.error(e.t("save-message-error"))},complete:function(){o.enabled(!0)}})}},t={name:"Test",enabled:ko.observable(!0),execute:function(){console.info("TEST"),console.log(e.metadata.url.send),t.enabled(!1);var o=e.t("Insert here the recipient email address");if(!(o=global.prompt(e.t("Test email address"),o)))return t.enabled(!0);if(!isEmail(o))return global.alert(e.t("Invalid email address")),t.enabled(!0);console.log("TODO testing...",o);ko.toJS(e.metadata);var a={rcpt:o,html:e.exportHTML()};$.ajax({url:e.metadata.url.send,method:"POST",data:a,success:function(o,t,a){console.log("test success"),e.notifier.success(e.t("Test email sent..."))},error:function(o,t,a){console.log("test error"),console.log(a),e.notifier.error(e.t("Unexpected error talking to server: contact us!"))},complete:function(){t.enabled(!0)}})}},a={name:"Download",enabled:ko.observable(!0),execute:function(o){console.info("DOWNLOAD – "+o),a.enabled(!1),e.notifier.info(e.t("Downloading...")),e.exportHTMLtoTextarea("#downloadHtmlTextarea"),$("#downloadHtmlFilename").val(e.metadata.name()),$("#downloadForm").attr("action",e.metadata.url.zip+"?format="+o).submit(),a.enabled(!0)}};e.save=o,e.test=t,e.download=a};module.exports=loader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3,"lodash.omit":15,"validator/lib/isEmail":37}],82:[function(require,module,exports){
"use strict";var debounce=require("lodash.debounce"),defaults=[0,1,2,3,5,8,13].map(function(t){return Math.round(.1*t*100)/100}).map(function(t){return t+"="+t+"em"}).join(" ");function addLetterSpacing(t,e){t.addButton("letterspacingselect",function(){return{type:"listbox",text:"Letter spacing",tooltip:"Letter spacing",values:(t.settings.spacing_formats||defaults).split(" ").map(function(t){var e=t,n=t,i=t.split("=");return i.length>1&&(e=i[0],n=i[1]),{text:e,value:n}}),fixedWidth:!0,onclick:function(t){t.control.settings.value&&(tinymce.activeEditor.formatter.register("letter-spacing",{inline:"span",styles:{"letter-spacing":t.control.settings.value}}),tinymce.activeEditor.formatter.apply("letter-spacing"))}}})}function each(t,e,n){var i,l;if(!t)return 0;if(n=n||t,void 0!==t.length){for(i=0,l=t.length;i<l;i++)if(!1===e.call(n,t[i],i,t))return 0}else for(i in t)if(t.hasOwnProperty(i)&&!1===e.call(n,t[i],i,t))return 0;return 1}function fontsizedialog(t,e){console.dir(t);var n=8,i=666,l=!1,o=[tinymce.util.I18n.translate("minimum size: 8px"),tinymce.util.I18n.translate("no decimals")].map(function(t){return"• "+t}).join("<br>");t.addButton("fontsizedialogbutton",{text:"Font size",tooltip:"Font size",classes:"fontsizedialogbutton",icon:!1,onPostRender:function(e){var n=e.control;function i(t){if(t.style&&t.style.fontSize)return n.text(tinymce.util.I18n.translate("Font size: ")+t.style.fontSize),l=t.style.fontSize,!1;l=!1,n.text(tinymce.util.I18n.translate("Font size"))}t.on("nodeChange",debounce(function(t){each(t.parents,i),l||(l=document.defaultView.getComputedStyle(t.parents[0]||t.element,null).getPropertyValue("font-size"))},150))},onclick:function(e){var r=l?/^(\d+)/.exec(l):null;r=Array.isArray(r)?r[0]:"",t.windowManager.open({title:"Enter a font-size",width:320,height:120,body:[{type:"label",multiline:!0,text:"",onPostRender:function(){this.getEl().innerHTML=o}},{type:"textbox",name:"bsdialogfontsize",label:"in pixel",autofocus:!0,value:r,onPostRender:function(){this.$el.attr({type:"number",min:n,step:1})}}],onsubmit:function(e){var l=~~e.data.bsdialogfontsize;l>=n&&l<=i&&t.execCommand("FontSize",!1,l+"px")}})}})}tinymce.PluginManager.add("spacing",addLetterSpacing),tinymce.PluginManager.add("fontsizedialog",fontsizedialog);var tinymceConfigFull={toolbar1:"bold italic forecolor backcolor hr | fontsizedialogbutton styleselect letterspacingselect removeformat | link unlink | pastetext code",plugins:["link hr paste lists textcolor colorpicker code spacing fontsizedialog"],style_formats:[{title:"Inline",items:[{title:"Bold",icon:"bold",inline:"strong"},{title:"Italic",icon:"italic",inline:"em"},{title:"Underline",icon:"underline",inline:"span",styles:{"text-decoration":"underline"}},{title:"Strikethrough",icon:"strikethrough",inline:"span",styles:{"text-decoration":"line-through"}},{title:"Superscript",icon:"superscript",inline:"sup"},{title:"Subscript",icon:"subscript",inline:"sub"},{title:"Code",icon:"code",inline:"code"}]},{title:"Alignment",items:[{title:"Left",icon:"alignleft",block:"div",styles:{"text-align":"left"}},{title:"Center",icon:"aligncenter",block:"div",styles:{"text-align":"center"}},{title:"Right",icon:"alignright",block:"div",styles:{"text-align":"right"}},{title:"Justify",icon:"alignjustify",block:"div",styles:{"text-align":"justify"}}]}]};module.exports=tinymceConfigFull;

},{"lodash.debounce":13}],83:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify"),defaultParameters=Object.freeze({}),transparentGif="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",isValidSize=function(e){return/(\d+)x(\d+)/.test(e.trim())};function html(e,t,a){return'\n    <input size="7" type="hidden" value="nothing" id="'+e+'" data-bind="value: '+e+", "+t+"\" />\n    <button data-bind=\"text: $root.t('widget-bgimage-button'), click: $root.openDialogGallery.bind($element, '"+e+"', '"+a+"');\">pick an image</button>\n    <button data-bind=\"click: $root.resetBgimage.bind($element, '"+e+"', '"+a+"'), button: {icons: {primary: 'fas fa-eraser'}, text: false, label: $root.t('widget-bgimage-reset') }\"></button>\n  "}module.exports=function(e){var t=e.basePath;return{widget:function(e,t,a){return{widget:"bgimage",defaultParameters:defaultParameters,html:html}},viewModel:function(e){e.showDialogGallery=ko.observable(!1),e.currentBgimage=ko.observable(!1),e.setBgImage=function(a,i,n){e.currentBgimage()(t+"/img/"+a),e.closeDialogGallery()},e.resetBgimage=function(e,t,a,i){a[e](transparentGif)},e.openDialogGallery=function(t,a,i,n){e.currentBgimage(i[t].bind(i)),e.showDialogGallery(!0)},e.closeDialogGallery=function(){e.currentBgimage(!1),e.showDialogGallery(!1)};var a=e.showDialogGallery.subscribe(function(t){!0===t&&!1===e.mailingGalleryStatus()&&(e.loadMailingGallery(),a.dispose())})}}};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],84:[function(require,module,exports){
(function (global){
"use strict";var console=require("console-browserify"),$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,inlineDocument=require("juice/lib/inline")({}).inlineDocument,inlinerPlugin=function(e){e.inline=function(e){$("[style]:not([replacedstyle])",e).each(function(e,n){var i=$(n);i.attr("replacedstyle",i.attr("style"))});var n=[];$('style[data-inline="true"]',e).each(function(e,i){var t=$(i).html();t=(t=t.replace(/<!-- ko ((?!--).)*? -->/g,"")).replace(/<!-- \/ko -->/g,""),n.push(t),$(i).removeAttr("data-inline")});var i=n.join("\n"),t=function(n,i){return void 0===i&&(i=e),$(n,i)};t.root=function(){return $(":root",e)},inlineDocument(t,i,{styleAttributeName:"replacedstyle"})}};module.exports=inlinerPlugin;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3,"juice/lib/inline":7}],85:[function(require,module,exports){
(function (global){
"use strict";var lsLoader,lsCommandPluginFactory,console=require("console-browserify"),ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,$="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null;module.exports=function(){};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],86:[function(require,module,exports){
(function (global){
var utilPlugin=function(e){global.Util={decodeURI:decodeURI,encodeURI:encodeURI,decodeURIComponent:decodeURIComponent,encodeURIComponent:encodeURIComponent}};module.exports=utilPlugin;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],87:[function(require,module,exports){
"use strict";require("knockout-sortable"),require("./bindings/jqueryui-spinner.js"),require("./bindings/jqueryui-tabs.js"),require("./bindings/colorpicker.js"),require("./bindings/blocks.js"),require("./bindings/csstext.js"),require("./bindings/bind-iframe.js"),require("./bindings/extdroppable.js"),require("./bindings/preloader.js"),require("./bindings/fileupload.js"),require("./bindings/virtuals.js"),require("./bindings/wysiwygs.js"),require("./bindings/scrollfix.js"),require("./bindings/if-subs.js"),require("./bindings/extsortables.js"),require("./bindings/eventable.js"),require("./bindings/tooltips.js"),require("./bindings/extender-pagination.js"),require("./bindings/validated-value.js"),require("./bindings/scrollintoview.js");

},{"./bindings/bind-iframe.js":44,"./bindings/blocks.js":45,"./bindings/colorpicker.js":47,"./bindings/csstext.js":48,"./bindings/eventable.js":49,"./bindings/extdroppable.js":50,"./bindings/extender-pagination.js":51,"./bindings/extsortables.js":52,"./bindings/fileupload.js":53,"./bindings/if-subs.js":54,"./bindings/jqueryui-spinner.js":55,"./bindings/jqueryui-tabs.js":56,"./bindings/preloader.js":57,"./bindings/scrollfix.js":59,"./bindings/scrollintoview.js":60,"./bindings/tooltips.js":62,"./bindings/validated-value.js":63,"./bindings/virtuals.js":64,"./bindings/wysiwygs.js":65,"knockout-sortable":11}],88:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,kojqui="undefined"!=typeof window?window.kojqui:"undefined"!=typeof global?global.kojqui:null,templateConverter=require("./converter/main.js"),console=require("console-browserify"),initializeViewmodel=require("./viewmodel.js"),templateSystem=require("./bindings/choose-template.js");if(!$.ui.version.match(/^1\.11\..*$/))throw"Usupported jQuery UI version detected: "+$.ui.version+" (we only support 1.11.*)";var pluginsCall=function(e,t,n,o){var i,a,r,d,l;l=[],void 0!==o&&o?(i=e.length-1,a=0,r=-1):(i=0,a=e.length-1,r=1);for(var s=i;s!=a+r;s+=r)void 0!==e[s][t]&&void 0!==(d=e[s][t].apply(e[s],n))&&l.push(d);return l},origDisposeCallback=ko.utils.domNodeDisposal.addDisposeCallback;ko.utils.domNodeDisposal.addDisposeCallback=function(e,t){origDisposeCallback(e,function(e){try{t(e)}catch(e){"function"==typeof console.debug&&console.debug("Caught unexpected dispose callback exception",e)}})};var _templateUrlConverter,bindingPluginMaker=function(e){return{viewModel:function(t){try{e("applyBindings",ko.applyBindings.bind(void 0,t))}catch(e){throw console.warn(e,e.stack),e}},dispose:function(){try{e("unapplyBindings",ko.cleanNode.bind(this,global.document.body))}catch(e){throw console.warn(e,e.stack),e}}}},templateCreator=function(e,t,n,o){var i=n;for(void 0!==n&&void 0!==o&&("object"==typeof t&&"replacedhtml"==t.tagName.toLowerCase()||(i+="-"+o));null==i||e.exists(i);)i="anonymous-"+Math.floor(1e5*Math.random()+1);if("object"==typeof t&&"replacedhtml"==t.tagName.toLowerCase()){var a=$(t),r=$("replacedhead",a),d=$("replacedbody",a);e.adder(i+"-head",r.html()||""),e.adder(i+"-show",d.html()||""),e.adder(i+"-preview",a.html()),e.adder(i+"-wysiwyg",a.html()),r.children().detach(),r.html("\x3c!-- ko block: content --\x3e\x3c!-- /ko --\x3e"),r.before("\x3c!-- ko withProperties: { templateMode: 'head' } --\x3e"),r.after("\x3c!-- /ko --\x3e"),d.html("\x3c!-- ko block: content --\x3e\x3c!-- /ko --\x3e"),e.adder(i+"-iframe",a[0].outerHTML)}else"object"==typeof t?e.adder(i,t.outerHTML):e.adder(i,t);return i};function _viewModelPluginInstance(e){var t;return{viewModel:function(n){t=e(n)},init:function(){void 0!==t&&void 0!==t.init&&t.init()},dispose:function(){void 0!==t&&void 0!==t.dispose&&t.dispose()}}}var templateLoader=function(e,t,n,o,i,a){console.info("TEMPLATE LOADER");var r=ko.bindingHandlers.wysiwygSrc.templateUrlConverter,d=n;$.ajax({url:t,method:"GET",success:function(t,n,l){templateCompiler(e,r,"template",t,o,d,i,a).init()},error:function(e,t,n){console.error("cannot retrieve HTML data from template"),$(".mo-standalone").html("<h1>error</h1><h2>"+n+"</h2>")}})},templateCompiler=function(e,t,n,o,i,a,r,d){var l=o.match(/^([\S\s]*)([<]html[^>]*>[\S\s]*<\/html>)([\S\s]*)$/i);if(null===l)throw"Unable to find <html> opening and closing tags in the template";var s=l[1],c={"<html":0,"<head":0,"<body":0,"</html":0,"</body":0,"</head":0},u=l[2].replace(/(<\/?)(html|head|body)([^>]*>)/gi,function(e,t,n,o){return c[(t+n).toLowerCase()]+=1,t+"replaced"+n+o});for(var m in c)if(c.hasOwnProperty(m)&&1!=c[m]){if(0===c[m])throw"ERROR: missing mandatory element "+m+">";if(c[m]>1)throw"ERROR: multiple element "+m+"> occourences are not supported (found "+c[m]+" occourences)"}var p=l[3],b=[],h=[];if(void 0!==r)for(var g=0;g<r.length;g++)"function"==typeof r[g]?h.push(_viewModelPluginInstance(r[g])):h.push(r[g]);var v=[],f={adder:function(e,t){if("string"!=typeof t)throw"Template system: cannot create new template "+e;var n=t.match(/(data)?-ko-[^ =:]*/g);n&&console.error("ERROR: found unexpected -ko- attribute in compiled template",e,", you probably mispelled it:",n),templateSystem.addTemplate(e,t),v.push(e)},exists:function(e){return void 0!==templateSystem.getTemplateContent(e)},dispose:function(){for(var e=v.length-1;e>=0;e--)templateSystem.removeTemplate(v[e])}};ko.bindingHandlers.block.templateExists=f.exists;for(var y=templateCreator.bind(void 0,f),w=e("translateTemplate",templateConverter.translateTemplate.bind(void 0,n,u,t,y)),k=e("generateModel",templateConverter.wrappedResultModel.bind(void 0,w)),C={},x=pluginsCall(h,"widget",[$,ko,kojqui]),E=0;E<x.length;E++)C[x[E].widget]=x[E];b.push.apply(b,e("generateEditors",templateConverter.generateEditors.bind(void 0,w,C,t,y,"+$root.contentListeners()")));var S=!1;if(null!=i){var M;M="string"==typeof i?ko.utils.parseJson(i):i,2==e("checkModel",templateConverter.checkModel.bind(void 0,k._unwrap(),b,M))&&(console.error("Trying to compile an incompatible template version!",k._unwrap(),b,M),S=!0);try{k._wrap(M)}catch(e){console.error("Unable to inject model content!",e),S=!0}}var T=s+templateSystem.getTemplateContent(n+"-iframe").replace(/(<\/?)replaced(html|head|body)([^>]*>)/gi,function(e,t,n,o){return t+n+o})+p,L=ko.bindingHandlers.bindIframe.tpl;ko.bindingHandlers.bindIframe.tpl=T;var I={dispose:function(){ko.bindingHandlers.bindIframe.tpl=L}};h.push(I),h.push(f);var D=e("initializeViewmodel",initializeViewmodel.bind(this,k,b,t,d));D.metadata=a;return void 0!==D.metadata.editorversion&&"0.17.4"!==D.metadata.editorversion&&console.log("The model being loaded has been created with a different editor version",D.metadata.editorversion,"runtime:","0.17.4"),D.metadata.editorversion="0.17.4",void 0!==w.version&&(void 0!==D.metadata.templateversion&&D.metadata.templateversion!==w.version&&console.log("The model being loaded has been created with a different template version",D.metadata.templateversion,"runtime:",w.version),D.metadata.templateversion=w.version),templateSystem.init(),h.push(bindingPluginMaker(e)),pluginsCall(h,"viewModel",[D]),S&&$("#incompatible-template").dialog({modal:!0,appendTo:"#mo-body",buttons:{Ok:function(){$(this).dialog("close")}}}),{model:D,init:function(){pluginsCall(h,"init",void 0,!0)},dispose:function(){pluginsCall(h,"dispose",void 0,!0)}}},checkFeature=function(e,t){if(!t())throw console.warn("Missing feature",e),"Missing feature "+e},isCompatible=function(){try{return checkFeature("matchMedia",function(){return void 0!==global.matchMedia}),checkFeature("XMLHttpRequest 2",function(){return"XMLHttpRequest"in global&&"withCredentials"in new global.XMLHttpRequest}),checkFeature("ES5 strict",function(){return function(){return void 0===this}()}),checkFeature("CSS borderRadius",function(){return void 0!==global.document.body.style.borderRadius}),checkFeature("CSS boxShadow",function(){return void 0!==global.document.body.style.boxShadow}),checkFeature("CSS boxSizing",function(){return void 0!==global.document.body.style.boxSizing}),checkFeature("CSS backgroundSize",function(){return void 0!==global.document.body.style.backgroundSize}),checkFeature("CSS backgroundOrigin",function(){return void 0!==global.document.body.style.backgroundOrigin}),checkBadBrowserExtensions(),!0}catch(e){return!1}},checkBadBrowserExtensions=function(){var e="checkbadbrowsersframe",t=ko.bindingHandlers.bindIframe.tpl;ko.bindingHandlers.bindIframe.tpl='<!DOCTYPE html>\r\n<html>\r\n<head><title>A</title>\r\n</head>\r\n<body><p style="color: blue" align="right" data-bind="style: { color: \'red\' }">B</p><div data-bind="text: content"></div></body>\r\n</html>\r\n',$("body").append('<iframe id="'+e+'" data-bind="bindIframe: $data"></iframe>');var n=global.document.getElementById(e);ko.applyBindings({content:"dummy content"},n);var o=n.contentWindow.document.doctype,i="<!DOCTYPE "+o.name+(o.publicId?' PUBLIC "'+o.publicId+'"':"")+(!o.publicId&&o.systemId?" SYSTEM":"")+(o.systemId?' "'+o.systemId+'"':"")+">"+"\n"+n.contentWindow.document.documentElement.outerHTML;ko.cleanNode(n),ko.removeNode(n),ko.bindingHandlers.bindIframe.tpl=t;var a='<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p align="right" style="color: red;" data-bind="style: { color: \'red\' }">B</p><div data-bind="text: content">dummy content</div>\n\n</body></html>',r='<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p style="color: red;" data-bind="style: { color: \'red\' }" align="right">B</p><div data-bind="text: content">dummy content</div>\n\n</body></html>',d='<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p style="color: red;" align="right" data-bind="style: { color: \'red\' }">B</p><div data-bind="text: content">dummy content</div>\n\n</body></html>';if(a!==i&&r!==i&&d!==i)throw console.info("BadBrowser.FrameContentCheck",i.length,a.length,r.length,d.length,i==a,i==r,i==d),console.info(i),"Unexpected frame content. Misbehaving browser: "+i.length+"/"+a.length+"/"+r.length+"/"+d.length},fixPageEvents=function(){global.addEventListener&&(global.addEventListener("drag",function(e){(e=e||global.event).preventDefault()},!1),global.addEventListener("dragstart",function(e){(e=e||global.event).preventDefault()},!1),global.addEventListener("dragover",function(e){(e=e||global.event).preventDefault()},!1),global.addEventListener("drop",function(e){(e=e||global.event).preventDefault()},!1),global.document.body.addEventListener("drop",function(e){e.preventDefault()},!1)),global.document.ondragstart&&(global.document.ondragstart=function(){return!1})};module.exports={compile:templateCompiler,load:templateLoader,isCompatible:isCompatible,fixPageEvents:fixPageEvents};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./bindings/choose-template.js":46,"./converter/main.js":70,"./viewmodel.js":93,"console-browserify":3}],89:[function(require,module,exports){
"use strict";var console=require("console-browserify"),_call=function(e){return e()},logs=[],_timedCall=function(e,o){var t,l=(new Date).getTime();"object"==typeof console&&console.time&&console.time(e),t=_call(o),"object"==typeof console&&console.time&&console.timeEnd(e);var n=(new Date).getTime()-l;return"object"!=typeof console||console.time||"function"==typeof console.debug&&console.debug(e,"took",n,"ms"),logs.push({name:e,time:n}),logs.length>100&&logs.unshift(),t};module.exports={timedCall:_timedCall,logs:logs};

},{"console-browserify":3}],90:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,undoManager=require("./undomanager.js"),undoserializer=require("./undoserializer.js"),addUndoStackExtensionMaker=function(e){return function(n){n.contentListeners(n.contentListeners()+2);var o=undoManager(n.content,{levels:100,undoLabel:ko.computed(function(){return n.t("Undo (#COUNT#)")}),redoLabel:ko.computed(function(){return n.t("Redo")})});return n.undo=o.undoCommand,n.undo.execute=e.bind(n,"undo",n.undo.execute),n.redo=o.redoCommand,n.redo.execute=e.bind(n,"redo",n.redo.execute),n.undoReset=e.bind(n,"undoReset",o.reset),n.setUndoModeMerge=o.setModeMerge,n.setUndoModeOnce=o.setModeOnce,o.setModeIgnore(),o.setUndoActionMaker(undoserializer.makeUndoAction.bind(void 0,n.content)),undoserializer.watchEnabled(!0),{pause:function(){o.setModeIgnore()},run:function(){o.setModeOnce()},init:function(){o.setModeOnce()},dispose:function(){n.contentListeners(n.contentListeners()-2),undoserializer.watchEnabled(!1),o.dispose()}}}};module.exports=addUndoStackExtensionMaker;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./undomanager.js":91,"./undoserializer.js":92}],91:[function(require,module,exports){
(function (global){
"use strict";var ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,reactor=require("ko-reactor/dist/ko-reactor.min.js"),console=require("console-browserify"),undoManager=function(e,o){var n,t=ko.observableArray(),i=ko.observableArray(),r=0,d=0,l={levels:100,undoLabel:"undo (#COUNT#)",redoLabel:"redo (#COUNT#)"};o="object"==typeof o?ko.utils.extend(l,o):l;var u=function(e){1==r?a(e,i):2==r?a(e,t):0==r&&(a(e,t),i.removeAll())},a=function(e,t){if(t().length>0){var i=(r=t()[t().length-1],d=e,void 0!==r.mergedAction?r.mergedAction(d):null);if(null!==i)return void(t()[t().length-1]=i)}var r,d;t().length>=o.levels&&t.shift(),n=t,t.push(e)},c=function(e,o,t){return{name:ko.computed(function(){return ko.utils.unwrapObservable(e).replace(/#COUNT#/,t().length)}),enabled:ko.computed(function(){return 0!==t().length}),execute:function(){var e=t.pop();if(e){var i=r;r=o;var l=d;d=3,e(),s(n),d=l,r=i}return!0}}},s=function(e){if(void 0===e)throw"Unexpected operation: stack cleaner called with undefined stack";e().length>0&&void 0!==e()[e().length-1].mergedAction&&delete e()[e().length-1].mergedAction},f=function(e,o){var n=function(e,o){e(),o()}.bind(void 0,e,o);return void 0!==e.mergedAction&&(n.mergedAction=e.mergedAction),n},m=function(e,o,n){if(void 0!==o)e(o);else{if(!n)throw"Unexpected condition: no item and no child.oldValues!";if("deleted"==n.status)e.splice(n.index,0,n.value);else{if("added"!=n.status)throw"Unsupported item.status: "+n.status;e.splice(n.index,1)}}},v=function(e,o,n,t,i){return e.bind(void 0,n,t,i)},g=("function"==typeof reactor?reactor:ko.watch)(e,{depth:-1,oldValues:1,mutable:!0,tagFields:!0},function(e,o,n){var t=void 0!==o.oldValues?o.oldValues[0]:void 0,i=v(m,e,o,t,n);1!=d&&(3==d?void 0!==i&&(i.mergedAction=function(e){return void 0!==e.mergeMe&&e.mergeMe?f(e,this):null},i.mergeMe=!0):void 0!==i&&(o.oldValues&&2==d&&(i.mergedAction=function(e,o,n){return"object"==typeof n.mergeableAction&&e==n.mergeableAction.child?this:null}.bind(i,o,n),i.mergeableAction={child:o,item:n}),n&&"deleted"==n.status?i.mergedAction=function(e,o,n){return"object"==typeof n.mergeableMove&&o.value==n.mergeableMove.item.value?f(n,this):null}.bind(i,o,n):n&&"added"==n.status?i.mergeableMove={child:o,item:n}:n&&console.warn("Unsupported item.status",n.status)),void 0!==i&&u(i))},{});return{push:u,undoCommand:c(o.undoLabel,1,t),redoCommand:c(o.redoLabel,2,i),reset:function(){t.removeAll(),i.removeAll()},setModeOnce:function(){d=2,s(t)},setModeMerge:function(){d=3,s(t)},setModeNormal:function(){d=0,s(t)},setModeIgnore:function(){d=1,s(t)},setUndoActionMaker:function(e){v=e},dispose:function(){g.dispose()}}};module.exports=undoManager;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3,"ko-reactor/dist/ko-reactor.min.js":12}],92:[function(require,module,exports){
(function (global){
"use strict";var listener,watchEnabled,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify"),_reference=function(e,n){for(var t,o,r=0,a=e;r<n.length;)switch(n.charAt(r)){case"(":")"==n.charAt(r+1)&&(a=a()),r+=2;break;case"[":o=n.indexOf("]",r),a=a[n.substring(r+1,o)],r=o+1;break;case".":-1==(t=n.indexOf("(",r))&&(t=n.length),-1==(o=n.indexOf("[",r))&&(o=n.length),o=Math.min(t,o),a=a[n.substring(r+1,o)],r=o}return a},_getPath=function(e,n){for(var t,o="",r=0;r<=e.length;r++)if(t=r<e.length?e[r]:n,ko.isObservable(t)&&(o+="()"),void 0!==t._fieldName)o+="."+t._fieldName;else{if(!(r>0&&"function"==typeof e[r-1].pop))throw console.error("Unexpected parent with no _fieldName and no parent array",r,e),"Unexpected parent with no _fieldName and no parent array";var a=ko.isObservable(e[r-1])?ko.utils.peekObservable(e[r-1]):e[r-1],i=ko.utils.arrayIndexOf(a,t);if(-1==i)throw console.error("Unexpected object not found in parent array",a,t,r,e.length,ko.toJS(a),ko.utils.unwrapObservable(t)),"Unexpected object not found in parent array";o+="["+i+"]"}return o},makeDereferencedUndoAction=function(e,n,t,o,r){e(_reference(n,t),o,r)},_setListener=function(e){listener=e},makeUndoActionDereferenced=function(e,n,t,o,r,a){try{var i=_getPath(t,o);if("object"!=typeof r&&"function"!=typeof r||(r=ko.toJS(r)),void 0!==a&&("object"==typeof a.value||"function"==typeof a.value))a=ko.toJS(a);if(void 0!==listener)try{listener(i,o,r,a)}catch(e){console.log("Undoserializer ignoring exception in listener callback")}return makeDereferencedUndoAction.bind(void 0,n,e,i,r,a)}catch(e){console.error("Exception processing undo",e,t,o,a)}},_watchEnabled=function(e){if(void 0===e)return watchEnabled;watchEnabled=e};module.exports={dereference:_getPath,reference:_reference,makeUndoAction:makeUndoActionDereferenced,setListener:_setListener,watchEnabled:_watchEnabled};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"console-browserify":3}],93:[function(require,module,exports){
(function (global){
"use strict";var $="undefined"!=typeof window?window.jQuery:"undefined"!=typeof global?global.jQuery:null,ko="undefined"!=typeof window?window.ko:"undefined"!=typeof global?global.ko:null,console=require("console-browserify"),performanceAwareCaller=require("./timed-call.js").timedCall,toastr=require("toastr");function initializeEditor(e,o,t,l){var r={galleryRecent:ko.observableArray([]),galleryRemote:ko.observableArray([]),selectedBlock:ko.observable(null),selectedItem:ko.observable(null),selectedTool:ko.observable(0),selectedImageTab:ko.observable(0),dragging:ko.observable(!1),draggingImage:ko.observable(!1),galleryLoaded:ko.observable(!1),showPreviewFrame:ko.observable(!1),previewMode:ko.observable("mobile"),showToolbox:ko.observable(!0),showTheme:ko.observable(!1),showGallery:ko.observable(!1),debug:ko.observable(!1),contentListeners:ko.observable(0),logoPath:"rs/img/mosaico32.png",logoUrl:".",logoAlt:"mosaico"};return r.content=e,r.blockDefs=o,r.notifier=toastr,r.tt=function(e,o){if(void 0!==o)for(var t in o)o.hasOwnProperty(t)&&(e=e.replace(new RegExp("__"+t+"__","g"),o[t]));return e},r.t=r.tt,r.ut=function(e,o){return o},r.templatePath=t,r.remoteUrlProcessor=function(e){return e},r.remoteFileProcessor=function(e){return void 0!==e.url&&(e.url=r.remoteUrlProcessor(e.url)),void 0!==e.thumbnailUrl&&(e.thumbnailUrl=r.remoteUrlProcessor(e.thumbnailUrl)),e},r.loadGallery=function(){r.galleryLoaded("loading");var e=l||"/upload/";$.getJSON(e,function(e){for(var o=0;o<e.files.length;o++)e.files[o]=r.remoteFileProcessor(e.files[o]);r.galleryLoaded(e.files.length),r.galleryRemote(e.files.reverse())}).fail(function(){r.galleryLoaded(!1),r.notifier.error(r.t("Unexpected error listing files"))})},r.fileToImage=function(e,o,t){return e.url},r.removeBlock=function(e,o){ko.utils.unwrapObservable(r.selectedBlock)==ko.utils.unwrapObservable(e)&&r.selectBlock(null,!0);var t=o.blocks.remove(e);return r.notifier.info(r.t("Block removed: use undo button to restore it...")),t},r.duplicateBlock=function(e,o){var t=ko.utils.unwrapObservable(e),l=ko.toJS(ko.utils.unwrapObservable(o.blocks)[t]);void 0!==l.id&&(l.id=""),o.blocks.splice(t+1,0,l)},r.moveBlock=function(e,o,t){var l=ko.utils.unwrapObservable(e),n=ko.utils.unwrapObservable(o.blocks);if(t&&l>0||!t&&l<n.length-1){var a=l+(t?-1:1),c=n[a];r.startMultiple(),o.blocks.splice(a,1),o.blocks.splice(l,0,c),r.stopMultiple()}},r.loadDefaultBlocks=function(){var e=ko.toJS(r.content().mainBlocks);e.blocks=[];for(var o=ko.utils.unwrapObservable(r.blockDefs),t=0;t<o.length;t++){var l=ko.toJS(o[t]);l.id="block_"+t,e.blocks.push(l)}performanceAwareCaller("setMainBlocks",r.content().mainBlocks._wrap.bind(r.content().mainBlocks,e))},r.addImage=function(e){var o=$("#main-wysiwyg-area .selectable-img.selecteditem");return 1==o.length&&"object"==typeof e&&void 0!==e.url&&(ko.contextFor(o[0])._src(e.url),!0)},r.addBlock=function(e,o){var t,l,n=r.selectedBlock();if(null!==n)for(var a=r.content().mainBlocks().blocks().length-1;a>=0;a--)if(r.content().mainBlocks().blocks()[a]()==n){t=a;break}void 0!==t?(l=t+1,r.content().mainBlocks().blocks.splice(l,0,e),r.notifier.info(r.t("New block added after the selected one (__pos__)",{pos:l}))):(r.content().mainBlocks().blocks.push(e),l=r.content().mainBlocks().blocks().length-1,r.notifier.info(r.t("New block added at the model bottom (__pos__)",{pos:l})));var c=r.content().mainBlocks().blocks()[l]();return r.selectBlock(c,!0),!1},r.findObjectsOfType=function(e,o){var t=[],l=ko.utils.unwrapObservable(e);for(var r in l)if(l.hasOwnProperty(r)){var n=ko.utils.unwrapObservable(l[r]);if(r.match(/Blocks$/))for(var a=ko.utils.unwrapObservable(n.blocks),c=0;c<a.length;c++){var i=ko.utils.unwrapObservable(a[c]);null!==o&&ko.utils.unwrapObservable(i.type)!=o||t.push(i)}else"object"==typeof n&&null!==n&&(null!==o&&ko.utils.unwrapObservable(n.type)!=o||t.push(n))}return t},r.placeholderHelper={element:function(e){return $(e[0].outerHTML).removeClass("ui-draggable").addClass("sortable-placeholder").css("display","block").css("position","relative").css("width","100%").css("height","auto").css("opacity",".8")[0]},update:function(e,o){}},r.startMultiple=function(){void 0!==r.setUndoModeMerge&&r.setUndoModeMerge()},r.stopMultiple=function(){void 0!==r.setUndoModeOnce&&r.setUndoModeOnce()},r.localGlobalSwitch=function(e,o){var t=e();return e(null===t?o():null),!1},r.selectItem=function(e,o,t){var l=ko.utils.peekObservable(e);return void 0!==t&&r.selectBlock(t,!1,!0),l!=o&&(e(o),null!==o&&0===r.selectedTool()&&r.selectedTool(1)),!1}.bind(r,r.selectedItem),r.isSelectedItem=function(e){return r.selectedItem()==e},r.selectBlock=function(e,o,t,l){var n=ko.utils.peekObservable(e);l||r.selectItem(null),n!=o&&(e(o),r.showGallery(!1),null===o||t||0!==r.selectedTool()||r.selectedTool(1))}.bind(r,r.selectedBlock),r.countSubscriptions=function(e,o){var t=0;for(var l in e)if(e.hasOwnProperty(l)){var n=e[l];if(ko.isObservable(n)&&(void 0!==n._defaultComputed&&(void 0!==o&&console.log(o+"/"+l+"/_",n._defaultComputed.getSubscriptionsCount()),t+=n._defaultComputed.getSubscriptionsCount()),void 0!==o&&console.log(o+"/"+l+"/-",n.getSubscriptionsCount()),t+=n.getSubscriptionsCount(),n=ko.utils.unwrapObservable(n)),"object"==typeof n&&null!==n){var a=r.countSubscriptions(n,void 0!==o?o+"/"+l+"@":void 0);void 0!==o&&console.log(o+"/"+l+"@",a),t+=a}}return t},r.loopSubscriptionsCount=function(){var e=r.countSubscriptions(r.content());global.document.getElementById("subscriptionsCount").innerHTML=e,global.setTimeout(r.loopSubscriptionsCount,1e3)},r.export=function(){return performanceAwareCaller("exportHTML",r.exportHTML)},r.exportHTML=function(){console.log("viewModel.exportHTML");var e="exportframe";$("body").append('<iframe id="'+e+'" data-bind="bindIframe: $data"></iframe>');var o=global.document.getElementById(e);ko.applyBindings(r,o),ko.cleanNode(o),r.inline&&r.inline(o.contentWindow.document);var t=o.contentWindow.document.doctype,l="<!DOCTYPE "+t.name+(t.publicId?' PUBLIC "'+t.publicId+'"':"")+(!t.publicId&&t.systemId?" SYSTEM":"")+(t.systemId?' "'+t.systemId+'"':"")+">"+"\n"+o.contentWindow.document.documentElement.outerHTML;ko.removeNode(o),l=(l=(l=(l=(l=(l=(l=(l=(l=(l=(l=(l=(l=l.replace(/<script ([^>]* )?type="text\/html"[^>]*>[\s\S]*?<\/script>/gm,"")).replace(/<!-- ko ((?!--).)*? -->/g,"")).replace(/<!-- \/ko -->/g,"")).replace(/ data-bind="[^"]*"/gm,"")).replace(/ data-mce-(href|src|style)="[^"]*"/gm,"")).replace(/ style="[^"]*"([^>]*) replaced(style="[^"]*")/gm,"$1 $2")).replace(/ replaced(style="[^"]*")([^>]*) style="[^"]*"/gm," $1$2")).replace(/ replaced(style="[^"]*")/gm," $1")).replace(/ http-equiv="[^"]*"([^>]*) replaced(http-equiv="[^"]*")/gm,"$1 $2")).replace(/ replaced(http-equiv="[^"]*")([^>]*) http-equiv="[^"]*"/gm," $1$2")).replace(/ replaced(http-equiv="[^"]*")/gm," $1")).replace(/&lt;%/g,"<%")).replace(/%&gt;/g,"%>");var n=(l=l.replace(/<replacedcc[^>]* condition="([^"]*)"[^>]*>([\s\S]*?)<\/replacedcc>/g,function(e,o,t){var l="\x3c!--[if "+o.replace(/&amp;/,"&")+"]>";return l+=t.replace(/<!-- cc:bc:([A-Za-z:]*) -->(<\/cc>)?<!-- cc:ac:\1 -->/g,"</$1>").replace(/><\/cc><!-- cc:sc -->/g,"/>").replace(/<!-- cc:bo:([A-Za-z:]*) --><cc/g,"<$1").replace(/^.*<!-- cc:start -->/,"").replace(/<!-- cc:end -->.*$/,""),l+="<![endif]--\x3e"})).match(/ data-[^ =]+(="[^"]+")? /)||l.match(/ replaced([^= ]*=)/);return n&&console.warn("Output HTML contains unexpected data- attributes or replaced attributes",n),l},r.exportHTMLtoTextarea=function(e){$(e).val(r.exportHTML())},r.exportJSONtoTextarea=function(e){$(e).val(r.exportJSON())},r.importJSONfromTextarea=function(e){r.importJSON($(e).val())},r.exportMetadata=function(){return ko.toJSON(r.metadata)},r.exportJSON=function(){return ko.toJSON(r.content)},r.exportJS=function(){return ko.toJS(r.content)},r.importJSON=function(e){var o=ko.utils.parseJson(e);r.content._wrap(o)},r.exportTheme=function(){var e={},o=r.content().theme(),t=function(e,o,l){for(var r in l)if(l.hasOwnProperty(r)){var n=ko.utils.unwrapObservable(l[r]);null!==n&&"object"==typeof n?t(r+".",o,n):o[e+r]=n}};t("",e,o);var l="";for(var n in e)e.hasOwnProperty(n)&&"type"!=n&&(l+=n+": "+e[n]+";\n");return l},r.loadImage=function(e){r.galleryRecent.unshift(e),r.selectedImageTab(0)},r.selectImage=function(e){r.showGallery(!0)},r.dialog=function(e,o){$(e).dialog(o)},r.log=function(e,o){},r}toastr.options={closeButton:!1,debug:!1,positionClass:"toast-bottom-full-width",target:"#mo-body",onclick:null,showDuration:"300",hideDuration:"1000",timeOut:"5000",extendedTimeOut:"1000",showEasing:"swing",hideEasing:"linear",showMethod:"fadeIn",hideMethod:"fadeOut"},module.exports=initializeEditor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./timed-call.js":89,"console-browserify":3,"toastr":30}]},{},[43,1])(43)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC90ZW1wbGF0ZXMuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0ZS1ub3cvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZvbC1jb2xvcnBpY2tlci9qcy9ldm9sLWNvbG9ycGlja2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzZXAvYnVpbGQvanNlcC5qcyIsIm5vZGVfbW9kdWxlcy9qdWljZS9saWIvaW5saW5lLmpzIiwibm9kZV9tb2R1bGVzL2p1aWNlL2xpYi9wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9qdWljZS9saWIvc2VsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvanVpY2UvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2tub2Nrb3V0LXNvcnRhYmxlL2J1aWxkL2tub2Nrb3V0LXNvcnRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2tvLXJlYWN0b3IvZGlzdC9rby1yZWFjdG9yLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmZpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLm9taXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVuc2NoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lbnNjaC9saWIvZGVidWcuanMiLCJub2RlX21vZHVsZXMvbWVuc2NoL2xpYi9sZXhlci5qcyIsIm5vZGVfbW9kdWxlcy9tZW5zY2gvbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9tZW5zY2gvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zbGljay9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvc3BlYWtpbmd1cmwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3BlYWtpbmd1cmwvbGliL3NwZWFraW5ndXJsLmpzIiwibm9kZV9tb2R1bGVzL3Rpbnljb2xvcjIvdGlueWNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL3RvYXN0ci90b2FzdHIuanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNCeXRlTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNFbWFpbC5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzRlFETi5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVAuanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi91dGlsL2Fzc2VydFN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3V0aWwvbWVyZ2UuanMiLCJzaGFyZWQvc2x1Zy1maWxlbmFtZS5qcyIsInNyYy9qcy9hcHAuanMiLCJzcmMvanMvYmluZGluZ3MvYmluZC1pZnJhbWUuanMiLCJzcmMvanMvYmluZGluZ3MvYmxvY2tzLmpzIiwic3JjL2pzL2JpbmRpbmdzL2Nob29zZS10ZW1wbGF0ZS5qcyIsInNyYy9qcy9iaW5kaW5ncy9jb2xvcnBpY2tlci5qcyIsInNyYy9qcy9iaW5kaW5ncy9jc3N0ZXh0LmpzIiwic3JjL2pzL2JpbmRpbmdzL2V2ZW50YWJsZS5qcyIsInNyYy9qcy9iaW5kaW5ncy9leHRkcm9wcGFibGUuanMiLCJzcmMvanMvYmluZGluZ3MvZXh0ZW5kZXItcGFnaW5hdGlvbi5qcyIsInNyYy9qcy9iaW5kaW5ncy9leHRzb3J0YWJsZXMuanMiLCJzcmMvanMvYmluZGluZ3MvZmlsZXVwbG9hZC5qcyIsInNyYy9qcy9iaW5kaW5ncy9pZi1zdWJzLmpzIiwic3JjL2pzL2JpbmRpbmdzL2pxdWVyeXVpLXNwaW5uZXIuanMiLCJzcmMvanMvYmluZGluZ3MvanF1ZXJ5dWktdGFicy5qcyIsInNyYy9qcy9iaW5kaW5ncy9wcmVsb2FkZXIuanMiLCJzcmMvanMvYmluZGluZ3Mvc2NyaXB0LXRlbXBsYXRlLmpzIiwic3JjL2pzL2JpbmRpbmdzL3Njcm9sbGZpeC5qcyIsInNyYy9qcy9iaW5kaW5ncy9zY3JvbGxpbnRvdmlldy5qcyIsInNyYy9qcy9iaW5kaW5ncy9zdHJpbmctdGVtcGxhdGUuanMiLCJzcmMvanMvYmluZGluZ3MvdG9vbHRpcHMuanMiLCJzcmMvanMvYmluZGluZ3MvdmFsaWRhdGVkLXZhbHVlLmpzIiwic3JjL2pzL2JpbmRpbmdzL3ZpcnR1YWxzLmpzIiwic3JjL2pzL2JpbmRpbmdzL3d5c2l3eWdzLmpzIiwic3JjL2pzL2NvbnZlcnRlci9jaGVja21vZGVsLmpzIiwic3JjL2pzL2NvbnZlcnRlci9kZWNsYXJhdGlvbnMuanMiLCJzcmMvanMvY29udmVydGVyL2RvbXV0aWxzLmpzIiwic3JjL2pzL2NvbnZlcnRlci9lZGl0b3IuanMiLCJzcmMvanMvY29udmVydGVyL21haW4uanMiLCJzcmMvanMvY29udmVydGVyL21vZGVsLmpzIiwic3JjL2pzL2NvbnZlcnRlci9wYXJzZXIuanMiLCJzcmMvanMvY29udmVydGVyL3N0eWxlc2hlZXQuanMiLCJzcmMvanMvY29udmVydGVyL3V0aWxzLmpzIiwic3JjL2pzL2NvbnZlcnRlci93cmFwcGVyLmpzIiwic3JjL2pzL2V4dC9jb2xvci5qcyIsInNyYy9qcy9leHQvY3VzdG9tLWVkaXQtdGl0bGUuanMiLCJzcmMvanMvZXh0L2N1c3RvbS1leHRlbnNpb25zLmpzIiwic3JjL2pzL2V4dC9jdXN0b20tZ2FsbGVyeS5qcyIsInNyYy9qcy9leHQvY3VzdG9tLXJlbW92ZS1nYWxsZXJ5LWltYWdlLmpzIiwic3JjL2pzL2V4dC9jdXN0b20tc2VydmVyLXN0b3JhZ2UuanMiLCJzcmMvanMvZXh0L2N1c3RvbS10ZXh0LWVkaXRvci5qcyIsInNyYy9qcy9leHQvY3VzdG9tLXdpZGdldC1iZ2ltYWdlLmpzIiwic3JjL2pzL2V4dC9pbmxpbmVyLmpzIiwic3JjL2pzL2V4dC9sb2NhbHN0b3JhZ2UuanMiLCJzcmMvanMvZXh0L3V0aWwuanMiLCJzcmMvanMva28tYmluZGluZ3MuanMiLCJzcmMvanMvdGVtcGxhdGUtbG9hZGVyLmpzIiwic3JjL2pzL3RpbWVkLWNhbGwuanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb21haW4uanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb21hbmFnZXIuanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb3NlcmlhbGl6ZXIuanMiLCJzcmMvanMvdmlld21vZGVsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaDlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM3FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7QUNGQSxhQUVBLElBQUksRUFBSixvQkFBc0IsT0FBdEIsT0FBQSxPQUFBLG9CQUFBLE9BQUEsT0FBQSxPQUFBLEtBQ0ksR0FBSixvQkFBc0IsT0FBdEIsT0FBQSxHQUFBLG9CQUFBLE9BQUEsT0FBQSxHQUFBLEtBQ0ksUUFBVSxRQUFRLHNCQUV0QixTQUFTLGtCQUFrQixHQUN6QixJQUFJLEVBQ0osRUFBVSxVQUFvQixHQUFHLFdBQVcsUUFDNUMsRUFBVSxTQUFTLEtBQVcsR0FBRyxXQUFXLEVBQVUsU0FBUyxNQUUvRCxFQUFVLFlBQW9CLEdBQUcsU0FBUyxXQUN4QyxPQUFPLEVBQVUsU0FBUyxRQUN6QixHQUVILEVBQVUsc0JBQXlCLFNBQVUsRUFBTSxHQUNqRCxRQUFRLElBQUksd0JBQXlCLEdBQ3JDLEVBQWdCLEVBQVUsU0FBUyxPQUNuQyxFQUFVLFVBQVUsU0FHdEIsRUFBVSxzQkFBeUIsU0FBVSxFQUFNLEdBQ2pELFFBQVEsSUFBSSx5QkFDWixFQUFVLFNBQVMsS0FBSyxHQUN4QixFQUFnQixHQUNoQixFQUFVLFVBQVUsU0FHdEIsRUFBVSxvQkFBdUIsU0FBVSxFQUFNLEdBQy9DLFFBQVEsSUFBSSxzQkFBdUIsRUFBVSxTQUFTLFFBQ3RELEVBQVUsVUFBVSxVQUNwQixFQUFVLFNBQVMsS0FBSyxFQUFVLEVBQUUsNEJBRXBDLEVBQUUsS0FBSyxDQUNMLE9BQVEsT0FDUixJQUFRLEVBQVUsU0FBUyxJQUFJLE9BQy9CLEtBQVEsQ0FDTixLQUFNLEVBQVUsU0FBUyxRQUUzQixRQUFTLFNBQVUsR0FDakIsRUFBVSxTQUFTLEtBQU0sRUFBZSxLQUFLLE1BQzdDLEVBQVUsU0FBUyxRQUFRLEVBQVUsRUFBRSw2QkFFekMsTUFBTyxXQUNMLEVBQVUsU0FBUyxNQUFNLEVBQVUsRUFBRSwwQkFFdkMsU0FBVSxXQUNSLEVBQWdCLEdBQ2hCLEVBQVUsVUFBVSxZQU01QixPQUFPLFFBQVU7Ozs7OztBQ3REakIsYUFFQSxJQUFJLEdBQUosb0JBQWlCLE9BQWpCLE9BQUEsR0FBQSxvQkFBQSxPQUFBLE9BQUEsR0FBQSxLQUNJLElBQU0sUUFBUSxPQUNkLGFBQWUsUUFBUSxvQ0FRckIsY0FBZ0IsUUFBUSwyQkFDeEIsVUFBWSxRQUFRLHVCQUN0QixXQUFhLFFBQVEsd0JBQ25CLFFBQVUsUUFBUSxvQkFDbEIsWUFBYyxRQUFRLGlDQUd0QixjQUFnQixRQUFRLDJCQUV4QixjQUFnQixTQUFBLEdBQUEsT0FBUSxTQUFBLEdBQzVCLEVBQVUsVUFBVyxFQUNyQixFQUFVLFNBQVUsRUFDcEIsRUFBVSxTQUFVLEVBQ3BCLEVBQVUsVUFBWSxFQUFLLFlBRzdCLFNBQVMsZ0JBQWdCLEVBQU0sR0FDN0IsRUFBaUIsS0FBSyxlQUN0QixFQUFpQixLQUFLLGNBQWMsSUFDcEMsRUFBaUIsS0FBSyxXQUN0QixFQUFpQixLQUFLLFFBQVEsSUFDOUIsRUFBaUIsS0FBSyxhQUd0QixFQUFpQixLQUFLLGNBQWMsSUFPdEMsU0FBUyxxQkFBcUIsR0FDNUIsSUFBSSxFQUFTLEVBQUssU0FBUyxRQUFVLEdBQ3JDLE9BQU8sU0FBb0MsR0FDekMsSUFBSyxFQUFLLE9BQU8sS0FHakIsR0FGQSxRQUFRLElBQUksNkJBQThCLEdBRXRDLE1BQU0sS0FBSyxHQUFNLE9BQU8sS0FFNUIsR0FBSSxRQUFRLEtBQUssR0FBTSxPQUFPLEtBRTlCLEdBQUksS0FBSyxLQUFLLEdBQU0sT0FBTyxLQVMzQixPQUpBLEVBSGdCLFlBR0EsS0FBSyxHQUFLLEdBRkosZUFNRCxLQUFLLElBQzFCLFFBQVEsSUFBSSw2QkFBOEIsR0FNMUMsRUFBTSxhQUFhLEdBQ25CLEVBQU0sRUFBTyxHQUFPLEVBQUssb0JBQXNCLEVBQU8sR0FBTyxNQVJ0QixNQWlCM0MsU0FBUyxlQUFlLEdBSUosT0FBZCxFQUFLLE9BQ1AsV0FBVyxhQUFlLDBCQUMxQixXQUFXLFNBQVcsUUFDdEIsUUFBUSxLQUFLLEtBQUssSUFBSSxRQUFTLENBQzdCLE9BQVEsVUFDUixXQUFZLFdBQ1osb0JBQXFCLDhCQUNyQixpQkFBa0IsZ0JBQ2xCLFlBQWEsbUJBQ2IsY0FBZSxZQUNmLG9CQUFxQix1QkFDckIsY0FBZSxzQkFJbkIsV0FBYSxFQUFFLE9BQU8sQ0FBRSxjQUFjLEdBQVMsV0FBWSxFQUFLLFNBQ2hFLEdBQUcsZ0JBQWdCLFFBQVEsWUFBYyxXQUd6QyxHQUFHLGdCQUFnQixRQUFRLGdCQUFrQixDQUMzQyxjQUFjLEVBQ2QsaUJBQWtCLENBQ2hCLE1BQU8sV0FBVyxpQkFBaUIsT0FFckMsVUFBVyxXQUFXLFVBQ3RCLFNBQVUsV0FBVyxVQVV2QixHQUFHLGdCQUFnQixXQUFXLHFCQUF1QixxQkFDbkQsR0FJRixJQUFJLEVBQXNCLElBQUksTUFBTSxFQUFLLHFCQUd6QyxHQUFHLGdCQUFnQixXQUFXLHVCQUF5QixTQUFTLEdBQzlELFFBQVEsS0FBSyw0QkFDYixRQUFRLElBQUksR0FDWixJQUFJLEVBQVUsSUFBSSxPQUFPLENBQ3ZCLFNBQVUsRUFBb0IsU0FDOUIsS0FBTSxFQUFvQixLQUMxQixTQUFVLEVBQW9CLFdBR2hDLE9BREEsRUFBSyxJQUFNLElBQUksUUFBUSxFQUFTLElBQUksTUFBTSxFQUFLLEtBQUssVUFDN0MsR0FJVCxHQUFHLGdCQUFnQixXQUFXLGFBQWUsU0FDM0MsRUFDQSxFQUNBLEVBQ0EsR0FFQSxJQUFJLEVBQVksSUFBSSxNQUFNLEdBQUssU0FDMUIsR0FBVyxRQUFRLEtBQUssd0JBQXlCLEdBQ3RELFFBQVEsS0FBSyxnQkFBaUIsRUFBVyxFQUFRLEVBQU8sR0FDeEQsRUFBWSxFQUFVLFFBQVEsUUFBUyxJQUN2QyxJQUFJLEVBQU8sRUFBSyxTQUFXLElBQU0sRUFFakMsT0FEQSxFQUFPLEVBQU8sSUFBTSxFQUFRLElBQU0sRUFBUyxJQUFNLEdBSW5ELEdBQUcsZ0JBQWdCLFdBQVcsZUFBaUIsU0FBUyxFQUFPLEVBQVEsR0FFckUsT0FBTyxFQUFLLFNBQVcsZ0JBQWtCLEVBQVEsSUFBTSxFQUFTLFFBSXBFLE9BQU8sUUFBVSxDQUNmLGdCQUFBLGdCQUNBLGVBQUE7Ozs7OztBQ2xLRixhQUVBLElBQUksUUFBVSxRQUFRLHNCQUNsQixFQUFKLG9CQUFzQixPQUF0QixPQUFBLE9BQUEsb0JBQUEsT0FBQSxPQUFBLE9BQUEsS0FDSSxHQUFKLG9CQUFzQixPQUF0QixPQUFBLEdBQUEsb0JBQUEsT0FBQSxPQUFBLEdBQUEsS0FDSSxNQUFVLFFBQVEsZUFFdEIsU0FBUyxjQUFlLEdBRXRCLElBQUksRUFBYSxFQUFLLGlCQUFpQixJQUV2QyxPQUFPLFNBQVUsR0FPZixTQUFTLEVBQWEsR0FDcEIsSUFBSSxFQUFXLEVBQVksR0FDdkIsRUFBVyxFQUFXLEVBQU8sV0FDN0IsRUFBVyxFQUFXLEVBQU8saUJBQ2pDLE9BQU8sV0FDTCxFQUFPLFdBRVAsRUFBRSxRQUFRLEVBQUssU0FBVyxHQUN4QixJQUFLLElBQUksRUFBSSxFQUFHLEVBQUksRUFBSyxNQUFNLE9BQVEsSUFBSyxFQUFLLE1BQU0sR0FBSyxFQUFVLG9CQUFvQixFQUFLLE1BQU0sSUFDckcsRUFBUSxFQUFLLE1BQU0sUUFDbkIsRUFBUyxFQUFLLE1BQU0sYUFDbkIsS0FBSyxXQUNOLEdBQVEsR0FDUixFQUFVLFNBQVMsTUFBTSxFQUFVLEVBQUUsc0NBUzNDLFNBQVMsRUFBVyxHQUNsQixJQUFJLEVBQVcsRUFBVyxFQUFPLFdBQzdCLEVBQVcsRUFBVyxFQUFPLGlCQUNqQyxPQUFPLFNBQVcsR0FDaEIsSUFBSSxFQUFvQixFQUFJLEtBR0osTUFBTyxJQUFXLFNBQVUsR0FDbEQsT0FBTyxFQUFLLE9BQVMsTUFNTCxJQUFiLE1BQ0wsRUFBUSxRQUFTLEdBQ2pCLEVBQVEsSUFBVSxVQTNDdEIsRUFBVSxlQUF3QixHQUFHLGdCQUFnQixJQUNyRCxFQUFVLGdCQUF3QixHQUFHLGdCQUFnQixJQUNyRCxFQUFVLHFCQUF3QixHQUFHLFlBQVcsR0FDaEQsRUFBVSxzQkFBd0IsR0FBRyxZQUFXLEdBNENoRCxFQUFVLG1CQUF3QixFQUFhLFdBQy9DLEVBQVUsb0JBQXdCLEVBQWEsWUFDL0MsRUFBVSxpQkFBd0IsRUFBVyxXQUM3QyxFQUFVLGtCQUF3QixFQUFXLFlBRTdDLElBQU0sRUFBYyxFQUFVLFlBQVksVUFBVyxTQUFBLElBQ2xDLElBQWIsSUFBMEQsSUFBckMsRUFBVSx5QkFDakMsRUFBVSxxQkFDVixFQUFZLGFBSVYsRUFBWSxFQUFVLGlCQUFpQixVQUFXLFNBQUEsR0FDckMsSUFBYixJQUF3RCxJQUF0QyxFQUFVLDBCQUM5QixFQUFVLHNCQUNWLEVBQVUsWUFFWCxFQUFXLFdBTWxCLE9BQU8sUUFBVTs7Ozs7O0FDbkZqQixhQUVBLElBQUksUUFBVSxRQUFRLHNCQUNsQixFQUFKLG9CQUFzQixPQUF0QixPQUFBLE9BQUEsb0JBQUEsT0FBQSxPQUFBLE9BQUEsS0FDSSxHQUFKLG9CQUFzQixPQUF0QixPQUFBLEdBQUEsb0JBQUEsT0FBQSxPQUFBLEdBQUEsS0FFQSxTQUFTLG1CQUFvQixHQUUzQixFQUFVLFlBQWMsU0FBVSxFQUFNLEVBQU0sR0FDNUMsSUFBSSxFQUFZLEVBQUssVUFFckIsRUFBRSxLQUFLLENBQ0wsSUFBUSxFQUNSLE9BQVEsU0FJUixLQUFRLFNBQ1IsUUFBUyxTQUFVLEdBQ2pCLEVBQVUsU0FBUyxRQUFRLEVBQVUsRUFBRSxpQ0FDdkMsSUFBSSxFQUFXLEVBQVcsRUFBTyxZQUVqQyxFQURlLEVBQVcsRUFBTyxrQkFDekIsRUFBSSxNQUFNLFFBQ2xCLEVBQVMsRUFBSSxNQUFNLFlBRXJCLE1BQU8sU0FBVSxHQUNmLFFBQVEsSUFBSSxHQUNaLEVBQVUsU0FBUyxNQUFNLEVBQVUsRUFBRSxrQ0FPN0MsT0FBTyxRQUFVOzs7Ozs7QUNsQ2pCLGFBRUEsSUFBSSxRQUFVLFFBQVEsc0JBQ2xCLEVBQUosb0JBQWdCLE9BQWhCLE9BQUEsT0FBQSxvQkFBQSxPQUFBLE9BQUEsT0FBQSxLQUNJLEdBQUosb0JBQWlCLE9BQWpCLE9BQUEsR0FBQSxvQkFBQSxPQUFBLE9BQUEsR0FBQSxLQUNJLE1BQVEsUUFBUSxlQUNoQixRQUFVLFFBQVEseUJBRXRCLFNBQVMsUUFBUSxHQUdmLElBQUksRUFBUSxNQUFNLEdBQUcsS0FBSyxFQUFVLFVBQVcsQ0FBQyxlQUFnQixhQUVoRSxPQURBLEVBQU0sS0FBTyxFQUFVLFdBQ2hCLEVBR1QsSUFBSSxPQUFTLFNBQVMsR0FDcEIsUUFBUSxLQUFLLDhDQU1iLElBQUksRUFBVSxDQUNaLEtBQU0sT0FDTixRQUFTLEdBQUcsWUFBVyxHQUV6QixRQUFrQixXQUNoQixFQUFRLFNBQVEsR0FDaEIsSUFBSSxFQUFPLFFBQVEsR0FDbkIsUUFBUSxLQUFLLGFBQ2IsUUFBUSxJQUFJLEdBSVosRUFBRSxLQUFLLENBQ0wsSUFBSyxPQUFPLFNBQVMsS0FDckIsT0FBUSxPQUNSLFlBQWEsbUJBQ2IsS0FBTSxLQUFLLFVBQVUsR0FDckIsUUFPRixTQUF1QixFQUFNLEVBQVksR0FDdkMsUUFBUSxJQUFJLGdCQUNaLEVBQVUsU0FBUyxRQUFRLEVBQVUsRUFBRSwwQkFSdkMsTUFXRixTQUFxQixFQUFPLEVBQVksR0FDdEMsUUFBUSxJQUFJLGNBQ1osUUFBUSxJQUFJLEdBQ1osRUFBVSxTQUFTLE1BQU0sRUFBVSxFQUFFLHdCQWJyQyxTQWdCRixXQUNFLEVBQVEsU0FBUSxRQVFoQixFQUFVLENBQ1osS0FBTSxPQUNOLFFBQVMsR0FBRyxZQUFXLEdBRXpCLFFBQWtCLFdBQ2hCLFFBQVEsS0FBSyxRQUNiLFFBQVEsSUFBSSxFQUFVLFNBQVMsSUFBSSxNQUNuQyxFQUFRLFNBQVEsR0FDaEIsSUFBSSxFQUFRLEVBQVUsRUFBRSwyQ0FJeEIsS0FIQSxFQUFRLE9BQU8sT0FBTyxFQUFVLEVBQUUsc0JBQXVCLElBRzdDLE9BQU8sRUFBUSxTQUFRLEdBRW5DLElBQUssUUFBUSxHQUVYLE9BREEsT0FBTyxNQUFNLEVBQVUsRUFBRSwwQkFDbEIsRUFBUSxTQUFRLEdBR3pCLFFBQVEsSUFBSSxrQkFBbUIsR0FDaEIsR0FBRyxLQUFLLEVBQVUsVUFBakMsSUFDSSxFQUFRLENBQ1YsS0FBTSxFQUNOLEtBQU0sRUFBVSxjQUVsQixFQUFFLEtBQUssQ0FDTCxJQUFLLEVBQVUsU0FBUyxJQUFJLEtBQzVCLE9BQVEsT0FDUixLQUFNLEVBQ04sUUFLRixTQUF1QixFQUFNLEVBQVksR0FDdkMsUUFBUSxJQUFJLGdCQUNaLEVBQVUsU0FBUyxRQUFRLEVBQVUsRUFBRSx3QkFOdkMsTUFTRixTQUFxQixFQUFPLEVBQVksR0FDdEMsUUFBUSxJQUFJLGNBQ1osUUFBUSxJQUFJLEdBQ1osRUFBVSxTQUFTLE1BQ2pCLEVBQVUsRUFBRSxxREFaZCxTQWdCRixXQUNFLEVBQVEsU0FBUSxRQVFoQixFQUFjLENBQ2hCLEtBQU0sV0FDTixRQUFTLEdBQUcsWUFBVyxHQUV6QixRQUFzQixTQUFxQixHQUN6QyxRQUFRLEtBQVIsY0FBMkIsR0FDM0IsRUFBWSxTQUFRLEdBQ3BCLEVBQVUsU0FBUyxLQUFLLEVBQVUsRUFBRSxtQkFDcEMsRUFBVSxxQkFBcUIseUJBQy9CLEVBQUUseUJBQXlCLElBQUksRUFBVSxTQUFTLFFBQ2xELEVBQUUsaUJBQ0MsS0FBSyxTQUFhLEVBQVUsU0FBUyxJQUFJLElBRDVDLFdBQzBELEdBQ3ZELFNBQ0gsRUFBWSxTQUFRLEtBRXRCLEVBQVUsS0FBTyxFQUNqQixFQUFVLEtBQU8sRUFDakIsRUFBVSxTQUFXLEdBR3ZCLE9BQU8sUUFBVTs7Ozs7QUMvSWpCLGFBRUEsSUFBSSxTQUFXLFFBQVEsbUJBU25CLFNBQVcsQ0FBQyxFQUFHLEVBQUcsRUFBRyxFQUFHLEVBQUcsRUFBRyxJQUNqQyxJQUFJLFNBQVUsR0FBSyxPQUFPLEtBQUssTUFBVyxHQUFKLEVBQVcsS0FBTyxNQUN4RCxJQUFJLFNBQVUsR0FBSyxPQUFPLEVBQUksSUFBTSxFQUFJLE9BQ3hDLEtBQUssS0FJTixTQUFTLGlCQUFpQixFQUFRLEdBQ2hDLEVBQU8sVUFBVSxzQkFBdUIsV0F1QnRDLE1BQU8sQ0FDTCxLQUFZLFVBQ1osS0FBWSxpQkFDWixRQUFZLGlCQUNaLFFBMUJjLEVBQU8sU0FBUyxpQkFBbUIsVUFDM0IsTUFBTSxLQUFLLElBQUssU0FBVSxHQUNoRCxJQUFJLEVBQVEsRUFDUixFQUFRLEVBRVIsRUFBUyxFQUFLLE1BQU0sS0FLeEIsT0FKSSxFQUFPLE9BQVMsSUFDbEIsRUFBTyxFQUFPLEdBQ2QsRUFBUSxFQUFPLElBRVYsQ0FBQyxLQUFNLEVBQU0sTUFBTyxLQWlCM0IsWUFBWSxFQUNaLFFBZkYsU0FBMEIsR0FDbkIsRUFBRSxRQUFRLFNBQVMsUUFDeEIsUUFBUSxhQUFhLFVBQVUsU0FBUyxpQkFBa0IsQ0FDeEQsT0FBUyxPQUNULE9BQVMsQ0FBRSxpQkFBbUIsRUFBRSxRQUFRLFNBQVMsU0FFbkQsUUFBUSxhQUFhLFVBQVUsTUFBTSx1QkFrQjNDLFNBQVMsS0FBSyxFQUFHLEVBQUksR0FDbkIsSUFBSSxFQUFHLEVBRVAsSUFBSyxFQUNILE9BQU8sRUFLVCxHQUZBLEVBQUksR0FBSyxPQUVRLElBQWIsRUFBRSxRQUVKLElBQUssRUFBSSxFQUFHLEVBQUksRUFBRSxPQUFRLEVBQUksRUFBRyxJQUMvQixJQUErQixJQUEzQixFQUFHLEtBQUssRUFBRyxFQUFFLEdBQUksRUFBRyxHQUN0QixPQUFPLE9BS1gsSUFBSyxLQUFLLEVBQ1IsR0FBSSxFQUFFLGVBQWUsS0FDWSxJQUEzQixFQUFHLEtBQUssRUFBRyxFQUFFLEdBQUksRUFBRyxHQUN0QixPQUFPLEVBTWYsT0FBTyxFQU1ULFNBQVMsZUFBZSxFQUFRLEdBQzlCLFFBQVEsSUFBSSxHQUNaLElBQUksRUFBa0IsRUFDbEIsRUFBa0IsSUFDbEIsR0FBa0IsRUFDbEIsRUFBa0IsQ0FDcEIsUUFBUSxLQUFLLEtBQUssVUFBVSxxQkFDNUIsUUFBUSxLQUFLLEtBQUssVUFBVSxnQkFFN0IsSUFBSyxTQUFVLEdBQUssTUFBTyxLQUFPLElBQ2xDLEtBQU0sUUFFUCxFQUFPLFVBQVUsdUJBQXdCLENBQ3ZDLEtBQWMsWUFDZCxRQUFjLFlBS2QsUUFBYyx1QkFDZCxNQUFjLEVBQ2QsYUFJRixTQUFzQixHQUNwQixJQUFJLEVBQWMsRUFBVSxRQWM1QixTQUFTLEVBQVksR0FDbkIsR0FBSSxFQUFLLE9BQVMsRUFBSyxNQUFNLFNBRzNCLE9BRkEsRUFBWSxLQUFNLFFBQVEsS0FBSyxLQUFLLFVBQVUsZUFBaUIsRUFBSyxNQUFNLFVBQzFFLEVBQWMsRUFBSyxNQUFNLFVBQ2xCLEVBRVQsR0FBYyxFQUNkLEVBQVksS0FBTSxRQUFRLEtBQUssS0FBSyxVQUFVLGNBakJoRCxFQUFPLEdBQUcsYUFBYyxTQUV4QixTQUF1QixHQUNyQixLQUFLLEVBQUUsUUFBUyxHQUNYLElBQ0gsRUFBYyxTQUFTLFlBQVksaUJBQWlCLEVBQUUsUUFBUSxJQUFNLEVBQUUsUUFBUyxNQUM5RSxpQkFBaUIsZUFOeUIsT0FSL0MsUUE2QkYsU0FBc0IsR0FDcEIsSUFBSSxFQUFZLEVBQWMsU0FBUyxLQUFLLEdBQWUsS0FDM0QsRUFBZ0IsTUFBTSxRQUFRLEdBQWEsRUFBVSxHQUFLLEdBRTFELEVBQU8sY0FBYyxLQUFLLENBQ3hCLE1BQU8sb0JBQ1AsTUFBTyxJQUNQLE9BQVEsSUFDUixLQUFNLENBQ0osQ0FDRSxLQUFZLFFBQ1osV0FBWSxFQUNaLEtBQVksR0FHWixhQUFjLFdBQ1osS0FBSyxRQUFRLFVBQVksSUFHN0IsQ0FDRSxLQUFVLFVBQ1YsS0FBVSxtQkFDVixNQUFVLFdBQ1YsV0FBVyxFQUNYLE1BQVcsRUFDWCxhQUFjLFdBQ1osS0FBSyxJQUFJLEtBQUssQ0FDWixLQUFRLFNBQ1IsSUFBUSxFQUNSLEtBQVEsT0FLaEIsU0FBVSxTQUFVLEdBQ2xCLElBQUksSUFBZ0IsRUFBRSxLQUFLLGlCQUN2QixHQUFlLEdBQWUsR0FBZSxHQUMvQyxFQUFPLFlBQVksWUFBWSxFQUFPLEVBQWMsWUFsSzlELFFBQVEsY0FBYyxJQUFJLFVBQVcsa0JBd0VyQyxRQUFRLGNBQWMsSUFBSSxpQkFBa0IsZ0JBNkc1QyxJQUFJLGtCQUFvQixDQUN0QixTQUFVLHdJQUdWLFFBQVMsQ0FBQyx5RUFFVixjQUFlLENBQ2IsQ0FBQyxNQUFPLFNBQVUsTUFBTyxDQUN2QixDQUFDLE1BQU8sT0FBaUIsS0FBTSxPQUFpQixPQUFRLFVBQ3hELENBQUMsTUFBTyxTQUFpQixLQUFNLFNBQWlCLE9BQVEsTUFDeEQsQ0FBQyxNQUFPLFlBQWlCLEtBQU0sWUFBaUIsT0FBUSxPQUFRLE9BQVEsQ0FBQyxrQkFBb0IsY0FDN0YsQ0FBQyxNQUFPLGdCQUFpQixLQUFNLGdCQUFpQixPQUFRLE9BQVEsT0FBUSxDQUFDLGtCQUFvQixpQkFDN0YsQ0FBQyxNQUFPLGNBQWlCLEtBQU0sY0FBaUIsT0FBUSxPQUN4RCxDQUFDLE1BQU8sWUFBaUIsS0FBTSxZQUFpQixPQUFRLE9BQ3hELENBQUMsTUFBTyxPQUFpQixLQUFNLE9BQWlCLE9BQVEsVUFFMUQsQ0FBQyxNQUFPLFlBQWEsTUFBTyxDQUMxQixDQUFDLE1BQU8sT0FBVyxLQUFNLFlBQWdCLE1BQU8sTUFBTyxPQUFRLENBQUMsYUFBZSxTQUMvRSxDQUFDLE1BQU8sU0FBVyxLQUFNLGNBQWdCLE1BQU8sTUFBTyxPQUFRLENBQUMsYUFBZSxXQUMvRSxDQUFDLE1BQU8sUUFBVyxLQUFNLGFBQWdCLE1BQU8sTUFBTyxPQUFRLENBQUMsYUFBZSxVQUMvRSxDQUFDLE1BQU8sVUFBVyxLQUFNLGVBQWdCLE1BQU8sTUFBTyxPQUFRLENBQUMsYUFBZSxnQkFLckYsT0FBTyxRQUFVOzs7O0FDOU5qQixhQUVBLElBQU0sR0FBTixvQkFBbUIsT0FBbkIsT0FBQSxHQUFBLG9CQUFBLE9BQUEsT0FBQSxHQUFBLEtBQ00sUUFBVSxRQUFRLHNCQVlsQixrQkFBb0IsT0FBTyxPQUFPLElBR2xDLGVBQUEscUZBRUEsWUFBYyxTQUFBLEdBQUEsTUFBUSxjQUFjLEtBQUssRUFBSyxTQUVwRCxTQUFTLEtBQUssRUFBYyxFQUFnQixHQUMxQyxNQUFBLDJEQUNzRCxFQUR0RCx1QkFDeUYsRUFEekYsS0FDMEcsRUFEMUcseUhBRThHLEVBRjlHLE9BRWlJLEVBRmpJLG1HQUdpRSxFQUhqRSxPQUdvRixFQUhwRix3SEFPRixPQUFPLFFBQVUsU0FBQSxHQUFRLElBQ2YsRUFBYSxFQUFiLFNBK0NSLE1BQU8sQ0FDTCxPQTlDRixTQUFnQixFQUFHLEVBQUksR0FDckIsTUFBTyxDQUNMLE9BQVEsVUFDUixrQkFBQSxrQkFDQSxLQUFBLE9BMkNGLFVBdkNGLFNBQW1CLEdBQ2pCLEVBQUcsa0JBQW9CLEdBQUcsWUFBVyxHQUNyQyxFQUFHLGVBQWlCLEdBQUcsWUFBVyxHQUNsQyxFQUFHLFdBQWEsU0FBQyxFQUFXLEVBQUssR0FLL0IsRUFBRyxnQkFBSCxDQUF1QixFQUF2QixRQUF1QyxHQUN2QyxFQUFHLHNCQUVMLEVBQUcsYUFBZSxTQUFDLEVBQWMsRUFBWSxFQUFpQixHQUM1RCxFQUFnQixHQUFjLGlCQUVoQyxFQUFHLGtCQUFvQixTQUNyQixFQUNBLEVBQ0EsRUFDQSxHQUdBLEVBQUcsZUFBZSxFQUFnQixHQUFjLEtBQUssSUFDckQsRUFBRyxtQkFBa0IsSUFFdkIsRUFBRyxtQkFBcUIsV0FDdEIsRUFBRyxnQkFBZSxHQUNsQixFQUFHLG1CQUFrQixJQUd2QixJQUFNLEVBQW9CLEVBQUcsa0JBQWtCLFVBQVUsU0FBQSxJQUN0QyxJQUFiLElBQW1ELElBQTlCLEVBQUcseUJBQzFCLEVBQUcscUJBQ0gsRUFBa0I7Ozs7OztBQ3pFMUI7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciB0ZW1wbGF0ZVN5c3RlbT1yZXF1aXJlKFwiLi4vc3JjL2pzL2JpbmRpbmdzL2Nob29zZS10ZW1wbGF0ZS5qc1wiKTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKHQpe3RlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYXJyYXlcIixcIlxceDNjIS0tIGtvIGZvcmVhY2g6ICRkYXRhIC0tXFx4M2VcXHgzYyEtLSBrbyBibG9jazogJGRhdGEgLS1cXHgzZVxceDNjIS0tIC9rbyAtLVxceDNlXFx4M2MhLS0gL2tvIC0tXFx4M2VcIiksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJibG9jay1zaG93XCIsXCJcXHgzYyEtLSBrbyBibG9jazogJGRhdGEsIHNjcm9sbEludG9WaWV3OiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgPT09ICRkYXRhIC0tXFx4M2VcXHgzYyEtLSAva28gLS1cXHgzZVwiKSx0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImJsb2NrLXd5c2l3eWdcIiwnPGRpdiBjbGFzcz1cImVkaXRhYmxlIGJsb2NrXCIgZGF0YS1kcm9wLWNvbnRlbnQ9XCJEcm9wIGhlcmVcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IFxcJ2RhdGEtZHJvcC1jb250ZW50XFwnOiAkcm9vdC50KFxcJ0Ryb3AgaGVyZVxcJykgfSwgY2xpY2s6IGZ1bmN0aW9uKG9iaiwgZXZ0KSB7ICRyb290LnNlbGVjdEJsb2NrKG9iaik7IHJldHVybiB0cnVlIH0sIGNsaWNrQnViYmxlOiBmYWxzZSwgY3NzOiB7IHNlbGVjdGVkOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgPT09ICRkYXRhIH0sIHNjcm9sbEludG9WaWV3OiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgPT09ICRkYXRhXCI+ICA8ZGl2IGNsYXNzPVwibW8tYmxvY2tzZWxlY3Rpb25oZWxwZXJcIj48L2Rpdj4gIDxkaXYgY2xhc3M9XCJ0b29sc1wiIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7fVwiPiAgICBcXHgzYyEtLSBrbyBpZjogdHlwZW9mICRpbmRleCAhPSBcXCd1bmRlZmluZWRcXCcgLS1cXHgzZSAgICA8ZGl2IHRpdGxlPVwiRHJhZyB0aGlzIGhhbmRsZSB0byBtb3ZlIHRoZSBibG9ja1wiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnRHJhZyB0aGlzIGhhbmRsZSB0byBtb3ZlIHRoZSBibG9ja1xcJykgfVwiICAgICAgY2xhc3M9XCJ0b29sIGhhbmRsZVwiPjxpIGNsYXNzPVwiZmFzIGZhLXNvcnRcIj48L2k+PC9kaXY+ICAgIFxceDNjIS0tIGtvIGlmOiAkaW5kZXgoKSA+IDAgLS1cXHgzZSAgICA8ZGl2IHRpdGxlPVwiTW92ZSB0aGlzIGJsb2NrIHVwc2lkZVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnTW92ZSB0aGlzIGJsb2NrIHVwc2lkZVxcJykgfVwiIGNsYXNzPVwidG9vbCBtb3ZldXBcIj48aSAgICAgICAgY2xhc3M9XCJmYXMgZmEtc29ydC11cFwiIGRhdGEtYmluZD1cXCdjbGljazogJHJvb3QubW92ZUJsb2NrLmJpbmQoJGVsZW1lbnQsICRpbmRleCwgJHBhcmVudCwgdHJ1ZSlcXCc+PC9pPjwvZGl2PiAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICBcXHgzYyEtLSBrbyBpZjogJGluZGV4KCkgPCAkcGFyZW50LmJsb2NrcygpLmxlbmd0aCAtMSAtLVxceDNlICAgIDxkaXYgdGl0bGU9XCJNb3ZlIHRoaXMgYmxvY2sgZG93bnNpZGVcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ01vdmUgdGhpcyBibG9jayBkb3duc2lkZVxcJykgfVwiIGNsYXNzPVwidG9vbCBtb3ZlZG93blwiPjxpICAgICAgICBjbGFzcz1cImZhcyBmYS1zb3J0LWRvd25cIiBkYXRhLWJpbmQ9XFwnY2xpY2s6ICRyb290Lm1vdmVCbG9jay5iaW5kKCRlbGVtZW50LCAkaW5kZXgsICRwYXJlbnQsIGZhbHNlKVxcJz48L2k+PC9kaXY+ICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgIDxkaXYgdGl0bGU9XCJEZWxldGUgYmxvY2tcIiBjbGFzcz1cInRvb2wgZGVsZXRlXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdEZWxldGUgYmxvY2tcXCcpIH0sIGNsaWNrOiAkcm9vdC5yZW1vdmVCbG9jay5iaW5kKCRlbGVtZW50LCAkcmF3RGF0YSwgJHBhcmVudClcIj48aSAgICAgICAgY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L2k+PC9kaXY+ICAgIDxkaXYgdGl0bGU9XCJEdXBsaWNhdGUgYmxvY2tcIiBjbGFzcz1cInRvb2wgY2xvbmVcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ0R1cGxpY2F0ZSBibG9ja1xcJykgfSwgY2xpY2s6ICRyb290LmR1cGxpY2F0ZUJsb2NrLmJpbmQoJGVsZW1lbnQsICRpbmRleCwgJHBhcmVudClcIj48aSAgICAgICAgY2xhc3M9XCJmYXMgZmEtY29weVwiPjwvaT48L2Rpdj4gICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgXFx4M2MhLS0ga28gaWY6IHR5cGVvZiAkZGF0YS5fbmV4dFZhcmlhbnQgIT0gXFwndW5kZWZpbmVkXFwnIC0tXFx4M2UgICAgPGRpdiB0aXRsZT1cIlN3aXRjaCBibG9jayB2YXJpYW50XCIgY2xhc3M9XCJ0b29sIHZhcmlhbnRcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1N3aXRjaCBibG9jayB2YXJpYW50XFwnKSB9LCBjbGljazogJGRhdGEuX25leHRWYXJpYW50XCI+PGkgICAgICAgIGNsYXNzPVwiZmEgZmEtZncgZmEtbWFnaWNcIj48L2k+PC9kaXY+XFx4M2MhLS0gL2tvIC0tXFx4M2UgIDwvZGl2PiAgXFx4M2MhLS0ga28gYmxvY2s6ICRkYXRhIC0tXFx4M2UgIFxceDNjIS0tIC9rbyAtLVxceDNlPC9kaXY+JyksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJibG9ja3Mtc2hvd1wiLFwiXFx4M2MhLS0ga28gdGVtcGxhdGU6IHsgbmFtZTogJ2Jsb2NrLXNob3cnLCBmb3JlYWNoOiBibG9ja3MgfSAtLVxceDNlXFx4M2MhLS0gL2tvIC0tXFx4M2VcIiksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJibG9ja3Mtd3lzaXd5Z1wiLFwiPGRpdiBjbGFzcz1cXFwic29ydGFibGUtYmxvY2tzLWVkaXRcXFwiIGRhdGEtZHJvcC1jb250ZW50PVxcXCJEcm9wIGhlcmVcXFwiIGRhdGEtZW1wdHktY29udGVudD1cXFwiRHJvcCBoZXJlIGJsb2NrcyBmcm9tIHRoZSBCbG9ja3MgdGFiXFxcIiBkYXRhLWJpbmQ9XFxcImF0dHI6IHsgJ2RhdGEtZHJvcC1jb250ZW50JzogJHJvb3QudCgnRHJvcCBoZXJlJyksICdkYXRhLWVtcHR5LWNvbnRlbnQnOiAkcm9vdC50KCdEcm9wIGhlcmUgYmxvY2tzIGZyb20gdGhlICZxdW90O0Jsb2NrcyZxdW90OyB0YWInKSB9LCBjc3M6IHsgJ2VtcHR5Jzoga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShibG9ja3MpLmxlbmd0aCA9PSAwIH0sIGV4dHNvcnRhYmxlOiB7IGNvbm5lY3RDbGFzczogJ3NvcnRhYmxlLWJsb2Nrcy1lZGl0JywgdGVtcGxhdGU6ICdibG9jay13eXNpd3lnJywgZGF0YTogYmxvY2tzLCBkcmFnZ2luZzogJHJvb3QuZHJhZ2dpbmcsIGJlZm9yZU1vdmU6ICRyb290LnN0YXJ0TXVsdGlwbGUsIGFmdGVyTW92ZTogJHJvb3Quc3RvcE11bHRpcGxlLCBvcHRpb25zOiB7IGhhbmRsZTogJy5oYW5kbGUnLCBwbGFjZWhvbGRlcjogJHJvb3QucGxhY2Vob2xkZXJIZWxwZXIgfSB9XFxcIj48L2Rpdj5cIiksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJjdXN0b21zdHlsZVwiLCc8ZGl2IGNsYXNzPVwiY3VzdG9tU3R5bGVIZWxwXCIgZGF0YS1iaW5kPVwiaHRtbDogJHJvb3QudChcXCdDdXN0b21pemVkIGJsb2NrLjx1bD48bGk+SW4gdGhpcyBzdGF0dXMgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIHdpbGwgYmUgc3BlY2lmaWMgdG8gdGhlIGN1cnJlbnQgYmxvY2sgKGluc3RlYWQgb2YgYmVpbmcgZ2xvYmFsIHRvIGFsbCBibG9ja3MgaW4gdGhlIHNhbWUgc2VjdGlvbik8L2xpPjxsaT5BIDxzcGFuIGNsYXNzPSZxdW90O2N1c3RvbVN0eWxlZCZxdW90Oz48c3Bhbj4mcXVvdDtzbWFsbCBjdWJlJnF1b3Q7IDwvc3Bhbj48L3NwYW4+IGljb24gYmVzaWRlIHRoZSBwcm9wZXJ0eSB3aWxsIG1hcmsgdGhlIGN1c3RvbWl6YXRpb24uIEJ5IGNsaWNraW5nIHRoaXMgaWNvbiB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXZlcnRlZCB0byB0aGUgdmFsdWUgZGVmaW5lZCBmb3IgdGhlIHNlY3Rpb24uPC9saT48L3VsPlxcJylcIj5DdXN0b21pemVkIGJsb2NrLjx1bD48bGk+SW4gdGhpcyBzdGF0dXMgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIHdpbGwgYmUgc3BlY2lmaWMgdG8gdGhlIGN1cnJlbnQgYmxvY2sgKGluc3RlYWQgb2YgYmVpbmcgZ2xvYmFsIHRvIGFsbCBibG9ja3MgaW4gdGhlIHNhbWUgc2VjdGlvbik8L2xpPjxsaT5BIDxzcGFuIGNsYXNzPVwiY3VzdG9tU3R5bGVkXCI+PHNwYW4+XCJzbWFsbCBjdWJlXCIgPC9zcGFuPjwvc3Bhbj4gaWNvbiBiZXNpZGUgdGhlIHByb3BlcnR5IHdpbGwgbWFyayB0aGUgY3VzdG9taXphdGlvbi4gQnkgY2xpY2tpbmcgdGhpcyBpY29uIHRoZSBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGJlIHJldmVydGVkIHRvIHRoZSB2YWx1ZSBkZWZpbmVkIGZvciB0aGUgc2VjdGlvbi48L2xpPjwvdWw+PC9kaXY+JyksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJlbXB0eVwiLFwiXCIpLHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiZXJyb3JcIiwnWzxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmMGYwXCIgZGF0YS1iaW5kPVwidGV4dDoga28udG9KUygkZGF0YSlcIj48L2Rpdj5dJyksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJpbWctd3lzaXd5Z1wiLCc8dGFibGUgdGFiZm9jdXM9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCIgY2VsbHBhZGRpbmc9XCIwXCIgZGF0YS1kcm9wLWNvbnRlbnQ9XCJEcm9wIGhlcmVcIiBkYXRhLWJpbmQ9XCJzdHlsZTogX3N0eWxlYmluZCwgY2xpY2s6IGZ1bmN0aW9uKG9iaiwgZXZ0KSB7ICRyb290LnNlbGVjdEl0ZW0oX2l0ZW0sIF9kYXRhKTsgcmV0dXJuIHRydWU7IH0sIGNsaWNrQnViYmxlOiBmYWxzZSwgZnVkcm9wcGFibGU6IHsgYWN0aXZlQ2xhc3M6IFxcJ3VpLXN0YXRlLWhpZ2hsaWdodFxcJywgaG92ZXJDbGFzczogXFwndWktc3RhdGUtZHJhZ2hvdmVyXFwnIH0sIGV4dGRyb3BwYWJsZTogeyBvcHRpb25zOiB7IGFjY2VwdDogXFwnLmltYWdlXFwnLCBhY3RpdmVDbGFzczogXFwndWktc3RhdGUtaGlnaGxpZ2h0XFwnLCBob3ZlckNsYXNzOiBcXCd1aS1zdGF0ZS1kcmFnaG92ZXJcXCcgfSwgZGF0YTogX3NyYywgZHJhZ2dlZDogJHJvb3QuZmlsZVRvSW1hZ2UgfSwgY3NzOiB7IHNlbGVjdGVkaXRlbTogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oX2l0ZW0pIH0sIHNjcm9sbEludG9WaWV3OiAkcm9vdC5pc1NlbGVjdGVkSXRlbShfaXRlbSksIGF0dHI6IHsgXFwnZGF0YS1kcm9wLWNvbnRlbnRcXCc6ICRyb290LnQoXFwnRHJvcCBoZXJlXFwnKSwgd2lkdGg6IF93aWR0aCwgaGVpZ2h0OiBfaGVpZ2h0LCBhbGlnbjogX2FsaWduIH1cIiAgY2xhc3M9XCJpbWctd3lzaXd5ZyBzZWxlY3RhYmxlLWltZ1wiIHN0eWxlPVwiZGlzcGxheTogdGFibGU7XCI+ICA8dHI+ICAgIDx0ZCBjbGFzcz1cInVwbG9hZHpvbmVcIj4gICAgICA8ZGl2IGNsYXNzPVwibW8taW1nc2VsZWN0aW9uaGVscGVyXCI+PC9kaXY+ICAgICAgPGRpdiBjbGFzcz1cIm1vLXVwbG9hZHpvbmVcIj48L2Rpdj4gICAgICA8ZGl2IGNsYXNzPVwiaW1nLXNpemVcIiBkYXRhLWJpbmQ9XCJ0ZXh0OiBfc2l6ZVwiPnNpemU8L2Rpdj4gICAgICA8ZGl2IGNsYXNzPVwibWlkdG9vbHNcIiBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge31cIj4gICAgICAgIFxceDNjIS0tIGtvIGlmOiBfc3JjKCkgIT0gXFwnXFwnIC0tXFx4M2UgICAgICAgIDxkaXYgdGl0bGU9XCJSZW1vdmUgaW1hZ2VcIiBjbGFzcz1cInRvb2wgZGVsZXRlXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdSZW1vdmUgaW1hZ2VcXCcpIH0sIGNsaWNrOiBfc3JjLmJpbmQoX3NyYywgXFwnXFwnKSwgY2xpY2tCdWJibGU6IGZhbHNlXCI+PGkgICAgICAgICAgICBjbGFzcz1cImZhIGZhLWZ3IGZhLXRyYXNoLW9cIj48L2k+PC9kaXY+ICAgICAgICBcXHgzYyEtLSBrbyBpZjogdHlwZW9mICRyb290LmVkaXRJbWFnZSAhPT0gXFwndW5kZWZpbmVkXFwnIC0tXFx4M2UgICAgICAgIDxkaXYgdGl0bGU9XCJPcGVuIHRoZSBpbWFnZSBlZGl0aW5nIHRvb2xcIiBjbGFzcz1cInRvb2wgZWRpdFwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnT3BlbiB0aGUgaW1hZ2UgZWRpdGluZyB0b29sXFwnKSB9LCBjbGljazogJHJvb3QuZWRpdEltYWdlLmJpbmQoJGVsZW1lbnQsIF9zcmMpLCBjbGlja0J1YmJsZTogZmFsc2VcIj48aSAgICAgICAgICAgIGNsYXNzPVwiZmEgZmEtZncgZmEtcGVuY2lsXCI+PC9pPjwvZGl2PiAgICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgICBcXHgzYyEtLSBrbyBpZjogX3NyYygpID09IFxcJ1xcJyAtLVxceDNlICAgICAgICA8ZGl2IHRpdGxlPVwiVXBsb2FkIGEgbmV3IGltYWdlXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdVcGxvYWQgYSBuZXcgaW1hZ2VcXCcpIH1cIiBjbGFzcz1cInRvb2wgdXBsb2FkXCIgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7IG92ZXJmbG93OiBoaWRkZW47XCI+PGkgICAgICAgICAgICBjbGFzcz1cImZhcyBmYS11cGxvYWRcIj48L2k+ICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZpbGV1cGxvYWQgbm9maWxlXCIgdHlwZT1cImZpbGVcIiBuYW1lPVwiZmlsZXNbXVwiIGRhdGEtYmluZD1cImZpbGV1cGxvYWQ6IHsgZGF0YTogX3NyYywgb25lcnJvcjogJHJvb3Qubm90aWZpZXIuZXJyb3IsIG9uZmlsZTogJHJvb3QubG9hZE1haWxpbmdJbWFnZSwgY2FudmFzUHJldmlldzogdHJ1ZSB9XCIgICAgICAgICAgICBzdHlsZT1cInotaW5kZXg6IDIwOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgbWluLXdpZHRoOiAxMDAlOyBtaW4taGVpZ2h0OiAxMDAlOyBmb250LXNpemU6IDk5OXB4OyB0ZXh0LWFsaWduOiByaWdodDsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTApOyBvcGFjaXR5OiAwOyBvdXRsaW5lOiBub25lOyBjdXJzb3I6IGluaGVyaXQ7IGRpc3BsYXk6IGJsb2NrXCI+ICAgICAgICA8L2Rpdj4gICAgICAgIFxceDNjIS0tIGtvIGlmOiB0eXBlb2YgJHJvb3Quc2VsZWN0SW1hZ2UgIT09IFxcJ3VuZGVmaW5lZFxcJyAtLVxceDNlICAgICAgICA8ZGl2IHRpdGxlPVwiU2VsZWN0IGZyb20gZ2FsbGVyeVwiIGNsYXNzPVwidG9vbCBnYWxsZXJ5XCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdTZWxlY3QgZnJvbSBnYWxsZXJ5XFwnKSB9LCBjbGljazogJHJvb3Quc2VsZWN0SW1hZ2UuYmluZCgkZWxlbWVudCwgX3NyYyksIGNsaWNrQnViYmxlOiB0cnVlXCI+PGkgICAgICAgICAgICBjbGFzcz1cImZhcyBmYS1pbWFnZVwiPjwvaT48L2Rpdj4gICAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICAgIDwvZGl2PiAgICAgIFxceDNjIS0tIGtvIHRlbXBsYXRlOiBfdGVtcGxhdGUgLS1cXHgzZSAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgXFx4M2MhLS0ga28gaWY6IF9zcmMoKSA9PSBcXCdcXCcgLS1cXHgzZSAgICAgIFxceDNjIS0tICAgIDxpbWcgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIiBjbGFzcz1cImltZ3BsYWNlaG9sZGVyXCIgd2lkdGg9XCIyMDBcIiBzcmM9XCJcIiBhbHQ9XCJJbnNlcnQgYW4gaW1hZ2UgaGVyZVwiIGRhdGEtYmluZD1cInd5c2l3eWdTcmM6IHsgc3JjOiBfc3JjLnByZWxvYWRlZCwgcGxhY2Vob2xkZXI6IF9wbGFjZWhvbGRlcnNyYywgd2lkdGg6IF93aWR0aCwgaGVpZ2h0OiBfaGVpZ2h0LCBtZXRob2Q6IF9tZXRob2QgfVwiIC8+ICAgIC0tXFx4M2UgICAgICA8c3BhbiBjbGFzcz1cImZpbGV1cGxvYWR0ZXh0XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGRpc3BsYXk6IC1tcy1mbGV4Ym94OyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBmbGV4LWFsaWduOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyOyBwYWRkaW5nOiAxZW07IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwO1wiPjxzcGFuICAgICAgICAgIGNsYXNzPVwidGV4dE1pZGRsZVwiIHN0eWxlPVwiIHRleHQtc2hhZG93OiAxcHggMXB4IDAgI0ZGRkZGRiwgMCAwIDEwcHggI0ZGRkZGRjsgZm9udC13ZWlnaHQ6IGJvbGQ7XCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudChcXCdEcm9wIGFuIGltYWdlIGhlcmVcXCcpXCI+RHJvcCAgICAgICAgICBhbiBpbWFnZSBoZXJlPC9zcGFuPjwvc3Bhbj4gICAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICAgIFxceDNjIS0tIGtvIGlmOiBfc3JjKCkgIT0gXFwnXFwnIC0tXFx4M2UgICAgICBcXHgzYyEtLSAgICA8aW1nIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCIgd2lkdGg9XCIyMDBcIiBzcmM9XCJcIiBkYXRhLWJpbmQ9XCJwcmVsb2FkZXI6IF9zcmMsIHd5c2l3eWdTcmM6IHsgc3JjOiBfc3JjLnByZWxvYWRlZCwgcGxhY2Vob2xkZXI6IF9wbGFjZWhvbGRlcnNyYywgd2lkdGg6IF93aWR0aCwgaGVpZ2h0OiBfaGVpZ2h0LCBtZXRob2Q6IF9tZXRob2QgfVwiIC8+ICAgIC0tXFx4M2UgICAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICAgIFxceDNjIS0tIHB1bHNhbnRlIHBlciBsYSBjYW5jZWxsYXppb25lIC0tXFx4M2UgICAgICA8ZGl2IHRpdGxlPVwiRHJvcCBhbiBpbWFnZSBoZXJlIG9yIGNsaWNrIHRoZSB1cGxvYWQgYnV0dG9uXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdEcm9wIGFuIGltYWdlIGhlcmUgb3IgY2xpY2sgdGhlIHVwbG9hZCBidXR0b25cXCcpIH0sIHRvb2x0aXBzOiB7fVwiICAgICAgICBjbGFzcz1cIndvcmt6b25lXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgb3ZlcmZsb3c6IGhpZGRlbjtcIj4gICAgICAgIFxceDNjIS0tIGtvIGlmOiBfc3JjLnByZWxvYWRlZCAmJiBfc3JjKCkgIT0gX3NyYy5wcmVsb2FkZWQoKSAtLVxceDNlUFJFTE9BRElORy4uLi4gICAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgICBcXHgzYyEtLSBrbyBpZjogX3NyYygpICE9IFxcJ1xcJyAtLVxceDNlICAgICAgICA8aW5wdXQgY2xhc3M9XCJmaWxldXBsb2FkIHdpdGhmaWxlXCIgdHlwZT1cImZpbGVcIiBuYW1lPVwiZmlsZXNbXVwiIGRhdGEtYmluZD1cImZpbGV1cGxvYWQ6IHsgZGF0YTogX3NyYywgb25lcnJvcjogJHJvb3Qubm90aWZpZXIuZXJyb3IsIG9uZmlsZTogJHJvb3QubWFpbGluZ0dhbGxlcnkudW5zaGlmdC5iaW5kKCRyb290Lm1haWxpbmdHYWxsZXJ5KSwgY2FudmFzUHJldmlldzogdHJ1ZSB9XCIgICAgICAgICAgc3R5bGU9XCJ6LWluZGV4OiAtMjA7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBtaW4td2lkdGg6IDEwMCU7IG1pbi1oZWlnaHQ6IDEwMCU7IGZvbnQtemllOiA5OTlweDsgdGV4dC1hbGlnbjogcmlnaHQ7IGZpbHRlcjogYWxwaGEob3BhY2l0eT0wKTsgb3BhY2l0eTogMDsgb3V0bGluZTogbm9uZTsgY3Vyc29yOiBpbmhlcml0OyBkaXNwbGF5OiBibG9ja1wiPiAgICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiIHN0eWxlPVwib3BhY2l0eTogLjU7IHdpZHRoOiA4MCU7IG1hcmdpbi1sZWZ0OiAxMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAzMCU7IGhlaWdodDogMjBweDsgYm9yZGVyOiAycHggc29saWQgYmxhY2s7XCI+ICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXIgcHJvZ3Jlc3MtYmFyLXN1Y2Nlc3NcIiBzdHlsZT1cImhlaWdodDogMjBweDsgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IFwiPjwvZGl2PiAgICAgICAgPC9kaXY+ICAgICAgPC9kaXY+PC90YWJsZT4nKSx0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcIm1haW5cIiwnPGRpdiBpZD1cInBhZ2VcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCIgZGF0YS1iaW5kPVwidmlzaWJsZTogdHJ1ZSwgY3NzOiB7IHdpdGhUb29sYm94OiAkcm9vdC5zaG93VG9vbGJveCwgd2l0aFByZXZpZXdGcmFtZTogc2hvd1ByZXZpZXdGcmFtZSB9XCI+ICA8ZGl2IGlkPVwibWFpbi1lZGl0LWFyZWFcIiBkYXRhLWJpbmQ9XCJjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0QmxvY2sobnVsbCk7IHJldHVybiB0cnVlOyB9LCBjbGlja0J1YmJsZTogZmFsc2VcIj4gICAgXFx4M2MhLS0ga28gd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiBcXCd3eXNpd3lnXFwnLCB0ZW1wbGF0ZU1vZGVGYWxsYmFjazogXFwnc2hvd1xcJyB9IC0tXFx4M2UgICAgPGRpdiBpZD1cIm1haW4td3lzaXd5Zy1hcmVhXCIgZGF0YS1iaW5kPVwid3lzaXd5Z1Njcm9sbGZpeDogdHJ1ZSwgc2Nyb2xsYWJsZTogdHJ1ZSwgZnVkcm9wcGFibGU6IHsgYWN0aXZlOiBkcmFnZ2luZ0ltYWdlIH0sIGNzczogeyBpc2RyYWdnaW5nOiBkcmFnZ2luZywgaXNkcmFnZ2luZ2ltZzogZHJhZ2dpbmdJbWFnZSB9LCBibG9jazogY29udGVudFwiPjwvZGl2PiAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgPC9kaXY+ICA8ZGl2IGlkPVwidG9vbGJhclwiIGNsYXNzPVwibW9cIiBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge31cIj4gICAgXFx4M2MhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC51bmRvICE9IFxcJ3VuZGVmaW5lZFxcJyAtLVxceDNlICAgIDxzcGFuIGRhdGEtYmluZD1cImJ1dHRvbnNldDogeyB9XCIgY2xhc3M9XCJsZWZ0QnV0dG9uc1wiPiAgICAgIDxhIGNsYXNzPVwidG9vbGJhcl9fYnV0dG9uIHRvb2xiYXJfX2J1dHRvbi0tdW5kb1wiIHRpdGxlPVwiVW5kbyBsYXN0IG9wZXJhdGlvblwiIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1VuZG8gbGFzdCBvcGVyYXRpb25cXCcpIH0sIGNsaWNrOiAkcm9vdC51bmRvLmV4ZWN1dGUsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGRpc2FibGVkOiAhJHJvb3QudW5kby5lbmFibGVkKCksIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS1yZXBseVxcJyB9LCBsYWJlbDogJHJvb3QudW5kby5uYW1lLCB0ZXh0OiB0cnVlIH1cIj5VTkRPPC9hPiAgICAgIDxhIGNsYXNzPVwidG9vbGJhcl9fYnV0dG9uIHRvb2xiYXJfX2J1dHRvbi0tcmVkb1wiIHRpdGxlPVwiUmVkbyBsYXN0IG9wZXJhdGlvblwiIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1JlZG8gbGFzdCBvcGVyYXRpb25cXCcpIH0sIGNsaWNrOiAkcm9vdC5yZWRvLmV4ZWN1dGUsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGRpc2FibGVkOiAhJHJvb3QucmVkby5lbmFibGVkKCksIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS1zaGFyZVxcJyB9LCBsYWJlbDogJHJvb3QucmVkby5uYW1lLCB0ZXh0OiB0cnVlIH1cIj5SRURPPC9hPiAgICA8L3NwYW4+ICAgIFxceDNjIS0tIGtvIGlmOiAkcm9vdC5kZWJ1ZyAtLVxceDNlICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QudW5kb1Jlc2V0LCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnVuZG8uZW5hYmxlZCgpICYmICEkcm9vdC5yZWRvLmVuYWJsZWQoKSwgbGFiZWw6IFxcJ3Jlc2V0XFwnLCB0ZXh0OiB0cnVlIH1cIj5SRVNFVDwvYT4gICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgPHNwYW4+ICAgICAgPGlucHV0IGlkPVwic2hvd0dhbGxlcnlcIiB0eXBlPVwiY2hlY2tib3hcIiBkYXRhLWJpbmQ9XCJjaGVja2VkOiAkcm9vdC5zaG93R2FsbGVyeSwgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd0dhbGxlcnksICAgIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS1pbWFnZVxcJywgc2Vjb25kYXJ5OiBudWxsIH0sIHRleHQ6IHRydWUsIGxhYmVsOiAkcm9vdC50KFxcJ0dhbGxlcnlcXCcpIH1cIj48bGFiZWwgdGl0bGU9XCJTaG93IGltYWdlIGdhbGxlcnlcIiAgICAgICAgZm9yPVwic2hvd0dhbGxlcnlcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1Nob3cgaW1hZ2UgZ2FsbGVyeVxcJykgfVwiPnNob3cgZ2FsbGVyeTwvbGFiZWw+PC9pbnB1dD4gICAgPC9zcGFuPiAgICBcXHgzYyEtLSBrbyB0ZW1wbGF0ZToge25hbWU6IFxcJ2VkaXQtbmFtZVxcJyB9IC0tXFx4M2UjIG1haWxpbmcgbmFtZSAjICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgIDxpbnB1dCBpZD1cInByZXZpZXdGcmFtZVRvZ2dsZVwiIHR5cGU9XCJjaGVja2JveFwiIGRhdGEtYmluZD1cImNoZWNrZWQ6ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGJ1dHRvbjogeyByZWZyZXNoT246ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGljb25zOiB7IHByaW1hcnk6IG51bGwgLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogZmFsc2UsIGxhYmVsOiAkcm9vdC50KFxcJ1ByZXZpZXdcXCcpIH1cIiAgICAvPiAgICA8bGFiZWwgZm9yPVwicHJldmlld0ZyYW1lVG9nZ2xlXCIgdGl0bGU9XCJTaG93IGxpdmUgcHJldmlld1wiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnU2hvdyBsaXZlIHByZXZpZXdcXCcpIH1cIj4gICAgICBQUkVWSUVXICAgIDwvbGFiZWw+ICAgIFxceDNjIS0tIGtvIGlmOiAkcm9vdC5kZWJ1ZyAtLVxceDNlICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QuZXhwb3J0LCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBsYWJlbDogXFwnZXhwb3J0XFwnLCB0ZXh0OiB0cnVlIH1cIj5FWFBPUlQ8L2E+ICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBkYXRhLWJpbmQ9XCJjaGVja2VkOiAkcm9vdC5kZWJ1Z1wiIC8+IGRlYnVnICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QubG9hZERlZmF1bHRCbG9ja3MsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS11cGxvYWRcXCcgfSwgbGFiZWw6IFxcJ0RlZmF1bHRcXCcsIHRleHQ6IHRydWUgfVwiPkxPQUQgICAgICBCTE9DS1MgICAgPC9hPiAgICBbPGEgaWQ9XCJzdWJzY3JpcHRpb25zQ291bnRcIiBocmVmPVwiamF2YXNjcmlwdDp2aWV3TW9kZWwubG9vcFN1YnNjcmlwdGlvbnNDb3VudCgpXCI+c3ViczwvYT5dICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgIDxzcGFuIGRhdGEtYmluZD1cInZpc2libGU6IGZhbHNlXCI+ICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGRhdGEtYmluZD1cImNoZWNrZWQ6ICRyb290LnNob3dUb29sYm94XCIgLz4gdG9vbGJveCAgICA8L3NwYW4+ICAgIDxkaXYgY2xhc3M9XCJyaWdodEJ1dHRvbnNcIj4gICAgICBcXHgzYyEtLSBrbyBpZjogdHlwZW9mICRyb290LnNhdmUgIT09IFxcJ3VuZGVmaW5lZFxcJyAtLVxceDNlICAgICAgPGEgY2xhc3M9XCJ0b29sYmFyX19idXR0b24gdG9vbGJhcl9fYnV0dG9uLS1zYXZlXCIgdGl0bGU9XCJTYXZlIHRlbXBsYXRlXCIgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnU2F2ZSB0ZW1wbGF0ZVxcJykgfSwgY2xpY2s6ICRyb290LnNhdmUuZXhlY3V0ZSwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC5zYXZlLmVuYWJsZWQoKSwgaWNvbnM6IHsgcHJpbWFyeTogXFwnZmFzIGZhLXNhdmVcXCcgfSwgbGFiZWw6ICRyb290LnQoJHJvb3Quc2F2ZS5uYW1lKSwgdGV4dDogdHJ1ZSB9XCI+U0FMVkE8L2E+ICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICBcXHgzYyEtLSBrbyBpZjogdHlwZW9mICRyb290LnRlc3QgIT09IFxcJ3VuZGVmaW5lZFxcJyAtLVxceDNlICAgICAgPGEgY2xhc3M9XCJ0b29sYmFyX19idXR0b25cIiB0aXRsZT1cIlNob3cgcHJldmlldyBhbmQgc2VuZCB0ZXN0XCIgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnU2hvdyBwcmV2aWV3IGFuZCBzZW5kIHRlc3RcXCcpIH0sIGNsaWNrOiAkcm9vdC50ZXN0LmV4ZWN1dGUsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGRpc2FibGVkOiAhJHJvb3QudGVzdC5lbmFibGVkKCksIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS1wYXBlci1wbGFuZVxcJyB9LCBsYWJlbDogJHJvb3QudCgkcm9vdC50ZXN0Lm5hbWUpLCB0ZXh0OiB0cnVlIH1cIj5URVNUPC9hPiAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgXFx4M2MhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiBcXCdkb3dubG9hZC1idXR0b25cXCcgfSAtLVxceDNlIyBkb3dubG9hZCBidXR0b24gIyAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgIDwvZGl2PiAgPC9kaXY+ICBcXHgzYyEtLSBrbyB0ZW1wbGF0ZToge25hbWU6IFxcJ2RpYWxvZy1zZWxlY3QtaW1hZ2VcXCcgfSAtLVxceDNlIyBkaWFsb2cgaW1hZ2Ugc2VsZWN0aW9uICMgIFxceDNjIS0tIC9rbyAtLVxceDNlICBcXHgzYyEtLSBrbyBpZjogJHJvb3Quc2hvd1Rvb2xib3ggLS1cXHgzZSAgPGRpdiBpZD1cIm1haW4tdG9vbGJveFwiIGNsYXNzPVwibW9cIiBkYXRhLWJpbmQ9XCJzY3JvbGxhYmxlOiB0cnVlLCB3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6IFxcJ2VkaXRcXCcgfVwiPiAgICA8ZGl2IGRhdGEtYmluZD1cInRlbXBsYXRlOiB7IG5hbWU6IFxcJ3Rvb2xib3hcXCcgfVwiPjwvZGl2PiAgPC9kaXY+ICBcXHgzYyEtLSAva28gLS1cXHgzZSAgPGRpdiBpZD1cIm1haW4tcHJldmlld1wiIGNsYXNzPVwibW9cIiBkYXRhLWJpbmQ9XCJzY3JvbGxhYmxlOiB0cnVlLCBpZjogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZVwiPiAgICA8ZGl2IGlkPVwicHJldmlldy10b29sYmFyXCI+ICAgICAgPGRpdiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiAkcm9vdC5zaG93UHJldmlld0ZyYW1lLCBidXR0b25zZXQ6IHsgfVwiIHN0eWxlPVwiZGlzcGxheTogaW5saW5lLWJsb2NrXCI+ICAgICAgICA8aW5wdXQgaWQ9XCJwcmV2aWV3TGFyZ2VcIiB0eXBlPVwicmFkaW9cIiBuYW1lPVwicHJldmlld01vZGVcIiB2YWx1ZT1cImxhcmdlXCIgZGF0YS1iaW5kPVwiY2hlY2tlZDogJHJvb3QucHJldmlld01vZGUsIGJ1dHRvbjogeyB0ZXh0OiBmYWxzZSwgbGFiZWw6IFxcJ2xhcmdlXFwnLCBpY29uczogeyBwcmltYXJ5OiBcXCdmYXMgZmEtZGVza3RvcFxcJyB9IH1cIiAgICAgICAgLz4gICAgICAgIDxsYWJlbCBmb3I9XCJwcmV2aWV3TGFyZ2VcIiB0aXRsZT1cIkxhcmdlIHNjcmVlblwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnTGFyZ2Ugc2NyZWVuXFwnKSB9XCI+TGFyZ2Ugc2NyZWVuPC9sYWJlbD4gICAgICAgIDxpbnB1dCBpZD1cInByZXZpZXdEZXNrdG9wXCIgdHlwZT1cInJhZGlvXCIgbmFtZT1cInByZXZpZXdNb2RlXCIgdmFsdWU9XCJkZXNrdG9wXCIgZGF0YS1iaW5kPVwiY2hlY2tlZDogJHJvb3QucHJldmlld01vZGUsIGJ1dHRvbjogeyB0ZXh0OiBmYWxzZSwgbGFiZWw6IFxcJ2Rlc2t0b3BcXCcsIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS10YWJsZXQtYWx0XFwnIH0gfVwiICAgICAgICAvPiAgICAgICAgPGxhYmVsIGZvcj1cInByZXZpZXdEZXNrdG9wXCIgdGl0bGU9XCJUYWJsZXRcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1RhYmxldFxcJykgfVwiPlRhYmxldDwvbGFiZWw+ICAgICAgICA8aW5wdXQgaWQ9XCJwcmV2aWV3TW9iaWxlXCIgdHlwZT1cInJhZGlvXCIgbmFtZT1cInByZXZpZXdNb2RlXCIgdmFsdWU9XCJtb2JpbGVcIiBkYXRhLWJpbmQ9XCJjaGVja2VkOiAkcm9vdC5wcmV2aWV3TW9kZSwgYnV0dG9uOiB7IHRleHQ6IGZhbHNlLCBsYWJlbDogXFwnbW9iaWxlXFwnLCBpY29uczogeyBwcmltYXJ5OiBcXCdmYXMgZmEtbW9iaWxlLWFsdFxcJyB9IH1cIiAgICAgICAgLz4gICAgICAgIDxsYWJlbCBmb3I9XCJwcmV2aWV3TW9iaWxlXCIgdGl0bGU9XCJTbWFydHBob25lXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdTbWFydHBob25lXFwnKSB9XCI+U21hcnRwaG9uZTwvbGFiZWw+ICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgICA8ZGl2IGlkPVwiZnJhbWUtY29udGFpbmVyXCIgZGF0YS1iaW5kPVwiY3NzOiB7IGRlc2t0b3A6ICRyb290LnByZXZpZXdNb2RlKCkgPT0gXFwnZGVza3RvcFxcJywgbW9iaWxlOiAkcm9vdC5wcmV2aWV3TW9kZSgpID09IFxcJ21vYmlsZVxcJywgbGFyZ2U6ICRyb290LnByZXZpZXdNb2RlKCkgPT0gXFwnbGFyZ2VcXCcgfVwiPiAgICAgIDxpZnJhbWUgZGF0YS1iaW5kPVwiYmluZElmcmFtZTogJGRhdGFcIj48L2lmcmFtZT4gICAgPC9kaXY+ICA8L2Rpdj4gIDxkaXYgY2xhc3M9XCJtb1wiIGlkPVwibW8tYm9keVwiPjwvZGl2PiAgPGRpdiBpZD1cImluY29tcGF0aWJsZS10ZW1wbGF0ZVwiIHRpdGxlPVwiU2F2ZWQgbW9kZWwgaXMgb2Jzb2xldGVcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmVcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1NhdmVkIG1vZGVsIGlzIG9ic29sZXRlXFwnKSB9LCBodG1sOiAkcm9vdC50KFxcJzxwPlRoZSBzYXZlZCBtb2RlbCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYSBwcmV2aW91cywgbm9uIGNvbXBsZXRlbHkgY29tcGF0aWJsZSB2ZXJzaW9uLCBvZiB0aGUgdGVtcGxhdGU8L3A+PHA+U29tZSBjb250ZW50IG9yIHN0eWxlIGluIHRoZSBtb2RlbCA8Yj5DT1VMRCBCRSBMT1NUPC9iPiBpZiB5b3Ugd2lsbCA8Yj5zYXZlPC9iPjwvcD48cD5Db250YWN0IHVzIGZvciBtb3JlIGluZm9ybWF0aW9ucyE8L3A+XFwnKVwiPiAgICBJbmNvbXBhdGlibGUgdGVtcGxhdGUgIDwvZGl2PiAgPGRpdiBpZD1cImZha2UtaW1hZ2UtZWRpdG9yXCIgdGl0bGU9XCJGYWtlIGltYWdlIGVkaXRvclwiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnRmFrZSBpbWFnZSBlZGl0b3JcXCcpIH0sIGh0bWw6ICRyb290LnQoXFwnPHA+RmFrZSBpbWFnZSBlZGl0b3I8L3A+XFwnKVwiPiAgICA8cD5GYWtlIGltYWdlIGVkaXRvcjwvcD4gIDwvZGl2PjwvZGl2PlxceDNjIS0tIGtvIGlmOiAkcm9vdC5sb2dvUGF0aCAtLVxceDNlPGRpdiBpZD1cImxvYWRpbmdcIiBjbGFzcz1cImxvYWRpbmdcIiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrOyB3aWR0aDogMzAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgaGVpZ2h0OiAzMnB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDowOyBib3R0b206IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyAgbWFyZ2luOiBhdXRvO1wiICBkYXRhLWJpbmQ9XCJhdHRyOiB7IHN0eWxlOiBcXCdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogNXB4OyBsZWZ0OiA2cHg7IHotaW5kZXg6IDE1MDtcXCd9LCBjc3M6IHsgbG9hZGluZzogZmFsc2UgfVwiPiAgPGEgaHJlZj1cIi9cIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IGhyZWY6ICRyb290LmxvZ29VcmwsIGFsdDogJHJvb3QubG9nb0FsdCB9XCI+PGltZyBkYXRhLWJpbmQ9XCJhdHRyOiB7IHNyYzogJHJvb3QubG9nb1BhdGggfVwiICAgICAgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgYWx0PVwibW9zYWljb1wiIGJvcmRlcj1cIjBcIiAvPjwvYT4gIDxkaXYgc3R5bGU9XCJvcGFjaXR5OiAwXCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZmFsc2VcIj5PcHBwcy4uLiAhITwvZGl2PjwvZGl2PlxceDNjIS0tIC9rbyAtLVxceDNlXFx4M2MhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiBcXCdob21lLWljb25cXCcgfSAtLVxceDNlIyBob21lLWljb24gI1xceDNjIS0tIC9rbyAtLVxceDNlJyksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJ0b29sYm94XCIsJzxkaXYgaWQ9XCJ0b29sdGFic1wiIGNsYXNzPVwidGFic19ob3Jpem9udGFsIGJ1dHRvbl9jb2xvclwiIGRhdGEtYmluZD1cInRhYnM6IHsgYWN0aXZlOiAkcm9vdC5zZWxlY3RlZFRvb2wgfVwiPiAgPHVsPiAgICA8bGkgZGF0YS1iaW5kPVwidG9vbHRpcHM6IHt9XCI+PGEgdGl0bGU9XCJCbG9ja3MgcmVhZHkgdG8gYmUgYWRkZWQgdG8gdGhlIHRlbXBsYXRlXCIgZGF0YS1sb2NhbD1cInRydWVcIiBocmVmPVwiI3Rvb2xibG9ja3NcIiAgICAgICAgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdCbG9ja3MgcmVhZHkgdG8gYmUgYWRkZWQgdG8gdGhlIHRlbXBsYXRlXFwnKSB9XCI+PGkgY2xhc3M9XCJmYXMgZmEtY3ViZXNcIj48L2k+ICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJodG1sOiAkcm9vdC50KFxcJ0Jsb2Nrc1xcJylcIj5CbG9ja3M8L3NwYW4+PC9hPjwvbGk+ICAgIDxsaSBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge31cIj48YSB0aXRsZT1cIkVkaXQgY29udGVudCBvcHRpb25zXCIgaHJlZj1cIiN0b29sY29udGVudHNcIiBkYXRhLWxvY2FsPVwidHJ1ZVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnRWRpdCBjb250ZW50IG9wdGlvbnNcXCcpIH1cIj48aSAgICAgICAgICBjbGFzcz1cImZhcyBmYS1wZW5jaWwtYWx0XCI+PC9pPiA8c3BhbiBkYXRhLWJpbmQ9XCJodG1sOiAkcm9vdC50KFxcJ0NvbnRlbnRcXCcpXCI+Q29udGVudDwvc3Bhbj48L2E+PC9saT4gICAgPGxpIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7fVwiPjxhIHRpdGxlPVwiRWRpdCBzdHlsZSBvcHRpb25zXCIgaHJlZj1cIiN0b29sc3R5bGVzXCIgZGF0YS1sb2NhbD1cInRydWVcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ0VkaXQgc3R5bGUgb3B0aW9uc1xcJykgfVwiPjxpICAgICAgICAgIGNsYXNzPVwiZmFzIGZhLXBhaW50LWJydXNoXCI+PC9pPiA8c3BhbiBkYXRhLWJpbmQ9XCJodG1sOiAkcm9vdC50KFxcJ1N0eWxlXFwnKVwiPlN0eWxlPC9zcGFuPjwvYT48L2xpPiAgPC91bD4gIDxkaXYgaWQ9XCJ0b29sYmxvY2tzXCIgZGF0YS1iaW5kPVwic2Nyb2xsYWJsZTogdHJ1ZVwiPiAgICA8ZGl2IGNsYXNzPVwiYmxvY2stbGlzdFwiIGRhdGEtYmluZD1cImZvcmVhY2g6IGJsb2NrRGVmc1wiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyXCI+ICAgICAgPGRpdiBjbGFzcz1cImRyYWdnYWJsZS1pdGVtXCIgZGF0YS1iaW5kPVwid2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiBcXCdzaG93XFwnIH1cIj4gICAgICAgIDxkaXYgY2xhc3M9XCJibG9ja1wiIGRhdGEtYmluZD1cImV4dGRyYWdnYWJsZTogeyBjb25uZWN0Q2xhc3M6IFxcJ3NvcnRhYmxlLWJsb2Nrcy1lZGl0XFwnLCBkYXRhOiAkZGF0YSwgZHJvcENvbnRhaW5lcjogXFwnI21haW4td3lzaXd5Zy1hcmVhXFwnLCBkcmFnZ2luZzogJHJvb3QuZHJhZ2dpbmcsIFxcJ29wdGlvbnNcXCc6IHsgaGFuZGxlOiBcXCcuaGFuZGxlXFwnLCBkaXN0YW5jZTogMTAsIFxcJ2FwcGVuZFRvXFwnOiBcXCcjcGFnZVxcJyB9IH0sIGNsaWNrOiAkcm9vdC5hZGRCbG9ja1wiICAgICAgICAgIHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlO1wiPiAgICAgICAgICA8ZGl2IHRpdGxlPVwiQ2xpY2sgb3IgZHJhZyB0byBhZGQgdGhpcyBibG9jayB0byB0aGUgdGVtcGxhdGVcIiBjbGFzcz1cImhhbmRsZVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnQ2xpY2sgb3IgZHJhZyB0byBhZGQgdGhpcyBibG9jayB0byB0aGUgdGVtcGxhdGVcXCcpIH0sIHRvb2x0aXBzOiB7fVwiPjwvZGl2PiAgICAgICAgICA8aW1nIGRhdGEtYmluZD1cImF0dHI6IHsgYWx0OiAkcm9vdC50KFxcJ0Jsb2NrIF9fbmFtZV9fXFwnLCB7IG5hbWU6IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodHlwZSkgfSksIHNyYzogJHJvb3QudGVtcGxhdGVQYXRoKFxcJ2VkcmVzL1xcJytrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHR5cGUpK1xcJy5wbmdcXCcpIH1cIiAgICAgICAgICAgIGFsdD1cIkJsb2NrIF9fbmFtZV9fXCIgLz4gICAgICAgIDwvZGl2PiAgICAgICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwiYWRkYmxvY2tidXR0b25cIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QuYWRkQmxvY2ssIGJ1dHRvbjogeyBsYWJlbDogJHJvb3QudChcXCdBZGRcXCcpIH1cIj5BZGQ8L2E+ICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgPC9kaXY+ICA8ZGl2IGlkPVwidG9vbGNvbnRlbnRzXCIgZGF0YS1iaW5kPVwic2Nyb2xsYWJsZTogdHJ1ZVwiPiAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3Quc2VsZWN0ZWRCbG9jaygpICE9PSBudWxsIC0tXFx4M2UgICAgPGRpdiBkYXRhLWJpbmQ9XCJibG9jazogJHJvb3Quc2VsZWN0ZWRCbG9ja1wiPjwvZGl2PiAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09IG51bGwgLS1cXHgzZSAgICA8ZGl2IGNsYXNzPVwibm9TZWxlY3RlZEJsb2NrXCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudChcXCdCeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBjb250ZW50IG9wdGlvbnMsIGlmIGFueSwgd2lsbCBzaG93IGhlcmVcXCcpXCI+QnkgICAgICBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBjb250ZW50IG9wdGlvbnMsIGlmIGFueSwgd2lsbCBzaG93IGhlcmU8L2Rpdj4gICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgXFx4M2MhLS0ga28gYmxvY2s6IGNvbnRlbnQgLS1cXHgzZSAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgPC9kaXY+ICA8ZGl2IGlkPVwidG9vbHN0eWxlc1wiIGRhdGEtYmluZD1cInNjcm9sbGFibGU6IHRydWUsIHdpdGhQcm9wZXJ0aWVzOiB7IHRlbXBsYXRlTW9kZTogXFwnc3R5bGVyXFwnIH1cIj4gICAgXFx4M2MhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC5jb250ZW50KCkudGhlbWUgPT09IFxcJ3VuZGVmaW5lZFxcJyB8fCB0eXBlb2YgJHJvb3QuY29udGVudCgpLnRoZW1lKCkuc2NoZW1lID09PSBcXCd1bmRlZmluZWRcXCcgfHwgJHJvb3QuY29udGVudCgpLnRoZW1lKCkuc2NoZW1lKCkgPT09IFxcJ2N1c3RvbVxcJyAtLVxceDNlICAgIFxceDNjIS0tIGtvIGlmOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgIT09IG51bGwgLS1cXHgzZSAgICA8ZGl2IGRhdGEtYmluZD1cImJsb2NrOiAkcm9vdC5zZWxlY3RlZEJsb2NrLCBjc3M6IHsgd29ya0xvY2FsOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkuY3VzdG9tU3R5bGUsIHdvcmtHbG9iYWw6IHR5cGVvZiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkuY3VzdG9tU3R5bGUgPT09IFxcJ3VuZGVmaW5lZFxcJyB8fCAhJHJvb3Quc2VsZWN0ZWRCbG9jaygpLmN1c3RvbVN0eWxlKCkgfVwiPjwvZGl2PiAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09IG51bGwgLS1cXHgzZSAgICA8ZGl2IGNsYXNzPVwibm9TZWxlY3RlZEJsb2NrXCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudChcXCdCeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBzdHlsZSBvcHRpb25zLCBpZiBhdmFpbGFibGUsIHdpbGwgc2hvdyBoZXJlXFwnKVwiPkJ5ICAgICAgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgc3R5bGUgb3B0aW9ucywgaWYgYXZhaWxhYmxlLCB3aWxsIHNob3cgaGVyZTwvZGl2PiAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICA8ZGl2IGNsYXNzPVwid29ya0dsb2JhbENvbnRlbnRcIj4gICAgICBcXHgzYyEtLSBrbyBibG9jazogY29udGVudCAtLVxceDNlICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgPC9kaXY+ICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICA8L2Rpdj48L2Rpdj48ZGl2IGlkPVwidG9vbGltYWdlc1wiIGNsYXNzPVwic2xpZGViYXJcIiBkYXRhLWJpbmQ9XCJzY3JvbGxhYmxlOiB0cnVlLCBjc3M6IHsgaGlkZGVuOiAkcm9vdC5zaG93R2FsbGVyeSgpID09PSBmYWxzZSB9XCI+ICA8ZGl2IGNsYXNzPVwiY2xvc2VcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3Quc2hvd0dhbGxlcnkuYmluZCgkZWxlbWVudCwgZmFsc2UpO1wiPlg8L2Rpdj4gIDxzcGFuIGNsYXNzPVwicGFuZS10aXRsZVwiIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnQoXFwnZ2FsbGVyeS10aXRsZVxcJylcIj5HYWxsZXJpZXM6PC9zcGFuPiAgXFx4M2MhLS0ga28gaWY6ICRyb290LnNob3dHYWxsZXJ5KCkgLS1cXHgzZSAgPGRpdiBpZD1cInRvb2xpbWFnZXN0YWJcIiBjbGFzcz1cInRhYnNfaG9yaXpvbnRhbFwiIGRhdGEtYmluZD1cInRhYnM6IHsgYWN0aXZlOiAkcm9vdC5zZWxlY3RlZEltYWdlVGFiIH1cIj4gICAgPHVsPiAgICAgIDxsaSBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge31cIj48YSB0aXRsZT1cImdhbGxlcnktbWFpbGluZ1wiIGRhdGEtbG9jYWw9XCJ0cnVlXCIgaHJlZj1cIiN0b29saW1hZ2VzZ2FsbGVyeVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnZ2FsbGVyeS1tYWlsaW5nXFwnKSB9LCB0ZXh0OiAkcm9vdC50KFxcJ2dhbGxlcnktbWFpbGluZ1xcJylcIj5nYWxsZXJ5LW1haWxpbmc8L2E+PC9saT4gICAgICA8bGkgZGF0YS1iaW5kPVwidG9vbHRpcHM6IHt9XCI+PGEgdGl0bGU9XCJnYWxsZXJ5LXRlbXBsYXRlXCIgZGF0YS1sb2NhbD1cInRydWVcIiBocmVmPVwiI3Rvb2xpbWFnZXNnYWxsZXJ5dGVtcGxhdGVcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ2dhbGxlcnktdGVtcGxhdGVcXCcpIH0sIHRleHQ6ICRyb290LnQoXFwnZ2FsbGVyeS10ZW1wbGF0ZVxcJylcIj5nYWxsZXJ5LXRlbXBsYXRlPC9hPjwvbGk+ICAgIDwvdWw+ICAgIDxkaXYgaWQ9XCJ0b29saW1hZ2VzZ2FsbGVyeVwiIGNsYXNzPVwiZ2FsbGVyeS1wYW5lbFwiPiAgICAgIFxceDNjIS0tIGtvIHRlbXBsYXRlOiB7bmFtZTogXFwnZ2FsbGVyeS11cGxvYWRcXCcsIGRhdGE6IHsgdHlwZTogXFwnbWFpbGluZ1xcJyB9IH0gLS1cXHgzZSMgbWFpbGluZyBnYWxsZXJ5IGZpbGV1cGxvYWQgIyAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgXFx4M2MhLS0ga28gaWY6ICRyb290Lm1haWxpbmdHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlIC0tXFx4M2U8YSBjbGFzcz1cImxvYWRidXR0b25cIiB0aXRsZT1cIlNob3cgaW1hZ2VzIGZyb20gdGhlIGdhbGxlcnlcIiBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5XFwnKSB9LCBjbGljazogJHJvb3QubG9hZE1haWxpbmdHYWxsZXJ5LCBidXR0b246IHsgZGlzYWJsZWQ6ICRyb290Lm1haWxpbmdHYWxsZXJ5U3RhdHVzLCBpY29uczogeyBwcmltYXJ5OiBcXCdmYXMgZmEtaW1hZ2VcXCcgfSwgbGFiZWw6ICRyb290Lm1haWxpbmdHYWxsZXJ5U3RhdHVzKCkgPT0gXFwnbG9hZGluZ1xcJyA/ICRyb290LnQoXFwnTG9hZGluZy4uLlxcJykgOiAkcm9vdC50KFxcJ0xvYWQgZ2FsbGVyeVxcJyksIHRleHQ6IHRydWUgfVwiPiMgICAgICAgIGxvYWQgZ2FsbGVyeSAjPC9hPlxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgXFx4M2MhLS0ga28gaWY6ICRyb290Lm1haWxpbmdHYWxsZXJ5U3RhdHVzKCkgPT09IFxcJ2xvYWRpbmdcXCcgLS1cXHgzZSAgICAgIDxkaXYgY2xhc3M9XCJnYWxsZXJ5RW1wdHlcIiBkYXRhLWJpbmQ9XCJ0ZXh0OiAkcm9vdC50KFxcJ2dhbGxlcnktbWFpbGluZy1sb2FkaW5nXFwnKVwiPkxvYWRpbmcgbWFpbGluZyBnYWxsZXJ54oCmPC9kaXY+XFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PT0gMCAtLVxceDNlICAgICAgPGRpdiBjbGFzcz1cImdhbGxlcnlFbXB0eVwiIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnQoXFwnZ2FsbGVyeS1tYWlsaW5nLWVtcHR5XFwnKVwiPlRoZSBtYWlsaW5nIGdhbGxlcnkgaXMgZW1wdHk8L2Rpdj5cXHgzYyEtLSAva28gLS1cXHgzZSAgICAgIFxceDNjIS0tIGtvIHRlbXBsYXRlOiB7bmFtZTogXFwnZ2FsbGVyeS1pbWFnZXNcXCcsIGRhdGE6IHsgaXRlbXM6IG1haWxpbmdHYWxsZXJ5LCB0eXBlOiBcXCdtYWlsaW5nXFwnIH0gfSAtLVxceDNlIyBtYWlsaW5nIGdhbGxlcnkgIyAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgIDwvZGl2PiAgICA8ZGl2IGlkPVwidG9vbGltYWdlc2dhbGxlcnl0ZW1wbGF0ZVwiIGNsYXNzPVwiZ2FsbGVyeS1wYW5lbFwiPiAgICAgIFxceDNjIS0tIGtvIHRlbXBsYXRlOiB7bmFtZTogXFwnZ2FsbGVyeS11cGxvYWRcXCcsIGRhdGE6IHsgdHlwZTogXFwndGVtcGxhdGVcXCcgfSB9IC0tXFx4M2UjIG1haWxpbmcgdGVtcGxhdGUgZmlsZXVwbG9hZCAjICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlIC0tXFx4M2U8YSBjbGFzcz1cImxvYWRidXR0b25cIiB0aXRsZT1cIlNob3cgaW1hZ2VzIGZyb20gdGhlIGdhbGxlcnlcIiBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5XFwnKSB9LCBjbGljazogJHJvb3QubG9hZFRlbXBsYXRlR2FsbGVyeSwgYnV0dG9uOiB7IGRpc2FibGVkOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMsIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS1pbWFnZVxcJyB9LCBsYWJlbDogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT0gXFwnbG9hZGluZ1xcJyA/ICRyb290LnQoXFwnTG9hZGluZy4uLlxcJykgOiAkcm9vdC50KFxcJ0xvYWQgZ2FsbGVyeVxcJyksIHRleHQ6IHRydWUgfVwiPiMgICAgICAgIGxvYWQgZ2FsbGVyeSAjPC9hPlxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgXFx4M2MhLS0ga28gaWY6ICRyb290LnRlbXBsYXRlR2FsbGVyeVN0YXR1cygpID09PSBcXCdsb2FkaW5nXFwnIC0tXFx4M2UgICAgICA8ZGl2IGNsYXNzPVwiZ2FsbGVyeUVtcHR5XCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudChcXCdnYWxsZXJ5LW1haWxpbmctbG9hZGluZ1xcJylcIj5Mb2FkaW5nIHRlbXBsYXRlIGdhbGxlcnkuLi48L2Rpdj5cXHgzYyEtLSAva28gLS1cXHgzZSAgICAgIFxceDNjIS0tIGtvIGlmOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMoKSA9PT0gMCAtLVxceDNlICAgICAgPGRpdiBjbGFzcz1cImdhbGxlcnlFbXB0eVwiIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnQoXFwnZ2FsbGVyeS1tYWlsaW5nLWVtcHR5XFwnKVwiPlRoZSB0ZW1wbGF0ZSBnYWxsZXJ5IGlzIGVtcHR5PC9kaXY+XFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICBcXHgzYyEtLSBrbyB0ZW1wbGF0ZToge25hbWU6IFxcJ2dhbGxlcnktaW1hZ2VzXFwnLCBkYXRhOiB7IGl0ZW1zOiB0ZW1wbGF0ZUdhbGxlcnksIHR5cGU6IFxcJ3RlbXBsYXRlXFwnIH0gfSAtLVxceDNlIyB0ZW1wbGF0ZSBnYWxsZXJ5ICMgICAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICA8L2Rpdj4gIDwvZGl2PiAgXFx4M2MhLS0gL2tvIC0tXFx4M2U8L2Rpdj48ZGl2IGlkPVwidG9vbGRlYnVnXCIgY2xhc3M9XCJzbGlkZWJhclwiIGRhdGEtYmluZD1cImNzczogeyBoaWRkZW46ICRyb290LmRlYnVnKCkgPT09IGZhbHNlIH1cIj4gIDxkaXYgY2xhc3M9XCJjbG9zZVwiIGRhdGEtYmluZD1cImNsaWNrOiAkcm9vdC5kZWJ1Zy5iaW5kKCRlbGVtZW50LCBmYWxzZSk7XCI+WDwvZGl2PiAgXFx4M2MhLS0ga28gaWY6ICRyb290LmRlYnVnIC0tXFx4M2UgIENvbnRlbnQ6ICA8cHJlIGRhdGEtYmluZD1cXCd0ZXh0OiBrby50b0pTT04oY29udGVudCwgbnVsbCwgMilcXCcgc3R5bGU9XCJvdmVyZmxvdzogYXV0bzsgaGVpZ2h0OiAyMCVcIj48L3ByZT4gQmxvY2tEZWZzOiAgPHByZSBkYXRhLWJpbmQ9XFwndGV4dDoga28udG9KU09OKGJsb2NrRGVmcywgbnVsbCwgMilcXCcgc3R5bGU9XCJvdmVyZmxvdzogYXV0bzsgaGVpZ2h0OiAyMCVcIj48L3ByZT4gIFxceDNjIS0tIC9rbyAtLVxceDNlICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1iaW5kPVwiY2xpY2s6ICRyb290LmV4cG9ydEhUTUx0b1RleHRhcmVhLmJpbmQoJGVsZW1lbnQsIFxcJyNvdXRwdXRodG1sXFwnKTsgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgdGV4dDogdHJ1ZSwgbGFiZWw6XFwnR2VuZXJhdGVcXCcgfVwiPk91dHB1dDwvYT4gIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QuZXhwb3J0SlNPTnRvVGV4dGFyZWEuYmluZCgkZWxlbWVudCwgXFwnI291dHB1dGh0bWxcXCcpOyBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyB0ZXh0OiB0cnVlLCBsYWJlbDpcXCdFeHBvcnRcXCcgfVwiPkV4cG9ydDwvYT4gIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QuaW1wb3J0SlNPTmZyb21UZXh0YXJlYS5iaW5kKCRlbGVtZW50LCBcXCcjb3V0cHV0aHRtbFxcJyk7IGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IHRleHQ6IHRydWUsIGxhYmVsOlxcJ0ltcG9ydFxcJyB9XCI+SW1wb3J0PC9hPiAgPHRleHRhcmVhIGlkPVwib3V0cHV0aHRtbFwiIHJvd3M9XCIxMFwiIHN0eWxlPVwid2lkdGg6IDEwMCU7XCI+PC90ZXh0YXJlYT48L2Rpdj48ZGl2IGlkPVwidG9vbHRoZW1lXCIgY2xhc3M9XCJ1aS13aWRnZXQgc2xpZGViYXJcIiBkYXRhLWJpbmQ9XCJjc3M6IHsgaGlkZGVuOiAkcm9vdC5zaG93VGhlbWUoKSA9PT0gZmFsc2UgfVwiPiAgPGRpdiBjbGFzcz1cImNsb3NlXCIgZGF0YS1iaW5kPVwiY2xpY2s6ICRyb290LnNob3dUaGVtZS5iaW5kKCRlbGVtZW50LCBmYWxzZSk7XCI+WDwvZGl2PiAgXFx4M2MhLS0ga28gd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiBcXCdzdHlsZXJcXCcgfSAtLVxceDNlICBcXHgzYyEtLSBrbyBpZjogJHJvb3Quc2hvd1RoZW1lIC0tXFx4M2UgIFxceDNjIS0tIGtvIGJsb2NrOiAkcm9vdC5jb250ZW50KCkudGhlbWUgLS1cXHgzZSAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgIFxceDNjIS0tIC9rbyAtLVxceDNlICBcXHgzYyEtLSAva28gLS1cXHgzZTwvZGl2PicpLHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiZGlhbG9nLXNlbGVjdC1pbWFnZVwiLCdcXHgzYyEtLSBrbyBpZjogJHJvb3Quc2hvd0RpYWxvZ0dhbGxlcnkoKSAtLVxceDNlXFx4M2MhLS0gc2hvdWxkIHVzZSB1aS1kaWFsb2cgLS1cXHgzZTxhc2lkZSBpZD1cImRpYWxvZ0dhbGxlcnlcIiBjbGFzcz1cIm1vXCI+ICA8ZGl2IGNsYXNzPVwidGFic19ob3Jpem9udGFsXCIgZGF0YS1iaW5kPVwidGFiczogeyBhY3RpdmU6ICRyb290LnNlbGVjdGVkSW1hZ2VUYWIgfVwiPiAgICA8ZGl2IGNsYXNzPVwiY2xvc2VcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QuY2xvc2VEaWFsb2dHYWxsZXJ5O1wiPlg8L2Rpdj4gICAgPHVsPiAgICAgIDxsaSBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge31cIj48YSB0aXRsZT1cImdhbGxlcnktbWFpbGluZ1wiIGRhdGEtbG9jYWw9XCJ0cnVlXCIgaHJlZj1cIiNkaWFsb2dnYWxsZXJ5bWFpbGluZ1wiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnZ2FsbGVyeS1tYWlsaW5nXFwnKSB9LCB0ZXh0OiAkcm9vdC50KFxcJ2dhbGxlcnktbWFpbGluZ1xcJylcIj5nYWxsZXJ5LW1haWxpbmc8L2E+PC9saT4gICAgICA8bGkgZGF0YS1iaW5kPVwidG9vbHRpcHM6IHt9XCI+PGEgdGl0bGU9XCJnYWxsZXJ5LXRlbXBsYXRlXCIgZGF0YS1sb2NhbD1cInRydWVcIiBocmVmPVwiI2RpYWxvZ2dhbGxlcnl0ZW1wbGF0ZVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnZ2FsbGVyeS10ZW1wbGF0ZVxcJykgfSwgdGV4dDogJHJvb3QudChcXCdnYWxsZXJ5LXRlbXBsYXRlXFwnKVwiPmdhbGxlcnktdGVtcGxhdGU8L2E+PC9saT4gICAgPC91bD4gICAgPGRpdiBpZD1cImRpYWxvZ2dhbGxlcnltYWlsaW5nXCIgY2xhc3M9XCJnYWxsZXJ5LXBhbmVsXCI+ICAgICAgXFx4M2MhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiBcXCdnYWxsZXJ5LXVwbG9hZFxcJywgZGF0YTogeyB0eXBlOiBcXCdtYWlsaW5nXFwnIH0gfSAtLVxceDNlIyBtYWlsaW5nIGdhbGxlcnkgZmlsZXVwbG9hZCAjICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PT0gZmFsc2UgLS1cXHgzZTxhIGNsYXNzPVwibG9hZGJ1dHRvblwiIHRpdGxlPVwiU2hvdyBpbWFnZXMgZnJvbSB0aGUgZ2FsbGVyeVwiIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1Nob3cgaW1hZ2VzIGZyb20gdGhlIGdhbGxlcnlcXCcpIH0sIGNsaWNrOiAkcm9vdC5sb2FkTWFpbGluZ0dhbGxlcnksIGJ1dHRvbjogeyBkaXNhYmxlZDogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMsIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS1pbWFnZVxcJyB9LCBsYWJlbDogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PSBcXCdsb2FkaW5nXFwnID8gJHJvb3QudChcXCdMb2FkaW5nLi4uXFwnKSA6ICRyb290LnQoXFwnTG9hZCBnYWxsZXJ5XFwnKSwgdGV4dDogdHJ1ZSB9XCI+IyAgICAgICAgbG9hZCBnYWxsZXJ5ICM8L2E+XFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3QubWFpbGluZ0dhbGxlcnlTdGF0dXMoKSA9PT0gXFwnbG9hZGluZ1xcJyAtLVxceDNlICAgICAgPGRpdiBjbGFzcz1cImdhbGxlcnlFbXB0eVwiIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnQoXFwnZ2FsbGVyeS1tYWlsaW5nLWxvYWRpbmdcXCcpXCI+TG9hZGluZyBtYWlsaW5nIGdhbGxlcnnigKY8L2Rpdj4gICAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICAgIFxceDNjIS0tIGtvIGlmOiAkcm9vdC5tYWlsaW5nR2FsbGVyeVN0YXR1cygpID09PSAwIC0tXFx4M2UgICAgICA8ZGl2IGNsYXNzPVwiZ2FsbGVyeUVtcHR5XCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudChcXCdnYWxsZXJ5LW1haWxpbmctZW1wdHlcXCcpXCI+VGhlIG1haWxpbmcgZ2FsbGVyeSBpcyBlbXB0eTwvZGl2PiAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1nYWxsZXJ5LXdyYXBwZXJcIj4gICAgICAgIDx1bCBkYXRhLWJpbmQ9XCJmb3JlYWNoOiBtYWlsaW5nR2FsbGVyeVwiPiAgICAgICAgICBcXHgzYyEtLSBrbyBpZjogdHlwZW9mIHRodW1ibmFpbFVybCAhPSBcXCd1bmRlZmluZWRcXCcgLS1cXHgzZSAgICAgICAgICA8bGkgZGF0YS1iaW5kPVwiY2xpY2s6ICRyb290LnNldEJnSW1hZ2UuYmluZCgkZWxlbWVudCwgbmFtZSk7XCI+ICAgICAgICAgICAgPGltZyBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiIGRhdGEtYmluZD1cImF0dHI6IHsgc3JjOiB0aHVtYm5haWxVcmwgfVwiIC8+ICAgICAgICAgIDwvbGk+ICAgICAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgICA8L3VsPiAgICAgIDwvZGl2PiAgICA8L2Rpdj4gICAgPGRpdiBpZD1cImRpYWxvZ2dhbGxlcnl0ZW1wbGF0ZVwiIGNsYXNzPVwiZ2FsbGVyeS1wYW5lbFwiPiAgICAgIFxceDNjIS0tIGtvIHRlbXBsYXRlOiB7bmFtZTogXFwnZ2FsbGVyeS11cGxvYWRcXCcsIGRhdGE6IHsgdHlwZTogXFwndGVtcGxhdGVcXCcgfSB9IC0tXFx4M2UjIG1haWxpbmcgdGVtcGxhdGUgZmlsZXVwbG9hZCAjICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICBcXHgzYyEtLSBrbyBpZjogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlIC0tXFx4M2U8YSBjbGFzcz1cImxvYWRidXR0b25cIiB0aXRsZT1cIlNob3cgaW1hZ2VzIGZyb20gdGhlIGdhbGxlcnlcIiBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5XFwnKSB9LCBjbGljazogJHJvb3QubG9hZFRlbXBsYXRlR2FsbGVyeSwgYnV0dG9uOiB7IGRpc2FibGVkOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMsIGljb25zOiB7IHByaW1hcnk6IFxcJ2ZhcyBmYS1pbWFnZVxcJyB9LCBsYWJlbDogJHJvb3QudGVtcGxhdGVHYWxsZXJ5U3RhdHVzKCkgPT0gXFwnbG9hZGluZ1xcJyA/ICRyb290LnQoXFwnTG9hZGluZy4uLlxcJykgOiAkcm9vdC50KFxcJ0xvYWQgZ2FsbGVyeVxcJyksIHRleHQ6IHRydWUgfVwiPiMgICAgICAgIGxvYWQgZ2FsbGVyeSAjPC9hPlxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgXFx4M2MhLS0ga28gaWY6ICRyb290LnRlbXBsYXRlR2FsbGVyeVN0YXR1cygpID09PSBcXCdsb2FkaW5nXFwnIC0tXFx4M2UgICAgICA8ZGl2IGNsYXNzPVwiZ2FsbGVyeUVtcHR5XCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudChcXCdnYWxsZXJ5LW1haWxpbmctbG9hZGluZ1xcJylcIj5Mb2FkaW5nIHRlbXBsYXRlIGdhbGxlcnkuLi48L2Rpdj4gICAgICBcXHgzYyEtLSAva28gLS1cXHgzZSAgICAgIFxceDNjIS0tIGtvIGlmOiAkcm9vdC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMoKSA9PT0gMCAtLVxceDNlICAgICAgPGRpdiBjbGFzcz1cImdhbGxlcnlFbXB0eVwiIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnQoXFwnZ2FsbGVyeS1tYWlsaW5nLWVtcHR5XFwnKVwiPlRoZSB0ZW1wbGF0ZSBnYWxsZXJ5IGlzIGVtcHR5PC9kaXY+ICAgICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWdhbGxlcnktd3JhcHBlclwiPiAgICAgICAgPHVsIGRhdGEtYmluZD1cImZvcmVhY2g6IHRlbXBsYXRlR2FsbGVyeVwiPiAgICAgICAgICBcXHgzYyEtLSBrbyBpZjogdHlwZW9mIHRodW1ibmFpbFVybCAhPSBcXCd1bmRlZmluZWRcXCcgLS1cXHgzZSAgICAgICAgICA8bGkgZGF0YS1iaW5kPVwiY2xpY2s6ICRyb290LnNldEJnSW1hZ2UuYmluZCgkZWxlbWVudCwgbmFtZSk7XCI+ICAgICAgICAgICAgPGltZyBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiIGRhdGEtYmluZD1cImF0dHI6IHsgc3JjOiB0aHVtYm5haWxVcmwgfVwiIC8+ICAgICAgICAgIDwvbGk+ICAgICAgICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgICAgICA8L3VsPiAgICAgIDwvZGl2PiAgICA8L2Rpdj4gIDwvZGl2PjwvYXNpZGU+XFx4M2MhLS0gL2tvIC0tXFx4M2UnKSx0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImRvd25sb2FkLWJ1dHRvblwiLCdcXHgzYyEtLSBrbyBpZjogdHlwZW9mICRyb290LmRvd25sb2FkICE9PSBcXCd1bmRlZmluZWRcXCcgLS1cXHgzZTxmb3JtIGlkPVwiZG93bmxvYWRGb3JtXCIgY2xhc3M9XCJkb3dubG9hZFwiIGFjdGlvbj1cIiNcIiBtZXRob2Q9XCJQT1NUXCI+ICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJhY3Rpb25cIiB2YWx1ZT1cImRvd25sb2FkXCIgLz4gIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cImZpbGVuYW1lXCIgdmFsdWU9XCJlbWFpbC5odG1sXCIgaWQ9XCJkb3dubG9hZEh0bWxGaWxlbmFtZVwiIC8+ICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJodG1sXCIgaWQ9XCJkb3dubG9hZEh0bWxUZXh0YXJlYVwiIC8+ICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInRvb2xiYXJfX2J1dHRvbiBkb3dubG9hZF9fYnV0dG9uXCIgdGl0bGU9XCJEb3dubG9hZCB0ZW1wbGF0ZVwiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnRG93bmxvYWQgdGVtcGxhdGVcXCcpIH1cIj4gICAgPGkgY2xhc3M9XCJmYXMgZmEtZmlsZS1hcmNoaXZlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPiAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiAkcm9vdC50KCRyb290LmRvd25sb2FkLm5hbWUpXCI+RE9XTkxPQUQ8L3NwYW4+ICA8L2J1dHRvbj4gIDxkaXYgY2xhc3M9XCJkb3dubG9hZF9fcGFuZWxcIj4gICAgPGEgY2xhc3M9XCJkb3dubG9hZF9fcGFuZWxfYWN0aW9uXCIgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGRhdGEtYmluZD1cImNsaWNrOiAkcm9vdC5kb3dubG9hZC5leGVjdXRlLmJpbmQoJGVsZW1lbnQsIFxcJ2ltYWdlXFwnKSwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC5kb3dubG9hZC5lbmFibGVkKCksIGxhYmVsOiAkcm9vdC50KFxcJ2Rvd25sb2FkLXdpdGgtaW1hZ2VzXFwnKSwgdGV4dDogdHJ1ZSB9XCI+RE9XTkxPQUQ8L2E+ICAgIDxhIGNsYXNzPVwiZG93bmxvYWRfX3BhbmVsX2FjdGlvblwiIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWJpbmQ9XCJjbGljazogJHJvb3QuZG93bmxvYWQuZXhlY3V0ZS5iaW5kKCRlbGVtZW50LCBcXCdjZG5cXCcpLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LmRvd25sb2FkLmVuYWJsZWQoKSwgbGFiZWw6ICRyb290LnQoXFwnZG93bmxvYWQtY2RuXFwnKSwgdGV4dDogdHJ1ZSB9XCI+RE9XTkxPQUQ8L2E+ICA8L2Rpdj48L2Zvcm0+XFx4M2MhLS0gL2tvIC0tXFx4M2UnKSx0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImVkaXQtbmFtZVwiLCdcXHgzYyEtLSBrbyBpZjogJHJvb3QudGl0bGVNb2RlKCkgPT0gXFwnZWRpdFxcJyB8fCAkcm9vdC50aXRsZU1vZGUoKSA9PSBcXCdzYXZpbmdcXCcgLS1cXHgzZTxmb3JtIGNsYXNzPVwibWFpbGluZy1uYW1lXCIgZGF0YS1iaW5kPVwic3VibWl0OiBzYXZlRWRpdE1haWxpbmdOYW1lLCBzdWJtaXRCdWJibGU6IGZhbHNlXCI+ICA8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWJpbmQ9XCJ2YWx1ZTogJHJvb3QubWV0YWRhdGEubmFtZSwgZGlzYWJsZTogJHJvb3QudGl0bGVNb2RlKCkgPT0gXFwnc2F2aW5nXFwnLCBoYXNGb2N1czogJHJvb3QudGl0bGVNb2RlKCkgPT0gXFwnZWRpdFxcJ1wiLz4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtYmluZD1cImNsaWNrOiBjYW5jZWxFZGl0TWFpbGluZ05hbWUsIGNsaWNrQnViYmxlOiBmYWxzZSwgZGlzYWJsZTogJHJvb3QudGl0bGVNb2RlKCkgPT0gXFwnc2F2aW5nXFwnLCAgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZSwgaWNvbnM6IHsgcHJpbWFyeTogXFwnZmEgZmEtZncgZmEtdGltZXNcXCcsIHNlY29uZGFyeTogbnVsbCB9LCB0ZXh0OiBmYWxzZSwgbGFiZWw6ICRyb290LnQoXFwnZWRpdC10aXRsZS1jYW5jZWxcXCcpIH1cIj5jYW5jZWw8L2J1dHRvbj4gIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGRhdGEtYmluZD1cImRpc2FibGU6ICRyb290LnRpdGxlTW9kZSgpID09IFxcJ3NhdmluZ1xcJywgICAgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZSwgaWNvbnM6IHsgcHJpbWFyeTogXFwnZmEgZmEtZncgZmEtY2hlY2stY2lyY2xlXFwnLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogZmFsc2UsIGxhYmVsOiAkcm9vdC50KFxcJ2VkaXQtdGl0bGUtc2F2ZVxcJykgfVwiPnNhdmU8L2J1dHRvbj48L2Zvcm0+XFx4M2MhLS0gL2tvIC0tXFx4M2VcXHgzYyEtLSBrbyBpZjogJHJvb3QudGl0bGVNb2RlKCkgPT0gXFwnc2hvd1xcJyAtLVxceDNlPGRpdiBjbGFzcz1cIm1haWxpbmctbmFtZVwiPiAgPHAgY2xhc3M9XCJ1aS1idXR0b25cIiBkYXRhLWJpbmQ9XCJldmVudDogeyBkYmxjbGljazogZW5hYmxlRWRpdE1haWxpbmdOYW1lIH0sIGRibGNsaWNrQnViYmxlOiBmYWxzZSwgICAgYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdlZGl0LXRpdGxlLWRvdWJsZS1jbGlja1xcJykgfVwiPiAgICA8c3BhbiBjbGFzcz1cInVpLWJ1dHRvbi10ZXh0XCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QubWFpbGluZ05hbWVcIj48L3NwYW4+ICA8L3A+PC9kaXY+XFx4M2MhLS0gL2tvIC0tXFx4M2UnKSx0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImdhbGxlcnktaW1hZ2VzXCIsJzxhc2lkZSBjbGFzcz1cImdhbGxlcnktdGh1bWJzIGdhbGxlcnktdGh1bWJzLS1jdXN0b21cIiBkYXRhLWJpbmQ9XCJhdHRyOiB7XFwnZGF0YS10eXBlXFwnOiB0eXBlfVwiPiAgPGRpdiBkYXRhLWJpbmQ9XCJmb3JlYWNoOiBpdGVtc1wiPiAgICA8ZGl2IGNsYXNzPVwiZHJhZ2dhYmxlLWl0ZW1cIiBkYXRhLWJpbmQ9XCJpZjogdHlwZW9mIHRodW1ibmFpbFVybCAhPSBcXCd1bmRlZmluZWRcXCdcIj4gICAgICA8YnV0dG9uIGNsYXNzPVwiZ2FsbGVyeS10aHVtYnNfX3JlbW92ZVwiIGRhdGEtYmluZD1cImNsaWNrOiAkcm9vdC5yZW1vdmVJbWFnZS5iaW5kKCRkYXRhLCAkZGF0YSwgJHBhcmVudC50eXBlKVwiPiAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS10aW1lc1wiPjwvaT4gICAgICA8L2J1dHRvbj4gICAgICA8ZGl2IGNsYXNzPVwiZHJhZ2dhYmxlIGltYWdlXCIgZGF0YS1iaW5kPVwiY2xpY2s6ICRyb290LmFkZEltYWdlLCBleHRkcmFnZ2FibGU6IHsgZGF0YTogJGRhdGEsIGRyb3BDb250YWluZXI6IFxcJyNtYWluLXd5c2l3eWctYXJlYVxcJywgZHJhZ2dpbmc6ICRyb290LmRyYWdnaW5nSW1hZ2UsIFxcJ29wdGlvbnNcXCc6IHsgXFwnYXBwZW5kVG9cXCc6IFxcJyNwYWdlXFwnIH0gfSwgc3R5bGU6IHsgYmFja2dyb3VuZEltYWdlOiBcXCd1cmwoXFxcXFxcJ1xcJyArIHRodW1ibmFpbFVybCArIFxcJ1xcXFxcXCcpXFwnIH1cIj4gICAgICAgIDxpbWcgdGl0bGU9XCJEcmFnIHRoaXMgaW1hZ2UgYW5kIGRyb3AgaXQgb24gYW55IHRlbXBsYXRlIGltYWdlIHBsYWNlaG9sZGVyXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIiBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge30sIGF0dHI6IHsgc3JjOiB0aHVtYm5haWxVcmwsIFxcJ3RpdGxlXFwnOiAkcm9vdC50KFxcJ0RyYWcgdGhpcyBpbWFnZSBhbmQgZHJvcCBpdCBvbiBhbnkgdGVtcGxhdGUgaW1hZ2UgcGxhY2Vob2xkZXJcXCcpIH1cIi8+ICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgPC9kaXY+PC9hc2lkZT4nKSx0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImdhbGxlcnktdXBsb2FkXCIsJzxkaXYgZGF0YS1kcm9wLWNvbnRlbnQ9XCJEcm9wIGhlcmVcIiBjbGFzcz1cImltZy1kcm9wem9uZSBwYW5lIHVwbG9hZHpvbmVcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IFxcJ2RhdGEtZHJvcC1jb250ZW50XFwnOiAkcm9vdC50KFxcJ0Ryb3AgaGVyZVxcJykgfSwgZnVkcm9wcGFibGU6IHsgYWN0aXZlQ2xhc3M6IFxcJ3VpLXN0YXRlLWhpZ2hsaWdodFxcJywgaG92ZXJDbGFzczogXFwndWktc3RhdGUtZHJhZ2hvdmVyXFwnIH1cIj4gIDxkaXYgY2xhc3M9XCJtby11cGxvYWR6b25lXCI+ICAgIFxceDNjIS0tIGtvIGlmOiB0eXBlID09PSBcXCdtYWlsaW5nXFwnIC0tXFx4M2UgICAgICA8aW5wdXQgY2xhc3M9XCJmaWxldXBsb2FkXCIgdHlwZT1cImZpbGVcIiBtdWx0aXBsZSBuYW1lPVwiZmlsZXNbXVwiIGRhdGEtYmluZD1cImZpbGV1cGxvYWQ6IHsgb25lcnJvcjogJHJvb3Qubm90aWZpZXIuZXJyb3IsIG9uZmlsZTogJHJvb3QubG9hZE1haWxpbmdJbWFnZSB9XCI+ICAgIFxceDNjIS0tIC9rbyAtLVxceDNlICAgIFxceDNjIS0tIGtvIGlmOiB0eXBlID09PSBcXCd0ZW1wbGF0ZVxcJyAtLVxceDNlICAgICAgPGlucHV0IGNsYXNzPVwiZmlsZXVwbG9hZFwiIHR5cGU9XCJmaWxlXCIgbXVsdGlwbGUgbmFtZT1cImZpbGVzW11cIiBkYXRhLWJpbmQ9XCJmaWxldXBsb2FkOiB7IG9uZXJyb3I6ICRyb290Lm5vdGlmaWVyLmVycm9yLCBvbmZpbGU6ICRyb290LmxvYWRUZW1wbGF0ZUltYWdlLCB1cGxvYWRUb1RlbXBsYXRlOiB0cnVlIH1cIj4gICAgXFx4M2MhLS0gL2tvIC0tXFx4M2UgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudChcXCdDbGljayBvciBkcmFnIGZpbGVzIGhlcmVcXCcpXCI+Q2xpY2sgb3IgZHJhZyBmaWxlcyBoZXJlPC9zcGFuPiAgICAgIDxkaXYgY2xhc3M9XCJ3b3Jrem9uZVwiPiAgICAgICAgPGRpdiBjbGFzcz1cInByb2dyZXNzXCI+ICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXIgcHJvZ3Jlc3MtYmFyLXN1Y2Nlc3NcIj48L2Rpdj4gICAgICAgIDwvZGl2PiAgICAgIDwvZGl2PiAgPC9kaXY+PC9kaXY+JyksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJob21lLWljb25cIiwnPGRpdiBpZD1cImxvYWRpbmdcIiBjbGFzcz1cImxvYWRpbmdcIiBkYXRhLWJpbmQ9XCJjc3M6IHsgbG9hZGluZzogZmFsc2UgfVwiPiAgPGEgaHJlZj1cIi9cIiBpZD1cImhvbWUtYnV0dG9uXCIgYWx0PVwibW9zYWljLWJhY2tlbmRcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IGFsdDogJHJvb3QuYnJhbmROYW1lIH1cIj4gICAgPGkgY2xhc3M9XCJmYXMgZmEtaG9tZSBmYS1sZ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT4gIDwvYT4gIDxkaXYgc3R5bGU9XCJvcGFjaXR5OiAwXCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZmFsc2VcIj5PcHBwcy4uLiAhITwvZGl2PjwvZGl2PicpfSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJblJsYlhCc1lYUmxjeTVxY3lKZExDSnVZVzFsY3lJNld5SjBaVzF3YkdGMFpWTjVjM1JsYlNJc0luSmxjWFZwY21VaUxDSmtiMk4xYldWdWRDSXNJbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSWlMQ0psZG1WdWRDSXNJbUZrWkZSbGJYQnNZWFJsSWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4SlFVRkpRU3hsUVVGcFFrTXNVVUZCVVN4NVEwRkROMEpETEZOQlFWTkRMR2xDUVVGcFFpeHRRa0ZCYjBJc1UwRkJVME1zUjBGRGNrUktMR1ZCUVdWTExGbEJRVmtzVVVGQlV5eHpSMEZEY0VOTUxHVkJRV1ZMTEZsQlFWa3NZVUZCWXl4eFIwRkRla05NTEdWQlFXVkxMRmxCUVZrc1owSkJRV2xDTERob1JVRkROVU5NTEdWQlFXVkxMRmxCUVZrc1kwRkJaU3g1UmtGRE1VTk1MR1ZCUVdWTExGbEJRVmtzYVVKQlFXdENMR2R0UWtGRE4wTk1MR1ZCUVdWTExGbEJRVmtzWTBGQlpTeDFNa0pCUXpGRFRDeGxRVUZsU3l4WlFVRlpMRkZCUVZNc1NVRkRjRU5NTEdWQlFXVkxMRmxCUVZrc1VVRkJVeXh2UmtGRGNFTk1MR1ZCUVdWTExGbEJRVmtzWTBGQlpTeHZPRXBCUXpGRFRDeGxRVUZsU3l4WlFVRlpMRTlCUVZFc01qVlBRVU51UTB3c1pVRkJaVXNzV1VGQldTeFZRVUZYTERCc1VrRkRkRU5NTEdWQlFXVkxMRmxCUVZrc2MwSkJRWFZDTERoMlNFRkRiRVJNTEdWQlFXVkxMRmxCUVZrc2EwSkJRVzFDTEdkelEwRkRPVU5NTEdWQlFXVkxMRmxCUVZrc1dVRkJZU3huZFVOQlEzaERUQ3hsUVVGbFN5eFpRVUZaTEdsQ1FVRnJRaXh4TjBKQlF6ZERUQ3hsUVVGbFN5eFpRVUZaTEdsQ1FVRnJRaXgxSzBKQlF6ZERUQ3hsUVVGbFN5eFpRVUZaTEZsQlFXRWlMQ0ptYVd4bElqb2lMM0J5YVhaaGRHVXZkRzF3TDJadmJ5NUhUMFV2WW5WcGJHUXZkR1Z0Y0d4aGRHVnpMbXB6SW4wPSIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsIi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIilcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpXG52YXIgbm93ID0gcmVxdWlyZShcImRhdGUtbm93XCIpXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxudmFyIGNvbnNvbGVcbnZhciB0aW1lcyA9IHt9XG5cbmlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbC5jb25zb2xlXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGVcbn0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9XG59XG5cbnZhciBmdW5jdGlvbnMgPSBbXG4gICAgW2xvZywgXCJsb2dcIl0sXG4gICAgW2luZm8sIFwiaW5mb1wiXSxcbiAgICBbd2FybiwgXCJ3YXJuXCJdLFxuICAgIFtlcnJvciwgXCJlcnJvclwiXSxcbiAgICBbdGltZSwgXCJ0aW1lXCJdLFxuICAgIFt0aW1lRW5kLCBcInRpbWVFbmRcIl0sXG4gICAgW3RyYWNlLCBcInRyYWNlXCJdLFxuICAgIFtkaXIsIFwiZGlyXCJdLFxuICAgIFtjb25zb2xlQXNzZXJ0LCBcImFzc2VydFwiXVxuXVxuXG5mb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0dXBsZSA9IGZ1bmN0aW9uc1tpXVxuICAgIHZhciBmID0gdHVwbGVbMF1cbiAgICB2YXIgbmFtZSA9IHR1cGxlWzFdXG5cbiAgICBpZiAoIWNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgY29uc29sZVtuYW1lXSA9IGZcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc29sZVxuXG5mdW5jdGlvbiBsb2coKSB7fVxuXG5mdW5jdGlvbiBpbmZvKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gd2FybigpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICB0aW1lc1tsYWJlbF0gPSBub3coKVxufVxuXG5mdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgdmFyIHRpbWUgPSB0aW1lc1tsYWJlbF1cbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbDogXCIgKyBsYWJlbClcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBub3dcblxuZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxufVxuIiwiLypcbiBldm9sLWNvbG9ycGlja2VyIDMuMy4xXG4gQ29sb3JQaWNrZXIgd2lkZ2V0IGZvciBqUXVlcnkgVUlcblxuIGh0dHBzOi8vZ2l0aHViLmNvbS9ldm9sdXRldXIvY29sb3JwaWNrZXJcbiAoYykgMjAxNyBPbGl2aWVyIEdpdWxpZXJpXG5cbiAqIERlcGVuZHM6XG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcbiAqXHRqcXVlcnkudWkud2lkZ2V0LmpzXG4gKi9cblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciBfaWR4PTAsXG5cdHVhPXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LFxuXHRpc0lFPXVhLmluZGV4T2YoXCJNU0lFIFwiKT4wLFxuXHRfaWU9aXNJRT8nLWllJzonJyxcblx0aXNNb3o9aXNJRT9mYWxzZTovbW96aWxsYS8udGVzdCh1YS50b0xvd2VyQ2FzZSgpKSAmJiAhL3dlYmtpdC8udGVzdCh1YS50b0xvd2VyQ2FzZSgpKSxcblx0aGlzdG9yeT1bXSxcblx0YmFzZVRoZW1lQ29sb3JzPVsnZmZmZmZmJywnMDAwMDAwJywnZWVlY2UxJywnMWY0OTdkJywnNGY4MWJkJywnYzA1MDRkJywnOWJiYjU5JywnODA2NGEyJywnNGJhY2M2JywnZjc5NjQ2J10sXG5cdHN1YlRoZW1lQ29sb3JzPVsnZjJmMmYyJywnN2Y3ZjdmJywnZGRkOWMzJywnYzZkOWYwJywnZGJlNWYxJywnZjJkY2RiJywnZWJmMWRkJywnZTVlMGVjJywnZGJlZWYzJywnZmRlYWRhJyxcblx0XHQnZDhkOGQ4JywnNTk1OTU5JywnYzRiZDk3JywnOGRiM2UyJywnYjhjY2U0JywnZTViOWI3JywnZDdlM2JjJywnY2NjMWQ5JywnYjdkZGU4JywnZmJkNWI1Jyxcblx0XHQnYmZiZmJmJywnM2YzZjNmJywnOTM4OTUzJywnNTQ4ZGQ0JywnOTViM2Q3JywnZDk5Njk0JywnYzNkNjliJywnYjJhMmM3JywnOTJjZGRjJywnZmFjMDhmJyxcblx0XHQnYTVhNWE1JywnMjYyNjI2JywnNDk0NDI5JywnMTczNjVkJywnMzY2MDkyJywnOTUzNzM0JywnNzY5MjNjJywnNWY0OTdhJywnMzE4NTliJywnZTM2YzA5Jyxcblx0XHQnN2Y3ZjdmJywnMGMwYzBjJywnMWQxYjEwJywnMGYyNDNlJywnMjQ0MDYxJywnNjMyNDIzJywnNGY2MTI4JywnM2YzMTUxJywnMjA1ODY3JywnOTc0ODA2J10sXG5cdHN0YW5kYXJkQ29sb3JzPVsnYzAwMDAwJywnZmYwMDAwJywnZmZjMDAwJywnZmZmZjAwJywnOTJkMDUwJywnMDBiMDUwJywnMDBiMGYwJywnMDA3MGMwJywnMDAyMDYwJywnNzAzMGEwJ10sXG5cdHdlYkNvbG9ycz1bXG5cdFx0WycwMDMzNjYnLCczMzY2OTknLCczMzY2Y2MnLCcwMDMzOTknLCcwMDAwOTknLCcwMDAwY2MnLCcwMDAwNjYnXSxcblx0XHRbJzAwNjY2NicsJzAwNjY5OScsJzAwOTljYycsJzAwNjZjYycsJzAwMzNjYycsJzAwMDBmZicsJzMzMzNmZicsJzMzMzM5OSddLFxuXHRcdFsnNjY5OTk5JywnMDA5OTk5JywnMzNjY2NjJywnMDBjY2ZmJywnMDA5OWZmJywnMDA2NmZmJywnMzM2NmZmJywnMzMzM2NjJywnNjY2Njk5J10sXG5cdFx0WyczMzk5NjYnLCcwMGNjOTknLCcwMGZmY2MnLCcwMGZmZmYnLCczM2NjZmYnLCczMzk5ZmYnLCc2Njk5ZmYnLCc2NjY2ZmYnLCc2NjAwZmYnLCc2NjAwY2MnXSxcblx0XHRbJzMzOTkzMycsJzAwY2M2NicsJzAwZmY5OScsJzY2ZmZjYycsJzY2ZmZmZicsJzY2Y2NmZicsJzk5Y2NmZicsJzk5OTlmZicsJzk5NjZmZicsJzk5MzNmZicsJzk5MDBmZiddLFxuXHRcdFsnMDA2NjAwJywnMDBjYzAwJywnMDBmZjAwJywnNjZmZjk5JywnOTlmZmNjJywnY2NmZmZmJywnY2NjY2ZmJywnY2M5OWZmJywnY2M2NmZmJywnY2MzM2ZmJywnY2MwMGZmJywnOTkwMGNjJ10sXG5cdFx0WycwMDMzMDAnLCcwMDk5MzMnLCczM2NjMzMnLCc2NmZmNjYnLCc5OWZmOTknLCdjY2ZmY2MnLCdmZmZmZmYnLCdmZmNjZmYnLCdmZjk5ZmYnLCdmZjY2ZmYnLCdmZjAwZmYnLCdjYzAwY2MnLCc2NjAwNjYnXSxcblx0XHRbJzMzMzMwMCcsJzAwOTkwMCcsJzY2ZmYzMycsJzk5ZmY2NicsJ2NjZmY5OScsJ2ZmZmZjYycsJ2ZmY2NjYycsJ2ZmOTljYycsJ2ZmNjZjYycsJ2ZmMzNjYycsJ2NjMDA5OScsJzk5MzM5OSddLFxuXHRcdFsnMzM2NjAwJywnNjY5OTAwJywnOTlmZjMzJywnY2NmZjY2JywnZmZmZjk5JywnZmZjYzk5JywnZmY5OTk5JywnZmY2Njk5JywnZmYzMzk5JywnY2MzMzk5JywnOTkwMDk5J10sXG5cdFx0Wyc2NjY2MzMnLCc5OWNjMDAnLCdjY2ZmMzMnLCdmZmZmNjYnLCdmZmNjNjYnLCdmZjk5NjYnLCdmZjY2NjYnLCdmZjAwNjYnLCdkNjAwOTQnLCc5OTMzNjYnXSxcblx0XHRbJ2E1ODgwMCcsJ2NjY2MwMCcsJ2ZmZmYwMCcsJ2ZmY2MwMCcsJ2ZmOTkzMycsJ2ZmNjYwMCcsJ2ZmMDAzMycsJ2NjMDA2NicsJzY2MDAzMyddLFxuXHRcdFsnOTk2NjMzJywnY2M5OTAwJywnZmY5OTAwJywnY2M2NjAwJywnZmYzMzAwJywnZmYwMDAwJywnY2MwMDAwJywnOTkwMDMzJ10sXG5cdFx0Wyc2NjMzMDAnLCc5OTY2MDAnLCdjYzMzMDAnLCc5OTMzMDAnLCc5OTAwMDAnLCc4MDAwMDAnLCc5OTMzMzMnXVxuXHRdLFxuXHR0cmFuc0NvbG9yPScjMDAwMGZmZmYnLFxuXHRpbnQySGV4PWZ1bmN0aW9uKGkpe1xuXHRcdHZhciBoPWkudG9TdHJpbmcoMTYpO1xuXHRcdGlmKGgubGVuZ3RoPT0xKXtcblx0XHRcdGg9JzAnK2g7XG5cdFx0fVxuXHRcdHJldHVybiBoO1xuXHR9LFxuXHRzdDJIZXg9ZnVuY3Rpb24ocyl7XG5cdFx0cmV0dXJuIGludDJIZXgoTnVtYmVyKHMpKTtcblx0fSxcblx0aW50MkhleDM9ZnVuY3Rpb24oaSl7XG5cdFx0dmFyIGg9aW50MkhleChpKTtcblx0XHRyZXR1cm4gaCtoK2g7XG5cdH0sXG5cdHRvSGV4Mz1mdW5jdGlvbihjKXtcblx0XHRpZihjLmxlbmd0aD4xMCl7IC8vIElFOVxuXHRcdFx0dmFyIHAxPTErYy5pbmRleE9mKCcoJyksXG5cdFx0XHRcdHAyPWMuaW5kZXhPZignKScpLFxuXHRcdFx0XHRjcz1jLnN1YnN0cmluZyhwMSxwMikuc3BsaXQoJywnKTtcblx0XHRcdHJldHVybiBbJyMnLHN0MkhleChjc1swXSksc3QySGV4KGNzWzFdKSxzdDJIZXgoY3NbMl0pXS5qb2luKCcnKTtcblx0XHR9ZWxzZXtcblx0XHRcdHJldHVybiBjO1xuXHRcdH1cblx0fTtcblxuJC53aWRnZXQoIFwiZXZvbC5jb2xvcnBpY2tlclwiLCB7XG5cblx0dmVyc2lvbjogJzMuMy4xJyxcblx0XG5cdG9wdGlvbnM6IHtcblx0XHRjb2xvcjogbnVsbCwgLy8gZXhhbXBsZTonIzMxODU5Qidcblx0XHRjdXN0b21UaGVtZTogbnVsbCwgLy8gZXhhbXBsZTogW1wiI2ZmMDAwMFwiLCBcIiMwMGZmMDBcIiwgXCJibHVlXCJdLFxuXHRcdHNob3dPbjogJ2JvdGgnLCAvLyBwb3NzaWJsZSB2YWx1ZXM6ICdmb2N1cycsJ2J1dHRvbicsJ2JvdGgnXG5cdFx0aGlkZUJ1dHRvbjogZmFsc2UsXG5cdFx0ZGlzcGxheUluZGljYXRvcjogdHJ1ZSxcblx0XHR0cmFuc3BhcmVudENvbG9yOiBmYWxzZSxcblx0XHRoaXN0b3J5OiB0cnVlLFxuXHRcdGRlZmF1bHRQYWxldHRlOiAndGhlbWUnLCAvLyBwb3NzaWJsZSB2YWx1ZXM6ICd0aGVtZScsICd3ZWInXG5cdFx0c3RyaW5nczogJ1RoZW1lIENvbG9ycyxTdGFuZGFyZCBDb2xvcnMsV2ViIENvbG9ycyxUaGVtZSBDb2xvcnMsQmFjayB0byBQYWxldHRlLEhpc3RvcnksTm8gaGlzdG9yeSB5ZXQuJ1xuXHR9LFxuXG5cdC8vIHRoaXMgaXMgb25seSB0cnVlIHdoaWxlIHNob3dpbmcgdGhlIHBhbGV0dGUgdW50aWwgY29sb3IgaXMgY2hvc2VuXG5cdF9hY3RpdmU6IGZhbHNlLFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0PXRoaXM7XG5cdFx0dGhpcy5fcGFsZXR0ZUlkeD10aGlzLm9wdGlvbnMuZGVmYXVsdFBhbGV0dGU9PSd0aGVtZSc/MToyO1xuXHRcdHRoaXMuX2lkPSdldm8tY3AnK19pZHgrKztcblx0XHR0aGlzLl9lbmFibGVkPXRydWU7XG5cdFx0dGhpcy5vcHRpb25zLnNob3dPbj10aGlzLm9wdGlvbnMuaGlkZUJ1dHRvbj8nZm9jdXMnOnRoaXMub3B0aW9ucy5zaG93T247XG5cdFx0c3dpdGNoKHRoaXMuZWxlbWVudC5nZXQoMCkudGFnTmFtZSl7XG5cdFx0XHRjYXNlICdJTlBVVCc6XG5cdFx0XHRcdHZhciBjb2xvcj10aGlzLm9wdGlvbnMuY29sb3IsXG5cdFx0XHRcdFx0ZT10aGlzLmVsZW1lbnQsXG5cdFx0XHRcdFx0Y3NzPSgodGhpcy5vcHRpb25zLnNob3dPbj09PSdmb2N1cycpPycnOidldm8tcG9pbnRlciAnKSsnZXZvLWNvbG9yaW5kJysoaXNNb3o/Jy1mZic6X2llKSsodGhpcy5vcHRpb25zLmhpZGVCdXR0b24/JyBldm8taGlkZGVuLWJ1dHRvbic6JycpLFxuXHRcdFx0XHRcdHN0eWxlPScnO1xuXHRcdFx0XHR0aGlzLl9pc1BvcHVwPXRydWU7XG5cdFx0XHRcdHRoaXMuX3BhbGV0dGU9bnVsbDtcblx0XHRcdFx0dmFyIHY9ZS52YWwoKTtcblx0XHRcdFx0aWYoY29sb3IhPT1udWxsKXtcblx0XHRcdFx0XHRpZiAoY29sb3IgIT0gdikgZS52YWwoY29sb3IpLmNoYW5nZSgpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpZih2IT09Jycpe1xuXHRcdFx0XHRcdFx0Y29sb3I9dGhpcy5vcHRpb25zLmNvbG9yPXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGNvbG9yPT09dHJhbnNDb2xvcil7XG5cdFx0XHRcdFx0Y3NzKz0nIGV2by10cmFuc3BhcmVudCc7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHN0eWxlPShjb2xvciE9PW51bGwpPygnYmFja2dyb3VuZC1jb2xvcjonK2NvbG9yKTonJztcblx0XHRcdFx0fVxuXHRcdFx0XHRlLmFkZENsYXNzKCdjb2xvclBpY2tlciAnK3RoaXMuX2lkKVxuXHRcdFx0XHRcdC53cmFwKCc8ZGl2IHN0eWxlPVwid2lkdGg6JysodGhpcy5vcHRpb25zLmhpZGVCdXR0b24/dGhpcy5lbGVtZW50LndpZHRoKCk6dGhpcy5lbGVtZW50LndpZHRoKCkrMzIpKydweDsnK1xuXHRcdFx0XHRcdFx0KGlzSUU/J21hcmdpbi1ib3R0b206LTIxcHg7JzonJykrXG5cdFx0XHRcdFx0XHQoaXNNb3o/J3BhZGRpbmc6MXB4IDA7JzonJykrXG5cdFx0XHRcdFx0XHQnXCIgY2xhc3M9XCJldm8tY3Atd3JhcFwiPjwvZGl2PicpXG5cdFx0XHRcdFx0LmFmdGVyKCc8ZGl2IGNsYXNzPVwiJytjc3MrJ1wiIHN0eWxlPVwiJytzdHlsZSsnXCI+PC9kaXY+Jylcblx0XHRcdFx0XHQub24oJ2tleXVwIG9ucGFzdGUnLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdFx0dmFyIGM9JCh0aGlzKS52YWwoKTtcblx0XHRcdFx0XHRcdGlmKGMhPXRoYXQub3B0aW9ucy5jb2xvcil7XG5cdFx0XHRcdFx0XHRcdHRoYXQuX3NldFZhbHVlKGMsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR2YXIgc2hvd09uPXRoaXMub3B0aW9ucy5zaG93T247XG5cdFx0XHRcdGlmKHNob3dPbj09PSdib3RoJyB8fCBzaG93T249PT0nZm9jdXMnKXtcblx0XHRcdFx0XHRlLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHR0aGF0LnNob3dQYWxldHRlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoc2hvd09uPT09J2JvdGgnIHx8IHNob3dPbj09PSdidXR0b24nKXtcblx0XHRcdFx0XHRlLm5leHQoKS5vbignY2xpY2snLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdFx0ZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0dGhhdC5zaG93UGFsZXR0ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5faXNQb3B1cD1mYWxzZTtcblx0XHRcdFx0dGhpcy5fcGFsZXR0ZT10aGlzLmVsZW1lbnQuaHRtbCh0aGlzLl9wYWxldHRlSFRNTCgpKVxuXHRcdFx0XHRcdC5hdHRyKCdhcmlhLWhhc3BvcHVwJywndHJ1ZScpO1xuXHRcdFx0XHR0aGlzLl9iaW5kQ29sb3JzKCk7XG5cdFx0fVxuXHRcdGlmKHRoaXMub3B0aW9ucy5oaXN0b3J5KXtcblx0XHRcdGlmKGNvbG9yKXtcblx0XHRcdFx0dGhpcy5fYWRkMkhpc3RvcnkoY29sb3IpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5pbml0aWFsSGlzdG9yeSkge1xuXHRcdFx0XHR2YXIgYyA9IHRoaXMub3B0aW9ucy5pbml0aWFsSGlzdG9yeTtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBjKXtcblx0XHRcdFx0XHR0aGlzLl9hZGQySGlzdG9yeShjW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcGFsZXR0ZUhUTUw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwSWR4PXRoaXMuX3BhbGV0dGVJZHg9TWF0aC5hYnModGhpcy5fcGFsZXR0ZUlkeCksXG5cdFx0XHRvcHRzPXRoaXMub3B0aW9ucyxcblx0XHRcdGxhYmVscz1vcHRzLnN0cmluZ3Muc3BsaXQoJywnKTtcblxuXHRcdHZhciBoPSc8ZGl2IGNsYXNzPVwiZXZvLXBvcCcrX2llKycgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIicrXG5cdFx0XHQodGhpcy5faXNQb3B1cD8nIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGVcIic6JycpKyc+Jytcblx0XHRcdC8vIHBhbGV0dGVcblx0XHRcdCc8c3Bhbj4nK3RoaXNbJ19wYWxldHRlSFRNTCcrcElkeF0oKSsnPC9zcGFuPicrXG5cdFx0XHQvLyBsaW5rc1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJldm8tbW9yZVwiPjxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIj4nK2xhYmVsc1sxK3BJZHhdKyc8L2E+Jztcblx0XHRpZihvcHRzLmhpc3Rvcnkpe1xuXHRcdFx0aCs9JzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cImV2by1oaXN0XCI+JytsYWJlbHNbNV0rJzwvYT4nO1xuXHRcdH1cblx0XHRoKz0nPC9kaXY+Jztcblx0XHQvLyBpbmRpY2F0b3Jcblx0XHRpZihvcHRzLmRpc3BsYXlJbmRpY2F0b3Ipe1xuXHRcdFx0aCs9dGhpcy5fY29sb3JJbmRIVE1MKHRoaXMub3B0aW9ucy5jb2xvcikrdGhpcy5fY29sb3JJbmRIVE1MKCcnKTtcblx0XHR9XG5cdFx0aCs9JzwvZGl2Pic7XG5cdFx0cmV0dXJuIGg7XG5cdH0sXG5cblx0X2NvbG9ySW5kSFRNTDogZnVuY3Rpb24oYykge1xuXHRcdHZhciBjc3M9aXNJRT8nZXZvLWNvbG9yYm94LWllICc6JycsXG5cdFx0XHRzdHlsZT0nJztcblxuXHRcdGlmKGMpe1xuXHRcdFx0aWYoYz09PXRyYW5zQ29sb3Ipe1xuXHRcdFx0XHRjc3MrPSdldm8tdHJhbnNwYXJlbnQnO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOicrYztcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdHN0eWxlPSdkaXNwbGF5Om5vbmUnO1xuXHRcdH1cblx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJldm8tY29sb3JcIiBzdHlsZT1cImZsb2F0OmxlZnRcIj4nK1xuXHRcdFx0JzxkaXYgc3R5bGU9XCInK3N0eWxlKydcIiBjbGFzcz1cIicrY3NzKydcIj48L2Rpdj48c3Bhbj4nKyAvLyBjbGFzcz1cImV2by1jb2xvcnR4dC1pZVwiXG5cdFx0XHQoYz9jOicnKSsnPC9zcGFuPjwvZGl2Pic7XG5cdH0sXG5cblx0X3BhbGV0dGVIVE1MMTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdHM9dGhpcy5vcHRpb25zLFxuXHRcdFx0bGFiZWxzPW9wdHMuc3RyaW5ncy5zcGxpdCgnLCcpLFxuXHRcdFx0b1REPSc8dGQgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicsXG5cdFx0XHRjVEQ9aXNJRT8nXCI+PGRpdiBzdHlsZT1cIndpZHRoOjJweDtcIj48L2Rpdj48L3RkPic6J1wiPjxzcGFuLz48L3RkPicsXG5cdFx0XHRvVFJUSD0nPHRyPjx0aCBjb2xzcGFuPVwiMTBcIiBjbGFzcz1cInVpLXdpZGdldC1jb250ZW50XCI+Jyxcblx0XHRcdGk7XG5cblx0XHR2YXIgaD0nPHRhYmxlIGNsYXNzPVwiZXZvLXBhbGV0dGUnK19pZSsnXCI+JytvVFJUSCtsYWJlbHNbMF0rJzwvdGg+PC90cj48dHI+JztcblxuXHRcdGlmIChvcHRzLmN1c3RvbVRoZW1lKSB7XG5cdFx0XHRmb3IgKGk9MCwgbWw9b3B0cy5jdXN0b21UaGVtZS5sZW5ndGg7aTxtbDtpKyspIHtcblx0XHRcdFx0aCs9b1REK29wdHMuY3VzdG9tVGhlbWVbaV0rY1REO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvVEQrPScjJztcblx0XHRcdC8vIGJhc2UgdGhlbWUgY29sb3JzXG5cdFx0XHRmb3IoaT0wO2k8MTA7aSsrKXsgXG5cdFx0XHRcdGgrPW9URCtiYXNlVGhlbWVDb2xvcnNbaV0rY1REO1xuXHRcdFx0fVxuXHRcdFx0aCs9JzwvdHI+Jztcblx0XHRcdGlmKCFpc0lFKXtcblx0XHRcdFx0aCs9Jzx0cj48dGggY29sc3Bhbj1cIjEwXCI+PC90aD48L3RyPic7XG5cdFx0XHR9XG5cdFx0XHRoKz0nPHRyIGNsYXNzPVwidG9wXCI+Jztcblx0XHRcdC8vIHRoZW1lIGNvbG9yc1xuXHRcdFx0Zm9yKGk9MDtpPDEwO2krKyl7IFxuXHRcdFx0XHRoKz1vVEQrc3ViVGhlbWVDb2xvcnNbaV0rY1REO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKHZhciByPTE7cjw0O3IrKyl7XG5cdFx0XHRcdGgrPSc8L3RyPjx0ciBjbGFzcz1cImluXCI+Jztcblx0XHRcdFx0Zm9yKGk9MDtpPDEwO2krKyl7IFxuXHRcdFx0XHRcdGgrPW9URCtzdWJUaGVtZUNvbG9yc1tyKjEwK2ldK2NURDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aCs9JzwvdHI+PHRyIGNsYXNzPVwiYm90dG9tXCI+Jztcblx0XHRcdGZvcihpPTQwO2k8NTA7aSsrKXsgXG5cdFx0XHRcdGgrPW9URCtzdWJUaGVtZUNvbG9yc1tpXStjVEQ7XG5cdFx0XHR9XG5cdFx0XHRoKz0nPC90cj4nK29UUlRIO1xuXHRcdFx0Ly8gdHJhbnNwYXJlbnQgY29sb3Jcblx0XHRcdGlmKG9wdHMudHJhbnNwYXJlbnRDb2xvcil7XG5cdFx0XHRcdGgrPSc8ZGl2IGNsYXNzPVwiZXZvLXRyYW5zcGFyZW50IGV2by10ci1ib3hcIj48L2Rpdj4nO1xuXHRcdFx0fVxuXHRcdFx0aCs9bGFiZWxzWzFdKyc8L3RoPjwvdHI+PHRyPic7XG5cdFx0XHQvLyBzdGFuZGFyZCBjb2xvcnNcblx0XHRcdGZvcihpPTA7aTwxMDtpKyspeyBcblx0XHRcdFx0aCs9b1REK3N0YW5kYXJkQ29sb3JzW2ldK2NURDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aCs9JzwvdHI+PC90YWJsZT4nO1xuXHRcdHJldHVybiBoOyBcblx0fSxcblxuXHRfcGFsZXR0ZUhUTUwyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgaU1heCxcblx0XHRcdG9URD0nPHRkIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojJyxcblx0XHRcdGNURD1pc0lFPydcIj48ZGl2IHN0eWxlPVwid2lkdGg6NXB4O1wiPjwvZGl2PjwvdGQ+JzonXCI+PHNwYW4vPjwvdGQ+Jyxcblx0XHRcdG9UYWJsZVRSPSc8dGFibGUgY2xhc3M9XCJldm8tcGFsZXR0ZTInK19pZSsnXCI+PHRyPicsXG5cdFx0XHRjVGFibGVUUj0nPC90cj48L3RhYmxlPic7XG5cblx0XHR2YXIgaD0nPGRpdiBjbGFzcz1cImV2by1wYWxjZW50ZXJcIj4nO1xuXHRcdC8vIGhleGFnb24gY29sb3JzXG5cdFx0Zm9yKHZhciByPTAsck1heD13ZWJDb2xvcnMubGVuZ3RoO3I8ck1heDtyKyspe1xuXHRcdFx0aCs9b1RhYmxlVFI7XG5cdFx0XHR2YXIgY3M9d2ViQ29sb3JzW3JdO1xuXHRcdFx0Zm9yKGk9MCxpTWF4PWNzLmxlbmd0aDtpPGlNYXg7aSsrKXsgXG5cdFx0XHRcdGgrPW9URCtjc1tpXStjVEQ7XG5cdFx0XHR9XG5cdFx0XHRoKz1jVGFibGVUUjtcblx0XHR9XG5cdFx0aCs9JzxkaXYgY2xhc3M9XCJldm8tc2VwXCIvPic7XG5cdFx0Ly8gZ3JheSBzY2FsZSBjb2xvcnNcblx0XHR2YXIgaDI9Jyc7XG5cdFx0aCs9b1RhYmxlVFI7XG5cdFx0Zm9yKGk9MjU1O2k+MTA7aS09MTApe1xuXHRcdFx0aCs9b1REK2ludDJIZXgzKGkpK2NURDtcblx0XHRcdGktPTEwO1xuXHRcdFx0aDIrPW9URCtpbnQySGV4MyhpKStjVEQ7XG5cdFx0fVxuXHRcdGgrPWNUYWJsZVRSK29UYWJsZVRSK2gyK2NUYWJsZVRSKyc8L2Rpdj4nO1xuXHRcdHJldHVybiBoO1xuXHR9LFxuXG5cdF9zd2l0Y2hQYWxldHRlOiBmdW5jdGlvbihsaW5rKSB7XG5cdFx0aWYodGhpcy5fZW5hYmxlZCl7XG5cdFx0XHR2YXIgaWR4LCBcblx0XHRcdFx0Y29udGVudCwgXG5cdFx0XHRcdGxhYmVsLFxuXHRcdFx0XHRvcHRzPXRoaXMub3B0aW9ucyxcblx0XHRcdFx0bGFiZWxzPW9wdHMuc3RyaW5ncy5zcGxpdCgnLCcpO1xuXHRcdFx0aWYoJChsaW5rKS5oYXNDbGFzcygnZXZvLWhpc3QnKSl7XG5cdFx0XHRcdC8vIGhpc3Rvcnlcblx0XHRcdFx0dmFyIGg9Jzx0YWJsZSBjbGFzcz1cImV2by1wYWxldHRlXCI+PHRyPjx0aCBjbGFzcz1cInVpLXdpZGdldC1jb250ZW50XCI+Jytcblx0XHRcdFx0XHRsYWJlbHNbNV0rJzwvdGg+PC90cj48L3RyPjwvdGFibGU+Jytcblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImV2by1jSGlzdFwiPic7XG5cdFx0XHRcdGlmKGhpc3RvcnkubGVuZ3RoPT09MCl7XG5cdFx0XHRcdFx0aCs9JzxwPiZuYnNwOycrbGFiZWxzWzZdKyc8L3A+Jztcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Zm9yKHZhciBpPWhpc3RvcnkubGVuZ3RoLTE7aT4tMTtpLS0pe1xuXHRcdFx0XHRcdFx0aWYoaGlzdG9yeVtpXS5sZW5ndGg9PT05KXtcblx0XHRcdFx0XHRcdFx0aWYob3B0cy50cmFuc3BhcmVudENvbG9yKXtcblx0XHRcdFx0XHRcdFx0XHRoKz0nPGRpdiBjbGFzcz1cImV2by10cmFuc3BhcmVudFwiPjwvZGl2Pic7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRoKz0nPGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JytoaXN0b3J5W2ldKydcIj48L2Rpdj4nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRoKz0nPC9kaXY+Jztcblx0XHRcdFx0aWR4PS10aGlzLl9wYWxldHRlSWR4O1xuXHRcdFx0XHRjb250ZW50PWg7XG5cdFx0XHRcdGxhYmVsPWxhYmVsc1s0XTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyBwYWxldHRlXG5cdFx0XHRcdGlmKHRoaXMuX3BhbGV0dGVJZHg8MCl7XG5cdFx0XHRcdFx0aWR4PS10aGlzLl9wYWxldHRlSWR4O1xuXHRcdFx0XHRcdHRoaXMuX3BhbGV0dGUuZmluZCgnLmV2by1oaXN0Jykuc2hvdygpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpZHg9KHRoaXMuX3BhbGV0dGVJZHg9PTIpPzE6Mjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZW50PXRoaXNbJ19wYWxldHRlSFRNTCcraWR4XSgpO1xuXHRcdFx0XHRsYWJlbD1sYWJlbHNbaWR4KzFdO1xuXHRcdFx0XHR0aGlzLl9wYWxldHRlSWR4PWlkeDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3BhbGV0dGVJZHg9aWR4O1xuXHRcdFx0dmFyIGU9dGhpcy5fcGFsZXR0ZS5maW5kKCcuZXZvLW1vcmUnKVxuXHRcdFx0XHQucHJldigpLmh0bWwoY29udGVudCkuZW5kKClcblx0XHRcdFx0LmNoaWxkcmVuKCkuZXEoMCkuaHRtbChsYWJlbCk7XG5cdFx0XHRpZihpZHg8MCl7XG5cdFx0XHRcdGUubmV4dCgpLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2Rvd25PclVwUG9zaXRpb25pbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGkgPSAwO1xuXHRcdHdoaWxlIChlbCAhPT0gbnVsbCAmJiBpIDwgMTAwKSB7XG5cdFx0XHQvLyBMb29rIHVwIHRoZSBmaXJzdCBwYXJlbnQgd2l0aCBub24tdmlzaWJpbGUgb3ZlcmZsb3cgYW5kIGNvbXB1dGUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uXG5cdFx0XHRpZiAoZWwuY3NzKCdvdmVyZmxvdycpICE9ICd2aXNpYmxlJykge1xuXHRcdFx0XHR2YXIgYm90dCA9IHRoaXMuX3BhbGV0dGUub2Zmc2V0KCkudG9wICsgdGhpcy5fcGFsZXR0ZS5oZWlnaHQoKSxcblx0XHRcdFx0XHRwQm90dCA9IGVsLm9mZnNldCgpLnRvcCArIGVsLmhlaWdodCgpLFxuXHRcdFx0XHRcdHRvcCA9IHRoaXMuX3BhbGV0dGUub2Zmc2V0KCkudG9wIC0gdGhpcy5fcGFsZXR0ZS5oZWlnaHQoKSAtIHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdHBUb3AgPSBlbC5vZmZzZXQoKS50b3AsXG5cdFx0XHRcdFx0b3BlblVwID0gYm90dCA+IHBCb3R0ICYmIHRvcCA+IHBUb3A7XG5cdFx0XHRcdGlmIChvcGVuVXApIHtcblx0XHRcdFx0XHR0aGlzLl9wYWxldHRlLmNzcyh7IGJvdHRvbTogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkrJ3B4JyB9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wYWxldHRlLmNzcyh7IGJvdHRvbTogJ2F1dG8nIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsWzBdLnRhZ05hbWUgPT0gJ0hUTUwnKSBicmVhaztcblx0XHRcdGVsc2UgZWwgPSBlbC5vZmZzZXRQYXJlbnQoKTtcblx0XHRcdGkrKztcblx0XHR9XG5cdH0sXG5cblx0c2hvd1BhbGV0dGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuX2VuYWJsZWQpe1xuXHRcdFx0dGhpcy5fYWN0aXZlPXRydWU7XG5cdFx0XHQkKCcuY29sb3JQaWNrZXInKS5ub3QoJy4nK3RoaXMuX2lkKS5jb2xvcnBpY2tlcignaGlkZVBhbGV0dGUnKTtcblx0XHRcdGlmKHRoaXMuX3BhbGV0dGU9PT1udWxsKXtcblx0XHRcdFx0dGhpcy5fcGFsZXR0ZT10aGlzLmVsZW1lbnQubmV4dCgpXG5cdFx0XHRcdFx0LmFmdGVyKHRoaXMuX3BhbGV0dGVIVE1MKCkpLm5leHQoKVxuXHRcdFx0XHRcdC5vbignY2xpY2snLGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuX2JpbmRDb2xvcnMoKTtcblx0XHRcdFx0dmFyIHRoYXQ9dGhpcztcblx0XHRcdFx0aWYodGhpcy5faXNQb3B1cCl7XG5cdFx0XHRcdFx0dGhpcy5fZG93bk9yVXBQb3NpdGlvbmluZygpO1xuXHRcdFx0XHRcdCQoZG9jdW1lbnQuYm9keSkub24oJ2NsaWNrLicrdGhhdC5faWQsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0XHRpZihldnQudGFyZ2V0IT10aGF0LmVsZW1lbnQuZ2V0KDApKXtcblx0XHRcdFx0XHRcdFx0dGhhdC5oaWRlUGFsZXR0ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLm9uKCdrZXl1cC4nK3RoYXQuX2lkLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdFx0aWYoZXZ0LmtleUNvZGU9PT0yNyl7XG5cdFx0XHRcdFx0XHRcdHRoYXQuaGlkZVBhbGV0dGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRoaWRlUGFsZXR0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5faXNQb3B1cCAmJiB0aGlzLl9wYWxldHRlKXtcblx0XHRcdCQoZG9jdW1lbnQuYm9keSkub2ZmKCdjbGljay4nK3RoaXMuX2lkKTtcblx0XHRcdHZhciB0aGF0PXRoaXM7XG5cdFx0XHR0aGlzLl9wYWxldHRlLm9mZignbW91c2VvdmVyIGNsaWNrJywgJ3RkLC5ldm8tdHJhbnNwYXJlbnQnKVxuXHRcdFx0XHQuZmFkZU91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHRoYXQuX3BhbGV0dGUucmVtb3ZlKCk7XG5cdFx0XHRcdFx0dGhhdC5fcGFsZXR0ZT10aGF0Ll9jVHh0PW51bGw7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5maW5kKCcuZXZvLW1vcmUgYScpLm9mZignY2xpY2snKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2JpbmRDb2xvcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0PXRoaXMsXG5cdFx0XHRvcHRzPXRoaXMub3B0aW9ucyxcblx0XHRcdGVzPXRoaXMuX3BhbGV0dGUuZmluZCgnZGl2LmV2by1jb2xvcicpLFxuXHRcdFx0c2VsPW9wdHMuaGlzdG9yeT8ndGQsLmV2by1jSGlzdD5kaXYnOid0ZCc7XG5cblx0XHRpZihvcHRzLnRyYW5zcGFyZW50Q29sb3Ipe1xuXHRcdFx0c2VsKz0nLC5ldm8tdHJhbnNwYXJlbnQnO1xuXHRcdH1cblx0XHR0aGlzLl9jVHh0MT1lcy5lcSgwKS5jaGlsZHJlbigpLmVxKDApO1xuXHRcdHRoaXMuX2NUeHQyPWVzLmVxKDEpLmNoaWxkcmVuKCkuZXEoMCk7XG5cdFx0dGhpcy5fcGFsZXR0ZVxuXHRcdFx0Lm9uKCdjbGljaycsIHNlbCwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0aWYodGhhdC5fZW5hYmxlZCl7XG5cdFx0XHRcdFx0dmFyICR0aGlzPSQodGhpcyk7XG5cdFx0XHRcdFx0dGhhdC5fc2V0VmFsdWUoJHRoaXMuaGFzQ2xhc3MoJ2V2by10cmFuc3BhcmVudCcpP3RyYW5zQ29sb3I6dG9IZXgzKCR0aGlzLmF0dHIoJ3N0eWxlJykuc3Vic3RyaW5nKDE3KSkpO1xuXHRcdFx0XHRcdHRoYXQuX2FjdGl2ZT1mYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5vbignbW91c2VvdmVyJywgc2VsLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRpZih0aGF0Ll9lbmFibGVkKXtcblx0XHRcdFx0XHR2YXIgJHRoaXM9JCh0aGlzKSxcblx0XHRcdFx0XHRcdGM9JHRoaXMuaGFzQ2xhc3MoJ2V2by10cmFuc3BhcmVudCcpP3RyYW5zQ29sb3I6dG9IZXgzKCR0aGlzLmF0dHIoJ3N0eWxlJykuc3Vic3RyaW5nKDE3KSk7XG5cdFx0XHRcdFx0aWYodGhhdC5vcHRpb25zLmRpc3BsYXlJbmRpY2F0b3Ipe1xuXHRcdFx0XHRcdFx0dGhhdC5fc2V0Q29sb3JJbmQoYywyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodGhhdC5fYWN0aXZlKXtcblx0XHRcdFx0XHRcdHRoYXQuZWxlbWVudC50cmlnZ2VyKCdtb3VzZW92ZXIuY29sb3InLCBjKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuZmluZCgnLmV2by1tb3JlIGEnKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuXHRcdFx0XHR0aGF0Ll9zd2l0Y2hQYWxldHRlKHRoaXMpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0dmFsOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWU9PSd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNvbG9yO1xuXHRcdH1lbHNle1xuXHRcdFx0dGhpcy5fc2V0VmFsdWUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRWYWx1ZTogZnVuY3Rpb24oYywgbm9IaWRlKSB7XG5cdFx0YyA9IGMucmVwbGFjZSgvIC9nLCcnKTtcblx0XHR0aGlzLm9wdGlvbnMuY29sb3I9Yztcblx0XHRpZih0aGlzLl9pc1BvcHVwKXtcblx0XHRcdGlmKCFub0hpZGUpe1xuXHRcdFx0XHR0aGlzLmhpZGVQYWxldHRlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZXRCb3hDb2xvcih0aGlzLmVsZW1lbnQudmFsKGMpLmNoYW5nZSgpLm5leHQoKSwgYyk7XG5cdFx0fWVsc2V7XG5cdFx0XHR0aGlzLl9zZXRDb2xvckluZChjLDEpO1xuXHRcdH1cblx0XHRpZih0aGlzLm9wdGlvbnMuaGlzdG9yeSAmJiB0aGlzLl9wYWxldHRlSWR4PjApe1xuXHRcdFx0dGhpcy5fYWRkMkhpc3RvcnkoYyk7XG5cdFx0fVxuXHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UuY29sb3InLCBjKTtcblx0fSxcblxuXHRfc2V0Q29sb3JJbmQ6IGZ1bmN0aW9uKGMsIGlkeCkge1xuXHRcdHZhciAkYm94PXRoaXNbJ19jVHh0JytpZHhdO1xuXHRcdHRoaXMuX3NldEJveENvbG9yKCRib3gsIGMpO1xuXHRcdCRib3gubmV4dCgpLmh0bWwoYyk7XG5cdH0sXG5cblx0X3NldEJveENvbG9yOiBmdW5jdGlvbigkYm94LCBjKSB7XG5cdFx0aWYoYz09PXRyYW5zQ29sb3Ipe1xuXHRcdFx0JGJveC5hZGRDbGFzcygnZXZvLXRyYW5zcGFyZW50Jylcblx0XHRcdFx0LnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdFx0fWVsc2V7XG5cdFx0XHQkYm94LnJlbW92ZUNsYXNzKCdldm8tdHJhbnNwYXJlbnQnKVxuXHRcdFx0XHQuYXR0cignc3R5bGUnLCdiYWNrZ3JvdW5kLWNvbG9yOicrYyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0XHRpZihrZXk9PSdjb2xvcicpe1xuXHRcdFx0dGhpcy5fc2V0VmFsdWUodmFsdWUsIHRydWUpO1xuXHRcdH1lbHNle1xuXHRcdFx0dGhpcy5vcHRpb25zW2tleV09dmFsdWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGQySGlzdG9yeTogZnVuY3Rpb24oYykge1xuXHRcdHZhciBpTWF4PWhpc3RvcnkubGVuZ3RoO1xuXHRcdC8vIHNraXAgY29sb3IgaWYgYWxyZWFkeSBpbiBoaXN0b3J5XG5cdFx0Zm9yKHZhciBpPTA7aTxpTWF4O2krKyl7XG5cdFx0XHRpZihjPT1oaXN0b3J5W2ldKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBsaW1pdCBvZiAyOCBjb2xvcnMgaW4gaGlzdG9yeVxuXHRcdGlmKGlNYXg+Mjcpe1xuXHRcdFx0aGlzdG9yeS5zaGlmdCgpO1xuXHRcdH1cblx0XHQvLyBhZGQgdG8gaGlzdG9yeVxuXHRcdGhpc3RvcnkucHVzaChjKTtcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKXtcblx0XHR0aGlzLmhpZGVQYWxldHRlKCkudmFsKCcnKTtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlPXRoaXMuZWxlbWVudDtcblx0XHRpZih0aGlzLl9pc1BvcHVwKXtcblx0XHRcdGUucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblx0XHR9ZWxzZXtcblx0XHRcdGUuY3NzKHtcblx0XHRcdFx0J29wYWNpdHknOiAnMScsIFxuXHRcdFx0XHQncG9pbnRlci1ldmVudHMnOiAnYXV0bydcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZih0aGlzLm9wdGlvbnMuc2hvd09uIT09J2ZvY3VzJyl7XG5cdFx0XHR0aGlzLmVsZW1lbnQubmV4dCgpLmFkZENsYXNzKCdldm8tcG9pbnRlcicpO1xuXHRcdH1cblx0XHRlLnJlbW92ZUF0dHIoJ2FyaWEtZGlzYWJsZWQnKTtcblx0XHR0aGlzLl9lbmFibGVkPXRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGU9dGhpcy5lbGVtZW50O1xuXHRcdGlmKHRoaXMuX2lzUG9wdXApe1xuXHRcdFx0ZS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuXHRcdH1lbHNle1xuXHRcdFx0dGhpcy5oaWRlUGFsZXR0ZSgpO1xuXHRcdFx0ZS5jc3Moe1xuXHRcdFx0XHQnb3BhY2l0eSc6ICcwLjMnLCBcblx0XHRcdFx0J3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYodGhpcy5vcHRpb25zLnNob3dPbiE9PSdmb2N1cycpe1xuXHRcdFx0dGhpcy5lbGVtZW50Lm5leHQoKS5yZW1vdmVDbGFzcygnZXZvLXBvaW50ZXInKTtcblx0XHR9XG5cdFx0ZS5hdHRyKCdhcmlhLWRpc2FibGVkJywndHJ1ZScpO1xuXHRcdHRoaXMuX2VuYWJsZWQ9ZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0aXNEaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9lbmFibGVkO1xuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdCQoZG9jdW1lbnQuYm9keSkub2ZmKCdjbGljay4nK3RoaXMuX2lkKTtcblx0XHRpZih0aGlzLl9wYWxldHRlKXtcblx0XHRcdHRoaXMuX3BhbGV0dGUub2ZmKCdtb3VzZW92ZXIgY2xpY2snLCAndGQsLmV2by1jSGlzdD5kaXYsLmV2by10cmFuc3BhcmVudCcpXG5cdFx0XHRcdC5maW5kKCcuZXZvLW1vcmUgYScpLm9mZignY2xpY2snKTtcblx0XHRcdGlmKHRoaXMuX2lzUG9wdXApe1xuXHRcdFx0XHR0aGlzLl9wYWxldHRlLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcGFsZXR0ZT10aGlzLl9jVHh0PW51bGw7XG5cdFx0fVxuXHRcdGlmKHRoaXMuX2lzUG9wdXApe1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5uZXh0KCkub2ZmKCdjbGljaycpLnJlbW92ZSgpXG5cdFx0XHRcdC5lbmQoKS5vZmYoJ2ZvY3VzJykudW53cmFwKCk7XG5cdFx0fVxuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygnY29sb3JQaWNrZXIgJyt0aGlzLmlkKS5lbXB0eSgpO1xuXHRcdCQuV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cdH1cblxufSk7XG5cbn0pKGpRdWVyeSk7XG4iLCIvLyAgICAgSmF2YVNjcmlwdCBFeHByZXNzaW9uIFBhcnNlciAoSlNFUCkgMC4zLjRcclxuLy8gICAgIEpTRVAgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuLy8gICAgIGh0dHA6Ly9qc2VwLmZyb20uc28vXHJcblxyXG4vKmdsb2JhbCBtb2R1bGU6IHRydWUsIGV4cG9ydHM6IHRydWUsIGNvbnNvbGU6IHRydWUgKi9cclxuKGZ1bmN0aW9uIChyb290KSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdC8vIE5vZGUgVHlwZXNcclxuXHQvLyAtLS0tLS0tLS0tXHJcblxyXG5cdC8vIFRoaXMgaXMgdGhlIGZ1bGwgc2V0IG9mIHR5cGVzIHRoYXQgYW55IEpTRVAgbm9kZSBjYW4gYmUuXHJcblx0Ly8gU3RvcmUgdGhlbSBoZXJlIHRvIHNhdmUgc3BhY2Ugd2hlbiBtaW5pZmllZFxyXG5cdHZhciBDT01QT1VORCA9ICdDb21wb3VuZCcsXHJcblx0XHRJREVOVElGSUVSID0gJ0lkZW50aWZpZXInLFxyXG5cdFx0TUVNQkVSX0VYUCA9ICdNZW1iZXJFeHByZXNzaW9uJyxcclxuXHRcdExJVEVSQUwgPSAnTGl0ZXJhbCcsXHJcblx0XHRUSElTX0VYUCA9ICdUaGlzRXhwcmVzc2lvbicsXHJcblx0XHRDQUxMX0VYUCA9ICdDYWxsRXhwcmVzc2lvbicsXHJcblx0XHRVTkFSWV9FWFAgPSAnVW5hcnlFeHByZXNzaW9uJyxcclxuXHRcdEJJTkFSWV9FWFAgPSAnQmluYXJ5RXhwcmVzc2lvbicsXHJcblx0XHRMT0dJQ0FMX0VYUCA9ICdMb2dpY2FsRXhwcmVzc2lvbicsXHJcblx0XHRDT05ESVRJT05BTF9FWFAgPSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcclxuXHRcdEFSUkFZX0VYUCA9ICdBcnJheUV4cHJlc3Npb24nLFxyXG5cclxuXHRcdFBFUklPRF9DT0RFID0gNDYsIC8vICcuJ1xyXG5cdFx0Q09NTUFfQ09ERSAgPSA0NCwgLy8gJywnXHJcblx0XHRTUVVPVEVfQ09ERSA9IDM5LCAvLyBzaW5nbGUgcXVvdGVcclxuXHRcdERRVU9URV9DT0RFID0gMzQsIC8vIGRvdWJsZSBxdW90ZXNcclxuXHRcdE9QQVJFTl9DT0RFID0gNDAsIC8vIChcclxuXHRcdENQQVJFTl9DT0RFID0gNDEsIC8vIClcclxuXHRcdE9CUkFDS19DT0RFID0gOTEsIC8vIFtcclxuXHRcdENCUkFDS19DT0RFID0gOTMsIC8vIF1cclxuXHRcdFFVTUFSS19DT0RFID0gNjMsIC8vID9cclxuXHRcdFNFTUNPTF9DT0RFID0gNTksIC8vIDtcclxuXHRcdENPTE9OX0NPREUgID0gNTgsIC8vIDpcclxuXHJcblx0XHR0aHJvd0Vycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgaW5kZXgpIHtcclxuXHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgKyAnIGF0IGNoYXJhY3RlciAnICsgaW5kZXgpO1xyXG5cdFx0XHRlcnJvci5pbmRleCA9IGluZGV4O1xyXG5cdFx0XHRlcnJvci5kZXNjcmlwdGlvbiA9IG1lc3NhZ2U7XHJcblx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0fSxcclxuXHJcblx0Ly8gT3BlcmF0aW9uc1xyXG5cdC8vIC0tLS0tLS0tLS1cclxuXHJcblx0Ly8gU2V0IGB0YCB0byBgdHJ1ZWAgdG8gc2F2ZSBzcGFjZSAod2hlbiBtaW5pZmllZCwgbm90IGd6aXBwZWQpXHJcblx0XHR0ID0gdHJ1ZSxcclxuXHQvLyBVc2UgYSBxdWlja2x5LWFjY2Vzc2libGUgbWFwIHRvIHN0b3JlIGFsbCBvZiB0aGUgdW5hcnkgb3BlcmF0b3JzXHJcblx0Ly8gVmFsdWVzIGFyZSBzZXQgdG8gYHRydWVgIChpdCByZWFsbHkgZG9lc24ndCBtYXR0ZXIpXHJcblx0XHR1bmFyeV9vcHMgPSB7Jy0nOiB0LCAnISc6IHQsICd+JzogdCwgJysnOiB0fSxcclxuXHQvLyBBbHNvIHVzZSBhIG1hcCBmb3IgdGhlIGJpbmFyeSBvcGVyYXRpb25zIGJ1dCBzZXQgdGhlaXIgdmFsdWVzIHRvIHRoZWlyXHJcblx0Ly8gYmluYXJ5IHByZWNlZGVuY2UgZm9yIHF1aWNrIHJlZmVyZW5jZTpcclxuXHQvLyBzZWUgW09yZGVyIG9mIG9wZXJhdGlvbnNdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3JkZXJfb2Zfb3BlcmF0aW9ucyNQcm9ncmFtbWluZ19sYW5ndWFnZSlcclxuXHRcdGJpbmFyeV9vcHMgPSB7XHJcblx0XHRcdCd8fCc6IDEsICcmJic6IDIsICd8JzogMywgICdeJzogNCwgICcmJzogNSxcclxuXHRcdFx0Jz09JzogNiwgJyE9JzogNiwgJz09PSc6IDYsICchPT0nOiA2LFxyXG5cdFx0XHQnPCc6IDcsICAnPic6IDcsICAnPD0nOiA3LCAgJz49JzogNyxcclxuXHRcdFx0Jzw8Jzo4LCAgJz4+JzogOCwgJz4+Pic6IDgsXHJcblx0XHRcdCcrJzogOSwgJy0nOiA5LFxyXG5cdFx0XHQnKic6IDEwLCAnLyc6IDEwLCAnJSc6IDEwXHJcblx0XHR9LFxyXG5cdC8vIEdldCByZXR1cm4gdGhlIGxvbmdlc3Qga2V5IGxlbmd0aCBvZiBhbnkgb2JqZWN0XHJcblx0XHRnZXRNYXhLZXlMZW4gPSBmdW5jdGlvbihvYmopIHtcclxuXHRcdFx0dmFyIG1heF9sZW4gPSAwLCBsZW47XHJcblx0XHRcdGZvcih2YXIga2V5IGluIG9iaikge1xyXG5cdFx0XHRcdGlmKChsZW4gPSBrZXkubGVuZ3RoKSA+IG1heF9sZW4gJiYgb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0XHRcdG1heF9sZW4gPSBsZW47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBtYXhfbGVuO1xyXG5cdFx0fSxcclxuXHRcdG1heF91bm9wX2xlbiA9IGdldE1heEtleUxlbih1bmFyeV9vcHMpLFxyXG5cdFx0bWF4X2Jpbm9wX2xlbiA9IGdldE1heEtleUxlbihiaW5hcnlfb3BzKSxcclxuXHQvLyBMaXRlcmFsc1xyXG5cdC8vIC0tLS0tLS0tLS1cclxuXHQvLyBTdG9yZSB0aGUgdmFsdWVzIHRvIHJldHVybiBmb3IgdGhlIHZhcmlvdXMgbGl0ZXJhbHMgd2UgbWF5IGVuY291bnRlclxyXG5cdFx0bGl0ZXJhbHMgPSB7XHJcblx0XHRcdCd0cnVlJzogdHJ1ZSxcclxuXHRcdFx0J2ZhbHNlJzogZmFsc2UsXHJcblx0XHRcdCdudWxsJzogbnVsbFxyXG5cdFx0fSxcclxuXHQvLyBFeGNlcHQgZm9yIGB0aGlzYCwgd2hpY2ggaXMgc3BlY2lhbC4gVGhpcyBjb3VsZCBiZSBjaGFuZ2VkIHRvIHNvbWV0aGluZyBsaWtlIGAnc2VsZidgIGFzIHdlbGxcclxuXHRcdHRoaXNfc3RyID0gJ3RoaXMnLFxyXG5cdC8vIFJldHVybnMgdGhlIHByZWNlZGVuY2Ugb2YgYSBiaW5hcnkgb3BlcmF0b3Igb3IgYDBgIGlmIGl0IGlzbid0IGEgYmluYXJ5IG9wZXJhdG9yXHJcblx0XHRiaW5hcnlQcmVjZWRlbmNlID0gZnVuY3Rpb24ob3BfdmFsKSB7XHJcblx0XHRcdHJldHVybiBiaW5hcnlfb3BzW29wX3ZhbF0gfHwgMDtcclxuXHRcdH0sXHJcblx0Ly8gVXRpbGl0eSBmdW5jdGlvbiAoZ2V0cyBjYWxsZWQgZnJvbSBtdWx0aXBsZSBwbGFjZXMpXHJcblx0Ly8gQWxzbyBub3RlIHRoYXQgYGEgJiYgYmAgYW5kIGBhIHx8IGJgIGFyZSAqbG9naWNhbCogZXhwcmVzc2lvbnMsIG5vdCBiaW5hcnkgZXhwcmVzc2lvbnNcclxuXHRcdGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRcdHZhciB0eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IExPR0lDQUxfRVhQIDogQklOQVJZX0VYUDtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHRcdG9wZXJhdG9yOiBvcGVyYXRvcixcclxuXHRcdFx0XHRsZWZ0OiBsZWZ0LFxyXG5cdFx0XHRcdHJpZ2h0OiByaWdodFxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHRcdC8vIGBjaGAgaXMgYSBjaGFyYWN0ZXIgY29kZSBpbiB0aGUgbmV4dCB0aHJlZSBmdW5jdGlvbnNcclxuXHRcdGlzRGVjaW1hbERpZ2l0ID0gZnVuY3Rpb24oY2gpIHtcclxuXHRcdFx0cmV0dXJuIChjaCA+PSA0OCAmJiBjaCA8PSA1Nyk7IC8vIDAuLi45XHJcblx0XHR9LFxyXG5cdFx0aXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihjaCkge1xyXG5cdFx0XHRyZXR1cm4gKGNoID09PSAzNikgfHwgKGNoID09PSA5NSkgfHwgLy8gYCRgIGFuZCBgX2BcclxuXHRcdFx0XHRcdChjaCA+PSA2NSAmJiBjaCA8PSA5MCkgfHwgLy8gQS4uLlpcclxuXHRcdFx0XHRcdChjaCA+PSA5NyAmJiBjaCA8PSAxMjIpIHx8IC8vIGEuLi56XHJcbiAgICAgICAgICAgICAgICAgICAgKGNoID49IDEyOCAmJiAhYmluYXJ5X29wc1tTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKV0pOyAvLyBhbnkgbm9uLUFTQ0lJIHRoYXQgaXMgbm90IGFuIG9wZXJhdG9yXHJcblx0XHR9LFxyXG5cdFx0aXNJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKGNoKSB7XHJcblx0XHRcdHJldHVybiAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAvLyBgJGAgYW5kIGBfYFxyXG5cdFx0XHRcdFx0KGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAvLyBBLi4uWlxyXG5cdFx0XHRcdFx0KGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgLy8gYS4uLnpcclxuXHRcdFx0XHRcdChjaCA+PSA0OCAmJiBjaCA8PSA1NykgfHwgLy8gMC4uLjlcclxuICAgICAgICAgICAgICAgICAgICAoY2ggPj0gMTI4ICYmICFiaW5hcnlfb3BzW1N0cmluZy5mcm9tQ2hhckNvZGUoY2gpXSk7IC8vIGFueSBub24tQVNDSUkgdGhhdCBpcyBub3QgYW4gb3BlcmF0b3JcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gUGFyc2luZ1xyXG5cdFx0Ly8gLS0tLS0tLVxyXG5cdFx0Ly8gYGV4cHJgIGlzIGEgc3RyaW5nIHdpdGggdGhlIHBhc3NlZCBpbiBleHByZXNzaW9uXHJcblx0XHRqc2VwID0gZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0XHQvLyBgaW5kZXhgIHN0b3JlcyB0aGUgY2hhcmFjdGVyIG51bWJlciB3ZSBhcmUgY3VycmVudGx5IGF0IHdoaWxlIGBsZW5ndGhgIGlzIGEgY29uc3RhbnRcclxuXHRcdFx0Ly8gQWxsIG9mIHRoZSBnb2JibGVzIGJlbG93IHdpbGwgbW9kaWZ5IGBpbmRleGAgYXMgd2UgbW92ZSBhbG9uZ1xyXG5cdFx0XHR2YXIgaW5kZXggPSAwLFxyXG5cdFx0XHRcdGNoYXJBdEZ1bmMgPSBleHByLmNoYXJBdCxcclxuXHRcdFx0XHRjaGFyQ29kZUF0RnVuYyA9IGV4cHIuY2hhckNvZGVBdCxcclxuXHRcdFx0XHRleHBySSA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGNoYXJBdEZ1bmMuY2FsbChleHByLCBpKTsgfSxcclxuXHRcdFx0XHRleHBySUNvZGUgPSBmdW5jdGlvbihpKSB7IHJldHVybiBjaGFyQ29kZUF0RnVuYy5jYWxsKGV4cHIsIGkpOyB9LFxyXG5cdFx0XHRcdGxlbmd0aCA9IGV4cHIubGVuZ3RoLFxyXG5cclxuXHRcdFx0XHQvLyBQdXNoIGBpbmRleGAgdXAgdG8gdGhlIG5leHQgbm9uLXNwYWNlIGNoYXJhY3RlclxyXG5cdFx0XHRcdGdvYmJsZVNwYWNlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIGNoID0gZXhwcklDb2RlKGluZGV4KTtcclxuXHRcdFx0XHRcdC8vIHNwYWNlIG9yIHRhYlxyXG5cdFx0XHRcdFx0d2hpbGUoY2ggPT09IDMyIHx8IGNoID09PSA5IHx8IGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHtcclxuXHRcdFx0XHRcdFx0Y2ggPSBleHBySUNvZGUoKytpbmRleCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gVGhlIG1haW4gcGFyc2luZyBmdW5jdGlvbi4gTXVjaCBvZiB0aGlzIGNvZGUgaXMgZGVkaWNhdGVkIHRvIHRlcm5hcnkgZXhwcmVzc2lvbnNcclxuXHRcdFx0XHRnb2JibGVFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgdGVzdCA9IGdvYmJsZUJpbmFyeUV4cHJlc3Npb24oKSxcclxuXHRcdFx0XHRcdFx0Y29uc2VxdWVudCwgYWx0ZXJuYXRlO1xyXG5cdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XHJcblx0XHRcdFx0XHRpZihleHBySUNvZGUoaW5kZXgpID09PSBRVU1BUktfQ09ERSkge1xyXG5cdFx0XHRcdFx0XHQvLyBUZXJuYXJ5IGV4cHJlc3Npb246IHRlc3QgPyBjb25zZXF1ZW50IDogYWx0ZXJuYXRlXHJcblx0XHRcdFx0XHRcdGluZGV4Kys7XHJcblx0XHRcdFx0XHRcdGNvbnNlcXVlbnQgPSBnb2JibGVFeHByZXNzaW9uKCk7XHJcblx0XHRcdFx0XHRcdGlmKCFjb25zZXF1ZW50KSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3dFcnJvcignRXhwZWN0ZWQgZXhwcmVzc2lvbicsIGluZGV4KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcclxuXHRcdFx0XHRcdFx0aWYoZXhwcklDb2RlKGluZGV4KSA9PT0gQ09MT05fQ09ERSkge1xyXG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XHJcblx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlID0gZ29iYmxlRXhwcmVzc2lvbigpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFhbHRlcm5hdGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkIGV4cHJlc3Npb24nLCBpbmRleCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBDT05ESVRJT05BTF9FWFAsXHJcblx0XHRcdFx0XHRcdFx0XHR0ZXN0OiB0ZXN0LFxyXG5cdFx0XHRcdFx0XHRcdFx0Y29uc2VxdWVudDogY29uc2VxdWVudCxcclxuXHRcdFx0XHRcdFx0XHRcdGFsdGVybmF0ZTogYWx0ZXJuYXRlXHJcblx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdFeHBlY3RlZCA6JywgaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGVzdDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBTZWFyY2ggZm9yIHRoZSBvcGVyYXRpb24gcG9ydGlvbiBvZiB0aGUgc3RyaW5nIChlLmcuIGArYCwgYD09PWApXHJcblx0XHRcdFx0Ly8gU3RhcnQgYnkgdGFraW5nIHRoZSBsb25nZXN0IHBvc3NpYmxlIGJpbmFyeSBvcGVyYXRpb25zICgzIGNoYXJhY3RlcnM6IGA9PT1gLCBgIT09YCwgYD4+PmApXHJcblx0XHRcdFx0Ly8gYW5kIG1vdmUgZG93biBmcm9tIDMgdG8gMiB0byAxIGNoYXJhY3RlciB1bnRpbCBhIG1hdGNoaW5nIGJpbmFyeSBvcGVyYXRpb24gaXMgZm91bmRcclxuXHRcdFx0XHQvLyB0aGVuLCByZXR1cm4gdGhhdCBiaW5hcnkgb3BlcmF0aW9uXHJcblx0XHRcdFx0Z29iYmxlQmluYXJ5T3AgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xyXG5cdFx0XHRcdFx0dmFyIGJpb3AsIHRvX2NoZWNrID0gZXhwci5zdWJzdHIoaW5kZXgsIG1heF9iaW5vcF9sZW4pLCB0Y19sZW4gPSB0b19jaGVjay5sZW5ndGg7XHJcblx0XHRcdFx0XHR3aGlsZSh0Y19sZW4gPiAwKSB7XHJcblx0XHRcdFx0XHRcdC8vIERvbid0IGFjY2VwdCBhIGJpbmFyeSBvcCB3aGVuIGl0IGlzIGFuIGlkZW50aWZpZXIuXHJcblx0XHRcdFx0XHRcdC8vIEJpbmFyeSBvcHMgdGhhdCBzdGFydCB3aXRoIGEgaWRlbnRpZmllci12YWxpZCBjaGFyYWN0ZXIgbXVzdCBiZSBmb2xsb3dlZFxyXG5cdFx0XHRcdFx0XHQvLyBieSBhIG5vbiBpZGVudGlmaWVyLXBhcnQgdmFsaWQgY2hhcmFjdGVyXHJcblx0XHRcdFx0XHRcdGlmKGJpbmFyeV9vcHMuaGFzT3duUHJvcGVydHkodG9fY2hlY2spICYmIChcclxuXHRcdFx0XHRcdFx0XHQhaXNJZGVudGlmaWVyU3RhcnQoZXhwcklDb2RlKGluZGV4KSkgfHxcclxuXHRcdFx0XHRcdFx0XHQoaW5kZXgrdG9fY2hlY2subGVuZ3RoPCBleHByLmxlbmd0aCAmJiAhaXNJZGVudGlmaWVyUGFydChleHBySUNvZGUoaW5kZXgrdG9fY2hlY2subGVuZ3RoKSkpXHJcblx0XHRcdFx0XHRcdCkpIHtcclxuXHRcdFx0XHRcdFx0XHRpbmRleCArPSB0Y19sZW47XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvX2NoZWNrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRvX2NoZWNrID0gdG9fY2hlY2suc3Vic3RyKDAsIC0tdGNfbGVuKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBnb2JibGluZyBhbiBpbmRpdmlkdWFsIGV4cHJlc3Npb24sXHJcblx0XHRcdFx0Ly8gZS5nLiBgMWAsIGAxKzJgLCBgYSsoYioyKS1NYXRoLnNxcnQoMilgXHJcblx0XHRcdFx0Z29iYmxlQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIGNoX2ksIG5vZGUsIGJpb3AsIHByZWMsIHN0YWNrLCBiaW9wX2luZm8sIGxlZnQsIHJpZ2h0LCBpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEZpcnN0LCB0cnkgdG8gZ2V0IHRoZSBsZWZ0bW9zdCB0aGluZ1xyXG5cdFx0XHRcdFx0Ly8gVGhlbiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBiaW5hcnkgb3BlcmF0b3Igb3BlcmF0aW5nIG9uIHRoYXQgbGVmdG1vc3QgdGhpbmdcclxuXHRcdFx0XHRcdGxlZnQgPSBnb2JibGVUb2tlbigpO1xyXG5cdFx0XHRcdFx0YmlvcCA9IGdvYmJsZUJpbmFyeU9wKCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgd2Fzbid0IGEgYmluYXJ5IG9wZXJhdG9yLCBqdXN0IHJldHVybiB0aGUgbGVmdG1vc3Qgbm9kZVxyXG5cdFx0XHRcdFx0aWYoIWJpb3ApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHN0YXJ0IGEgc3RhY2sgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGJpbmFyeSBvcGVyYXRpb25zIGluIHRoZWlyXHJcblx0XHRcdFx0XHQvLyBwcmVjZWRlbmNlIHN0cnVjdHVyZVxyXG5cdFx0XHRcdFx0YmlvcF9pbmZvID0geyB2YWx1ZTogYmlvcCwgcHJlYzogYmluYXJ5UHJlY2VkZW5jZShiaW9wKX07XHJcblxyXG5cdFx0XHRcdFx0cmlnaHQgPSBnb2JibGVUb2tlbigpO1xyXG5cdFx0XHRcdFx0aWYoIXJpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uIGFmdGVyIFwiICsgYmlvcCwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhY2sgPSBbbGVmdCwgYmlvcF9pbmZvLCByaWdodF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gUHJvcGVybHkgZGVhbCB3aXRoIHByZWNlZGVuY2UgdXNpbmcgW3JlY3Vyc2l2ZSBkZXNjZW50XShodHRwOi8vd3d3LmVuZ3IubXVuLmNhL350aGVvL01pc2MvZXhwX3BhcnNpbmcuaHRtKVxyXG5cdFx0XHRcdFx0d2hpbGUoKGJpb3AgPSBnb2JibGVCaW5hcnlPcCgpKSkge1xyXG5cdFx0XHRcdFx0XHRwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShiaW9wKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmKHByZWMgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRiaW9wX2luZm8gPSB7IHZhbHVlOiBiaW9wLCBwcmVjOiBwcmVjIH07XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXHJcblx0XHRcdFx0XHRcdHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcclxuXHRcdFx0XHRcdFx0XHRyaWdodCA9IHN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdFx0XHRcdGJpb3AgPSBzdGFjay5wb3AoKS52YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRsZWZ0ID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0XHRcdFx0bm9kZSA9IGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oYmlvcCwgbGVmdCwgcmlnaHQpO1xyXG5cdFx0XHRcdFx0XHRcdHN0YWNrLnB1c2gobm9kZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG5vZGUgPSBnb2JibGVUb2tlbigpO1xyXG5cdFx0XHRcdFx0XHRpZighbm9kZSkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uIGFmdGVyIFwiICsgYmlvcCwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goYmlvcF9pbmZvLCBub2RlKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpID0gc3RhY2subGVuZ3RoIC0gMTtcclxuXHRcdFx0XHRcdG5vZGUgPSBzdGFja1tpXTtcclxuXHRcdFx0XHRcdHdoaWxlKGkgPiAxKSB7XHJcblx0XHRcdFx0XHRcdG5vZGUgPSBjcmVhdGVCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBub2RlKTtcclxuXHRcdFx0XHRcdFx0aSAtPSAyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gQW4gaW5kaXZpZHVhbCBwYXJ0IG9mIGEgYmluYXJ5IGV4cHJlc3Npb246XHJcblx0XHRcdFx0Ly8gZS5nLiBgZm9vLmJhcihiYXopYCwgYDFgLCBgXCJhYmNcImAsIGAoYSAlIDIpYCAoYmVjYXVzZSBpdCdzIGluIHBhcmVudGhlc2lzKVxyXG5cdFx0XHRcdGdvYmJsZVRva2VuID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgY2gsIHRvX2NoZWNrLCB0Y19sZW47XHJcblxyXG5cdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XHJcblx0XHRcdFx0XHRjaCA9IGV4cHJJQ29kZShpbmRleCk7XHJcblxyXG5cdFx0XHRcdFx0aWYoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSBQRVJJT0RfQ09ERSkge1xyXG5cdFx0XHRcdFx0XHQvLyBDaGFyIGNvZGUgNDYgaXMgYSBkb3QgYC5gIHdoaWNoIGNhbiBzdGFydCBvZmYgYSBudW1lcmljIGxpdGVyYWxcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGdvYmJsZU51bWVyaWNMaXRlcmFsKCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoY2ggPT09IFNRVU9URV9DT0RFIHx8IGNoID09PSBEUVVPVEVfQ09ERSkge1xyXG5cdFx0XHRcdFx0XHQvLyBTaW5nbGUgb3IgZG91YmxlIHF1b3Rlc1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZ29iYmxlU3RyaW5nTGl0ZXJhbCgpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PT0gT0JSQUNLX0NPREUpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGdvYmJsZUFycmF5KCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0b19jaGVjayA9IGV4cHIuc3Vic3RyKGluZGV4LCBtYXhfdW5vcF9sZW4pO1xyXG5cdFx0XHRcdFx0XHR0Y19sZW4gPSB0b19jaGVjay5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdHdoaWxlKHRjX2xlbiA+IDApIHtcclxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgYWNjZXB0IGFuIHVuYXJ5IG9wIHdoZW4gaXQgaXMgYW4gaWRlbnRpZmllci5cclxuXHRcdFx0XHRcdFx0Ly8gVW5hcnkgb3BzIHRoYXQgc3RhcnQgd2l0aCBhIGlkZW50aWZpZXItdmFsaWQgY2hhcmFjdGVyIG11c3QgYmUgZm9sbG93ZWRcclxuXHRcdFx0XHRcdFx0Ly8gYnkgYSBub24gaWRlbnRpZmllci1wYXJ0IHZhbGlkIGNoYXJhY3RlclxyXG5cdFx0XHRcdFx0XHRcdGlmKHVuYXJ5X29wcy5oYXNPd25Qcm9wZXJ0eSh0b19jaGVjaykgJiYgKFxyXG5cdFx0XHRcdFx0XHRcdFx0IWlzSWRlbnRpZmllclN0YXJ0KGV4cHJJQ29kZShpbmRleCkpIHx8XHJcblx0XHRcdFx0XHRcdFx0XHQoaW5kZXgrdG9fY2hlY2subGVuZ3RoIDwgZXhwci5sZW5ndGggJiYgIWlzSWRlbnRpZmllclBhcnQoZXhwcklDb2RlKGluZGV4K3RvX2NoZWNrLmxlbmd0aCkpKVxyXG5cdFx0XHRcdFx0XHRcdCkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ICs9IHRjX2xlbjtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFVOQVJZX0VYUCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0b3I6IHRvX2NoZWNrLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRhcmd1bWVudDogZ29iYmxlVG9rZW4oKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4OiB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR0b19jaGVjayA9IHRvX2NoZWNrLnN1YnN0cigwLCAtLXRjX2xlbik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkgfHwgY2ggPT09IE9QQVJFTl9DT0RFKSB7IC8vIG9wZW4gcGFyZW50aGVzaXNcclxuXHRcdFx0XHRcdFx0XHQvLyBgZm9vYCwgYGJhci5iYXpgXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdvYmJsZVZhcmlhYmxlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHQvLyBQYXJzZSBzaW1wbGUgbnVtZXJpYyBsaXRlcmFsczogYDEyYCwgYDMuNGAsIGAuNWAuIERvIHRoaXMgYnkgdXNpbmcgYSBzdHJpbmcgdG9cclxuXHRcdFx0XHQvLyBrZWVwIHRyYWNrIG9mIGV2ZXJ5dGhpbmcgaW4gdGhlIG51bWVyaWMgbGl0ZXJhbCBhbmQgdGhlbiBjYWxsaW5nIGBwYXJzZUZsb2F0YCBvbiB0aGF0IHN0cmluZ1xyXG5cdFx0XHRcdGdvYmJsZU51bWVyaWNMaXRlcmFsID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgbnVtYmVyID0gJycsIGNoLCBjaENvZGU7XHJcblx0XHRcdFx0XHR3aGlsZShpc0RlY2ltYWxEaWdpdChleHBySUNvZGUoaW5kZXgpKSkge1xyXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYoZXhwcklDb2RlKGluZGV4KSA9PT0gUEVSSU9EX0NPREUpIHsgLy8gY2FuIHN0YXJ0IHdpdGggYSBkZWNpbWFsIG1hcmtlclxyXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XHJcblxyXG5cdFx0XHRcdFx0XHR3aGlsZShpc0RlY2ltYWxEaWdpdChleHBySUNvZGUoaW5kZXgpKSkge1xyXG5cdFx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNoID0gZXhwckkoaW5kZXgpO1xyXG5cdFx0XHRcdFx0aWYoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7IC8vIGV4cG9uZW50IG1hcmtlclxyXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XHJcblx0XHRcdFx0XHRcdGNoID0gZXhwckkoaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRpZihjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHsgLy8gZXhwb25lbnQgc2lnblxyXG5cdFx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR3aGlsZShpc0RlY2ltYWxEaWdpdChleHBySUNvZGUoaW5kZXgpKSkgeyAvL2V4cG9uZW50IGl0c2VsZlxyXG5cdFx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZighaXNEZWNpbWFsRGlnaXQoZXhwcklDb2RlKGluZGV4LTEpKSApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdFeHBlY3RlZCBleHBvbmVudCAoJyArIG51bWJlciArIGV4cHJJKGluZGV4KSArICcpJywgaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGNoQ29kZSA9IGV4cHJJQ29kZShpbmRleCk7XHJcblx0XHRcdFx0XHQvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhpcyBpc24ndCBhIHZhcmlhYmxlIG5hbWUgdGhhdCBzdGFydCB3aXRoIGEgbnVtYmVyICgxMjNhYmMpXHJcblx0XHRcdFx0XHRpZihpc0lkZW50aWZpZXJTdGFydChjaENvZGUpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1ZhcmlhYmxlIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoIGEgbnVtYmVyICgnICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bnVtYmVyICsgZXhwckkoaW5kZXgpICsgJyknLCBpbmRleCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoY2hDb2RlID09PSBQRVJJT0RfQ09ERSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmV4cGVjdGVkIHBlcmlvZCcsIGluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHR0eXBlOiBMSVRFUkFMLFxyXG5cdFx0XHRcdFx0XHR2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxyXG5cdFx0XHRcdFx0XHRyYXc6IG51bWJlclxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBQYXJzZXMgYSBzdHJpbmcgbGl0ZXJhbCwgc3RhcmluZyB3aXRoIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzIHdpdGggYmFzaWMgc3VwcG9ydCBmb3IgZXNjYXBlIGNvZGVzXHJcblx0XHRcdFx0Ly8gZS5nLiBgXCJoZWxsbyB3b3JsZFwiYCwgYCd0aGlzIGlzXFxuSlNFUCdgXHJcblx0XHRcdFx0Z29iYmxlU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIHN0ciA9ICcnLCBxdW90ZSA9IGV4cHJJKGluZGV4KyspLCBjbG9zZWQgPSBmYWxzZSwgY2g7XHJcblxyXG5cdFx0XHRcdFx0d2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0Y2ggPSBleHBySShpbmRleCsrKTtcclxuXHRcdFx0XHRcdFx0aWYoY2ggPT09IHF1b3RlKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNoID09PSAnXFxcXCcpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBDaGVjayBmb3IgYWxsIG9mIHRoZSBjb21tb24gZXNjYXBlIGNvZGVzXHJcblx0XHRcdFx0XHRcdFx0Y2ggPSBleHBySShpbmRleCsrKTtcclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2goY2gpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ24nOiBzdHIgKz0gJ1xcbic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAncic6IHN0ciArPSAnXFxyJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd0Jzogc3RyICs9ICdcXHQnOyBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2InOiBzdHIgKz0gJ1xcYic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZic6IHN0ciArPSAnXFxmJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd2Jzogc3RyICs9ICdcXHgwQic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdCA6IHN0ciArPSBjaDtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IGNoO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYoIWNsb3NlZCkge1xyXG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCBxdW90ZSBhZnRlciBcIicrc3RyKydcIicsIGluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHR0eXBlOiBMSVRFUkFMLFxyXG5cdFx0XHRcdFx0XHR2YWx1ZTogc3RyLFxyXG5cdFx0XHRcdFx0XHRyYXc6IHF1b3RlICsgc3RyICsgcXVvdGVcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gR29iYmxlcyBvbmx5IGlkZW50aWZpZXJzXHJcblx0XHRcdFx0Ly8gZS5nLjogYGZvb2AsIGBfdmFsdWVgLCBgJHgxYFxyXG5cdFx0XHRcdC8vIEFsc28sIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoYXQgaWRlbnRpZmllciBpcyBhIGxpdGVyYWw6XHJcblx0XHRcdFx0Ly8gKGUuZy4gYHRydWVgLCBgZmFsc2VgLCBgbnVsbGApIG9yIGB0aGlzYFxyXG5cdFx0XHRcdGdvYmJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBjaCA9IGV4cHJJQ29kZShpbmRleCksIHN0YXJ0ID0gaW5kZXgsIGlkZW50aWZpZXI7XHJcblxyXG5cdFx0XHRcdFx0aWYoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XHJcblx0XHRcdFx0XHRcdGluZGV4Kys7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmV4cGVjdGVkICcgKyBleHBySShpbmRleCksIGluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR3aGlsZShpbmRleCA8IGxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRjaCA9IGV4cHJJQ29kZShpbmRleCk7XHJcblx0XHRcdFx0XHRcdGlmKGlzSWRlbnRpZmllclBhcnQoY2gpKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5kZXgrKztcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWRlbnRpZmllciA9IGV4cHIuc2xpY2Uoc3RhcnQsIGluZGV4KTtcclxuXHJcblx0XHRcdFx0XHRpZihsaXRlcmFscy5oYXNPd25Qcm9wZXJ0eShpZGVudGlmaWVyKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IExJVEVSQUwsXHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGxpdGVyYWxzW2lkZW50aWZpZXJdLFxyXG5cdFx0XHRcdFx0XHRcdHJhdzogaWRlbnRpZmllclxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKGlkZW50aWZpZXIgPT09IHRoaXNfc3RyKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7IHR5cGU6IFRISVNfRVhQIH07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IElERU5USUZJRVIsXHJcblx0XHRcdFx0XHRcdFx0bmFtZTogaWRlbnRpZmllclxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIEdvYmJsZXMgYSBsaXN0IG9mIGFyZ3VtZW50cyB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYSBmdW5jdGlvbiBjYWxsXHJcblx0XHRcdFx0Ly8gb3IgYXJyYXkgbGl0ZXJhbC4gVGhpcyBmdW5jdGlvbiBhbHNvIGFzc3VtZXMgdGhhdCB0aGUgb3BlbmluZyBjaGFyYWN0ZXJcclxuXHRcdFx0XHQvLyBgKGAgb3IgYFtgIGhhcyBhbHJlYWR5IGJlZW4gZ29iYmxlZCwgYW5kIGdvYmJsZXMgZXhwcmVzc2lvbnMgYW5kIGNvbW1hc1xyXG5cdFx0XHRcdC8vIHVudGlsIHRoZSB0ZXJtaW5hdG9yIGNoYXJhY3RlciBgKWAgb3IgYF1gIGlzIGVuY291bnRlcmVkLlxyXG5cdFx0XHRcdC8vIGUuZy4gYGZvbyhiYXIsIGJheilgLCBgbXlfZnVuYygpYCwgb3IgYFtiYXIsIGJhel1gXHJcblx0XHRcdFx0Z29iYmxlQXJndW1lbnRzID0gZnVuY3Rpb24odGVybWluYXRpb24pIHtcclxuXHRcdFx0XHRcdHZhciBjaF9pLCBhcmdzID0gW10sIG5vZGUsIGNsb3NlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0d2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XHJcblx0XHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRpZihjaF9pID09PSB0ZXJtaW5hdGlvbikgeyAvLyBkb25lIHBhcnNpbmdcclxuXHRcdFx0XHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoY2hfaSA9PT0gQ09NTUFfQ09ERSkgeyAvLyBiZXR3ZWVuIGV4cHJlc3Npb25zXHJcblx0XHRcdFx0XHRcdFx0aW5kZXgrKztcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRub2RlID0gZ29iYmxlRXhwcmVzc2lvbigpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFub2RlIHx8IG5vZGUudHlwZSA9PT0gQ09NUE9VTkQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkIGNvbW1hJywgaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRhcmdzLnB1c2gobm9kZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICghY2xvc2VkKSB7XHJcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkICcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHRlcm1pbmF0aW9uKSwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGFyZ3M7XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gR29iYmxlIGEgbm9uLWxpdGVyYWwgdmFyaWFibGUgbmFtZS4gVGhpcyB2YXJpYWJsZSBuYW1lIG1heSBpbmNsdWRlIHByb3BlcnRpZXNcclxuXHRcdFx0XHQvLyBlLmcuIGBmb29gLCBgYmFyLmJhemAsIGBmb29bJ2JhciddLmJhemBcclxuXHRcdFx0XHQvLyBJdCBhbHNvIGdvYmJsZXMgZnVuY3Rpb24gY2FsbHM6XHJcblx0XHRcdFx0Ly8gZS5nLiBgTWF0aC5hY29zKG9iai5hbmdsZSlgXHJcblx0XHRcdFx0Z29iYmxlVmFyaWFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBjaF9pLCBub2RlO1xyXG5cdFx0XHRcdFx0Y2hfaSA9IGV4cHJJQ29kZShpbmRleCk7XHJcblxyXG5cdFx0XHRcdFx0aWYoY2hfaSA9PT0gT1BBUkVOX0NPREUpIHtcclxuXHRcdFx0XHRcdFx0bm9kZSA9IGdvYmJsZUdyb3VwKCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRub2RlID0gZ29iYmxlSWRlbnRpZmllcigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XHJcblx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcclxuXHRcdFx0XHRcdHdoaWxlKGNoX2kgPT09IFBFUklPRF9DT0RFIHx8IGNoX2kgPT09IE9CUkFDS19DT0RFIHx8IGNoX2kgPT09IE9QQVJFTl9DT0RFKSB7XHJcblx0XHRcdFx0XHRcdGluZGV4Kys7XHJcblx0XHRcdFx0XHRcdGlmKGNoX2kgPT09IFBFUklPRF9DT0RFKSB7XHJcblx0XHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XHJcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IE1FTUJFUl9FWFAsXHJcblx0XHRcdFx0XHRcdFx0XHRjb21wdXRlZDogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3Q6IG5vZGUsXHJcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eTogZ29iYmxlSWRlbnRpZmllcigpXHJcblx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNoX2kgPT09IE9CUkFDS19DT0RFKSB7XHJcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IE1FTUJFUl9FWFAsXHJcblx0XHRcdFx0XHRcdFx0XHRjb21wdXRlZDogdHJ1ZSxcclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogbm9kZSxcclxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5OiBnb2JibGVFeHByZXNzaW9uKClcclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xyXG5cdFx0XHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKGNoX2kgIT09IENCUkFDS19DT0RFKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCBbJywgaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoY2hfaSA9PT0gT1BBUkVOX0NPREUpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBBIGZ1bmN0aW9uIGNhbGwgaXMgYmVpbmcgbWFkZTsgZ29iYmxlIGFsbCB0aGUgYXJndW1lbnRzXHJcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IENBTExfRVhQLFxyXG5cdFx0XHRcdFx0XHRcdFx0J2FyZ3VtZW50cyc6IGdvYmJsZUFyZ3VtZW50cyhDUEFSRU5fQ09ERSksXHJcblx0XHRcdFx0XHRcdFx0XHRjYWxsZWU6IG5vZGVcclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xyXG5cdFx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBub2RlO1xyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIFJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGEgZ3JvdXAgb2YgdGhpbmdzIHdpdGhpbiBwYXJlbnRoZXNlcyBgKClgXHJcblx0XHRcdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgaXQgbmVlZHMgdG8gZ29iYmxlIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzXHJcblx0XHRcdFx0Ly8gYW5kIHRoZW4gdHJpZXMgdG8gZ29iYmxlIGV2ZXJ5dGhpbmcgd2l0aGluIHRoYXQgcGFyZW50aGVzaXMsIGFzc3VtaW5nXHJcblx0XHRcdFx0Ly8gdGhhdCB0aGUgbmV4dCB0aGluZyBpdCBzaG91bGQgc2VlIGlzIHRoZSBjbG9zZSBwYXJlbnRoZXNpcy4gSWYgbm90LFxyXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV4cHJlc3Npb24gcHJvYmFibHkgZG9lc24ndCBoYXZlIGEgYClgXHJcblx0XHRcdFx0Z29iYmxlR3JvdXAgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGluZGV4Kys7XHJcblx0XHRcdFx0XHR2YXIgbm9kZSA9IGdvYmJsZUV4cHJlc3Npb24oKTtcclxuXHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xyXG5cdFx0XHRcdFx0aWYoZXhwcklDb2RlKGluZGV4KSA9PT0gQ1BBUkVOX0NPREUpIHtcclxuXHRcdFx0XHRcdFx0aW5kZXgrKztcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG5vZGU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCAoJywgaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIFJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIEFycmF5IGxpdGVyYWxzIGBbMSwgMiwgM11gXHJcblx0XHRcdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgaXQgbmVlZHMgdG8gZ29iYmxlIHRoZSBvcGVuaW5nIGJyYWNrZXRcclxuXHRcdFx0XHQvLyBhbmQgdGhlbiB0cmllcyB0byBnb2JibGUgdGhlIGV4cHJlc3Npb25zIGFzIGFyZ3VtZW50cy5cclxuXHRcdFx0XHRnb2JibGVBcnJheSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aW5kZXgrKztcclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHR5cGU6IEFSUkFZX0VYUCxcclxuXHRcdFx0XHRcdFx0ZWxlbWVudHM6IGdvYmJsZUFyZ3VtZW50cyhDQlJBQ0tfQ09ERSlcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0bm9kZXMgPSBbXSwgY2hfaSwgbm9kZTtcclxuXHJcblx0XHRcdHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XHJcblx0XHRcdFx0Y2hfaSA9IGV4cHJJQ29kZShpbmRleCk7XHJcblxyXG5cdFx0XHRcdC8vIEV4cHJlc3Npb25zIGNhbiBiZSBzZXBhcmF0ZWQgYnkgc2VtaWNvbG9ucywgY29tbWFzLCBvciBqdXN0IGluZmVycmVkIHdpdGhvdXQgYW55XHJcblx0XHRcdFx0Ly8gc2VwYXJhdG9yc1xyXG5cdFx0XHRcdGlmKGNoX2kgPT09IFNFTUNPTF9DT0RFIHx8IGNoX2kgPT09IENPTU1BX0NPREUpIHtcclxuXHRcdFx0XHRcdGluZGV4Kys7IC8vIGlnbm9yZSBzZXBhcmF0b3JzXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIFRyeSB0byBnb2JibGUgZWFjaCBleHByZXNzaW9uIGluZGl2aWR1YWxseVxyXG5cdFx0XHRcdFx0aWYoKG5vZGUgPSBnb2JibGVFeHByZXNzaW9uKCkpKSB7XHJcblx0XHRcdFx0XHRcdG5vZGVzLnB1c2gobm9kZSk7XHJcblx0XHRcdFx0XHQvLyBJZiB3ZSB3ZXJlbid0IGFibGUgdG8gZmluZCBhIGJpbmFyeSBleHByZXNzaW9uIGFuZCBhcmUgb3V0IG9mIHJvb20sIHRoZW5cclxuXHRcdFx0XHRcdC8vIHRoZSBleHByZXNzaW9uIHBhc3NlZCBpbiBwcm9iYWJseSBoYXMgdG9vIG11Y2hcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihpbmRleCA8IGxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmV4cGVjdGVkIFwiJyArIGV4cHJJKGluZGV4KSArICdcIicsIGluZGV4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgZXhwcmVzc2lvbiBqdXN0IHRyeSByZXR1cm5pbmcgdGhlIGV4cHJlc3Npb25cclxuXHRcdFx0aWYobm9kZXMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5vZGVzWzBdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHR0eXBlOiBDT01QT1VORCxcclxuXHRcdFx0XHRcdGJvZHk6IG5vZGVzXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0Ly8gVG8gYmUgZmlsbGVkIGluIGJ5IHRoZSB0ZW1wbGF0ZVxyXG5cdGpzZXAudmVyc2lvbiA9ICcwLjMuNCc7XHJcblx0anNlcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0phdmFTY3JpcHQgRXhwcmVzc2lvbiBQYXJzZXIgKEpTRVApIHYnICsganNlcC52ZXJzaW9uOyB9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIGpzZXAuYWRkVW5hcnlPcFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcF9uYW1lIFRoZSBuYW1lIG9mIHRoZSB1bmFyeSBvcCB0byBhZGRcclxuXHQgKiBAcmV0dXJuIGpzZXBcclxuXHQgKi9cclxuXHRqc2VwLmFkZFVuYXJ5T3AgPSBmdW5jdGlvbihvcF9uYW1lKSB7XHJcblx0XHRtYXhfdW5vcF9sZW4gPSBNYXRoLm1heChvcF9uYW1lLmxlbmd0aCwgbWF4X3Vub3BfbGVuKTtcclxuXHRcdHVuYXJ5X29wc1tvcF9uYW1lXSA9IHQ7IHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QganNlcC5hZGRCaW5hcnlPcFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkgb3AgdG8gYWRkXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHByZWNlZGVuY2UgVGhlIHByZWNlZGVuY2Ugb2YgdGhlIGJpbmFyeSBvcCAoY2FuIGJlIGEgZmxvYXQpXHJcblx0ICogQHJldHVybiBqc2VwXHJcblx0ICovXHJcblx0anNlcC5hZGRCaW5hcnlPcCA9IGZ1bmN0aW9uKG9wX25hbWUsIHByZWNlZGVuY2UpIHtcclxuXHRcdG1heF9iaW5vcF9sZW4gPSBNYXRoLm1heChvcF9uYW1lLmxlbmd0aCwgbWF4X2Jpbm9wX2xlbik7XHJcblx0XHRiaW5hcnlfb3BzW29wX25hbWVdID0gcHJlY2VkZW5jZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QganNlcC5hZGRMaXRlcmFsXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxpdGVyYWxfbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGl0ZXJhbCB0byBhZGRcclxuXHQgKiBAcGFyYW0geyp9IGxpdGVyYWxfdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBsaXRlcmFsXHJcblx0ICogQHJldHVybiBqc2VwXHJcblx0ICovXHJcblx0anNlcC5hZGRMaXRlcmFsID0gZnVuY3Rpb24obGl0ZXJhbF9uYW1lLCBsaXRlcmFsX3ZhbHVlKSB7XHJcblx0XHRsaXRlcmFsc1tsaXRlcmFsX25hbWVdID0gbGl0ZXJhbF92YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QganNlcC5yZW1vdmVVbmFyeU9wXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wX25hbWUgVGhlIG5hbWUgb2YgdGhlIHVuYXJ5IG9wIHRvIHJlbW92ZVxyXG5cdCAqIEByZXR1cm4ganNlcFxyXG5cdCAqL1xyXG5cdGpzZXAucmVtb3ZlVW5hcnlPcCA9IGZ1bmN0aW9uKG9wX25hbWUpIHtcclxuXHRcdGRlbGV0ZSB1bmFyeV9vcHNbb3BfbmFtZV07XHJcblx0XHRpZihvcF9uYW1lLmxlbmd0aCA9PT0gbWF4X3Vub3BfbGVuKSB7XHJcblx0XHRcdG1heF91bm9wX2xlbiA9IGdldE1heEtleUxlbih1bmFyeV9vcHMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBqc2VwLnJlbW92ZUFsbFVuYXJ5T3BzXHJcblx0ICogQHJldHVybiBqc2VwXHJcblx0ICovXHJcblx0anNlcC5yZW1vdmVBbGxVbmFyeU9wcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dW5hcnlfb3BzID0ge307XHJcblx0XHRtYXhfdW5vcF9sZW4gPSAwO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QganNlcC5yZW1vdmVCaW5hcnlPcFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkgb3AgdG8gcmVtb3ZlXHJcblx0ICogQHJldHVybiBqc2VwXHJcblx0ICovXHJcblx0anNlcC5yZW1vdmVCaW5hcnlPcCA9IGZ1bmN0aW9uKG9wX25hbWUpIHtcclxuXHRcdGRlbGV0ZSBiaW5hcnlfb3BzW29wX25hbWVdO1xyXG5cdFx0aWYob3BfbmFtZS5sZW5ndGggPT09IG1heF9iaW5vcF9sZW4pIHtcclxuXHRcdFx0bWF4X2Jpbm9wX2xlbiA9IGdldE1heEtleUxlbihiaW5hcnlfb3BzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QganNlcC5yZW1vdmVBbGxCaW5hcnlPcHNcclxuXHQgKiBAcmV0dXJuIGpzZXBcclxuXHQgKi9cclxuXHRqc2VwLnJlbW92ZUFsbEJpbmFyeU9wcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0YmluYXJ5X29wcyA9IHt9O1xyXG5cdFx0bWF4X2Jpbm9wX2xlbiA9IDA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBqc2VwLnJlbW92ZUxpdGVyYWxcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBsaXRlcmFsIHRvIHJlbW92ZVxyXG5cdCAqIEByZXR1cm4ganNlcFxyXG5cdCAqL1xyXG5cdGpzZXAucmVtb3ZlTGl0ZXJhbCA9IGZ1bmN0aW9uKGxpdGVyYWxfbmFtZSkge1xyXG5cdFx0ZGVsZXRlIGxpdGVyYWxzW2xpdGVyYWxfbmFtZV07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIGpzZXAucmVtb3ZlQWxsTGl0ZXJhbHNcclxuXHQgKiBAcmV0dXJuIGpzZXBcclxuXHQgKi9cclxuXHRqc2VwLnJlbW92ZUFsbExpdGVyYWxzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRsaXRlcmFscyA9IHt9O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8vIEluIGRlc2t0b3AgZW52aXJvbm1lbnRzLCBoYXZlIGEgd2F5IHRvIHJlc3RvcmUgdGhlIG9sZCB2YWx1ZSBmb3IgYGpzZXBgXHJcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0dmFyIG9sZF9qc2VwID0gcm9vdC5qc2VwO1xyXG5cdFx0Ly8gVGhlIHN0YXIgb2YgdGhlIHNob3chIEl0J3MgYSBmdW5jdGlvbiFcclxuXHRcdHJvb3QuanNlcCA9IGpzZXA7XHJcblx0XHQvLyBBbmQgYSBjb3VydGVvdXMgZnVuY3Rpb24gd2lsbGluZyB0byBtb3ZlIG91dCBvZiB0aGUgd2F5IGZvciBvdGhlciBzaW1pbGFybHktbmFtZWQgb2JqZWN0cyFcclxuXHRcdGpzZXAubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpZihyb290LmpzZXAgPT09IGpzZXApIHtcclxuXHRcdFx0XHRyb290LmpzZXAgPSBvbGRfanNlcDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4ganNlcDtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIEluIE5vZGUuSlMgZW52aXJvbm1lbnRzXHJcblx0XHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuXHRcdFx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ganNlcDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGV4cG9ydHMucGFyc2UgPSBqc2VwO1xyXG5cdFx0fVxyXG5cdH1cclxufSh0aGlzKSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1ha2VKdWljZUNsaWVudChqdWljZUNsaWVudCkge1xuXG5qdWljZUNsaWVudC5pZ25vcmVkUHNldWRvcyA9IFsnaG92ZXInLCAnYWN0aXZlJywgJ2ZvY3VzJywgJ3Zpc2l0ZWQnLCAnbGluayddO1xuanVpY2VDbGllbnQud2lkdGhFbGVtZW50cyA9IFsnVEFCTEUnLCAnVEQnLCAnSU1HJ107XG5qdWljZUNsaWVudC5oZWlnaHRFbGVtZW50cyA9IFsnVEFCTEUnLCAnVEQnLCAnSU1HJ107XG5qdWljZUNsaWVudC50YWJsZUVsZW1lbnRzID0gWydUQUJMRScsICdURCcsICdUSCcsICdUUicsICdURCcsICdDQVBUSU9OJywgJ0NPTEdST1VQJywgJ0NPTCcsICdUSEVBRCcsICdUQk9EWScsICdURk9PVCddO1xuanVpY2VDbGllbnQubm9uVmlzdWFsRWxlbWVudHMgPSBbICdIRUFEJywgJ1RJVExFJywgJ0JBU0UnLCAnTElOSycsICdTVFlMRScsICdNRVRBJywgJ1NDUklQVCcsICdOT1NDUklQVCcgXTtcbmp1aWNlQ2xpZW50LnN0eWxlVG9BdHRyaWJ1dGUgPSB7XG4gICdiYWNrZ3JvdW5kLWNvbG9yJzogJ2JnY29sb3InLFxuICAnYmFja2dyb3VuZC1pbWFnZSc6ICdiYWNrZ3JvdW5kJyxcbiAgJ3RleHQtYWxpZ24nOiAnYWxpZ24nLFxuICAndmVydGljYWwtYWxpZ24nOiAndmFsaWduJ1xufTtcbmp1aWNlQ2xpZW50LmV4Y2x1ZGVkUHJvcGVydGllcyA9IFtdO1xuXG5qdWljZUNsaWVudC5qdWljZURvY3VtZW50ID0ganVpY2VEb2N1bWVudDtcbmp1aWNlQ2xpZW50LmlubGluZURvY3VtZW50ID0gaW5saW5lRG9jdW1lbnQ7XG5cbmZ1bmN0aW9uIGlubGluZURvY3VtZW50KCQsIGNzcywgb3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcnVsZXMgPSB1dGlscy5wYXJzZUNTUyhjc3MpO1xuICB2YXIgZWRpdGVkRWxlbWVudHMgPSBbXTtcbiAgdmFyIHN0eWxlQXR0cmlidXRlTmFtZSA9ICdzdHlsZSc7XG5cbiAgaWYgKG9wdGlvbnMuc3R5bGVBdHRyaWJ1dGVOYW1lKSB7XG4gICAgc3R5bGVBdHRyaWJ1dGVOYW1lID0gb3B0aW9ucy5zdHlsZUF0dHJpYnV0ZU5hbWU7XG4gIH1cblxuICBydWxlcy5mb3JFYWNoKGhhbmRsZVJ1bGUpO1xuICBlZGl0ZWRFbGVtZW50cy5mb3JFYWNoKHNldFN0eWxlQXR0cnMpO1xuXG4gIGlmIChvcHRpb25zLmlubGluZVBzZXVkb0VsZW1lbnRzKSB7XG4gICAgZWRpdGVkRWxlbWVudHMuZm9yRWFjaChpbmxpbmVQc2V1ZG9FbGVtZW50cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hcHBseVdpZHRoQXR0cmlidXRlcykge1xuICAgIGVkaXRlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHNldERpbWVuc2lvbkF0dHJzKGVsLCAnd2lkdGgnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFwcGx5SGVpZ2h0QXR0cmlidXRlcykge1xuICAgIGVkaXRlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHNldERpbWVuc2lvbkF0dHJzKGVsLCAnaGVpZ2h0Jyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hcHBseUF0dHJpYnV0ZXNUYWJsZUVsZW1lbnRzKSB7XG4gICAgZWRpdGVkRWxlbWVudHMuZm9yRWFjaChzZXRBdHRyaWJ1dGVzT25UYWJsZUVsZW1lbnRzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmluc2VydFByZXNlcnZlZEV4dHJhQ3NzICYmIG9wdGlvbnMuZXh0cmFDc3MpIHtcbiAgICB2YXIgcHJlc2VydmVkVGV4dCA9IHV0aWxzLmdldFByZXNlcnZlZFRleHQob3B0aW9ucy5leHRyYUNzcywge1xuICAgICAgbWVkaWFRdWVyaWVzOiBvcHRpb25zLnByZXNlcnZlTWVkaWFRdWVyaWVzLFxuICAgICAgZm9udEZhY2VzOiBvcHRpb25zLnByZXNlcnZlRm9udEZhY2VzLFxuICAgICAga2V5RnJhbWVzOiBvcHRpb25zLnByZXNlcnZlS2V5RnJhbWVzXG4gICAgfSk7XG4gICAgaWYgKHByZXNlcnZlZFRleHQpIHtcbiAgICAgIHZhciAkYXBwZW5kVG8gPSBudWxsO1xuICAgICAgaWYgKG9wdGlvbnMuaW5zZXJ0UHJlc2VydmVkRXh0cmFDc3MgIT09IHRydWUpIHtcbiAgICAgICAgJGFwcGVuZFRvID0gJChvcHRpb25zLmluc2VydFByZXNlcnZlZEV4dHJhQ3NzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRhcHBlbmRUbyA9ICQoJ2hlYWQnKTtcbiAgICAgICAgaWYgKCEkYXBwZW5kVG8ubGVuZ3RoKSB7ICRhcHBlbmRUbyA9ICQoJ2JvZHknKTsgfVxuICAgICAgICBpZiAoISRhcHBlbmRUby5sZW5ndGgpIHsgJGFwcGVuZFRvID0gJC5yb290KCk7IH1cbiAgICAgIH1cblxuICAgICAgJGFwcGVuZFRvLmZpcnN0KCkuYXBwZW5kKCc8c3R5bGU+JyArIHByZXNlcnZlZFRleHQgKyAnPC9zdHlsZT4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSdWxlKHJ1bGUpIHtcbiAgICB2YXIgc2VsID0gcnVsZVswXTtcbiAgICB2YXIgc3R5bGUgPSBydWxlWzFdO1xuICAgIHZhciBzZWxlY3RvciA9IG5ldyB1dGlscy5TZWxlY3RvcihzZWwpO1xuICAgIHZhciBwYXJzZWRTZWxlY3RvciA9IHNlbGVjdG9yLnBhcnNlZCgpO1xuICAgIHZhciBwc2V1ZG9FbGVtZW50VHlwZSA9IGdldFBzZXVkb0VsZW1lbnRUeXBlKHBhcnNlZFNlbGVjdG9yKTtcblxuICAgIC8vIHNraXAgcnVsZSBpZiB0aGUgc2VsZWN0b3IgaGFzIGFueSBwc2V1ZG9zIHdoaWNoIGFyZSBpZ25vcmVkXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWRTZWxlY3Rvci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHN1YlNlbCA9IHBhcnNlZFNlbGVjdG9yW2ldO1xuICAgICAgaWYgKHN1YlNlbC5wc2V1ZG9zKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViU2VsLnBzZXVkb3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3ViU2VsUHNldWRvID0gc3ViU2VsLnBzZXVkb3Nbal07XG4gICAgICAgICAgaWYgKGp1aWNlQ2xpZW50Lmlnbm9yZWRQc2V1ZG9zLmluZGV4T2Yoc3ViU2VsUHNldWRvLm5hbWUpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHNldWRvRWxlbWVudFR5cGUpIHtcbiAgICAgIHZhciBsYXN0ID0gcGFyc2VkU2VsZWN0b3JbcGFyc2VkU2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcHNldWRvcyA9IGxhc3QucHNldWRvcztcbiAgICAgIGxhc3QucHNldWRvcyA9IGZpbHRlckVsZW1lbnRQc2V1ZG9zKGxhc3QucHNldWRvcyk7XG4gICAgICBzZWwgPSBwYXJzZWRTZWxlY3Rvci50b1N0cmluZygpO1xuICAgICAgbGFzdC5wc2V1ZG9zID0gcHNldWRvcztcbiAgICB9XG5cbiAgICB2YXIgZWxzO1xuICAgIHRyeSB7XG4gICAgICBlbHMgPSAkKHNlbCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBza2lwIGludmFsaWQgc2VsZWN0b3JcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbCA9IHRoaXM7XG5cbiAgICAgIGlmIChlbC5uYW1lICYmIGp1aWNlQ2xpZW50Lm5vblZpc3VhbEVsZW1lbnRzLmluZGV4T2YoZWwubmFtZS50b1VwcGVyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBzZXVkb0VsZW1lbnRUeXBlKSB7XG4gICAgICAgIHZhciBwc2V1ZG9FbFByb3BOYW1lID0gJ3BzZXVkbycgKyBwc2V1ZG9FbGVtZW50VHlwZTtcbiAgICAgICAgdmFyIHBzZXVkb0VsID0gZWxbcHNldWRvRWxQcm9wTmFtZV07XG4gICAgICAgIGlmICghcHNldWRvRWwpIHtcbiAgICAgICAgICBwc2V1ZG9FbCA9IGVsW3BzZXVkb0VsUHJvcE5hbWVdID0gJCgnPHNwYW4gLz4nKS5nZXQoMCk7XG4gICAgICAgICAgcHNldWRvRWwucHNldWRvRWxlbWVudFR5cGUgPSBwc2V1ZG9FbGVtZW50VHlwZTtcbiAgICAgICAgICBwc2V1ZG9FbC5wc2V1ZG9FbGVtZW50UGFyZW50ID0gZWw7XG4gICAgICAgICAgZWxbcHNldWRvRWxQcm9wTmFtZV0gPSBwc2V1ZG9FbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IHBzZXVkb0VsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsLnN0eWxlUHJvcHMpIHtcbiAgICAgICAgZWwuc3R5bGVQcm9wcyA9IHt9O1xuXG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyBpbmxpbmUgc3R5bGVzLCBmYWtlIHNlbGVjdG9yIHdpdGggdG9wbW9zdCBzcGVjaWZpY2l0eVxuICAgICAgICBpZiAoJChlbCkuYXR0cihzdHlsZUF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNzc1RleHQgPSAnKiB7ICcgKyAkKGVsKS5hdHRyKHN0eWxlQXR0cmlidXRlTmFtZSkgKyAnIH0gJztcbiAgICAgICAgICBhZGRQcm9wcyh1dGlscy5wYXJzZUNTUyhjc3NUZXh0KVswXVsxXSwgbmV3IHV0aWxzLlNlbGVjdG9yKCc8c3R5bGU+JywgdHJ1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQgd2UgbmVlZCB0byBjb21waWxlIHN0eWxlPVwiXCIgYXR0ciBmb3JcbiAgICAgICAgZWRpdGVkRWxlbWVudHMucHVzaChlbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHByb3BlcnRpZXNcbiAgICAgIGZ1bmN0aW9uIGFkZFByb3BzKHN0eWxlLCBzZWxlY3Rvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0eWxlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChzdHlsZVtpXS50eXBlID09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gc3R5bGVbaV0ubmFtZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW2ldLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGltcG9ydGFudCA9IHN0eWxlW2ldLnZhbHVlLm1hdGNoKC8haW1wb3J0YW50JC8pICE9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGltcG9ydGFudCAmJiAhb3B0aW9ucy5wcmVzZXJ2ZUltcG9ydGFudCkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHMqIWltcG9ydGFudCQvLCAnJyk7XG4gICAgICAgICAgICAvLyBhZGRzIGxpbmUgbnVtYmVyIGFuZCBjb2x1bW4gbnVtYmVyIGZvciB0aGUgcHJvcGVydGllcyBhcyBcImFkZGl0aW9uYWxQcmlvcml0eVwiIHRvIHRoZVxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyBiZWNhdXNlIGluIENTUyB0aGUgcG9zaXRpb24gZGlyZWN0bHkgYWZmZWN0IHRoZSBwcmlvcml0eS5cbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsUHJpb3JpdHkgPSBbc3R5bGVbaV0ucG9zaXRpb24uc3RhcnQubGluZSwgc3R5bGVbaV0ucG9zaXRpb24uc3RhcnQuY29sXTtcbiAgICAgICAgICAgIHZhciBwcm9wID0gbmV3IHV0aWxzLlByb3BlcnR5KG5hbWUsIHZhbHVlLCBzZWxlY3RvciwgaW1wb3J0YW50ID8gMiA6IDAsIGFkZGl0aW9uYWxQcmlvcml0eSk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBlbC5zdHlsZVByb3BzW25hbWVdO1xuXG4gICAgICAgICAgICAvLyBpZiBwcm9wZXJ0eSBuYW1lIGlzIG5vdCBpbiB0aGUgZXhjbHVkZWQgcHJvcGVydGllcyBhcnJheVxuICAgICAgICAgICAgaWYgKGp1aWNlQ2xpZW50LmV4Y2x1ZGVkUHJvcGVydGllcy5pbmRleE9mKG5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcuY29tcGFyZShwcm9wKSA9PT0gcHJvcCB8fCAhZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGluZyBhIHByb3BlcnR5IGxldCB1cyBjaGFuZ2UgdGhlIG9yZGVyIChtb3ZlIGl0IHRvIHRoZSBlbmQgaW4gdGhlIHNldFN0eWxlQXR0cnMgbG9vcClcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc2VsZWN0b3IgIT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgZWwuc3R5bGVQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBtYWtlIFwicHJvcFwiIGEgc3BlY2lhbCBjb21wb3NlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgIHByb3AubmV4dFByb3AgPSBleGlzdGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbC5zdHlsZVByb3BzW25hbWVdID0gcHJvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZGRQcm9wcyhzdHlsZSwgc2VsZWN0b3IpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3R5bGVBdHRycyhlbCkge1xuICAgIHZhciBsID0gT2JqZWN0LmtleXMoZWwuc3R5bGVQcm9wcykubGVuZ3RoO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIC8vIEhlcmUgd2UgbG9vcCBlYWNoIHByb3BlcnR5IGFuZCBtYWtlIHN1cmUgdG8gXCJleHBhbmRcIlxuICAgIC8vIGxpbmtlZCBcIm5leHRQcm9wXCIgcHJvcGVydGllcyBoYXBwZW5pbmcgd2hlbiB0aGUgc2FtZSBwcm9wZXJ0eVxuICAgIC8vIGlzIGRlY2xhcmVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHNlbGVjdG9yLlxuICAgIE9iamVjdC5rZXlzKGVsLnN0eWxlUHJvcHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbnAgPSBlbC5zdHlsZVByb3BzW2tleV07XG4gICAgICB3aGlsZSAodHlwZW9mIG5wICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wcy5wdXNoKG5wKTtcbiAgICAgICAgbnAgPSBucC5uZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBzb3J0IHByb3BlcnRpZXMgYnkgdGhlaXIgb3JpZ2luYXRpbmcgc2VsZWN0b3IncyBzcGVjaWZpY2l0eSBzbyB0aGF0XG4gICAgLy8gcHJvcHMgbGlrZSBcInBhZGRpbmdcIiBhbmQgXCJwYWRkaW5nLWJvdHRvbVwiIGFyZSByZXNvbHZlZCBhcyBleHBlY3RlZC5cbiAgICBwcm9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNvbXBhcmVGdW5jKGIpO1xuICAgIH0pO1xuICAgIHZhciBzdHJpbmcgPSBwcm9wc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIC8vIENvbnRlbnQgYmVjb21lcyB0aGUgaW5uZXJIVE1MIG9mIHBzZXVkbyBlbGVtZW50cywgbm90IHVzZWQgYXMgYVxuICAgICAgICAvLyBzdHlsZSBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gcHJvcC5wcm9wICE9PSAnY29udGVudCc7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wLnByb3AgKyAnOiAnICsgcHJvcC52YWx1ZS5yZXBsYWNlKC9bXCJdL2csICdcXCcnKSArICc7JztcbiAgICAgIH0pXG4gICAgICAuam9pbignICcpO1xuICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICQoZWwpLmF0dHIoc3R5bGVBdHRyaWJ1dGVOYW1lLCBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlubGluZVBzZXVkb0VsZW1lbnRzKGVsKSB7XG4gICAgaWYgKGVsLnBzZXVkb0VsZW1lbnRUeXBlICYmIGVsLnN0eWxlUHJvcHMuY29udGVudCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlQ29udGVudChlbC5zdHlsZVByb3BzLmNvbnRlbnQudmFsdWUpO1xuICAgICAgaWYgKHBhcnNlZC5pbWcpIHtcbiAgICAgICAgZWwubmFtZSA9ICdpbWcnO1xuICAgICAgICAkKGVsKS5hdHRyKCdzcmMnLCBwYXJzZWQuaW1nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoZWwpLnRleHQocGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wc2V1ZG9FbGVtZW50UGFyZW50O1xuICAgICAgaWYgKGVsLnBzZXVkb0VsZW1lbnRUeXBlID09PSAnYmVmb3JlJykge1xuICAgICAgICAkKHBhcmVudCkucHJlcGVuZChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHBhcmVudCkuYXBwZW5kKGVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXREaW1lbnNpb25BdHRycyhlbCwgZGltZW5zaW9uKSB7XG4gICAgaWYgKCFlbC5uYW1lKSB7IHJldHVybjsgfVxuICAgIHZhciBlbE5hbWUgPSBlbC5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGp1aWNlQ2xpZW50W2RpbWVuc2lvbiArICdFbGVtZW50cyddLmluZGV4T2YoZWxOYW1lKSA+IC0xKSB7XG4gICAgICBmb3IgKHZhciBpIGluIGVsLnN0eWxlUHJvcHMpIHtcbiAgICAgICAgaWYgKGVsLnN0eWxlUHJvcHNbaV0ucHJvcCA9PT0gZGltZW5zaW9uKSB7XG4gICAgICAgICAgaWYgKGVsLnN0eWxlUHJvcHNbaV0udmFsdWUubWF0Y2goL3B4LykpIHtcbiAgICAgICAgICAgIHZhciBweFNpemUgPSBlbC5zdHlsZVByb3BzW2ldLnZhbHVlLnJlcGxhY2UoJ3B4JywgJycpO1xuICAgICAgICAgICAgJChlbCkuYXR0cihkaW1lbnNpb24sIHB4U2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqdWljZUNsaWVudC50YWJsZUVsZW1lbnRzLmluZGV4T2YoZWxOYW1lKSA+IC0xICYmIGVsLnN0eWxlUHJvcHNbaV0udmFsdWUubWF0Y2goL1xcJS8pKSB7XG4gICAgICAgICAgICAkKGVsKS5hdHRyKGRpbWVuc2lvbiwgZWwuc3R5bGVQcm9wc1tpXS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdEJhY2tncm91bmRVcmwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuaW5kZXhPZigndXJsKCcpICE9PSAwXG4gICAgICA/IHZhbHVlXG4gICAgICA6IHZhbHVlLnJlcGxhY2UoL151cmxcXCgoW1wiJ10pPyhbXlwiJ10rKVxcMVxcKSQvLCAnJDInKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNPblRhYmxlRWxlbWVudHMoZWwpIHtcbiAgICBpZiAoIWVsLm5hbWUpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGVsTmFtZSA9IGVsLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgc3R5bGVQcm9wcyA9IE9iamVjdC5rZXlzKGp1aWNlQ2xpZW50LnN0eWxlVG9BdHRyaWJ1dGUpO1xuXG4gICAgaWYgKGp1aWNlQ2xpZW50LnRhYmxlRWxlbWVudHMuaW5kZXhPZihlbE5hbWUpID4gLTEpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gZWwuc3R5bGVQcm9wcykge1xuICAgICAgICBpZiAoc3R5bGVQcm9wcy5pbmRleE9mKGVsLnN0eWxlUHJvcHNbaV0ucHJvcCkgPiAtMSkge1xuICAgICAgICAgIHZhciBwcm9wID0ganVpY2VDbGllbnQuc3R5bGVUb0F0dHJpYnV0ZVtlbC5zdHlsZVByb3BzW2ldLnByb3BdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGVsLnN0eWxlUHJvcHNbaV0udmFsdWU7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgdmFsdWUgPSBleHRyYWN0QmFja2dyb3VuZFVybCh2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgJChlbCkuYXR0cihwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgPT09ICdub25lJyB8fCBjb250ZW50ID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpbWFnZVVybE1hdGNoID0gY29udGVudC5tYXRjaCgvXlxccyp1cmxcXHMqXFwoXFxzKiguKj8pXFxzKlxcKVxccyokL2kpO1xuICBpZiAoaW1hZ2VVcmxNYXRjaCkge1xuICAgIHZhciB1cmwgPSBpbWFnZVVybE1hdGNoWzFdLnJlcGxhY2UoL15bJ1wiXXxbJ1wiXSQvZywgJycpO1xuICAgIHJldHVybiB7IGltZzogdXJsIH07XG4gIH1cblxuICAvLyBOYWl2ZSBwYXJzaW5nLCBhc3N1bWUgd2VsbC1mb3JtZWQgdmFsdWVcbiAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSwgY29udGVudC5sZW5ndGggLSAxKTtcbiAgLy8gTmFpdmUgdW5lc2NhcGUsIGFzc3VtZSBubyB1bmljb2RlIGNoYXIgY29kZXNcbiAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vLyBSZXR1cm4gXCJiZWZvcmVcIiBvciBcImFmdGVyXCIgaWYgdGhlIGdpdmVuIHNlbGVjdG9yIGlzIGEgcHNldWRvIGVsZW1lbnQgKGUuZy4sXG4vLyBhOjphZnRlcikuXG5mdW5jdGlvbiBnZXRQc2V1ZG9FbGVtZW50VHlwZShzZWxlY3Rvcikge1xuICBpZiAoc2VsZWN0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBzZXVkb3MgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXS5wc2V1ZG9zO1xuICBpZiAoIXBzZXVkb3MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBzZXVkb3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNQc2V1ZG9FbGVtZW50TmFtZShwc2V1ZG9zW2ldKSkge1xuICAgICAgcmV0dXJuIHBzZXVkb3NbaV0ubmFtZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQc2V1ZG9FbGVtZW50TmFtZShwc2V1ZG8pIHtcbiAgcmV0dXJuIHBzZXVkby5uYW1lID09PSAnYmVmb3JlJyB8fCBwc2V1ZG8ubmFtZSA9PT0gJ2FmdGVyJztcbn1cblxuZnVuY3Rpb24gZmlsdGVyRWxlbWVudFBzZXVkb3MocHNldWRvcykge1xuICByZXR1cm4gcHNldWRvcy5maWx0ZXIoZnVuY3Rpb24ocHNldWRvKSB7XG4gICAgcmV0dXJuICFpc1BzZXVkb0VsZW1lbnROYW1lKHBzZXVkbyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBqdWljZURvY3VtZW50KCQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHV0aWxzLmdldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICB2YXIgY3NzID0gZXh0cmFjdENzc0Zyb21Eb2N1bWVudCgkLCBvcHRpb25zKTtcbiAgY3NzICs9ICdcXG4nICsgb3B0aW9ucy5leHRyYUNzcztcbiAgaW5saW5lRG9jdW1lbnQoJCwgY3NzLCBvcHRpb25zKTtcbiAgcmV0dXJuICQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlc0RhdGEoJCwgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgc3R5bGVzTGlzdCA9ICQoJ3N0eWxlJyk7XG4gIHZhciBzdHlsZURhdGFMaXN0LCBzdHlsZURhdGEsIHN0eWxlRWxlbWVudDtcbiAgc3R5bGVzTGlzdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHN0eWxlRWxlbWVudCA9IHRoaXM7XG4gICAgc3R5bGVEYXRhTGlzdCA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuICAgIGlmIChzdHlsZURhdGFMaXN0Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdHlsZURhdGEgPSBzdHlsZURhdGFMaXN0WzBdLmRhdGE7XG4gICAgaWYgKG9wdGlvbnMuYXBwbHlTdHlsZVRhZ3MgJiYgJChzdHlsZUVsZW1lbnQpLmF0dHIoJ2RhdGEtZW1iZWQnKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHRzLnB1c2goc3R5bGVEYXRhKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVtb3ZlU3R5bGVUYWdzICYmICQoc3R5bGVFbGVtZW50KS5hdHRyKCdkYXRhLWVtYmVkJykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHByZXNlcnZlZFRleHQgPSB1dGlscy5nZXRQcmVzZXJ2ZWRUZXh0KHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSwge1xuICAgICAgICBtZWRpYVF1ZXJpZXM6IG9wdGlvbnMucHJlc2VydmVNZWRpYVF1ZXJpZXMsXG4gICAgICAgIGZvbnRGYWNlczogb3B0aW9ucy5wcmVzZXJ2ZUZvbnRGYWNlcyxcbiAgICAgICAga2V5RnJhbWVzOiBvcHRpb25zLnByZXNlcnZlS2V5RnJhbWVzXG4gICAgICB9KTtcbiAgICAgIGlmIChwcmVzZXJ2ZWRUZXh0KSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHByZXNlcnZlZFRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHN0eWxlRWxlbWVudCkucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgICQoc3R5bGVFbGVtZW50KS5yZW1vdmVBdHRyKCdkYXRhLWVtYmVkJyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gZXh0cmFjdENzc0Zyb21Eb2N1bWVudCgkLCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHRzID0gZ2V0U3R5bGVzRGF0YSgkLCBvcHRpb25zKTtcbiAgdmFyIGNzcyA9IHJlc3VsdHMuam9pbignXFxuJyk7XG4gIHJldHVybiBjc3M7XG59XG5cbnJldHVybiBqdWljZUNsaWVudDtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ1NTIHByb3BlcnR5IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge1NlbGVjdG9yfSBzZWxlY3RvciB0aGUgcHJvcGVydHkgb3JpZ2luYXRlcyBmcm9tXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHByaW9yaXR5IDAgZm9yIG5vcm1hbCBwcm9wZXJ0aWVzLCAyIGZvciAhaW1wb3J0YW50IHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBhZGRpdGlvbmFsIGFycmF5IG9mIGludGVnZXJzIHJlcHJlc2VudGluZyBtb3JlIGRldGFpbGVkIHByaW9yaXRpZXMgKHNvcnRpbmcpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFByb3BlcnR5KHByb3AsIHZhbHVlLCBzZWxlY3RvciwgcHJpb3JpdHksIGFkZGl0aW9uYWxQcmlvcml0eSkge1xuICB0aGlzLnByb3AgPSBwcm9wO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG4gIHRoaXMuYWRkaXRpb25hbFByaW9yaXR5ID0gYWRkaXRpb25hbFByaW9yaXR5IHx8IFtdO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHdpdGggYW5vdGhlciBQcm9wZXJ0eSBiYXNlZCBvbiBTZWxlY3RvciNzcGVjaWZpY2l0eS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblByb3BlcnR5LnByb3RvdHlwZS5jb21wYXJlRnVuYyA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gIHZhciBhID0gW107XG4gIGEucHVzaC5hcHBseShhLCB0aGlzLnNlbGVjdG9yLnNwZWNpZmljaXR5KCkpO1xuICBhLnB1c2guYXBwbHkoYSwgdGhpcy5hZGRpdGlvbmFsUHJpb3JpdHkpO1xuICBhWzBdICs9IHRoaXMucHJpb3JpdHk7XG4gIHZhciBiID0gW107XG4gIGIucHVzaC5hcHBseShiLCBwcm9wZXJ0eS5zZWxlY3Rvci5zcGVjaWZpY2l0eSgpKTtcbiAgYi5wdXNoLmFwcGx5KGIsIHByb3BlcnR5LmFkZGl0aW9uYWxQcmlvcml0eSk7XG4gIGJbMF0gKz0gcHJvcGVydHkucHJpb3JpdHk7XG4gIHJldHVybiB1dGlscy5jb21wYXJlRnVuYyhhLCBiKTtcbn07XG5cblByb3BlcnR5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgdmFyIHdpbm5lciA9IHRoaXMuY29tcGFyZUZ1bmMocHJvcGVydHkpO1xuICBpZiAod2lubmVyID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgQ1NTIHByb3BlcnR5XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucHJvcCArICc6ICcgKyB0aGlzLnZhbHVlLnJlcGxhY2UoL1snXCJdKy9nLCAnJykgKyAnOyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc2xpY2svcGFyc2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNlbGVjdG9yO1xuXG4vKipcbiAqIENTUyBzZWxlY3RvciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgdGV4dFxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9uYWxseSwgcHJlY2FsY3VsYXRlZCBzcGVjaWZpY2l0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTZWxlY3Rvcih0ZXh0LCBzdHlsZUF0dHJpYnV0ZSkge1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLnNwZWMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuc3R5bGVBdHRyaWJ1dGUgPSBzdHlsZUF0dHJpYnV0ZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgcGFyc2VkIHNlbGVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VsZWN0b3IucHJvdG90eXBlLnBhcnNlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudG9rZW5zKSB7IHRoaXMudG9rZW5zID0gcGFyc2UodGhpcy50ZXh0KTsgfVxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIExhenkgc3BlY2lmaWNpdHkgZ2V0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZWxlY3Rvci5wcm90b3R5cGUuc3BlY2lmaWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlQXR0cmlidXRlID0gdGhpcy5zdHlsZUF0dHJpYnV0ZTtcbiAgaWYgKCF0aGlzLnNwZWMpIHsgdGhpcy5zcGVjID0gc3BlY2lmaWNpdHkodGhpcy50ZXh0LCB0aGlzLnBhcnNlZCgpKTsgfVxuICByZXR1cm4gdGhpcy5zcGVjO1xuXG4gIGZ1bmN0aW9uIHNwZWNpZmljaXR5KHRleHQsIHBhcnNlZCkge1xuICAgIHZhciBleHByZXNzaW9ucyA9IHBhcnNlZCB8fCBwYXJzZSh0ZXh0KTtcbiAgICB2YXIgc3BlYyA9IFtzdHlsZUF0dHJpYnV0ZSA/IDEgOiAwLCAwLCAwLCAwXTtcbiAgICB2YXIgbm90cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpXTtcbiAgICAgIHZhciBwc2V1ZG9zID0gZXhwcmVzc2lvbi5wc2V1ZG9zO1xuXG4gICAgICAvLyBpZCBhd2FyZHMgYSBwb2ludCBpbiB0aGUgc2Vjb25kIGNvbHVtblxuICAgICAgaWYgKGV4cHJlc3Npb24uaWQpIHsgc3BlY1sxXSsrOyB9XG5cbiAgICAgIC8vIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZXMgYXdhcmQgYSBwb2ludCBlYWNoIGluIHRoZSB0aGlyZCBjb2x1bW5cbiAgICAgIGlmIChleHByZXNzaW9uLmF0dHJpYnV0ZXMpIHsgc3BlY1syXSArPSBleHByZXNzaW9uLmF0dHJpYnV0ZXMubGVuZ3RoOyB9XG4gICAgICBpZiAoZXhwcmVzc2lvbi5jbGFzc0xpc3QpIHsgc3BlY1syXSArPSBleHByZXNzaW9uLmNsYXNzTGlzdC5sZW5ndGg7IH1cblxuICAgICAgLy8gdGFnIGF3YXJkcyBhIHBvaW50IGluIHRoZSBmb3VydGggY29sdW1uXG4gICAgICBpZiAoZXhwcmVzc2lvbi50YWcgJiYgZXhwcmVzc2lvbi50YWcgIT09ICcqJykgeyBzcGVjWzNdKys7IH1cblxuICAgICAgLy8gcHNldWRvcyBhd2FyZCBhIHBvaW50IGVhY2ggaW4gdGhlIGZvdXJ0aCBjb2x1bW5cbiAgICAgIGlmIChwc2V1ZG9zKSB7XG4gICAgICAgIHNwZWNbM10gKz0gcHNldWRvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwc2V1ZG9zLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgaWYgKHBzZXVkb3NbcF0ubmFtZSA9PT0gJ25vdCcpIHtcbiAgICAgICAgICAgIG5vdHMucHVzaChwc2V1ZG9zW3BdLnZhbHVlKTtcbiAgICAgICAgICAgIHNwZWNbM10tLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpaSA9IG5vdHMubGVuZ3RoOyBpaS0tOykge1xuICAgICAgdmFyIG5vdCA9IHNwZWNpZmljaXR5KG5vdHNbaWldKTtcbiAgICAgIGZvciAodmFyIGpqID0gNDsgamotLTspIHsgc3BlY1tqal0gKz0gbm90W2pqXTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGVjO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNlbGVjdG9yIGFuZCByZXR1cm5zIHRoZSB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UodGV4dCkge1xuICB0cnkge1xuICAgIHJldHVybiBwYXJzZXIodGV4dClbMF07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBtZW5zY2ggPSByZXF1aXJlKCdtZW5zY2gnKTtcbnZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuZXhwb3J0cy5TZWxlY3RvciA9IFNlbGVjdG9yO1xuZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHNlbGVjdG9ycy5cbiAqXG4gKiBAbGljZW5zZSBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSAtIE1JVFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yVGV4dCBmcm9tIG1lbnNjaFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiBleHRyYWN0KHNlbGVjdG9yVGV4dCkge1xuICB2YXIgYXR0ciA9IDA7XG4gIHZhciBzZWxzID0gW107XG4gIHZhciBzZWwgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGVjdG9yVGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgYyA9IHNlbGVjdG9yVGV4dC5jaGFyQXQoaSk7XG5cbiAgICBpZiAoYXR0cikge1xuICAgICAgaWYgKCddJyA9PT0gYyB8fCAnKScgPT09IGMpIHsgYXR0ci0tOyB9XG4gICAgICBzZWwgKz0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcsJyA9PT0gYykge1xuICAgICAgICBzZWxzLnB1c2goc2VsKTtcbiAgICAgICAgc2VsID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJ1snID09PSBjIHx8ICcoJyA9PT0gYykgeyBhdHRyKys7IH1cbiAgICAgICAgaWYgKHNlbC5sZW5ndGggfHwgKGMgIT09ICcsJyAmJiBjICE9PSAnXFxuJyAmJiBjICE9PSAnICcpKSB7IHNlbCArPSBjOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbC5sZW5ndGgpIHtcbiAgICBzZWxzLnB1c2goc2VsKTtcbiAgfVxuXG4gIHJldHVybiBzZWxzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGFyc2UgdHJlZSBmb3IgYSBDU1Mgc291cmNlLlxuICogSWYgaXQgZW5jb3VudGVycyBtdWx0aXBsZSBzZWxlY3RvcnMgc2VwYXJhdGVkIGJ5IGEgY29tbWEsIGl0IHNwbGl0cyB0aGVcbiAqIHRyZWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNzcyBzb3VyY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZUNTUyA9IGZ1bmN0aW9uKGNzcykge1xuICB2YXIgcGFyc2VkID0gbWVuc2NoLnBhcnNlKGNzcywge3Bvc2l0aW9uOiB0cnVlLCBjb21tZW50czogdHJ1ZX0pO1xuICB2YXIgcnVsZXMgPSB0eXBlb2YgcGFyc2VkLnN0eWxlc2hlZXQgIT0gJ3VuZGVmaW5lZCcgJiYgcGFyc2VkLnN0eWxlc2hlZXQucnVsZXMgPyBwYXJzZWQuc3R5bGVzaGVldC5ydWxlcyA6IFtdO1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocnVsZXNbaV0udHlwZSA9PSAncnVsZScpIHtcbiAgICAgIHZhciBydWxlID0gcnVsZXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3JzID0gcnVsZS5zZWxlY3RvcnM7XG5cbiAgICAgIGZvciAodmFyIGlpID0gMCwgbGwgPSBzZWxlY3RvcnMubGVuZ3RoOyBpaSA8IGxsOyBpaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKFtzZWxlY3RvcnNbaWldLCBydWxlLmRlY2xhcmF0aW9uc10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgcHJlc2VydmVkIHRleHQgZm9yIGEgQ1NTIHNvdXJjZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIHNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5nZXRQcmVzZXJ2ZWRUZXh0ID0gZnVuY3Rpb24oY3NzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZWQgPSBtZW5zY2gucGFyc2UoY3NzLCB7cG9zaXRpb246IHRydWUsIGNvbW1lbnRzOiB0cnVlfSk7XG4gIHZhciBydWxlcyA9IHR5cGVvZiBwYXJzZWQuc3R5bGVzaGVldCAhPSAndW5kZWZpbmVkJyAmJiBwYXJzZWQuc3R5bGVzaGVldC5ydWxlcyA/IHBhcnNlZC5zdHlsZXNoZWV0LnJ1bGVzIDogW107XG4gIHZhciBwcmVzZXJ2ZWQgPSBbXTtcbiAgdmFyIGxhc3RTdGFydCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IHJ1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChvcHRpb25zLmZvbnRGYWNlcyAmJiBydWxlc1tpXS50eXBlID09PSAnZm9udC1mYWNlJykgfHxcbiAgICAgICAgKG9wdGlvbnMubWVkaWFRdWVyaWVzICYmIHJ1bGVzW2ldLnR5cGUgPT09ICdtZWRpYScpIHx8XG4gICAgICAgIChvcHRpb25zLmtleUZyYW1lcyAmJiBydWxlc1tpXS50eXBlID09PSAna2V5ZnJhbWVzJykpIHtcbiAgICAgIHByZXNlcnZlZC51bnNoaWZ0KFxuICAgICAgICBtZW5zY2guc3RyaW5naWZ5KFxuICAgICAgICAgIHsgc3R5bGVzaGVldDogeyBydWxlczogWyBydWxlc1tpXSBdIH19LFxuICAgICAgICAgIHsgY29tbWVudHM6IGZhbHNlLCBpbmRlbnRhdGlvbjogJyAgJyB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGxhc3RTdGFydCA9IHJ1bGVzW2ldLnBvc2l0aW9uLnN0YXJ0O1xuICB9XG5cbiAgaWYgKHByZXNlcnZlZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICdcXG4nICsgcHJlc2VydmVkLmpvaW4oJ1xcbicpICsgJ1xcbic7XG59O1xuXG5leHBvcnRzLm5vcm1hbGl6ZUxpbmVFbmRpbmdzID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcbi9nLCAnXFxyXFxuJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIHNwZWNpZmljaXR5IHZlY3RvcnMsIHJldHVybmluZyB0aGUgd2lubmluZyBvbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yIGFcbiAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvciBiXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb21wYXJlRnVuYyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIG1pbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICBpZiAoYVtpXSA9PT0gYltpXSkgeyBjb250aW51ZTsgfVxuICAgIGlmIChhW2ldID4gYltpXSkgeyByZXR1cm4gMTsgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xufTtcblxuZXhwb3J0cy5jb21wYXJlID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gZXhwb3J0cy5jb21wYXJlRnVuYyhhLCBiKSA9PSAxID8gYSA6IGI7XG59O1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaiwgc3JjKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAob3duLmNhbGwoc3JjLCBrZXkpKSB7XG4gICAgICBvYmpba2V5XSA9IHNyY1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5nZXREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IGV4cG9ydHMuZXh0ZW5kKHtcbiAgICBleHRyYUNzczogJycsXG4gICAgaW5zZXJ0UHJlc2VydmVkRXh0cmFDc3M6IHRydWUsXG4gICAgYXBwbHlTdHlsZVRhZ3M6IHRydWUsXG4gICAgcmVtb3ZlU3R5bGVUYWdzOiB0cnVlLFxuICAgIHByZXNlcnZlTWVkaWFRdWVyaWVzOiB0cnVlLFxuICAgIHByZXNlcnZlRm9udEZhY2VzOiB0cnVlLFxuICAgIHByZXNlcnZlS2V5RnJhbWVzOiB0cnVlLFxuICAgIGFwcGx5V2lkdGhBdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGFwcGx5SGVpZ2h0QXR0cmlidXRlczogdHJ1ZSxcbiAgICBhcHBseUF0dHJpYnV0ZXNUYWJsZUVsZW1lbnRzOiB0cnVlLFxuICAgIHVybDogJydcbiAgfSwgb3B0aW9ucyk7XG5cbiAgcmVzdWx0LndlYlJlc291cmNlcyA9IHJlc3VsdC53ZWJSZXNvdXJjZXMgfHwge307XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBrbm9ja291dC1zb3J0YWJsZSAxLjEuMCB8IChjKSAyMDE3IFJ5YW4gTmllbWV5ZXIgfCAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuOyhmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRCBhbm9ueW1vdXMgbW9kdWxlXG4gICAgICAgIGRlZmluZShbXCJrbm9ja291dFwiLCBcImpxdWVyeVwiLCBcImpxdWVyeS11aS91aS93aWRnZXRzL3NvcnRhYmxlXCIsIFwianF1ZXJ5LXVpL3VpL3dpZGdldHMvZHJhZ2dhYmxlXCIsIFwianF1ZXJ5LXVpL3VpL3dpZGdldHMvZHJvcHBhYmxlXCJdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBDb21tb25KUyBtb2R1bGVcbiAgICAgICAgdmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCksXG4gICAgICAgICAgICBqUXVlcnkgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xuICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J11bJ3VpJ11bJ3NvcnRhYmxlJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXVsndWknXVsnc29ydGFibGUnXSA6IG51bGwpO1xuICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J11bJ3VpJ11bJ2RyYWdnYWJsZSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J11bJ3VpJ11bJ2RyYWdnYWJsZSddIDogbnVsbCk7XG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXVsndWknXVsnZHJvcHBhYmxlJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXVsndWknXVsnZHJvcHBhYmxlJ10gOiBudWxsKTtcbiAgICAgICAgZmFjdG9yeShrbywgalF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBtb2R1bGUgbG9hZGVyIChwbGFpbiA8c2NyaXB0PiB0YWcpIC0gcHV0IGRpcmVjdGx5IGluIGdsb2JhbCBuYW1lc3BhY2VcbiAgICAgICAgZmFjdG9yeSh3aW5kb3cua28sIHdpbmRvdy5qUXVlcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uKGtvLCAkKSB7XG4gICAgdmFyIElURU1LRVkgPSBcImtvX3NvcnRJdGVtXCIsXG4gICAgICAgIElOREVYS0VZID0gXCJrb19zb3VyY2VJbmRleFwiLFxuICAgICAgICBMSVNUS0VZID0gXCJrb19zb3J0TGlzdFwiLFxuICAgICAgICBQQVJFTlRLRVkgPSBcImtvX3BhcmVudExpc3RcIixcbiAgICAgICAgRFJBR0tFWSA9IFwia29fZHJhZ0l0ZW1cIixcbiAgICAgICAgdW53cmFwID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSxcbiAgICAgICAgZGF0YUdldCA9IGtvLnV0aWxzLmRvbURhdGEuZ2V0LFxuICAgICAgICBkYXRhU2V0ID0ga28udXRpbHMuZG9tRGF0YS5zZXQsXG4gICAgICAgIHZlcnNpb24gPSAkLnVpICYmICQudWkudmVyc2lvbixcbiAgICAgICAgLy8xLjguMjQgaW5jbHVkZWQgYSBmaXggZm9yIGhvdyBldmVudHMgd2VyZSB0cmlnZ2VyZWQgaW4gbmVzdGVkIHNvcnRhYmxlcy4gaW5kZXhPZiBjaGVja3Mgd2lsbCBmYWlsIGlmIHZlcnNpb24gc3RhcnRzIHdpdGggdGhhdCB2YWx1ZSAoMCB2cy4gLTEpXG4gICAgICAgIGhhc05lc3RlZFNvcnRhYmxlRml4ID0gdmVyc2lvbiAmJiB2ZXJzaW9uLmluZGV4T2YoXCIxLjYuXCIpICYmIHZlcnNpb24uaW5kZXhPZihcIjEuNy5cIikgJiYgKHZlcnNpb24uaW5kZXhPZihcIjEuOC5cIikgfHwgdmVyc2lvbiA9PT0gXCIxLjguMjRcIik7XG5cbiAgICAvL2ludGVybmFsIGFmdGVyUmVuZGVyIHRoYXQgYWRkcyBtZXRhLWRhdGEgdG8gY2hpbGRyZW5cbiAgICB2YXIgYWRkTWV0YURhdGFBZnRlclJlbmRlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBkYXRhKSB7XG4gICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkYXRhU2V0KGVsZW1lbnQsIElURU1LRVksIGRhdGEpO1xuICAgICAgICAgICAgICAgIGRhdGFTZXQoZWxlbWVudCwgUEFSRU5US0VZLCBkYXRhR2V0KGVsZW1lbnQucGFyZW50Tm9kZSwgTElTVEtFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy9wcmVwYXJlIHRoZSBwcm9wZXIgb3B0aW9ucyBmb3IgdGhlIHRlbXBsYXRlIGJpbmRpbmdcbiAgICB2YXIgcHJlcGFyZVRlbXBsYXRlT3B0aW9ucyA9IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IsIGRhdGFOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1bndyYXAodmFsdWVBY2Nlc3NvcigpKSB8fCB7fSxcbiAgICAgICAgICAgIGFjdHVhbEFmdGVyUmVuZGVyO1xuXG4gICAgICAgIC8vYnVpbGQgb3VyIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZW5naW5lXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIHJlc3VsdFtkYXRhTmFtZV0gPSBvcHRpb25zLmRhdGE7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbZGF0YU5hbWVdID0gdmFsdWVBY2Nlc3NvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAga28udXRpbHMuYXJyYXlGb3JFYWNoKFtcImFmdGVyQWRkXCIsIFwiYWZ0ZXJSZW5kZXJcIiwgXCJhc1wiLCBcImJlZm9yZVJlbW92ZVwiLCBcImluY2x1ZGVEZXN0cm95ZWRcIiwgXCJ0ZW1wbGF0ZUVuZ2luZVwiLCBcInRlbXBsYXRlT3B0aW9uc1wiLCBcIm5vZGVzXCJdLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtvLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZS5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W29wdGlvbl0gPSBrby5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGVbb3B0aW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy91c2UgYW4gYWZ0ZXJSZW5kZXIgZnVuY3Rpb24gdG8gYWRkIG1ldGEtZGF0YVxuICAgICAgICBpZiAoZGF0YU5hbWUgPT09IFwiZm9yZWFjaFwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFmdGVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgLy93cmFwIHRoZSBleGlzdGluZyBmdW5jdGlvbiwgaWYgaXQgd2FzIHBhc3NlZFxuICAgICAgICAgICAgICAgIGFjdHVhbEFmdGVyUmVuZGVyID0gcmVzdWx0LmFmdGVyUmVuZGVyO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZnRlclJlbmRlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWV0YURhdGFBZnRlclJlbmRlci5jYWxsKGRhdGEsIGVsZW1lbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxBZnRlclJlbmRlci5jYWxsKGRhdGEsIGVsZW1lbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZnRlclJlbmRlciA9IGFkZE1ldGFEYXRhQWZ0ZXJSZW5kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3JldHVybiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGJpbmRpbmdcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUluZGV4RnJvbURlc3Ryb3llZEl0ZW1zID0gZnVuY3Rpb24oaW5kZXgsIGl0ZW1zKSB7XG4gICAgICAgIHZhciB1bndyYXBwZWQgPSB1bndyYXAoaXRlbXMpO1xuXG4gICAgICAgIGlmICh1bndyYXBwZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vYWRkIG9uZSBmb3IgZXZlcnkgZGVzdHJveWVkIGl0ZW0gd2UgZmluZCBiZWZvcmUgdGhlIHRhcmdldEluZGV4IGluIHRoZSB0YXJnZXQgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAodW53cmFwcGVkW2ldICYmIHVud3JhcCh1bndyYXBwZWRbaV0uX2Rlc3Ryb3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICAvL3JlbW92ZSBwcm9ibGVtYXRpYyBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSB0ZW1wbGF0ZXNcbiAgICB2YXIgc3RyaXBUZW1wbGF0ZVdoaXRlc3BhY2UgPSBmdW5jdGlvbihlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVNvdXJjZSxcbiAgICAgICAgICAgIHRlbXBsYXRlRWxlbWVudDtcblxuICAgICAgICAvL3Byb2Nlc3MgbmFtZWQgdGVtcGxhdGVzXG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuYW1lKTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVNvdXJjZSA9IG5ldyBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCh0ZW1wbGF0ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlU291cmNlLnRleHQoJC50cmltKHRlbXBsYXRlU291cmNlLnRleHQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9yZW1vdmUgbGVhZGluZy90cmFpbGluZyBub24tZWxlbWVudHMgZnJvbSBhbm9ueW1vdXMgdGVtcGxhdGVzXG4gICAgICAgICAgICAkKGVsZW1lbnQpLmNvbnRlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9jb25uZWN0IGl0ZW1zIHdpdGggb2JzZXJ2YWJsZUFycmF5c1xuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpIHx8IHt9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9ucyA9IHByZXBhcmVUZW1wbGF0ZU9wdGlvbnModmFsdWVBY2Nlc3NvciwgXCJmb3JlYWNoXCIpLFxuICAgICAgICAgICAgICAgIHNvcnRhYmxlID0ge30sXG4gICAgICAgICAgICAgICAgc3RhcnRBY3R1YWwsIHVwZGF0ZUFjdHVhbDtcblxuICAgICAgICAgICAgc3RyaXBUZW1wbGF0ZVdoaXRlc3BhY2UoZWxlbWVudCwgdGVtcGxhdGVPcHRpb25zLm5hbWUpO1xuXG4gICAgICAgICAgICAvL2J1aWxkIGEgbmV3IG9iamVjdCB0aGF0IGhhcyB0aGUgZ2xvYmFsIG9wdGlvbnMgd2l0aCBvdmVycmlkZXMgZnJvbSB0aGUgYmluZGluZ1xuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgc29ydGFibGUsIGtvLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUub3B0aW9ucyAmJiBzb3J0YWJsZS5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAga28udXRpbHMuZXh0ZW5kKHNvcnRhYmxlLm9wdGlvbnMsIHZhbHVlLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZS5vcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga28udXRpbHMuZXh0ZW5kKHNvcnRhYmxlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vaWYgYWxsb3dEcm9wIGlzIGFuIG9ic2VydmFibGUgb3IgYSBmdW5jdGlvbiwgdGhlbiBleGVjdXRlIGl0IGluIGEgY29tcHV0ZWQgb2JzZXJ2YWJsZVxuICAgICAgICAgICAgaWYgKHNvcnRhYmxlLmNvbm5lY3RDbGFzcyAmJiAoa28uaXNPYnNlcnZhYmxlKHNvcnRhYmxlLmFsbG93RHJvcCkgfHwgdHlwZW9mIHNvcnRhYmxlLmFsbG93RHJvcCA9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAga28uY29tcHV0ZWQoe1xuICAgICAgICAgICAgICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVud3JhcChzb3J0YWJsZS5hbGxvd0Ryb3ApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEFkZCA9IHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZS5jYWxsKHRoaXMsIHRlbXBsYXRlT3B0aW9ucy5mb3JlYWNoKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAga28udXRpbHMudG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGVsZW1lbnQsIHNvcnRhYmxlLmNvbm5lY3RDbGFzcywgc2hvdWxkQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtvLnV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcyhlbGVtZW50LCBzb3J0YWJsZS5jb25uZWN0Q2xhc3MsIHNvcnRhYmxlLmFsbG93RHJvcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vd3JhcCB0aGUgdGVtcGxhdGUgYmluZGluZ1xuICAgICAgICAgICAga28uYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLmluaXQoZWxlbWVudCwgZnVuY3Rpb24oKSB7IHJldHVybiB0ZW1wbGF0ZU9wdGlvbnM7IH0sIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAvL2tlZXAgYSByZWZlcmVuY2UgdG8gc3RhcnQvdXBkYXRlIGZ1bmN0aW9ucyB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBwYXNzZWQgaW5cbiAgICAgICAgICAgIHN0YXJ0QWN0dWFsID0gc29ydGFibGUub3B0aW9ucy5zdGFydDtcbiAgICAgICAgICAgIHVwZGF0ZUFjdHVhbCA9IHNvcnRhYmxlLm9wdGlvbnMudXBkYXRlO1xuXG4gICAgICAgICAgICAvL2Vuc3VyZSBkcmFnZ2FibGUgdGFibGUgcm93IGNlbGxzIG1haW50YWluIHRoZWlyIHdpZHRoIHdoaWxlIGRyYWdnaW5nICh1bmxlc3MgYSBoZWxwZXIgaXMgcHJvdmlkZWQpXG4gICAgICAgICAgICBpZiAoICFzb3J0YWJsZS5vcHRpb25zLmhlbHBlciApIHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZS5vcHRpb25zLmhlbHBlciA9IGZ1bmN0aW9uKGUsIHVpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1aS5pcyhcInRyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS53aWR0aCgkKHRoaXMpLndpZHRoKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSBzb3J0YWJsZSBiaW5kaW5nIGFmdGVyIHRlbXBsYXRlIGJpbmRpbmcgaGFzIHJlbmRlcmVkIGluIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIGNyZWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnSXRlbTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxSZWNlaXZlID0gc29ydGFibGUub3B0aW9ucy5yZWNlaXZlO1xuXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQuc29ydGFibGUoa28udXRpbHMuZXh0ZW5kKHNvcnRhYmxlLm9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90cmFjayBvcmlnaW5hbCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdWkuaXRlbVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTZXQoZWwsIElOREVYS0VZLCBrby51dGlscy5hcnJheUluZGV4T2YodWkuaXRlbS5wYXJlbnQoKS5jaGlsZHJlbigpLCBlbCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGF0IGZpZWxkcyBoYXZlIGEgY2hhbmNlIHRvIHVwZGF0ZSBtb2RlbFxuICAgICAgICAgICAgICAgICAgICAgICAgdWkuaXRlbS5maW5kKFwiaW5wdXQ6Zm9jdXNcIikuY2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFjdHVhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlOiBmdW5jdGlvbihldmVudCwgdWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb3B0aW9uYWxseSBhcHBseSBhbiBleGlzdGluZyByZWNlaXZlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxSZWNlaXZlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlY2VpdmUuY2FsbCh0aGlzLCBldmVudCwgdWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbSA9IGRhdGFHZXQodWkuaXRlbVswXSwgRFJBR0tFWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0l0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvcHkgdGhlIG1vZGVsIGl0ZW0sIGlmIGEgY2xvbmUgb3B0aW9uIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdJdGVtLmNsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtID0gZHJhZ0l0ZW0uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbmZpZ3VyZSBhIGhhbmRsZXIgdG8gcG90ZW50aWFsbHkgbWFuaXB1bGF0ZSBpdGVtIGJlZm9yZSBkcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlLmRyYWdnZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW0gPSBzb3J0YWJsZS5kcmFnZ2VkLmNhbGwodGhpcywgZHJhZ0l0ZW0sIGV2ZW50LCB1aSkgfHwgZHJhZ0l0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVBhcmVudCwgdGFyZ2V0UGFyZW50LCBzb3VyY2VJbmRleCwgdGFyZ2V0SW5kZXgsIGFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHVpLml0ZW1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWwgPSB1aS5pdGVtLnBhcmVudCgpWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBkYXRhR2V0KGVsLCBJVEVNS0VZKSB8fCBkcmFnSXRlbTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRoYXQgbW92ZXMgb25seSBydW4gb25jZSwgYXMgdXBkYXRlIGZpcmVzIG9uIG11bHRpcGxlIGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtICYmICh0aGlzID09PSBwYXJlbnRFbCkgfHwgKCFoYXNOZXN0ZWRTb3J0YWJsZUZpeCAmJiAkLmNvbnRhaW5zKHRoaXMsIHBhcmVudEVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lkZW50aWZ5IHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VQYXJlbnQgPSBkYXRhR2V0KGVsLCBQQVJFTlRLRVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUluZGV4ID0gZGF0YUdldChlbCwgSU5ERVhLRVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFBhcmVudCA9IGRhdGFHZXQoZWwucGFyZW50Tm9kZSwgTElTVEtFWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBrby51dGlscy5hcnJheUluZGV4T2YodWkuaXRlbS5wYXJlbnQoKS5jaGlsZHJlbigpLCBlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rha2UgZGVzdHJveWVkIGl0ZW1zIGludG8gY29uc2lkZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVtcGxhdGVPcHRpb25zLmluY2x1ZGVEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSW5kZXggPSB1cGRhdGVJbmRleEZyb21EZXN0cm95ZWRJdGVtcyhzb3VyY2VJbmRleCwgc291cmNlUGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSB1cGRhdGVJbmRleEZyb21EZXN0cm95ZWRJdGVtcyh0YXJnZXRJbmRleCwgdGFyZ2V0UGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2J1aWxkIHVwIGFyZ3MgZm9yIHRoZSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGFibGUuYmVmb3JlTW92ZSB8fCBzb3J0YWJsZS5hZnRlck1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVBhcmVudDogc291cmNlUGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlUGFyZW50Tm9kZTogc291cmNlUGFyZW50ICYmIHVpLnNlbmRlciB8fCBlbC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSW5kZXg6IHNvdXJjZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UGFyZW50OiB0YXJnZXRQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmRleDogdGFyZ2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxEcm9wOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXhlY3V0ZSB0aGUgY29uZmlndXJlZCBjYWxsYmFjayBwcmlvciB0byBhY3R1YWxseSBtb3ZpbmcgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlLmJlZm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRhYmxlLmJlZm9yZU1vdmUuY2FsbCh0aGlzLCBhcmcsIGV2ZW50LCB1aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGwgY2FuY2VsIG9uIHRoZSBjb3JyZWN0IGxpc3QsIHNvIEtPIGNhbiB0YWtlIGNhcmUgb2YgRE9NIG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChzb3VyY2VQYXJlbnQgPT09IHRhcmdldFBhcmVudCA/IHRoaXMgOiB1aS5zZW5kZXIgfHwgdGhpcykuc29ydGFibGUoXCJjYW5jZWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIGEgZHJhZ2dhYmxlIGl0ZW0ganVzdCByZW1vdmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBiZWZvcmVNb3ZlIHRvbGQgdXMgdG8gY2FuY2VsLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcuY2FuY2VsRHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgc3RyYXRlZ3kgb3B0aW9uIGlzIHVuc2V0IG9yIGZhbHNlLCBlbXBsb3kgdGhlIG9yZGVyIHN0cmF0ZWd5IGludm9sdmluZyByZW1vdmFsIGFuZCBpbnNlcnRpb24gb2YgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNvcnRhYmxlLmhhc093blByb3BlcnR5KFwic3RyYXRlZ3lNb3ZlXCIpIHx8IHNvcnRhYmxlLnN0cmF0ZWd5TW92ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kbyB0aGUgYWN0dWFsIG1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VQYXJlbnQuc3BsaWNlKHNvdXJjZUluZGV4LCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdXNpbmcgZGVmZXJyZWQgdXBkYXRlcyBwbHVnaW4sIGZvcmNlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa28ucHJvY2Vzc0FsbERlZmVycmVkQmluZGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga28ucHJvY2Vzc0FsbERlZmVycmVkQmluZGluZ1VwZGF0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHVzaW5nIGRlZmVycmVkIHVwZGF0ZXMgb24ga25vY2tvdXQgMy40LCBmb3JjZSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtvLm9wdGlvbnMgJiYga28ub3B0aW9ucy5kZWZlclVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga28udGFza3MucnVuRWFybHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFBhcmVudC5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW5kZXJpbmcgaXMgaGFuZGxlZCBieSBtYW5pcHVsYXRpbmcgdGhlIG9ic2VydmFibGVBcnJheTsgaWdub3JlIGRyb3BwZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhU2V0KGVsLCBJVEVNS0VZLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vZW1wbG95IHRoZSBzdHJhdGVneSBvZiBtb3ZpbmcgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlUGFyZW50ICE9PSB0YXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92aW5nIGZyb20gb25lIGxpc3QgdG8gYW5vdGhlclxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVBhcmVudC5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQYXJlbnQuc3BsaWNlKHRhcmdldEluZGV4LCAwLCBpdGVtKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbmRlcmluZyBpcyBoYW5kbGVkIGJ5IG1hbmlwdWxhdGluZyB0aGUgb2JzZXJ2YWJsZUFycmF5OyBpZ25vcmUgZHJvcHBlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTZXQoZWwsIElURU1LRVksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aS5pdGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92aW5nIHdpdGhpbiBzYW1lIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZGVybHlpbmdMaXN0ID0gdW53cmFwKHNvdXJjZVBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aWZ5ICdiZWZvcmVDaGFuZ2UnIHN1YnNjcmliZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQYXJlbnQudmFsdWVXaWxsTXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VQYXJlbnQudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGZyb20gc291cmNlIGluZGV4IC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmx5aW5nTGlzdC5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gdG8gdGFyZ2V0IGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybHlpbmdMaXN0LnNwbGljZSh0YXJnZXRJbmRleCwgMCwgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aWZ5IHN1YnNjcmliZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQYXJlbnQudmFsdWVIYXNNdXRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VQYXJlbnQudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIG5ldyBlbGVtZW50IGZyb20gb3V0c2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFBhcmVudC5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW5kZXJpbmcgaXMgaGFuZGxlZCBieSBtYW5pcHVsYXRpbmcgdGhlIG9ic2VydmFibGVBcnJheTsgaWdub3JlIGRyb3BwZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTZXQoZWwsIElURU1LRVksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpLml0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHVzaW5nIGRlZmVycmVkIHVwZGF0ZXMgcGx1Z2luLCBmb3JjZSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtvLnByb2Nlc3NBbGxEZWZlcnJlZEJpbmRpbmdVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtvLnByb2Nlc3NBbGxEZWZlcnJlZEJpbmRpbmdVcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hbGxvdyBiaW5kaW5nIHRvIGFjY2VwdCBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgbW92aW5nIHRoZSBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlLmFmdGVyTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZS5hZnRlck1vdmUuY2FsbCh0aGlzLCBhcmcsIGV2ZW50LCB1aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQWN0dWFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RXaXRoOiBzb3J0YWJsZS5jb25uZWN0Q2xhc3MgPyBcIi5cIiArIHNvcnRhYmxlLmNvbm5lY3RDbGFzcyA6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgZW5hYmxpbmcvZGlzYWJsaW5nIHNvcnRpbmdcbiAgICAgICAgICAgICAgICBpZiAoc29ydGFibGUuaXNFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAga28uY29tcHV0ZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuc29ydGFibGUodW53cmFwKHNvcnRhYmxlLmlzRW5hYmxlZCkgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgLy9oYW5kbGUgZGlzcG9zYWxcbiAgICAgICAgICAgIGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy9vbmx5IGNhbGwgZGVzdHJveSBpZiBzb3J0YWJsZSBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgaWYgKCRlbGVtZW50LmRhdGEoXCJ1aS1zb3J0YWJsZVwiKSB8fCAkZWxlbWVudC5kYXRhKFwic29ydGFibGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuc29ydGFibGUoXCJkZXN0cm95XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGtvLnV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcyhlbGVtZW50LCBzb3J0YWJsZS5jb25uZWN0Q2xhc3MsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8vZG8gbm90IGNyZWF0ZSB0aGUgc29ydGFibGUgaWYgdGhlIGVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIERPTVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjcmVhdGVUaW1lb3V0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlT3B0aW9ucyA9IHByZXBhcmVUZW1wbGF0ZU9wdGlvbnModmFsdWVBY2Nlc3NvciwgXCJmb3JlYWNoXCIpO1xuXG4gICAgICAgICAgICAvL2F0dGFjaCBtZXRhLWRhdGFcbiAgICAgICAgICAgIGRhdGFTZXQoZWxlbWVudCwgTElTVEtFWSwgdGVtcGxhdGVPcHRpb25zLmZvcmVhY2gpO1xuXG4gICAgICAgICAgICAvL2NhbGwgdGVtcGxhdGUgYmluZGluZydzIHVwZGF0ZSB3aXRoIGNvcnJlY3Qgb3B0aW9uc1xuICAgICAgICAgICAga28uYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLnVwZGF0ZShlbGVtZW50LCBmdW5jdGlvbigpIHsgcmV0dXJuIHRlbXBsYXRlT3B0aW9uczsgfSwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RDbGFzczogJ2tvX2NvbnRhaW5lcicsXG4gICAgICAgIGFsbG93RHJvcDogdHJ1ZSxcbiAgICAgICAgYWZ0ZXJNb3ZlOiBudWxsLFxuICAgICAgICBiZWZvcmVNb3ZlOiBudWxsLFxuICAgICAgICBvcHRpb25zOiB7fVxuICAgIH07XG5cbiAgICAvL2NyZWF0ZSBhIGRyYWdnYWJsZSB0aGF0IGlzIGFwcHJvcHJpYXRlIGZvciBkcm9wcGluZyBpbnRvIGEgc29ydGFibGVcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1bndyYXAodmFsdWVBY2Nlc3NvcigpKSB8fCB7fSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdmFsdWUub3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGVPcHRpb25zID0ga28udXRpbHMuZXh0ZW5kKHt9LCBrby5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLm9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlT3B0aW9ucyA9IHByZXBhcmVUZW1wbGF0ZU9wdGlvbnModmFsdWVBY2Nlc3NvciwgXCJkYXRhXCIpLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RDbGFzcyA9IHZhbHVlLmNvbm5lY3RDbGFzcyB8fCBrby5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLmNvbm5lY3RDbGFzcyxcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQgPSB2YWx1ZS5pc0VuYWJsZWQgIT09IHVuZGVmaW5lZCA/IHZhbHVlLmlzRW5hYmxlZCA6IGtvLmJpbmRpbmdIYW5kbGVycy5kcmFnZ2FibGUuaXNFbmFibGVkO1xuXG4gICAgICAgICAgICB2YWx1ZSA9IFwiZGF0YVwiIGluIHZhbHVlID8gdmFsdWUuZGF0YSA6IHZhbHVlO1xuXG4gICAgICAgICAgICAvL3NldCBtZXRhLWRhdGFcbiAgICAgICAgICAgIGRhdGFTZXQoZWxlbWVudCwgRFJBR0tFWSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAvL292ZXJyaWRlIGdsb2JhbCBvcHRpb25zIHdpdGggb3ZlcnJpZGUgb3B0aW9ucyBwYXNzZWQgaW5cbiAgICAgICAgICAgIGtvLnV0aWxzLmV4dGVuZChkcmFnZ2FibGVPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy9zZXR1cCBjb25uZWN0aW9uIHRvIGEgc29ydGFibGVcbiAgICAgICAgICAgIGRyYWdnYWJsZU9wdGlvbnMuY29ubmVjdFRvU29ydGFibGUgPSBjb25uZWN0Q2xhc3MgPyBcIi5cIiArIGNvbm5lY3RDbGFzcyA6IGZhbHNlO1xuXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgZHJhZ2dhYmxlXG4gICAgICAgICAgICAkKGVsZW1lbnQpLmRyYWdnYWJsZShkcmFnZ2FibGVPcHRpb25zKTtcblxuICAgICAgICAgICAgLy9oYW5kbGUgZW5hYmxpbmcvZGlzYWJsaW5nIHNvcnRpbmdcbiAgICAgICAgICAgIGlmIChpc0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtvLmNvbXB1dGVkKHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmRyYWdnYWJsZSh1bndyYXAoaXNFbmFibGVkKSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2hhbmRsZSBkaXNwb3NhbFxuICAgICAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmRyYWdnYWJsZShcImRlc3Ryb3lcIik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy50ZW1wbGF0ZS5pbml0KGVsZW1lbnQsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGVtcGxhdGVPcHRpb25zOyB9LCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVPcHRpb25zID0gcHJlcGFyZVRlbXBsYXRlT3B0aW9ucyh2YWx1ZUFjY2Vzc29yLCBcImRhdGFcIik7XG5cbiAgICAgICAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMudGVtcGxhdGUudXBkYXRlKGVsZW1lbnQsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGVtcGxhdGVPcHRpb25zOyB9LCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdENsYXNzOiBrby5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGUuY29ubmVjdENsYXNzLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBoZWxwZXI6IFwiY2xvbmVcIlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNpbXBsZSBEcm9wcGFibGUgSW1wbGVtZW50YXRpb25cbiAgICAvLyBiaW5kaW5nIHRoYXQgdXBkYXRlcyAoZnVuY3Rpb24gb3Igb2JzZXJ2YWJsZSlcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuZHJvcHBhYmxlID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1bndyYXAodmFsdWVBY2Nlc3NvcigpKSB8fCB7fSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdmFsdWUub3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgICAgICBkcm9wcGFibGVPcHRpb25zID0ga28udXRpbHMuZXh0ZW5kKHt9LCBrby5iaW5kaW5nSGFuZGxlcnMuZHJvcHBhYmxlLm9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGlzRW5hYmxlZCA9IHZhbHVlLmlzRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gdmFsdWUuaXNFbmFibGVkIDoga28uYmluZGluZ0hhbmRsZXJzLmRyb3BwYWJsZS5pc0VuYWJsZWQ7XG5cbiAgICAgICAgICAgIC8vb3ZlcnJpZGUgZ2xvYmFsIG9wdGlvbnMgd2l0aCBvdmVycmlkZSBvcHRpb25zIHBhc3NlZCBpblxuICAgICAgICAgICAga28udXRpbHMuZXh0ZW5kKGRyb3BwYWJsZU9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvL2dldCByZWZlcmVuY2UgdG8gZHJvcCBtZXRob2RcbiAgICAgICAgICAgIHZhbHVlID0gXCJkYXRhXCIgaW4gdmFsdWUgPyB2YWx1ZS5kYXRhIDogdmFsdWVBY2Nlc3NvcigpO1xuXG4gICAgICAgICAgICAvL3NldCBkcm9wIG1ldGhvZFxuICAgICAgICAgICAgZHJvcHBhYmxlT3B0aW9ucy5kcm9wID0gZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BwZWRJdGVtID0gZGF0YUdldCh1aS5kcmFnZ2FibGVbMF0sIERSQUdLRVkpIHx8IGRhdGFHZXQodWkuZHJhZ2dhYmxlWzBdLCBJVEVNS0VZKTtcbiAgICAgICAgICAgICAgICB2YWx1ZShkcm9wcGVkSXRlbSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgZHJvcHBhYmxlXG4gICAgICAgICAgICAkKGVsZW1lbnQpLmRyb3BwYWJsZShkcm9wcGFibGVPcHRpb25zKTtcblxuICAgICAgICAgICAgLy9oYW5kbGUgZW5hYmxpbmcvZGlzYWJsaW5nIGRyb3BwYWJsZVxuICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga28uY29tcHV0ZWQoe1xuICAgICAgICAgICAgICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZWxlbWVudCkuZHJvcHBhYmxlKHVud3JhcChpc0VuYWJsZWQpID8gXCJlbmFibGVcIjogXCJkaXNhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9oYW5kbGUgZGlzcG9zYWxcbiAgICAgICAgICAgIGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5kcm9wcGFibGUoXCJkZXN0cm95XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGFjY2VwdDogXCIqXCJcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIi8qISBrby1yZWFjdG9yIHYxLjQuMFxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggWmlhZCBKZWVyb2J1cmtoYW4gKi9cbiFmdW5jdGlvbihlKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9lKCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImtub2Nrb3V0XCJdLGUpOmUod2luZG93LmtvKX0oZnVuY3Rpb24oZSl7ZS5zdWJzY3JpYmFibGUuZm4ud2F0Y2g9ZnVuY3Rpb24odCxhLG4scil7dmFyIG89dHlwZW9mIHQ7cmV0dXJuXCJib29sZWFuXCI9PT1vfHxcInVuZGVmaW5lZFwiPT09bz9lLndhdGNoKHRoaXMse2VuYWJsZWQ6ITEhPT10fSk6XCJmdW5jdGlvblwiIT09b3x8ZS5pc1N1YnNjcmliYWJsZSh0KT9lLndhdGNoKHQsYSxuLHJ8fHRoaXMpOmUud2F0Y2godGhpcyxhfHx7fSx0LHJ8fHRoaXMpLHRoaXN9LGUud2F0Y2g9ZnVuY3Rpb24odCxhLG4scil7ZnVuY3Rpb24gbyhjLHUsZixzLGIsaCl7aWYoYyYmMCE9PWEuZGVwdGgmJigtMT09PWEuZGVwdGh8fGYubGVuZ3RoPChhLmRlcHRofHwxKSkpe2lmKGEud2F0Y2hlZE9ubHkmJiFjLndhdGNoYWJsZSYmYyE9dClyZXR1cm47aWYoITEhPT1hLmVuYWJsZWQmJiEwIT09YS5lbmFibGVkfHwoYy53YXRjaGFibGU9YS5lbmFibGVkKSwhMT09PWMud2F0Y2hhYmxlKXJldHVybjshMD09PWEuc2VhbCYmKGMud2F0Y2hhYmxlPSExKTt2YXIgZD10eXBlb2YgYztpZihcIm9iamVjdFwiPT09ZHx8XCJmdW5jdGlvblwiPT09ZCl7aWYoYy5fd2F0Y2hlcj09PXIpcmV0dXJuO2lmKGEuaGlkZSYmZS51dGlscy5hcnJheUluZGV4T2YoYS5oaWRlLGMpPi0xKXJldHVybjt2YXIgcD1bXS5jb25jYXQoZix1JiZ1IT09dD91OltdKTtpZihcImZ1bmN0aW9uXCIhPT1kKXtpZihcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGMpKWUudXRpbHMub2JqZWN0Rm9yRWFjaChjLGZ1bmN0aW9uKHQsbil7aWYobj1hLmdldHRlcj9hLmdldHRlci5jYWxsKHIscCxjLHQpOm4pe2lmKGEud3JhcCl7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pO1wiW29iamVjdCBGdW5jdGlvbl1cIiE9PWkmJlwiW29iamVjdCBPYmplY3RdXCIhPT1pJiYoYS5iZWZvcmVXcmFwJiYhMT09PWEuYmVmb3JlV3JhcC5jYWxsKHIscCxjLG4pfHwobj1jW3RdPVwiW29iamVjdCBBcnJheV1cIj09PWk/ZS5vYnNlcnZhYmxlQXJyYXkobik6ZS5vYnNlcnZhYmxlKG4pKSl9YS51bmxvb3AmJihuLl93YXRjaGVyPXM/dm9pZCAwOnIpO3ZhciBsPW8obixiP251bGw6YyxwLHMsbnVsbCx0KTthLnRhZ0ZpZWxkcyYmdm9pZCAwPT09bi5fZmllbGROYW1lJiYobHx8XCJwYXJlbnRzT25seVwiIT09YS50YWdGaWVsZHMmJlwiZnVuY3Rpb25cIj09dHlwZW9mIG58fFwib2JqZWN0XCI9PXR5cGVvZiBuKSYmKG4uX2ZpZWxkTmFtZT10KX19KTtlbHNlIGlmKCEwIT09YS5oaWRlQXJyYXlzKWZvcih2YXIgeT0wO3k8Yy5sZW5ndGg7eSsrKW8oY1t5XSxiP251bGw6YyxwLHMpO3JldHVybiEwfWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGMubm90aWZ5U3Vic2NyaWJlcnMmJm4pe2lmKCEwPT09YS5lbmFibGVkJiYhMT09PWMud2F0Y2hhYmxlKXJldHVybjtpZihzfHwhYS5iZWZvcmVXYXRjaHx8ITEhPT1hLmJlZm9yZVdhdGNoLmNhbGwocixwLGMsaCkpe3ZhciB2PVwiZnVuY3Rpb25cIj09dHlwZW9mIGMucG9wO2lmKHM/aShjKTpsKGMsdixwLGIpLHYpcmV0dXJuIG8oYygpLGI/bnVsbDpjLHAscywhMCksITA7aWYoITAhPT1hLmhpZGVXcmFwcGVkVmFsdWVzKXJldHVybiBvKGMoKSxiP251bGw6YyxwLHMsITApfX19fX1mdW5jdGlvbiBpKGUpe3ZhciB0PWVbY107aWYoIXQpdGhyb3dcIlN1YnNjcmlwdGlvbnMgZmllbGQgKC5cIitjK1wiKSBub3QgZGVmaW5lZCBmb3Igb2JzZXJ2YWJsZSBjaGlsZCBcIisoZS5fZmllbGROYW1lfHxcIlwiKTtpZih0LmNoYW5nZSlmb3Iobj10LmNoYW5nZS5sZW5ndGgtMTtuPj0wO24tLSl0LmNoYW5nZVtuXS5fd2F0Y2hlcj09PXImJnQuY2hhbmdlW25dLmRpc3Bvc2UoKTtpZih0LmJlZm9yZUNoYW5nZSYmKGEubXV0YWJsZXx8YS5vbGRWYWx1ZXM+MCkpZm9yKG49dC5iZWZvcmVDaGFuZ2UubGVuZ3RoLTE7bj49MDtuLS0pdC5iZWZvcmVDaGFuZ2Vbbl0uX3dhdGNoZXI9PT1yJiZ0LmJlZm9yZUNoYW5nZVtuXS5kaXNwb3NlKCk7aWYodC5hcnJheUNoYW5nZSlmb3IodmFyIG49dC5hcnJheUNoYW5nZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFycmF5Q2hhbmdlW25dLl93YXRjaGVyPT09ciYmdC5hcnJheUNoYW5nZVtuXS5kaXNwb3NlKCl9ZnVuY3Rpb24gbCh0LGksbCxjKXtpP3Quc3Vic2NyaWJlKGZ1bmN0aW9uKGkpe3ZhciB1OyExPT09YS5zcGxpdEFycmF5Q2hhbmdlcyYmdm9pZCAwIT09KHU9bi5jYWxsKHIsbCx0LGkpKSYmcih1KSxlLnV0aWxzLmFycmF5Rm9yRWFjaChpLGZ1bmN0aW9uKGUpe2lmKCExIT09YS5zcGxpdEFycmF5Q2hhbmdlcyl7dmFyIGk9bi5jYWxsKHIsbCx0LGUpO3ZvaWQgMCE9PWkmJnIoaSl9ZS5tb3ZlZHx8KCExPT09YS5hc3luYz9vKGUudmFsdWUsYz9udWxsOnQsbCxcImRlbGV0ZWRcIj09PWUuc3RhdHVzKTpzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7byhlLnZhbHVlLGM/bnVsbDp0LGwsXCJkZWxldGVkXCI9PT1lLnN0YXR1cyl9KSl9KX0sdm9pZCAwLFwiYXJyYXlDaGFuZ2VcIikuX3dhdGNoZXI9cjoodC5zdWJzY3JpYmUoZnVuY3Rpb24oKXtpZighMSE9PXQud2F0Y2hhYmxlKXt2YXIgZT1uLmNhbGwocixsLHQpO3ZvaWQgMCE9PWUmJnIoZSksYS5tdXRhYmxlJiZcIm9iamVjdFwiPT10eXBlb2YgdCgpJiYoITE9PT1hLmFzeW5jP28odCgpLGM/bnVsbDp0LGwsITEsITApOnNldFRpbWVvdXQoZnVuY3Rpb24oKXtvKHQoKSxjP251bGw6dCxsLCExLCEwKX0pKX19LG51bGwsXCJjaGFuZ2VcIikuX3dhdGNoZXI9ciwoYS5vbGRWYWx1ZXM+MHx8YS5tdXRhYmxlKSYmKHQuc3Vic2NyaWJlKGZ1bmN0aW9uKGUpe2lmKGEub2xkVmFsdWVzPjApe3ZhciBuPXQub2xkVmFsdWVzP3Qub2xkVmFsdWVzOnQub2xkVmFsdWVzPVtdO2ZvcihuLnVuc2hpZnQoZSk7bi5sZW5ndGg+YS5vbGRWYWx1ZXM7KW4ucG9wKCl9YS5tdXRhYmxlJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmbyhlLGM/bnVsbDp0LGwsITAsITApfSxudWxsLFwiYmVmb3JlQ2hhbmdlXCIpLl93YXRjaGVyPXIpKX1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiYocj1yfHxuLG49YSxhPXt9KSxyPXJ8fHRoaXM7dmFyIGM7c3dpdGNoKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc3Vic2NyaXB0aW9ufHxlLnZlcnNpb24pe2Nhc2UhMDpjPVwiX3N1YnNjcmlwdGlvbnNcIjticmVhaztjYXNlXCIzLjAuMFwiOmM9XCJGXCI7YnJlYWs7Y2FzZVwiMy4xLjBcIjpjPVwiSFwiO2JyZWFrO2Nhc2VcIjMuMi4wXCI6Yz1cIk1cIjticmVhaztjYXNlXCIzLjMuMFwiOmM9XCJHXCI7YnJlYWs7Y2FzZVwiMy40LjBcIjpjYXNlXCIzLjQuMVwiOmM9XCJLXCI7YnJlYWs7Y2FzZVwiMy40LjJcIjpjPVwiRlwiO2JyZWFrO2Nhc2VcIjMuNS4wLWJldGFcIjpjPVwiU1wiO2JyZWFrO2RlZmF1bHQ6dGhyb3dcIlVuc3VwcG9ydGVkIEtub2Nrb3V0IHZlcnNpb24uIE9ubHkgdjMuMC4wIHRvIHYzLjUuMC1iZXRhIGFyZSBzdXBwb3J0ZWQgd2hlbiBtaW5pZmllZC4gQ3VycmVudCB2ZXJzaW9uIGlzIFwiK2UudmVyc2lvbn1yZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHxlLmlzU3Vic2NyaWJhYmxlKHQpPyhvKHQsbnVsbCxbXSkse2Rpc3Bvc2U6ZnVuY3Rpb24oKXtvKHQsbnVsbCxbXSwhMCl9fSk6ZS5jb21wdXRlZCh0LG4sYSl9fSk7d2luZG93LmZvbyA9IFwiMS40LjBcIjsiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGNhY2hlIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gY2FjaGUuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNhY2hlID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgdmFyIHJlc3VsdCA9IChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpXG4gICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXG4gICAgOiBbXTtcblxuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuXG4gKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gKiAgICAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgICAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICB9XG4gIGlmICghb3RoSXNBcnIpIHtcbiAgICBvdGhUYWcgPSBnZXRUYWcob3RoZXIpO1xuICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICB9XG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvYmplY3QpLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHVuZGVmaW5lZCwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4uYWRkKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gVU5PUkRFUkVEX0NPTVBBUkVfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciByZXN1bHQsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogMDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV1cbiAqICBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldXG4gKiAgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChpdGVyYXRlZSkge1xuICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gIH1cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHByb3BzKSB7XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmplY3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBwaWNrIGZyb20uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSBhcnJheTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gbmF0aXZlR2V0U3ltYm9scyA/IG92ZXJBcmcobmF0aXZlR2V0U3ltYm9scywgT2JqZWN0KSA6IHN0dWJBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzXG4gKiBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXQgYXJlXG4gKiBub3Qgb21pdHRlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gb21pdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYic6ICcyJyB9XG4gKi9cbnZhciBvbWl0ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvcHMgPSBhcnJheU1hcChiYXNlRmxhdHRlbihwcm9wcywgMSksIHRvS2V5KTtcbiAgcmV0dXJuIGJhc2VQaWNrKG9iamVjdCwgYmFzZURpZmZlcmVuY2UoZ2V0QWxsS2V5c0luKG9iamVjdCksIHByb3BzKSk7XG59KTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBsZXggIDogcmVxdWlyZSgnLi9saWIvbGV4ZXInKSxcclxuICAgIHBhcnNlOiByZXF1aXJlKCcuL2xpYi9wYXJzZXInKSxcclxuICAgIHN0cmluZ2lmeTogcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5JylcclxufTtcclxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XHJcblxyXG5mdW5jdGlvbiBkZWJ1ZyhsYWJlbCkge1xyXG4gIHJldHVybiBfZGVidWcuYmluZChudWxsLCBsYWJlbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9kZWJ1ZyhsYWJlbCkge1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gIGFyZ3MudW5zaGlmdCgnWycgKyBsYWJlbCArICddJyk7XHJcbiAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoYXJncy5qb2luKCcgJykgKyAnXFxuJyk7XHJcbn0iLCJ2YXIgREVCVUcgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHByaW50IGRlYnVnZ2luZyBpbmZvLlxyXG52YXIgVElNRVIgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHRpbWUgY2FsbHMgdG8gYGxleCgpYCBhbmQgcHJpbnQgdGhlIHJlc3VsdHMuXHJcblxyXG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJykoJ2xleCcpO1xyXG5cclxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbGV4O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBDU1Mgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgbGV4aWNhbCB0b2tlbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3MgQ1NTXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gbGV4aWNhbCB0b2tlbnNcclxuICovXHJcbmZ1bmN0aW9uIGxleChjc3MpIHtcclxuICB2YXIgc3RhcnQ7IC8vIERlYnVnIHRpbWVyIHN0YXJ0LlxyXG5cclxuICB2YXIgYnVmZmVyID0gJyc7ICAgICAgLy8gQ2hhcmFjdGVyIGFjY3VtdWxhdG9yXHJcbiAgdmFyIGNoOyAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgY2hhcmFjdGVyXHJcbiAgdmFyIGNvbHVtbiA9IDA7ICAgICAgIC8vIEN1cnJlbnQgc291cmNlIGNvbHVtbiBudW1iZXJcclxuICB2YXIgY3Vyc29yID0gLTE7ICAgICAgLy8gQ3VycmVudCBzb3VyY2UgY3Vyc29yIHBvc2l0aW9uXHJcbiAgdmFyIGRlcHRoID0gMDsgICAgICAgIC8vIEN1cnJlbnQgbmVzdGluZyBkZXB0aFxyXG4gIHZhciBsaW5lID0gMTsgICAgICAgICAvLyBDdXJyZW50IHNvdXJjZSBsaW5lIG51bWJlclxyXG4gIHZhciBzdGF0ZSA9ICdiZWZvcmUtc2VsZWN0b3InOyAvLyBDdXJyZW50IHN0YXRlXHJcbiAgdmFyIHN0YWNrID0gW3N0YXRlXTsgIC8vIFN0YXRlIHN0YWNrXHJcbiAgdmFyIHRva2VuID0ge307ICAgICAgIC8vIEN1cnJlbnQgdG9rZW5cclxuICB2YXIgdG9rZW5zID0gW107ICAgICAgLy8gVG9rZW4gYWNjdW11bGF0b3JcclxuXHJcbiAgLy8gU3VwcG9ydGVkIEAtcnVsZXMsIGluIHJvdWdobHkgZGVzY2VuZGluZyBvcmRlciBvZiB1c2FnZSBwcm9iYWJpbGl0eS5cclxuICB2YXIgYXRSdWxlcyA9IFtcclxuICAgICdtZWRpYScsXHJcbiAgICAna2V5ZnJhbWVzJyxcclxuICAgIHsgbmFtZTogJy13ZWJraXQta2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy13ZWJraXQtJyB9LFxyXG4gICAgeyBuYW1lOiAnLW1vei1rZXlmcmFtZXMnLCB0eXBlOiAna2V5ZnJhbWVzJywgcHJlZml4OiAnLW1vei0nIH0sXHJcbiAgICB7IG5hbWU6ICctbXMta2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy1tcy0nIH0sXHJcbiAgICB7IG5hbWU6ICctby1rZXlmcmFtZXMnLCB0eXBlOiAna2V5ZnJhbWVzJywgcHJlZml4OiAnLW8tJyB9LFxyXG4gICAgJ2ZvbnQtZmFjZScsXHJcbiAgICB7IG5hbWU6ICdpbXBvcnQnLCBzdGF0ZTogJ2JlZm9yZS1hdC12YWx1ZScgfSxcclxuICAgIHsgbmFtZTogJ2NoYXJzZXQnLCBzdGF0ZTogJ2JlZm9yZS1hdC12YWx1ZScgfSxcclxuICAgICdzdXBwb3J0cycsXHJcbiAgICAndmlld3BvcnQnLFxyXG4gICAgeyBuYW1lOiAnbmFtZXNwYWNlJywgc3RhdGU6ICdiZWZvcmUtYXQtdmFsdWUnIH0sXHJcbiAgICAnZG9jdW1lbnQnLFxyXG4gICAgeyBuYW1lOiAnLW1vei1kb2N1bWVudCcsIHR5cGU6ICdkb2N1bWVudCcsIHByZWZpeDogJy1tb3otJyB9LFxyXG4gICAgJ3BhZ2UnXHJcbiAgXTtcclxuXHJcbiAgLy8gLS0gRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvKipcclxuICAgKiBBZHZhbmNlIHRoZSBjaGFyYWN0ZXIgY3Vyc29yIGFuZCByZXR1cm4gdGhlIG5leHQgY2hhcmFjdGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIG5leHQgY2hhcmFjdGVyLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldENoKCkge1xyXG4gICAgc2tpcCgpO1xyXG4gICAgcmV0dXJuIGNzc1tjdXJzb3JdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBzdGF0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIHN0YWNrLlxyXG4gICAqIFRoZSBzdGFjayBpcyBMSUZPIHNvIGluZGV4aW5nIGlzIGZyb20gdGhlIHJpZ2h0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleD0wXSBJbmRleCB0byByZXR1cm4uXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRTdGF0ZShpbmRleCkge1xyXG4gICAgcmV0dXJuIGluZGV4ID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGluZGV4XSA6IHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9vayBhaGVhZCBmb3IgYSBzdHJpbmcgYmVnaW5uaW5nIGZyb20gdGhlIG5leHQgcG9zaXRpb24uIFRoZSBzdHJpbmdcclxuICAgKiBiZWluZyBsb29rZWQgZm9yIG11c3Qgc3RhcnQgYXQgdGhlIG5leHQgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gbG9vayBmb3IuXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHN0cmluZyB3YXMgZm91bmQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNOZXh0U3RyaW5nKHN0cikge1xyXG4gICAgdmFyIHN0YXJ0ID0gY3Vyc29yICsgMTtcclxuICAgIHJldHVybiAoc3RyID09PSBjc3Muc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgc3RyLmxlbmd0aCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYSBzdWJzdHJpbmcgYmVnaW5uaW5nIGZyb20gdGhlIG5leHRcclxuICAgKiBwb3NpdGlvbi4gVGhlIHN0cmluZyBiZWluZyBsb29rZWQgZm9yIG1heSBiZWdpbiBhbnl3aGVyZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YnN0cmluZyB0byBsb29rIGZvci5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfGZhbHNlfSBUaGUgcG9zaXRpb24sIG9yIGBmYWxzZWAgaWYgbm90IGZvdW5kLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZpbmQoc3RyKSB7XHJcbiAgICB2YXIgcG9zID0gY3NzLnNsaWNlKGN1cnNvcikuaW5kZXhPZihzdHIpO1xyXG5cclxuICAgIHJldHVybiBwb3MgPiAwID8gcG9zIDogZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNoYXJhY3RlciBpcyBuZXh0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoIENoYXJhY3Rlci5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIG5leHQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNOZXh0Q2hhcihjaCkge1xyXG4gICAgcmV0dXJuIGNoID09PSBwZWVrKDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGdpdmVuIGN1cnNvciBvZmZzZXQuIFRoZSBvZmZzZXQgaXMgcmVsYXRpdmVcclxuICAgKiB0byB0aGUgY3Vyc29yLCBzbyBuZWdhdGl2ZSB2YWx1ZXMgbW92ZSBiYWNrd2FyZHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0xXSBDdXJzb3Igb2Zmc2V0LlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENoYXJhY3Rlci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwZWVrKG9mZnNldCkge1xyXG4gICAgcmV0dXJuIGNzc1tjdXJzb3IgKyAob2Zmc2V0IHx8IDEpXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBzdGFjayBhbmQgc2V0IHRoZSBuZXcgY3VycmVudCBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZW1vdmVkIHN0YXRlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBvcFN0YXRlKCkge1xyXG4gICAgdmFyIHJlbW92ZWQgPSBzdGFjay5wb3AoKTtcclxuICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblxyXG4gICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGFkZCBpdCB0byB0aGUgc3RhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3U3RhdGUgVGhlIG5ldyBzdGF0ZS5cclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbmV3IHN0YWNrIGxlbmd0aC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwdXNoU3RhdGUobmV3U3RhdGUpIHtcclxuICAgIHN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICBzdGFjay5wdXNoKHN0YXRlKTtcclxuXHJcbiAgICByZXR1cm4gc3RhY2subGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwbGFjZSB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIGEgbmV3IHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1N0YXRlIFRoZSBuZXcgc3RhdGUuXHJcbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlcGxhY2VkIHN0YXRlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShuZXdTdGF0ZSkge1xyXG4gICAgdmFyIHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcclxuICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID0gc3RhdGUgPSBuZXdTdGF0ZTtcclxuXHJcbiAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIGNoYXJhY3RlciBjdXJzb3IuIFBvc2l0aXZlIG51bWJlcnMgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQuXHJcbiAgICogTmVnYXRpdmUgbnVtYmVycyBhcmUgbm90IHN1cHBvcnRlZCFcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbj0xXSBOdW1iZXIgb2YgY2hhcmFjdGVycyB0byBza2lwLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNraXAobikge1xyXG4gICAgaWYgKChuIHx8IDEpID09IDEpIHtcclxuICAgICAgaWYgKGNzc1tjdXJzb3JdID09ICdcXG4nKSB7XHJcbiAgICAgICAgbGluZSsrO1xyXG4gICAgICAgIGNvbHVtbiA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sdW1uKys7XHJcbiAgICAgIH1cclxuICAgICAgY3Vyc29yKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgc2tpcFN0ciA9IGNzcy5zbGljZShjdXJzb3IsIGN1cnNvciArIG4pLnNwbGl0KCdcXG4nKTtcclxuICAgICAgaWYgKHNraXBTdHIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGxpbmUgKz0gc2tpcFN0ci5sZW5ndGggLSAxO1xyXG4gICAgICAgIGNvbHVtbiA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgY29sdW1uICs9IHNraXBTdHJbc2tpcFN0ci5sZW5ndGggLSAxXS5sZW5ndGg7XHJcbiAgICAgIGN1cnNvciA9IGN1cnNvciArIG47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgdGhlIGN1cnJlbnQgdG9rZW4gdG8gdGhlIHBpbGUgYW5kIHJlc2V0IHRoZSBidWZmZXIuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWRkVG9rZW4oKSB7XHJcbiAgICB0b2tlbi5lbmQgPSB7XHJcbiAgICAgIGxpbmU6IGxpbmUsXHJcbiAgICAgIGNvbDogY29sdW1uXHJcbiAgICB9O1xyXG5cclxuICAgIERFQlVHICYmIGRlYnVnKCdhZGRUb2tlbjonLCBKU09OLnN0cmluZ2lmeSh0b2tlbiwgbnVsbCwgMikpO1xyXG5cclxuICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuXHJcbiAgICBidWZmZXIgPSAnJztcclxuICAgIHRva2VuID0ge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdG9rZW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUb2tlbiB0eXBlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVUb2tlbih0eXBlKSB7XHJcbiAgICB0b2tlbiA9IHtcclxuICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgc3RhcnQ6IHtcclxuICAgICAgICBsaW5lOiBsaW5lLFxyXG4gICAgICAgIGNvbCA6IGNvbHVtblxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gLS0gTWFpbiBMb29wIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvKlxyXG4gIFRoZSBtYWluIGxvb3AgaXMgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgcmVhZHMgaW4gb25lIGNoYXJhY3RlciBhdCBhIHRpbWUsXHJcbiAgYW5kIGRldGVybWluZXMgd2hhdCB0byBkbyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY2hhcmFjdGVyLlxyXG4gIFRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzZXJpZXMgb2YgbmVzdGVkIGBzd2l0Y2hgIHN0YXRlbWVudHMgYW5kIHRoZVxyXG4gIGNhc2Ugb3JkZXJzIGhhdmUgYmVlbiBtaWxkbHkgb3B0aW1pemVkIGJhc2VkIG9uIHJvdWdoIHByb2JhYmlsaXRpZXNcclxuICBjYWxjdWxhdGVkIGJ5IHByb2Nlc3NpbmcgYSBzbWFsbCBzYW1wbGUgb2YgcmVhbC13b3JsZCBDU1MuXHJcblxyXG4gIEZ1cnRoZXIgb3B0aW1pemF0aW9uIChzdWNoIGFzIGEgZGlzcGF0Y2ggdGFibGUpIHNob3VsZG4ndCBiZSBuZWNlc3NhcnlcclxuICBzaW5jZSB0aGUgdG90YWwgbnVtYmVyIG9mIGNhc2VzIGlzIHZlcnkgbG93LlxyXG4gICovXHJcblxyXG4gIFRJTUVSICYmIChzdGFydCA9IERhdGUubm93KCkpO1xyXG5cclxuICB3aGlsZSAoY2ggPSBnZXRDaCgpKSB7XHJcbiAgICBERUJVRyAmJiBkZWJ1ZyhjaCwgZ2V0U3RhdGUoKSk7XHJcblxyXG4gICAgLy8gY29sdW1uICs9IDE7XHJcblxyXG4gICAgc3dpdGNoIChjaCkge1xyXG4gICAgLy8gU3BhY2VcclxuICAgIGNhc2UgJyAnOlxyXG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcclxuICAgICAgY2FzZSAnc2VsZWN0b3InOlxyXG4gICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgIGNhc2UgJ3ZhbHVlLXBhcmVuJzpcclxuICAgICAgY2FzZSAnYXQtZ3JvdXAnOlxyXG4gICAgICBjYXNlICdhdC12YWx1ZSc6XHJcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxyXG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcclxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XHJcbiAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIC8vIE5ld2xpbmUgb3IgdGFiXHJcbiAgICBjYXNlICdcXG4nOlxyXG4gICAgY2FzZSAnXFx0JzpcclxuICAgIGNhc2UgJ1xccic6XHJcbiAgICBjYXNlICdcXGYnOlxyXG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcclxuICAgICAgY2FzZSAndmFsdWUnOlxyXG4gICAgICBjYXNlICd2YWx1ZS1wYXJlbic6XHJcbiAgICAgIGNhc2UgJ2F0LWdyb3VwJzpcclxuICAgICAgY2FzZSAnY29tbWVudCc6XHJcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxyXG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcclxuICAgICAgY2FzZSAnc2VsZWN0b3InOlxyXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2F0LXZhbHVlJzpcclxuICAgICAgICAvLyBUb2tlbml6ZSBhbiBALXJ1bGUgaWYgYSBzZW1pLWNvbG9uIHdhcyBvbWl0dGVkLlxyXG4gICAgICAgIGlmICgnXFxuJyA9PT0gY2gpIHtcclxuICAgICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKTtcclxuICAgICAgICAgIGFkZFRva2VuKCk7XHJcbiAgICAgICAgICBwb3BTdGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgKCdcXG4nID09PSBjaCkge1xyXG4gICAgICAvLyAgIGNvbHVtbiA9IDA7XHJcbiAgICAgIC8vICAgbGluZSArPSAxO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgJzonOlxyXG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcclxuICAgICAgY2FzZSAnbmFtZSc6XHJcbiAgICAgICAgdG9rZW4ubmFtZSA9IGJ1ZmZlci50cmltKCk7XHJcbiAgICAgICAgYnVmZmVyID0gJyc7XHJcblxyXG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnYmVmb3JlLXZhbHVlJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdiZWZvcmUtc2VsZWN0b3InOlxyXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcclxuXHJcbiAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdzZWxlY3RvcicpO1xyXG4gICAgICAgIHB1c2hTdGF0ZSgnc2VsZWN0b3InKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XHJcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xyXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgJzsnOlxyXG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcclxuICAgICAgY2FzZSAnbmFtZSc6XHJcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XHJcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcclxuICAgICAgICAvLyBUb2tlbml6ZSBhIGRlY2xhcmF0aW9uXHJcbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgZW1wdHkgc2tpcCB0aGUgZGVjbGFyYXRpb25cclxuICAgICAgICBpZiAoYnVmZmVyLnRyaW0oKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9IGJ1ZmZlci50cmltKCksXHJcbiAgICAgICAgICBhZGRUb2tlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBsYWNlU3RhdGUoJ2JlZm9yZS1uYW1lJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICd2YWx1ZS1wYXJlbic6XHJcbiAgICAgICAgLy8gSW5zaWduaWZpY2FudCBzZW1pLWNvbG9uXHJcbiAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnYXQtdmFsdWUnOlxyXG4gICAgICAgIC8vIFRva2VuaXplIGFuIEAtcnVsZVxyXG4gICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKTtcclxuICAgICAgICBhZGRUb2tlbigpO1xyXG4gICAgICAgIHBvcFN0YXRlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdiZWZvcmUtbmFtZSc6XHJcbiAgICAgICAgLy8gRXh0cmFuZW91cyBzZW1pLWNvbG9uXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICd7JzpcclxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XHJcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcclxuICAgICAgICAvLyBJZiB0aGUgc2VxdWVuY2UgaXMgYFxce2AgdGhlbiBhc3N1bWUgdGhhdCB0aGUgYnJhY2Ugc2hvdWxkIGJlIGVzY2FwZWQuXHJcbiAgICAgICAgaWYgKHBlZWsoLTEpID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRva2VuaXplIGEgc2VsZWN0b3JcclxuICAgICAgICB0b2tlbi50ZXh0ID0gYnVmZmVyLnRyaW0oKTtcclxuICAgICAgICBhZGRUb2tlbigpO1xyXG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnYmVmb3JlLW5hbWUnKTtcclxuICAgICAgICBkZXB0aCA9IGRlcHRoICsgMTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2F0LWdyb3VwJzpcclxuICAgICAgICAvLyBUb2tlbml6ZSBhbiBALWdyb3VwXHJcbiAgICAgICAgdG9rZW4ubmFtZSA9IGJ1ZmZlci50cmltKCk7XHJcblxyXG4gICAgICAgIC8vIFhYWDogQC1ydWxlcyBhcmUgc3RhcnRpbmcgdG8gZ2V0IGhhaXJ5XHJcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnZm9udC1mYWNlJzpcclxuICAgICAgICBjYXNlICd2aWV3cG9ydCcgOlxyXG4gICAgICAgIGNhc2UgJ3BhZ2UnICAgICA6XHJcbiAgICAgICAgICBwdXNoU3RhdGUoJ2JlZm9yZS1uYW1lJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHB1c2hTdGF0ZSgnYmVmb3JlLXNlbGVjdG9yJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGRUb2tlbigpO1xyXG4gICAgICAgIGRlcHRoID0gZGVwdGggKyAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnbmFtZSc6XHJcbiAgICAgIGNhc2UgJ2F0LXJ1bGUnOlxyXG4gICAgICAgIC8vIFRva2VuaXplIGEgZGVjbGFyYXRpb24gb3IgYW4gQC1ydWxlXHJcbiAgICAgICAgdG9rZW4ubmFtZSA9IGJ1ZmZlci50cmltKCk7XHJcbiAgICAgICAgYWRkVG9rZW4oKTtcclxuICAgICAgICBwdXNoU3RhdGUoJ2JlZm9yZS1uYW1lJyk7XHJcbiAgICAgICAgZGVwdGggPSBkZXB0aCArIDE7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdjb21tZW50JzpcclxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XHJcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxyXG4gICAgICAgIC8vIElnbm9yZSBicmFjZXMgaW4gY29tbWVudHMgYW5kIHN0cmluZ3NcclxuICAgICAgICBidWZmZXIgKz0gY2g7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XHJcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xyXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAnfSc6XHJcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xyXG4gICAgICBjYXNlICdiZWZvcmUtbmFtZSc6XHJcbiAgICAgIGNhc2UgJ25hbWUnOlxyXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxyXG4gICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgLy8gSWYgdGhlIGJ1ZmZlciBjb250YWlucyBhbnl0aGluZywgaXQgaXMgYSB2YWx1ZVxyXG4gICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHRva2VuIGhhcyBhIG5hbWUgYW5kIGEgdmFsdWUgaXQgc2hvdWxkIGJlIHRva2VuaXplZC5cclxuICAgICAgICBpZiAodG9rZW4ubmFtZSAmJiB0b2tlbi52YWx1ZSkge1xyXG4gICAgICAgICAgYWRkVG9rZW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExlYXZlIHRoZSBibG9ja1xyXG4gICAgICAgIGluaXRpYWxpemVUb2tlbignZW5kJyk7XHJcbiAgICAgICAgYWRkVG9rZW4oKTtcclxuICAgICAgICBwb3BTdGF0ZSgpO1xyXG5cclxuICAgICAgICAvLyBXZSBtaWdodCBuZWVkIHRvIGxlYXZlIGFnYWluLlxyXG4gICAgICAgIC8vIFhYWDogV2hhdCBhYm91dCAzIGxldmVscyBkZWVwP1xyXG4gICAgICAgIGlmICgnYXQtZ3JvdXAnID09PSBnZXRTdGF0ZSgpKSB7XHJcbiAgICAgICAgICBpbml0aWFsaXplVG9rZW4oJ2F0LWdyb3VwLWVuZCcpO1xyXG4gICAgICAgICAgYWRkVG9rZW4oKTtcclxuICAgICAgICAgIHBvcFN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChkZXB0aCA+IDApIHtcclxuICAgICAgICAgIGRlcHRoID0gZGVwdGggLSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdhdC1ncm91cCc6XHJcbiAgICAgIGNhc2UgJ2JlZm9yZS1zZWxlY3Rvcic6XHJcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcclxuICAgICAgICAvLyBJZiB0aGUgc2VxdWVuY2UgaXMgYFxcfWAgdGhlbiBhc3N1bWUgdGhhdCB0aGUgYnJhY2Ugc2hvdWxkIGJlIGVzY2FwZWQuXHJcbiAgICAgICAgaWYgKHBlZWsoLTEpID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZXB0aCA+IDApIHtcclxuICAgICAgICAgIC8vIExlYXZlIGJsb2NrIGlmIGluIGFuIGF0LWdyb3VwXHJcbiAgICAgICAgICBpZiAoJ2F0LWdyb3VwJyA9PT0gZ2V0U3RhdGUoMSkpIHtcclxuICAgICAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdhdC1ncm91cC1lbmQnKTtcclxuICAgICAgICAgICAgYWRkVG9rZW4oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZXB0aCA+IDEpIHtcclxuICAgICAgICAgIHBvcFN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVwdGggPiAwKSB7XHJcbiAgICAgICAgICBkZXB0aCA9IGRlcHRoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcclxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XHJcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxyXG4gICAgICAgIC8vIElnbm9yZSBicmFjZXMgaW4gY29tbWVudHMgYW5kIHN0cmluZ3MuXHJcbiAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICAvLyBTdHJpbmdzXHJcbiAgICBjYXNlICdcIic6XHJcbiAgICBjYXNlIFwiJ1wiOlxyXG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcclxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XHJcbiAgICAgICAgaWYgKCdcIicgPT09IGNoICYmICdcXFxcJyAhPT0gcGVlaygtMSkpIHtcclxuICAgICAgICAgIHBvcFN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XHJcbiAgICAgICAgaWYgKFwiJ1wiID09PSBjaCAmJiAnXFxcXCcgIT09IHBlZWsoLTEpKSB7XHJcbiAgICAgICAgICBwb3BTdGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2JlZm9yZS1hdC12YWx1ZSc6XHJcbiAgICAgICAgcmVwbGFjZVN0YXRlKCdhdC12YWx1ZScpO1xyXG4gICAgICAgIHB1c2hTdGF0ZSgnXCInID09PSBjaCA/ICdkb3VibGUtc3RyaW5nJyA6ICdzaW5nbGUtc3RyaW5nJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxyXG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcclxuICAgICAgICBwdXNoU3RhdGUoJ1wiJyA9PT0gY2ggPyAnZG91YmxlLXN0cmluZycgOiAnc2luZ2xlLXN0cmluZycpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnY29tbWVudCc6XHJcbiAgICAgICAgLy8gSWdub3JlIHN0cmluZ3Mgd2l0aGluIGNvbW1lbnRzLlxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBpZiAoJ1xcXFwnICE9PSBwZWVrKC0xKSkge1xyXG4gICAgICAgICAgcHVzaFN0YXRlKCdcIicgPT09IGNoID8gJ2RvdWJsZS1zdHJpbmcnIDogJ3NpbmdsZS1zdHJpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgLy8gQ29tbWVudHNcclxuICAgIGNhc2UgJy8nOlxyXG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcclxuICAgICAgY2FzZSAnY29tbWVudCc6XHJcbiAgICAgIGNhc2UgJ2RvdWJsZS1zdHJpbmcnOlxyXG4gICAgICBjYXNlICdzaW5nbGUtc3RyaW5nJzpcclxuICAgICAgICAvLyBJZ25vcmVcclxuICAgICAgICBidWZmZXIgKz0gY2g7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxyXG4gICAgICBjYXNlICdzZWxlY3Rvcic6XHJcbiAgICAgIGNhc2UgJ25hbWUnOlxyXG4gICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgaWYgKGlzTmV4dENoYXIoJyonKSkge1xyXG4gICAgICAgICAgLy8gSWdub3JlIGNvbW1lbnRzIGluIHNlbGVjdG9ycywgcHJvcGVydGllcyBhbmQgdmFsdWVzLiBUaGV5IGFyZVxyXG4gICAgICAgICAgLy8gZGlmZmljdWx0IHRvIHJlcHJlc2VudCBpbiB0aGUgQVNULlxyXG4gICAgICAgICAgdmFyIHBvcyA9IGZpbmQoJyovJyk7XHJcblxyXG4gICAgICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICAgICBza2lwKHBvcyArIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoZ2V0U3RhdGUoKSA9PSAnYmVmb3JlLXZhbHVlJykgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xyXG4gICAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgaWYgKGlzTmV4dENoYXIoJyonKSkge1xyXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY29tbWVudCB0b2tlblxyXG4gICAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdjb21tZW50Jyk7XHJcbiAgICAgICAgICBwdXNoU3RhdGUoJ2NvbW1lbnQnKTtcclxuICAgICAgICAgIHNraXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBidWZmZXIgKz0gY2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIC8vIENvbW1lbnQgZW5kIG9yIHVuaXZlcnNhbCBzZWxlY3RvclxyXG4gICAgY2FzZSAnKic6XHJcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xyXG4gICAgICBjYXNlICdjb21tZW50JzpcclxuICAgICAgICBpZiAoaXNOZXh0Q2hhcignLycpKSB7XHJcbiAgICAgICAgICAvLyBUb2tlbml6ZSBhIGNvbW1lbnRcclxuICAgICAgICAgIHRva2VuLnRleHQgPSBidWZmZXI7IC8vIERvbid0IHRyaW0oKSFcclxuICAgICAgICAgIHNraXAoKTtcclxuICAgICAgICAgIGFkZFRva2VuKCk7XHJcbiAgICAgICAgICBwb3BTdGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdiZWZvcmUtc2VsZWN0b3InOlxyXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgICBpbml0aWFsaXplVG9rZW4oJ3NlbGVjdG9yJyk7XHJcbiAgICAgICAgcHVzaFN0YXRlKCdzZWxlY3RvcicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcclxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XHJcbiAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBidWZmZXIgKz0gY2g7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgLy8gQC1ydWxlc1xyXG4gICAgY2FzZSAnQCc6XHJcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xyXG4gICAgICBjYXNlICdjb21tZW50JzpcclxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XHJcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxyXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcclxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XHJcbiAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHN1cHBvcnRlZCBALXJ1bGVzIGFuZCBhdHRlbXB0IHRvIHRva2VuaXplIG9uZS5cclxuICAgICAgICB2YXIgdG9rZW5pemVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgdmFyIHJ1bGU7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBhdFJ1bGVzLmxlbmd0aDsgIXRva2VuaXplZCAmJiBqIDwgbGVuOyArK2opIHtcclxuICAgICAgICAgIHJ1bGUgPSBhdFJ1bGVzW2pdO1xyXG4gICAgICAgICAgbmFtZSA9IHJ1bGUubmFtZSB8fCBydWxlO1xyXG5cclxuICAgICAgICAgIGlmICghaXNOZXh0U3RyaW5nKG5hbWUpKSB7IGNvbnRpbnVlOyB9XHJcblxyXG4gICAgICAgICAgdG9rZW5pemVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICBpbml0aWFsaXplVG9rZW4obmFtZSk7XHJcbiAgICAgICAgICBwdXNoU3RhdGUocnVsZS5zdGF0ZSB8fCAnYXQtZ3JvdXAnKTtcclxuICAgICAgICAgIHNraXAobmFtZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgIGlmIChydWxlLnByZWZpeCkge1xyXG4gICAgICAgICAgICB0b2tlbi5wcmVmaXggPSBydWxlLnByZWZpeDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAocnVsZS50eXBlKSB7XHJcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBydWxlLnR5cGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRva2VuaXplZCkge1xyXG4gICAgICAgICAgLy8gS2VlcCBvbiB0cnVja2luJyBBbWVyaWNhIVxyXG4gICAgICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICAvLyBQYXJlbnRoZXNlcyBhcmUgdHJhY2tlZCB0byBkaXNhbWJpZ3VhdGUgc2VtaS1jb2xvbnMsIHN1Y2ggYXMgd2l0aGluIGFcclxuICAgIC8vIGRhdGEgVVJJLlxyXG4gICAgY2FzZSAnKCc6XHJcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xyXG4gICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgcHVzaFN0YXRlKCd2YWx1ZS1wYXJlbicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxyXG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICcpJzpcclxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XHJcbiAgICAgIGNhc2UgJ3ZhbHVlLXBhcmVuJzpcclxuICAgICAgICBwb3BTdGF0ZSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxyXG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgYnVmZmVyICs9IGNoO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcclxuICAgICAgY2FzZSAnYmVmb3JlLXNlbGVjdG9yJzpcclxuICAgICAgICBpbml0aWFsaXplVG9rZW4oJ3NlbGVjdG9yJyk7XHJcbiAgICAgICAgcHVzaFN0YXRlKCdzZWxlY3RvcicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnYmVmb3JlLW5hbWUnOlxyXG4gICAgICAgIGluaXRpYWxpemVUb2tlbigncHJvcGVydHknKTtcclxuICAgICAgICByZXBsYWNlU3RhdGUoJ25hbWUnKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XHJcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnYmVmb3JlLWF0LXZhbHVlJzpcclxuICAgICAgICByZXBsYWNlU3RhdGUoJ2F0LXZhbHVlJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJ1ZmZlciArPSBjaDtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBUSU1FUiAmJiBkZWJ1ZygncmFuIGluJywgKERhdGUubm93KCkgLSBzdGFydCkgKyAnbXMnKTtcclxuXHJcbiAgcmV0dXJuIHRva2VucztcclxufVxyXG4iLCJ2YXIgREVCVUcgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHByaW50IGRlYnVnZ2luZyBpbmZvLlxyXG52YXIgVElNRVIgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHRpbWUgY2FsbHMgdG8gYHBhcnNlKClgIGFuZCBwcmludCB0aGUgcmVzdWx0cy5cclxuXHJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKSgncGFyc2UnKTtcclxudmFyIGxleCA9IHJlcXVpcmUoJy4vbGV4ZXInKTtcclxuXHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xyXG5cclxudmFyIF9jb21tZW50czsgICAvLyBXaGV0aGVyIGNvbW1lbnRzIGFyZSBhbGxvd2VkLlxyXG52YXIgX2RlcHRoOyAgICAgIC8vIEN1cnJlbnQgYmxvY2sgbmVzdGluZyBkZXB0aC5cclxudmFyIF9wb3NpdGlvbjsgICAvLyBXaGV0aGVyIHRvIGluY2x1ZGUgbGluZS9jb2x1bW4gcG9zaXRpb24uXHJcbnZhciBfdG9rZW5zOyAgICAgLy8gQXJyYXkgb2YgbGV4aWNhbCB0b2tlbnMuXHJcblxyXG4vKipcclxuICogQ29udmVydCBhIENTUyBzdHJpbmcgb3IgYXJyYXkgb2YgbGV4aWNhbCB0b2tlbnMgaW50byBhIGBzdHJpbmdpZnlgLWFibGUgQVNULlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIENTUyBzdHJpbmcgb3IgYXJyYXkgb2YgbGV4aWNhbCB0b2tlblxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tbWVudHM9ZmFsc2VdIGFsbG93IGNvbW1lbnQgbm9kZXMgaW4gdGhlIEFTVFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBgc3RyaW5naWZ5YC1hYmxlIEFTVFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2UoY3NzLCBvcHRpb25zKSB7XHJcbiAgdmFyIHN0YXJ0OyAvLyBEZWJ1ZyB0aW1lciBzdGFydC5cclxuXHJcbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcclxuICBfY29tbWVudHMgPSAhIW9wdGlvbnMuY29tbWVudHM7XHJcbiAgX3Bvc2l0aW9uID0gISFvcHRpb25zLnBvc2l0aW9uO1xyXG5cclxuICBfZGVwdGggPSAwO1xyXG5cclxuICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiB0aGUgZ2l2ZW4gdG9rZW5zLCBvciB0aGUgbGV4KCknZCBDU1Mgc3RyaW5nLlxyXG4gIF90b2tlbnMgPSBBcnJheS5pc0FycmF5KGNzcykgPyBjc3Muc2xpY2UoKSA6IGxleChjc3MpO1xyXG5cclxuICB2YXIgcnVsZTtcclxuICB2YXIgcnVsZXMgPSBbXTtcclxuICB2YXIgdG9rZW47XHJcblxyXG4gIFRJTUVSICYmIChzdGFydCA9IERhdGUubm93KCkpO1xyXG5cclxuICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSkge1xyXG4gICAgcnVsZSA9IHBhcnNlVG9rZW4odG9rZW4pO1xyXG4gICAgcnVsZSAmJiBydWxlcy5wdXNoKHJ1bGUpO1xyXG4gIH1cclxuXHJcbiAgVElNRVIgJiYgZGVidWcoJ3JhbiBpbicsIChEYXRlLm5vdygpIC0gc3RhcnQpICsgJ21zJyk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiBcInN0eWxlc2hlZXRcIixcclxuICAgIHN0eWxlc2hlZXQ6IHtcclxuICAgICAgcnVsZXM6IHJ1bGVzXHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLy8gLS0gRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQnVpbGQgYW4gQVNUIG5vZGUgZnJvbSBhIGxleGljYWwgdG9rZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBsZXhpY2FsIHRva2VuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3ZlcnJpZGVdIG9iamVjdCBoYXNoIG9mIHByb3BlcnRpZXMgdGhhdCBvdmVycmlkZSB0aG9zZVxyXG4gKiAgIGFscmVhZHkgaW4gdGhlIHRva2VuLCBvciB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRva2VuLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBU1Qgbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gYXN0Tm9kZSh0b2tlbiwgb3ZlcnJpZGUpIHtcclxuICBvdmVycmlkZSB8fCAob3ZlcnJpZGUgPSB7fSk7XHJcblxyXG4gIHZhciBrZXk7XHJcbiAgdmFyIGtleXMgPSBbJ3R5cGUnLCAnbmFtZScsICd2YWx1ZSddO1xyXG4gIHZhciBub2RlID0ge307XHJcblxyXG4gIC8vIEF2b2lkaW5nIFtdLmZvckVhY2ggZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBrZXkgPSBrZXlzW2ldO1xyXG5cclxuICAgIGlmICh0b2tlbltrZXldKSB7XHJcbiAgICAgIG5vZGVba2V5XSA9IG92ZXJyaWRlW2tleV0gfHwgdG9rZW5ba2V5XTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGtleXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZSk7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBrZXkgPSBrZXlzW2ldO1xyXG5cclxuICAgIGlmICghbm9kZVtrZXldKSB7XHJcbiAgICAgIG5vZGVba2V5XSA9IG92ZXJyaWRlW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoX3Bvc2l0aW9uKSB7XHJcbiAgICBub2RlLnBvc2l0aW9uID0ge1xyXG4gICAgICBzdGFydDogdG9rZW4uc3RhcnQsXHJcbiAgICAgIGVuZDogdG9rZW4uZW5kXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgREVCVUcgJiYgZGVidWcoJ2FzdE5vZGU6JywgSlNPTi5zdHJpbmdpZnkobm9kZSwgbnVsbCwgMikpO1xyXG5cclxuICByZXR1cm4gbm9kZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIGxleGljYWwgdG9rZW4gZnJvbSB0aGUgc3RhY2sgYW5kIHJldHVybiB0aGUgcmVtb3ZlZCB0b2tlbi5cclxuICpcclxuICogQHJldHVybnMge09iamVjdH0gbGV4aWNhbCB0b2tlblxyXG4gKi9cclxuZnVuY3Rpb24gbmV4dCgpIHtcclxuICB2YXIgdG9rZW4gPSBfdG9rZW5zLnNoaWZ0KCk7XHJcbiAgREVCVUcgJiYgZGVidWcoJ25leHQ6JywgSlNPTi5zdHJpbmdpZnkodG9rZW4sIG51bGwsIDIpKTtcclxuICByZXR1cm4gdG9rZW47XHJcbn1cclxuXHJcbi8vIC0tIFBhcnNlKiBGdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQ29udmVydCBhbiBALWdyb3VwIGxleGljYWwgdG9rZW4gdG8gYW4gQVNUIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBALWdyb3VwIGxleGljYWwgdG9rZW5cclxuICogQHJldHVybnMge09iamVjdH0gQC1ncm91cCBBU1Qgbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VBdEdyb3VwKHRva2VuKSB7XHJcbiAgX2RlcHRoID0gX2RlcHRoICsgMTtcclxuXHJcbiAgLy8gQXMgdGhlIEAtZ3JvdXAgdG9rZW4gaXMgYXNzZW1ibGVkLCByZWxldmFudCB0b2tlbiB2YWx1ZXMgYXJlIGNhcHR1cmVkIGhlcmVcclxuICAvLyB0ZW1wb3JhcmlseS4gVGhleSB3aWxsIGxhdGVyIGJlIHVzZWQgYXMgYHRva2VuaXplKClgIG92ZXJyaWRlcy5cclxuICB2YXIgb3ZlcnJpZGVzID0ge307XHJcblxyXG4gIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG4gIGNhc2UgJ2ZvbnQtZmFjZSc6XHJcbiAgY2FzZSAndmlld3BvcnQnIDpcclxuICAgIG92ZXJyaWRlcy5kZWNsYXJhdGlvbnMgPSBwYXJzZURlY2xhcmF0aW9ucygpO1xyXG4gICAgYnJlYWs7XHJcblxyXG4gIGNhc2UgJ3BhZ2UnOlxyXG4gICAgb3ZlcnJpZGVzLnByZWZpeCA9IHRva2VuLnByZWZpeDtcclxuICAgIG92ZXJyaWRlcy5kZWNsYXJhdGlvbnMgPSBwYXJzZURlY2xhcmF0aW9ucygpO1xyXG4gICAgYnJlYWs7XHJcblxyXG4gIGRlZmF1bHQ6XHJcbiAgICBvdmVycmlkZXMucHJlZml4ID0gdG9rZW4ucHJlZml4O1xyXG4gICAgb3ZlcnJpZGVzLnJ1bGVzID0gcGFyc2VSdWxlcygpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4sIG92ZXJyaWRlcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGFuIEBpbXBvcnQgbGV4aWNhbCB0b2tlbiB0byBhbiBBU1Qgbm9kZS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIEBpbXBvcnQgbGV4aWNhbCB0b2tlblxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBAaW1wb3J0IEFTVCBub2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUF0SW1wb3J0KHRva2VuKSB7XHJcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4pO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhbiBAY2hhcnNldCB0b2tlbiB0byBhbiBBU1Qgbm9kZS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIEBjaGFyc2V0IGxleGljYWwgdG9rZW5cclxuICogQHJldHVybnMge09iamVjdH0gQGNoYXJzZXQgbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VDaGFyc2V0KHRva2VuKSB7XHJcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4pO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIGNvbW1lbnQgdG9rZW4gdG8gYW4gQVNUIE5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBjb21tZW50IGxleGljYWwgdG9rZW5cclxuICogQHJldHVybnMge09iamVjdH0gY29tbWVudCBub2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUNvbW1lbnQodG9rZW4pIHtcclxuICByZXR1cm4gYXN0Tm9kZSh0b2tlbiwge3RleHQ6IHRva2VuLnRleHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VOYW1lc3BhY2UodG9rZW4pIHtcclxuICByZXR1cm4gYXN0Tm9kZSh0b2tlbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcHJvcGVydHkgbGV4aWNhbCB0b2tlbiB0byBhIHByb3BlcnR5IEFTVCBub2RlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwcm9wZXJ0eSBub2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVByb3BlcnR5KHRva2VuKSB7XHJcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4pO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIHNlbGVjdG9yIGxleGljYWwgdG9rZW4gdG8gYSBzZWxlY3RvciBBU1Qgbm9kZS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIHNlbGVjdG9yIGxleGljYWwgdG9rZW5cclxuICogQHJldHVybnMge09iamVjdH0gc2VsZWN0b3Igbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VTZWxlY3Rvcih0b2tlbikge1xyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhc3ROb2RlKHRva2VuLCB7XHJcbiAgICB0eXBlOiAncnVsZScsXHJcbiAgICBzZWxlY3RvcnM6IHRva2VuLnRleHQuc3BsaXQoJywnKS5tYXAodHJpbSksXHJcbiAgICBkZWNsYXJhdGlvbnM6IHBhcnNlRGVjbGFyYXRpb25zKHRva2VuKVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIGxleGljYWwgdG9rZW4gdG8gYW4gQVNUIG5vZGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSBBU1Qgbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUb2tlbih0b2tlbikge1xyXG4gIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG4gIC8vIENhc2VzIGFyZSBsaXN0ZWQgaW4gcm91Z2hseSBkZXNjZW5kaW5nIG9yZGVyIG9mIHByb2JhYmlsaXR5LlxyXG4gIGNhc2UgJ3Byb3BlcnR5JzogcmV0dXJuIHBhcnNlUHJvcGVydHkodG9rZW4pO1xyXG5cclxuICBjYXNlICdzZWxlY3Rvcic6IHJldHVybiBwYXJzZVNlbGVjdG9yKHRva2VuKTtcclxuXHJcbiAgY2FzZSAnYXQtZ3JvdXAtZW5kJzogX2RlcHRoID0gX2RlcHRoIC0gMTsgcmV0dXJuO1xyXG5cclxuICBjYXNlICdtZWRpYScgICAgIDpcclxuICBjYXNlICdrZXlmcmFtZXMnIDpyZXR1cm4gcGFyc2VBdEdyb3VwKHRva2VuKTtcclxuXHJcbiAgY2FzZSAnY29tbWVudCc6IGlmIChfY29tbWVudHMpIHsgcmV0dXJuIHBhcnNlQ29tbWVudCh0b2tlbik7IH0gYnJlYWs7XHJcblxyXG4gIGNhc2UgJ2NoYXJzZXQnOiByZXR1cm4gcGFyc2VDaGFyc2V0KHRva2VuKTtcclxuICBjYXNlICdpbXBvcnQnOiByZXR1cm4gcGFyc2VBdEltcG9ydCh0b2tlbik7XHJcblxyXG4gIGNhc2UgJ25hbWVzcGFjZSc6IHJldHVybiBwYXJzZU5hbWVzcGFjZSh0b2tlbik7XHJcblxyXG4gIGNhc2UgJ2ZvbnQtZmFjZSc6XHJcbiAgY2FzZSAnc3VwcG9ydHMnIDpcclxuICBjYXNlICd2aWV3cG9ydCcgOlxyXG4gIGNhc2UgJ2RvY3VtZW50JyA6XHJcbiAgY2FzZSAncGFnZScgICAgIDogcmV0dXJuIHBhcnNlQXRHcm91cCh0b2tlbik7XHJcbiAgfVxyXG5cclxuICBERUJVRyAmJiBkZWJ1ZygncGFyc2VUb2tlbjogdW5leHBlY3RlZCB0b2tlbjonLCBKU09OLnN0cmluZ2lmeSh0b2tlbikpO1xyXG59XHJcblxyXG4vLyAtLSBQYXJzZSBIZWxwZXIgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIEl0ZXJhdGl2ZWx5IHBhcnNlcyBsZXhpY2FsIHRva2VucyBmcm9tIHRoZSBzdGFjayBpbnRvIEFTVCBub2RlcyB1bnRpbCBhXHJcbiAqIGNvbmRpdGlvbmFsIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgYXQgd2hpY2ggcG9pbnQgaXRlcmF0aW9uIHRlcm1pbmF0ZXNcclxuICogYW5kIGFueSBBU1Qgbm9kZXMgY29sbGVjdGVkIGFyZSByZXR1cm5lZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uRm5cclxuICogICBAcGFyYW0ge09iamVjdH0gdG9rZW4gdGhlIGxleGljYWwgdG9rZW4gYmVpbmcgcGFyc2VkXHJcbiAqICAgQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdG9rZW4gc2hvdWxkIGJlIHBhcnNlZCwgYGZhbHNlYCBvdGhlcndpc2VcclxuICogQHJldHVybiB7QXJyYXl9IEFTVCBub2Rlc1xyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUb2tlbnNXaGlsZShjb25kaXRpb25Gbikge1xyXG4gIHZhciBub2RlO1xyXG4gIHZhciBub2RlcyA9IFtdO1xyXG4gIHZhciB0b2tlbjtcclxuXHJcbiAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgJiYgKGNvbmRpdGlvbkZuICYmIGNvbmRpdGlvbkZuKHRva2VuKSkpIHtcclxuICAgIG5vZGUgPSBwYXJzZVRva2VuKHRva2VuKTtcclxuICAgIG5vZGUgJiYgbm9kZXMucHVzaChub2RlKTtcclxuICB9XHJcblxyXG4gIC8vIFBsYWNlIGFuIHVudXNlZCBub24tYGVuZGAgbGV4aWNhbCB0b2tlbiBiYWNrIG9udG8gdGhlIHN0YWNrLlxyXG4gIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlICE9PSAnZW5kJykge1xyXG4gICAgX3Rva2Vucy51bnNoaWZ0KHRva2VuKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBub2RlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBzZXJpZXMgb2YgdG9rZW5zIGludG8gYSBzZXF1ZW5jZSBvZiBkZWNsYXJhdGlvbiBBU1Qgbm9kZXMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gZGVjbGFyYXRpb24gbm9kZXNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlRGVjbGFyYXRpb25zKCkge1xyXG4gIHJldHVybiBwYXJzZVRva2Vuc1doaWxlKGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgcmV0dXJuICh0b2tlbi50eXBlID09PSAncHJvcGVydHknIHx8IHRva2VuLnR5cGUgPT09ICdjb21tZW50Jyk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgc2VyaWVzIG9mIHRva2VucyBpbnRvIGEgc2VxdWVuY2Ugb2YgcnVsZSBub2Rlcy5cclxuICpcclxuICogQHJldHVybnMge0FycmF5fSBydWxlIG5vZGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVJ1bGVzKCkge1xyXG4gIHJldHVybiBwYXJzZVRva2Vuc1doaWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9kZXB0aDsgfSk7XHJcbn1cclxuIiwidmFyIERFQlVHID0gZmFsc2U7IC8vIGB0cnVlYCB0byBwcmludCBkZWJ1Z2dpbmcgaW5mby5cclxudmFyIFRJTUVSID0gZmFsc2U7IC8vIGB0cnVlYCB0byB0aW1lIGNhbGxzIHRvIGBzdHJpbmdpZnkoKWAgYW5kIHByaW50IHRoZSByZXN1bHRzLlxyXG5cclxudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpKCdzdHJpbmdpZnknKTtcclxuXHJcbnZhciBfY29tbWVudHM7ICAgICAgLy8gV2hldGhlciBjb21tZW50cyBhcmUgYWxsb3dlZCBpbiB0aGUgc3RyaW5naWZpZWQgQ1NTLlxyXG52YXIgX2NvbXByZXNzOyAgICAgIC8vIFdoZXRoZXIgdGhlIHN0cmluZ2lmaWVkIENTUyBzaG91bGQgYmUgY29tcHJlc3NlZC5cclxudmFyIF9pbmRlbnRhdGlvbjsgICAvLyBJbmRlbnRhdGlvbiBvcHRpb24gdmFsdWUuXHJcbnZhciBfbjsgICAgICAgICAgICAgLy8gQ29tcHJlc3Npb24tYXdhcmUgbmV3bGluZSBjaGFyYWN0ZXIuXHJcbnZhciBfczsgICAgICAgICAgICAgLy8gQ29tcHJlc3Npb24tYXdhcmUgc3BhY2UgY2hhcmFjdGVyLlxyXG5cclxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBgc3RyaW5naWZ5YC1hYmxlIEFTVCBpbnRvIGEgQ1NTIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGBzdHJpbmdpZnlgLWFibGUgQVNUXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21tZW50cz1mYWxzZV0gYWxsb3cgY29tbWVudHMgaW4gdGhlIENTU1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBjb21wcmVzcyB3aGl0ZXNwYWNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbmRlbnRhdGlvbj0nJ10gaW5kZW50YXRpb24gc2VxdWVuY2VcclxuICogQHJldHVybnMge1N0cmluZ30gQ1NTXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXN0LCBvcHRpb25zKSB7XHJcbiAgdmFyIHN0YXJ0OyAvLyBEZWJ1ZyB0aW1lciBzdGFydC5cclxuXHJcbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcclxuICBfaW5kZW50YXRpb24gPSBvcHRpb25zLmluZGVudGF0aW9uIHx8ICcnO1xyXG4gIF9jb21wcmVzcyA9ICEhb3B0aW9ucy5jb21wcmVzcztcclxuICBfY29tbWVudHMgPSAhIW9wdGlvbnMuY29tbWVudHM7XHJcblxyXG4gIGlmIChfY29tcHJlc3MpIHtcclxuICAgIF9uID0gX3MgPSAnJztcclxuICB9IGVsc2Uge1xyXG4gICAgX24gPSAnXFxuJztcclxuICAgIF9zID0gJyAnO1xyXG4gIH1cclxuXHJcbiAgVElNRVIgJiYgKHN0YXJ0ID0gRGF0ZS5ub3coKSk7XHJcblxyXG4gIHZhciBjc3MgPSByZWR1Y2UoYXN0LnN0eWxlc2hlZXQucnVsZXMsIHN0cmluZ2lmeU5vZGUpLmpvaW4oJ1xcbicpLnRyaW0oKTtcclxuXHJcbiAgVElNRVIgJiYgZGVidWcoJ3JhbiBpbicsIChEYXRlLm5vdygpIC0gc3RhcnQpICsgJ21zJyk7XHJcblxyXG4gIHJldHVybiBjc3M7XHJcbn1cclxuXHJcbi8vIC0tIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIE1vZGlmeSB0aGUgaW5kZW50YXRpb24gbGV2ZWwsIG9yIHJldHVybiBhIGNvbXByZXNzaW9uLWF3YXJlIHNlcXVlbmNlIG9mXHJcbiAqIHNwYWNlcyBlcXVhbCB0byB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbD11bmRlZmluZWRdIGluZGVudGF0aW9uIGxldmVsIG1vZGlmaWVyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHNlcXVlbmNlIG9mIHNwYWNlc1xyXG4gKi9cclxuZnVuY3Rpb24gaW5kZW50KGxldmVsKSB7XHJcbiAgdGhpcy5sZXZlbCB8fCAodGhpcy5sZXZlbCA9IDEpO1xyXG5cclxuICBpZiAobGV2ZWwpIHtcclxuICAgIHRoaXMubGV2ZWwgKz0gbGV2ZWw7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoX2NvbXByZXNzKSB7IHJldHVybiAnJzsgfVxyXG5cclxuICByZXR1cm4gQXJyYXkodGhpcy5sZXZlbCkuam9pbihfaW5kZW50YXRpb24gfHwgJycpO1xyXG59XHJcblxyXG4vLyAtLSBTdHJpbmdpZnkgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIFN0cmluZ2lmeSBhbiBALXJ1bGUgQVNUIG5vZGUuXHJcbiAqXHJcbiAqIFVzZSBgc3RyaW5naWZ5QXRHcm91cCgpYCB3aGVuIGRlYWxpbmcgd2l0aCBALWdyb3VwcyB0aGF0IG1heSBjb250YWluIGJsb2Nrc1xyXG4gKiBzdWNoIGFzIEBtZWRpYS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQC1ydWxlIHR5cGUuIEUuZy4sIGltcG9ydCwgY2hhcnNldFxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmdpZmllZCBALXJ1bGVcclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUF0UnVsZShub2RlKSB7XHJcbiAgcmV0dXJuICdAJyArIG5vZGUudHlwZSArICcgJyArIG5vZGUudmFsdWUgKyAnOycgKyBfbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0cmluZ2lmeSBhbiBALWdyb3VwIEFTVCBub2RlLlxyXG4gKlxyXG4gKiBVc2UgYHN0cmluZ2lmeUF0UnVsZSgpYCB3aGVuIGRlYWxpbmcgd2l0aCBALXJ1bGVzIHRoYXQgbWF5IG5vdCBjb250YWluIGJsb2Nrc1xyXG4gKiBzdWNoIGFzIEBpbXBvcnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIEAtZ3JvdXAgQVNUIG5vZGVcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUF0R3JvdXAobm9kZSkge1xyXG4gIHZhciBsYWJlbCA9ICcnO1xyXG4gIHZhciBwcmVmaXggPSBub2RlLnByZWZpeCB8fCAnJztcclxuXHJcbiAgaWYgKG5vZGUubmFtZSkge1xyXG4gICAgbGFiZWwgPSAnICcgKyBub2RlLm5hbWU7XHJcbiAgfVxyXG5cclxuICAvLyBGSVhNRTogQC1ydWxlIGNvbmRpdGlvbmFsIGxvZ2ljIGlzIGxlYWtpbmcgZXZlcnl3aGVyZS5cclxuICB2YXIgY2hvbXAgPSBub2RlLnR5cGUgIT09ICdwYWdlJztcclxuXHJcbiAgcmV0dXJuICdAJyArIHByZWZpeCArIG5vZGUudHlwZSArIGxhYmVsICsgX3MgKyBzdHJpbmdpZnlCbG9jayhub2RlLCBjaG9tcCkgKyBfbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0cmluZ2lmeSBhIGNvbW1lbnQgQVNUIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGNvbW1lbnQgQVNUIG5vZGVcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnQobm9kZSkge1xyXG4gIGlmICghX2NvbW1lbnRzKSB7IHJldHVybiAnJzsgfVxyXG5cclxuICByZXR1cm4gJy8qJyArIChub2RlLnRleHQgfHwgJycpICsgJyovJyArIF9uO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaW5naWZ5IGEgcnVsZSBBU1Qgbm9kZS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgcnVsZSBBU1Qgbm9kZVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShub2RlKSB7XHJcbiAgdmFyIGxhYmVsO1xyXG5cclxuICBpZiAobm9kZS5zZWxlY3RvcnMpIHtcclxuICAgIGxhYmVsID0gbm9kZS5zZWxlY3RvcnMuam9pbignLCcgKyBfbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGxhYmVsID0gJ0AnICsgbm9kZS50eXBlO1xyXG4gICAgbGFiZWwgKz0gbm9kZS5uYW1lID8gJyAnICsgbm9kZS5uYW1lIDogJyc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5kZW50KCkgKyBsYWJlbCArIF9zICsgc3RyaW5naWZ5QmxvY2sobm9kZSkgKyBfbjtcclxufVxyXG5cclxuXHJcbi8vIC0tIFN0cmluZ2lmeSBIZWxwZXIgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogUmVkdWNlIGFuIGFycmF5IGJ5IGFwcGx5aW5nIGEgZnVuY3Rpb24gdG8gZWFjaCBpdGVtIGFuZCByZXRhaW5pbmcgdGhlIHRydXRoeVxyXG4gKiByZXN1bHRzLlxyXG4gKlxyXG4gKiBXaGVuIGBpdGVtLnR5cGVgIGlzIGAnY29tbWVudCdgIGBzdHJpbmdpZnlDb21tZW50YCB3aWxsIGJlIGFwcGxpZWQgaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gaXRlbXMgYXJyYXkgdG8gcmVkdWNlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXlcclxuICogICBAcmV0dXJucyB7TWl4ZWR9IFRydXRoeSB2YWx1ZXMgd2lsbCBiZSByZXRhaW5lZCwgZmFsc3kgdmFsdWVzIG9taXR0ZWRcclxuICogQHJldHVybnMge0FycmF5fSByZXRhaW5lZCByZXN1bHRzXHJcbiAqL1xyXG5mdW5jdGlvbiByZWR1Y2UoaXRlbXMsIGZuKSB7XHJcbiAgcmV0dXJuIGl0ZW1zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0cywgaXRlbSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IChpdGVtLnR5cGUgPT09ICdjb21tZW50JykgPyBzdHJpbmdpZnlDb21tZW50KGl0ZW0pIDogZm4oaXRlbSk7XHJcbiAgICByZXN1bHQgJiYgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9LCBbXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdHJpbmdpZnkgYW4gQVNUIG5vZGUgd2l0aCB0aGUgYXNzdW1wdGlvbiB0aGF0IGl0IHJlcHJlc2VudHMgYSBibG9jayBvZlxyXG4gKiBkZWNsYXJhdGlvbnMgb3Igb3RoZXIgQC1ncm91cCBjb250ZW50cy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQVNUIG5vZGVcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbi8vIEZJWE1FOiBjaG9tcCBzaG91bGQgbm90IGJlIGEgbWFnaWMgYm9vbGVhbiBwYXJhbWV0ZXJcclxuZnVuY3Rpb24gc3RyaW5naWZ5QmxvY2sobm9kZSwgY2hvbXApIHtcclxuICB2YXIgY2hpbGRyZW4gPSBub2RlLmRlY2xhcmF0aW9ucztcclxuICB2YXIgZm4gPSBzdHJpbmdpZnlEZWNsYXJhdGlvbjtcclxuXHJcbiAgaWYgKG5vZGUucnVsZXMpIHtcclxuICAgIGNoaWxkcmVuID0gbm9kZS5ydWxlcztcclxuICAgIGZuID0gc3RyaW5naWZ5UnVsZTtcclxuICB9XHJcblxyXG4gIGNoaWxkcmVuID0gc3RyaW5naWZ5Q2hpbGRyZW4oY2hpbGRyZW4sIGZuKTtcclxuICBjaGlsZHJlbiAmJiAoY2hpbGRyZW4gPSBfbiArIGNoaWxkcmVuICsgKGNob21wID8gJycgOiBfbikpO1xyXG5cclxuICByZXR1cm4gJ3snICsgY2hpbGRyZW4gKyBpbmRlbnQoKSArICd9JztcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0cmluZ2lmeSBhbiBhcnJheSBvZiBjaGlsZCBBU1Qgbm9kZXMgYnkgY2FsbGluZyB0aGUgZ2l2ZW4gc3RyaW5naWZ5IGZ1bmN0aW9uXHJcbiAqIG9uY2UgZm9yIGVhY2ggY2hpbGQsIGFuZCBjb25jYXRlbmF0aW5nIHRoZSByZXN1bHRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBjaGlsZHJlbiBgbm9kZS5ydWxlc2Agb3IgYG5vZGUuZGVjbGFyYXRpb25zYFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBzdHJpbmdpZnkgZnVuY3Rpb25cclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUNoaWxkcmVuKGNoaWxkcmVuLCBmbikge1xyXG4gIGlmICghY2hpbGRyZW4pIHsgcmV0dXJuICcnOyB9XHJcblxyXG4gIGluZGVudCgxKTtcclxuICB2YXIgcmVzdWx0cyA9IHJlZHVjZShjaGlsZHJlbiwgZm4pO1xyXG4gIGluZGVudCgtMSk7XHJcblxyXG4gIGlmICghcmVzdWx0cy5sZW5ndGgpIHsgcmV0dXJuICcnOyB9XHJcblxyXG4gIHJldHVybiByZXN1bHRzLmpvaW4oX24pO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaW5naWZ5IGEgZGVjbGFyYXRpb24gQVNUIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGRlY2xhcmF0aW9uIEFTVCBub2RlXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlEZWNsYXJhdGlvbihub2RlKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xyXG4gICAgcmV0dXJuIHN0cmluZ2lmeVByb3BlcnR5KG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgREVCVUcgJiYgZGVidWcoJ3N0cmluZ2lmeURlY2xhcmF0aW9uOiB1bmV4cGVjdGVkIG5vZGU6JywgSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaW5naWZ5IGFuIEFTVCBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBBU1Qgbm9kZVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5Tm9kZShub2RlKSB7XHJcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAvLyBDYXNlcyBhcmUgbGlzdGVkIGluIHJvdWdobHkgZGVzY2VuZGluZyBvcmRlciBvZiBwcm9iYWJpbGl0eS5cclxuICBjYXNlICdydWxlJzogcmV0dXJuIHN0cmluZ2lmeVJ1bGUobm9kZSk7XHJcblxyXG4gIGNhc2UgJ21lZGlhJyAgICA6XHJcbiAgY2FzZSAna2V5ZnJhbWVzJzogcmV0dXJuIHN0cmluZ2lmeUF0R3JvdXAobm9kZSk7XHJcblxyXG4gIGNhc2UgJ2NvbW1lbnQnOiByZXR1cm4gc3RyaW5naWZ5Q29tbWVudChub2RlKTtcclxuXHJcbiAgY2FzZSAnaW1wb3J0JyAgIDpcclxuICBjYXNlICdjaGFyc2V0JyAgOlxyXG4gIGNhc2UgJ25hbWVzcGFjZSc6IHJldHVybiBzdHJpbmdpZnlBdFJ1bGUobm9kZSk7XHJcblxyXG4gIGNhc2UgJ2ZvbnQtZmFjZSc6XHJcbiAgY2FzZSAnc3VwcG9ydHMnIDpcclxuICBjYXNlICd2aWV3cG9ydCcgOlxyXG4gIGNhc2UgJ2RvY3VtZW50JyA6XHJcbiAgY2FzZSAncGFnZScgICAgIDogcmV0dXJuIHN0cmluZ2lmeUF0R3JvdXAobm9kZSk7XHJcbiAgfVxyXG5cclxuICBERUJVRyAmJiBkZWJ1Zygnc3RyaW5naWZ5Tm9kZTogdW5leHBlY3RlZCBub2RlOiAnICsgSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaW5naWZ5IGFuIEFTVCBwcm9wZXJ0eSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBBU1QgcHJvcGVydHkgbm9kZVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcGVydHkobm9kZSkge1xyXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lICsgJzonICsgX3MgOiAnJztcclxuXHJcbiAgcmV0dXJuIGluZGVudCgpICsgbmFtZSArIG5vZGUudmFsdWUgKyAnOyc7XHJcbn1cclxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvKlxyXG5TbGljayBQYXJzZXJcclxuIC0gb3JpZ2luYWxseSBjcmVhdGVkIGJ5IHRoZSBhbG1pZ2h0eSBUaG9tYXMgQXlsb3R0IDxAc3VidGxlZ3JhZGllbnQ+IChodHRwOi8vc3VidGxlZ3JhZGllbnQuY29tKVxyXG4qL1widXNlIHN0cmljdFwiXHJcblxyXG4vLyBOb3RhYmxlIGNoYW5nZXMgZnJvbSBTbGljay5QYXJzZXIgMS4wLnhcclxuXHJcbi8vIFRoZSBwYXJzZXIgbm93IHVzZXMgMiBjbGFzc2VzOiBFeHByZXNzaW9ucyBhbmQgRXhwcmVzc2lvblxyXG4vLyBgbmV3IEV4cHJlc3Npb25zYCBwcm9kdWNlcyBhbiBhcnJheS1saWtlIG9iamVjdCBjb250YWluaW5nIGEgbGlzdCBvZiBFeHByZXNzaW9uIG9iamVjdHNcclxuLy8gLSBFeHByZXNzaW9uczo6dG9TdHJpbmcoKSBwcm9kdWNlcyBhIGNsZWFuZWQgdXAgZXhwcmVzc2lvbnMgc3RyaW5nXHJcbi8vIGBuZXcgRXhwcmVzc2lvbmAgcHJvZHVjZXMgYW4gYXJyYXktbGlrZSBvYmplY3RcclxuLy8gLSBFeHByZXNzaW9uOjp0b1N0cmluZygpIHByb2R1Y2VzIGEgY2xlYW5lZCB1cCBleHByZXNzaW9uIHN0cmluZ1xyXG4vLyBUaGUgb25seSBleHBvc2VkIG1ldGhvZCBpcyBwYXJzZSwgd2hpY2ggcHJvZHVjZXMgYSAoY2FjaGVkKSBgbmV3IEV4cHJlc3Npb25zYCBpbnN0YW5jZVxyXG4vLyBwYXJzZWQucmF3IGlzIG5vIGxvbmdlciBwcmVzZW50LCB1c2UgLnRvU3RyaW5nKClcclxuLy8gcGFyc2VkLmV4cHJlc3Npb24gaXMgbm93IHVzZWxlc3MsIGp1c3QgdXNlIHRoZSBpbmRpY2VzXHJcbi8vIHBhcnNlZC5yZXZlcnNlKCkgaGFzIGJlZW4gcmVtb3ZlZCBmb3Igbm93LCBkdWUgdG8gaXRzIGFwcGFyZW50IHVzZWxlc3NuZXNzXHJcbi8vIE90aGVyIGNoYW5nZXMgaW4gdGhlIEV4cHJlc3Npb25zIG9iamVjdDpcclxuLy8gLSBjbGFzc05hbWVzIGFyZSBub3cgdW5pcXVlLCBhbmQgc2F2ZSBib3RoIGVzY2FwZWQgYW5kIHVuZXNjYXBlZCB2YWx1ZXNcclxuLy8gLSBhdHRyaWJ1dGVzIG5vdyBzYXZlIGJvdGggZXNjYXBlZCBhbmQgdW5lc2NhcGVkIHZhbHVlc1xyXG4vLyAtIHBzZXVkb3Mgbm93IHNhdmUgYm90aCBlc2NhcGVkIGFuZCB1bmVzY2FwZWQgdmFsdWVzXHJcblxyXG52YXIgZXNjYXBlUmUgICA9IC8oWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXSkvZyxcclxuICAgIHVuZXNjYXBlUmUgPSAvXFxcXC9nXHJcblxyXG52YXIgZXNjYXBlID0gZnVuY3Rpb24oc3RyaW5nKXtcclxuICAgIC8vIFhSZWdFeHAgdjIuMC4wLWJldGEtM1xyXG4gICAgLy8gwqsgaHR0cHM6Ly9naXRodWIuY29tL3NsZXZpdGhhbi9YUmVnRXhwL2Jsb2IvbWFzdGVyL3NyYy94cmVnZXhwLmpzXHJcbiAgICByZXR1cm4gKHN0cmluZyArIFwiXCIpLnJlcGxhY2UoZXNjYXBlUmUsICdcXFxcJDEnKVxyXG59XHJcblxyXG52YXIgdW5lc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpe1xyXG4gICAgcmV0dXJuIChzdHJpbmcgKyBcIlwiKS5yZXBsYWNlKHVuZXNjYXBlUmUsICcnKVxyXG59XHJcblxyXG52YXIgc2xpY2tSZSA9IFJlZ0V4cChcclxuLypcclxuIyEvdXNyL2Jpbi9lbnYgcnVieVxyXG5wdXRzIFwiXFx0XFx0XCIgKyBEQVRBLnJlYWQuZ3N1YigvXFwoXFw/eFxcKXxcXHMrIy4qJHxcXHMrfFxcXFwkfFxcXFxuLywnJylcclxuX19FTkRfX1xyXG4gICAgXCIoP3gpXig/OlxcXHJcbiAgICAgIFxcXFxzKiAoICwgKSBcXFxccyogICAgICAgICAgICAgICAjIFNlcGFyYXRvciAgICAgICAgICBcXG5cXFxyXG4gICAgfCBcXFxccyogKCA8Y29tYmluYXRvcj4rICkgXFxcXHMqICAgIyBDb21iaW5hdG9yICAgICAgICAgXFxuXFxcclxuICAgIHwgICAgICAoIFxcXFxzKyApICAgICAgICAgICAgICAgICAjIENvbWJpbmF0b3JDaGlsZHJlbiBcXG5cXFxyXG4gICAgfCAgICAgICggPHVuaWNvZGU+KyB8IFxcXFwqICkgICAgICMgVGFnICAgICAgICAgICAgICAgIFxcblxcXHJcbiAgICB8IFxcXFwjICAoIDx1bmljb2RlPisgICAgICAgKSAgICAgIyBJRCAgICAgICAgICAgICAgICAgXFxuXFxcclxuICAgIHwgXFxcXC4gICggPHVuaWNvZGU+KyAgICAgICApICAgICAjIENsYXNzTmFtZSAgICAgICAgICBcXG5cXFxyXG4gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEF0dHJpYnV0ZSAgICAgICAgICBcXG5cXFxyXG4gICAgXFxcXFsgIFxcXHJcbiAgICAgICAgXFxcXHMqICg8dW5pY29kZTE+KykgICg/OiAgXFxcclxuICAgICAgICAgICAgXFxcXHMqIChbKl4kIX58XT89KSAgKD86ICBcXFxyXG4gICAgICAgICAgICAgICAgXFxcXHMqICg/OlxcXHJcbiAgICAgICAgICAgICAgICAgICAgKFtcXFwiJ10/KSguKj8pXFxcXDkgXFxcclxuICAgICAgICAgICAgICAgIClcXFxyXG4gICAgICAgICAgICApICBcXFxyXG4gICAgICAgICk/ICBcXFxccyogIFxcXHJcbiAgICBcXFxcXSg/IVxcXFxdKSBcXG5cXFxyXG4gICAgfCAgIDorICggPHVuaWNvZGU+KyApKD86XFxcclxuICAgIFxcXFwoICg/OlxcXHJcbiAgICAgICAgKD86KFtcXFwiJ10pKFteXFxcXDEyXSopXFxcXDEyKXwoKD86XFxcXChbXildK1xcXFwpfFteKCldKikrKVxcXHJcbiAgICApIFxcXFwpXFxcclxuICAgICk/XFxcclxuICAgIClcIlxyXG4qL1xyXG5cIl4oPzpcXFxccyooLClcXFxccyp8XFxcXHMqKDxjb21iaW5hdG9yPispXFxcXHMqfChcXFxccyspfCg8dW5pY29kZT4rfFxcXFwqKXxcXFxcIyg8dW5pY29kZT4rKXxcXFxcLig8dW5pY29kZT4rKXxcXFxcW1xcXFxzKig8dW5pY29kZTE+KykoPzpcXFxccyooWypeJCF+fF0/PSkoPzpcXFxccyooPzooW1xcXCInXT8pKC4qPylcXFxcOSkpKT9cXFxccypcXFxcXSg/IVxcXFxdKXwoOispKDx1bmljb2RlPispKD86XFxcXCgoPzooPzooW1xcXCInXSkoW15cXFxcMTNdKilcXFxcMTMpfCgoPzpcXFxcKFteKV0rXFxcXCl8W14oKV0qKSspKVxcXFwpKT8pXCJcclxuICAgIC5yZXBsYWNlKC88Y29tYmluYXRvcj4vLCAnWycgKyBlc2NhcGUoXCI+K35gIUAkJV4mPXt9XFxcXDs8L1wiKSArICddJylcclxuICAgIC5yZXBsYWNlKC88dW5pY29kZT4vZywgJyg/OltcXFxcd1xcXFx1MDBhMS1cXFxcdUZGRkYtXXxcXFxcXFxcXFteXFxcXHMwLTlhLWZdKScpXHJcbiAgICAucmVwbGFjZSgvPHVuaWNvZGUxPi9nLCAnKD86WzpcXFxcd1xcXFx1MDBhMS1cXFxcdUZGRkYtXXxcXFxcXFxcXFteXFxcXHMwLTlhLWZdKScpXHJcbilcclxuXHJcbi8vIFBhcnRcclxuXHJcbnZhciBQYXJ0ID0gZnVuY3Rpb24gUGFydChjb21iaW5hdG9yKXtcclxuICAgIHRoaXMuY29tYmluYXRvciA9IGNvbWJpbmF0b3IgfHwgXCIgXCJcclxuICAgIHRoaXMudGFnID0gXCIqXCJcclxufVxyXG5cclxuUGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xyXG5cclxuICAgIGlmICghdGhpcy5yYXcpe1xyXG5cclxuICAgICAgICB2YXIgeHByID0gXCJcIiwgaywgcGFydFxyXG5cclxuICAgICAgICB4cHIgKz0gdGhpcy50YWcgfHwgXCIqXCJcclxuICAgICAgICBpZiAodGhpcy5pZCkgeHByICs9IFwiI1wiICsgdGhpcy5pZFxyXG4gICAgICAgIGlmICh0aGlzLmNsYXNzZXMpIHhwciArPSBcIi5cIiArIHRoaXMuY2xhc3NMaXN0LmpvaW4oXCIuXCIpXHJcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcykgZm9yIChrID0gMDsgcGFydCA9IHRoaXMuYXR0cmlidXRlc1trKytdOyl7XHJcbiAgICAgICAgICAgIHhwciArPSBcIltcIiArIHBhcnQubmFtZSArIChwYXJ0Lm9wZXJhdG9yID8gcGFydC5vcGVyYXRvciArICdcIicgKyBwYXJ0LnZhbHVlICsgJ1wiJyA6ICcnKSArIFwiXVwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBzZXVkb3MpIGZvciAoayA9IDA7IHBhcnQgPSB0aGlzLnBzZXVkb3NbaysrXTspe1xyXG4gICAgICAgICAgICB4cHIgKz0gXCI6XCIgKyBwYXJ0Lm5hbWVcclxuICAgICAgICAgICAgaWYgKHBhcnQudmFsdWUpIHhwciArPSBcIihcIiArIHBhcnQudmFsdWUgKyBcIilcIlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yYXcgPSB4cHJcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmF3XHJcbn1cclxuXHJcbi8vIEV4cHJlc3Npb25cclxuXHJcbnZhciBFeHByZXNzaW9uID0gZnVuY3Rpb24gRXhwcmVzc2lvbigpe1xyXG4gICAgdGhpcy5sZW5ndGggPSAwXHJcbn1cclxuXHJcbkV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcclxuXHJcbiAgICBpZiAoIXRoaXMucmF3KXtcclxuXHJcbiAgICAgICAgdmFyIHhwciA9IFwiXCJcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGJpdDsgYml0ID0gdGhpc1tqKytdOyl7XHJcbiAgICAgICAgICAgIGlmIChqICE9PSAxKSB4cHIgKz0gXCIgXCJcclxuICAgICAgICAgICAgaWYgKGJpdC5jb21iaW5hdG9yICE9PSBcIiBcIikgeHByICs9IGJpdC5jb21iaW5hdG9yICsgXCIgXCJcclxuICAgICAgICAgICAgeHByICs9IGJpdFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yYXcgPSB4cHJcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmF3XHJcbn1cclxuXHJcbnZhciByZXBsYWNlciA9IGZ1bmN0aW9uKFxyXG4gICAgcmF3TWF0Y2gsXHJcblxyXG4gICAgc2VwYXJhdG9yLFxyXG4gICAgY29tYmluYXRvcixcclxuICAgIGNvbWJpbmF0b3JDaGlsZHJlbixcclxuXHJcbiAgICB0YWdOYW1lLFxyXG4gICAgaWQsXHJcbiAgICBjbGFzc05hbWUsXHJcblxyXG4gICAgYXR0cmlidXRlS2V5LFxyXG4gICAgYXR0cmlidXRlT3BlcmF0b3IsXHJcbiAgICBhdHRyaWJ1dGVRdW90ZSxcclxuICAgIGF0dHJpYnV0ZVZhbHVlLFxyXG5cclxuICAgIHBzZXVkb01hcmtlcixcclxuICAgIHBzZXVkb0NsYXNzLFxyXG4gICAgcHNldWRvUXVvdGUsXHJcbiAgICBwc2V1ZG9DbGFzc1F1b3RlZFZhbHVlLFxyXG4gICAgcHNldWRvQ2xhc3NWYWx1ZVxyXG4pe1xyXG5cclxuICAgIHZhciBleHByZXNzaW9uLCBjdXJyZW50XHJcblxyXG4gICAgaWYgKHNlcGFyYXRvciB8fCAhdGhpcy5sZW5ndGgpe1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSB0aGlzW3RoaXMubGVuZ3RoKytdID0gbmV3IEV4cHJlc3Npb25cclxuICAgICAgICBpZiAoc2VwYXJhdG9yKSByZXR1cm4gJydcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWV4cHJlc3Npb24pIGV4cHJlc3Npb24gPSB0aGlzW3RoaXMubGVuZ3RoIC0gMV1cclxuXHJcbiAgICBpZiAoY29tYmluYXRvciB8fCBjb21iaW5hdG9yQ2hpbGRyZW4gfHwgIWV4cHJlc3Npb24ubGVuZ3RoKXtcclxuICAgICAgICBjdXJyZW50ID0gZXhwcmVzc2lvbltleHByZXNzaW9uLmxlbmd0aCsrXSA9IG5ldyBQYXJ0KGNvbWJpbmF0b3IpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjdXJyZW50KSBjdXJyZW50ID0gZXhwcmVzc2lvbltleHByZXNzaW9uLmxlbmd0aCAtIDFdXHJcblxyXG4gICAgaWYgKHRhZ05hbWUpe1xyXG5cclxuICAgICAgICBjdXJyZW50LnRhZyA9IHVuZXNjYXBlKHRhZ05hbWUpXHJcblxyXG4gICAgfSBlbHNlIGlmIChpZCl7XHJcblxyXG4gICAgICAgIGN1cnJlbnQuaWQgPSB1bmVzY2FwZShpZClcclxuXHJcbiAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSl7XHJcblxyXG4gICAgICAgIHZhciB1bmVzY2FwZWQgPSB1bmVzY2FwZShjbGFzc05hbWUpXHJcblxyXG4gICAgICAgIHZhciBjbGFzc2VzID0gY3VycmVudC5jbGFzc2VzIHx8IChjdXJyZW50LmNsYXNzZXMgPSB7fSlcclxuICAgICAgICBpZiAoIWNsYXNzZXNbdW5lc2NhcGVkXSl7XHJcbiAgICAgICAgICAgIGNsYXNzZXNbdW5lc2NhcGVkXSA9IGVzY2FwZShjbGFzc05hbWUpXHJcbiAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSBjdXJyZW50LmNsYXNzTGlzdCB8fCAoY3VycmVudC5jbGFzc0xpc3QgPSBbXSlcclxuICAgICAgICAgICAgY2xhc3NMaXN0LnB1c2godW5lc2NhcGVkKVxyXG4gICAgICAgICAgICBjbGFzc0xpc3Quc29ydCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAocHNldWRvQ2xhc3Mpe1xyXG5cclxuICAgICAgICBwc2V1ZG9DbGFzc1ZhbHVlID0gcHNldWRvQ2xhc3NWYWx1ZSB8fCBwc2V1ZG9DbGFzc1F1b3RlZFZhbHVlXHJcblxyXG4gICAgICAgIDsoY3VycmVudC5wc2V1ZG9zIHx8IChjdXJyZW50LnBzZXVkb3MgPSBbXSkpLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlICAgICAgICAgOiBwc2V1ZG9NYXJrZXIubGVuZ3RoID09IDEgPyAnY2xhc3MnIDogJ2VsZW1lbnQnLFxyXG4gICAgICAgICAgICBuYW1lICAgICAgICAgOiB1bmVzY2FwZShwc2V1ZG9DbGFzcyksXHJcbiAgICAgICAgICAgIGVzY2FwZWROYW1lICA6IGVzY2FwZShwc2V1ZG9DbGFzcyksXHJcbiAgICAgICAgICAgIHZhbHVlICAgICAgICA6IHBzZXVkb0NsYXNzVmFsdWUgPyB1bmVzY2FwZShwc2V1ZG9DbGFzc1ZhbHVlKSA6IG51bGwsXHJcbiAgICAgICAgICAgIGVzY2FwZWRWYWx1ZSA6IHBzZXVkb0NsYXNzVmFsdWUgPyBlc2NhcGUocHNldWRvQ2xhc3NWYWx1ZSkgOiBudWxsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZUtleSl7XHJcblxyXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlVmFsdWUgPyBlc2NhcGUoYXR0cmlidXRlVmFsdWUpIDogbnVsbFxyXG5cclxuICAgICAgICA7KGN1cnJlbnQuYXR0cmlidXRlcyB8fCAoY3VycmVudC5hdHRyaWJ1dGVzID0gW10pKS5wdXNoKHtcclxuICAgICAgICAgICAgb3BlcmF0b3IgICAgIDogYXR0cmlidXRlT3BlcmF0b3IsXHJcbiAgICAgICAgICAgIG5hbWUgICAgICAgICA6IHVuZXNjYXBlKGF0dHJpYnV0ZUtleSksXHJcbiAgICAgICAgICAgIGVzY2FwZWROYW1lICA6IGVzY2FwZShhdHRyaWJ1dGVLZXkpLFxyXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgOiBhdHRyaWJ1dGVWYWx1ZSA/IHVuZXNjYXBlKGF0dHJpYnV0ZVZhbHVlKSA6IG51bGwsXHJcbiAgICAgICAgICAgIGVzY2FwZWRWYWx1ZSA6IGF0dHJpYnV0ZVZhbHVlID8gZXNjYXBlKGF0dHJpYnV0ZVZhbHVlKSA6IG51bGxcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJydcclxuXHJcbn1cclxuXHJcbi8vIEV4cHJlc3Npb25zXHJcblxyXG52YXIgRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiBFeHByZXNzaW9ucyhleHByZXNzaW9uKXtcclxuICAgIHRoaXMubGVuZ3RoID0gMFxyXG5cclxuICAgIHZhciBzZWxmID0gdGhpc1xyXG5cclxuICAgIHZhciBvcmlnaW5hbCA9IGV4cHJlc3Npb24sIHJlcGxhY2VkXHJcblxyXG4gICAgd2hpbGUgKGV4cHJlc3Npb24pe1xyXG4gICAgICAgIHJlcGxhY2VkID0gZXhwcmVzc2lvbi5yZXBsYWNlKHNsaWNrUmUsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlci5hcHBseShzZWxmLCBhcmd1bWVudHMpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZiAocmVwbGFjZWQgPT09IGV4cHJlc3Npb24pIHRocm93IG5ldyBFcnJvcihvcmlnaW5hbCArICcgaXMgYW4gaW52YWxpZCBleHByZXNzaW9uJylcclxuICAgICAgICBleHByZXNzaW9uID0gcmVwbGFjZWRcclxuICAgIH1cclxufVxyXG5cclxuRXhwcmVzc2lvbnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIGlmICghdGhpcy5yYXcpe1xyXG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGV4cHJlc3Npb247IGV4cHJlc3Npb24gPSB0aGlzW2krK107KSBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pXHJcbiAgICAgICAgdGhpcy5yYXcgPSBleHByZXNzaW9ucy5qb2luKFwiLCBcIilcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yYXdcclxufVxyXG5cclxudmFyIGNhY2hlID0ge31cclxuXHJcbnZhciBwYXJzZSA9IGZ1bmN0aW9uKGV4cHJlc3Npb24pe1xyXG4gICAgaWYgKGV4cHJlc3Npb24gPT0gbnVsbCkgcmV0dXJuIG51bGxcclxuICAgIGV4cHJlc3Npb24gPSAoJycgKyBleHByZXNzaW9uKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcclxuICAgIHJldHVybiBjYWNoZVtleHByZXNzaW9uXSB8fCAoY2FjaGVbZXhwcmVzc2lvbl0gPSBuZXcgRXhwcmVzc2lvbnMoZXhwcmVzc2lvbikpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9zcGVha2luZ3VybCcpO1xuIiwiKGZ1bmN0aW9uIChyb290KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogY2hhck1hcFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGNoYXJNYXAgPSB7XG5cbiAgICAgICAgLy8gbGF0aW5cbiAgICAgICAgJ8OAJzogJ0EnLFxuICAgICAgICAnw4EnOiAnQScsXG4gICAgICAgICfDgic6ICdBJyxcbiAgICAgICAgJ8ODJzogJ0EnLFxuICAgICAgICAnw4QnOiAnQWUnLFxuICAgICAgICAnw4UnOiAnQScsXG4gICAgICAgICfDhic6ICdBRScsXG4gICAgICAgICfDhyc6ICdDJyxcbiAgICAgICAgJ8OIJzogJ0UnLFxuICAgICAgICAnw4knOiAnRScsXG4gICAgICAgICfDiic6ICdFJyxcbiAgICAgICAgJ8OLJzogJ0UnLFxuICAgICAgICAnw4wnOiAnSScsXG4gICAgICAgICfDjSc6ICdJJyxcbiAgICAgICAgJ8OOJzogJ0knLFxuICAgICAgICAnw48nOiAnSScsXG4gICAgICAgICfDkCc6ICdEJyxcbiAgICAgICAgJ8ORJzogJ04nLFxuICAgICAgICAnw5InOiAnTycsXG4gICAgICAgICfDkyc6ICdPJyxcbiAgICAgICAgJ8OUJzogJ08nLFxuICAgICAgICAnw5UnOiAnTycsXG4gICAgICAgICfDlic6ICdPZScsXG4gICAgICAgICfFkCc6ICdPJyxcbiAgICAgICAgJ8OYJzogJ08nLFxuICAgICAgICAnw5knOiAnVScsXG4gICAgICAgICfDmic6ICdVJyxcbiAgICAgICAgJ8ObJzogJ1UnLFxuICAgICAgICAnw5wnOiAnVWUnLFxuICAgICAgICAnxbAnOiAnVScsXG4gICAgICAgICfDnSc6ICdZJyxcbiAgICAgICAgJ8OeJzogJ1RIJyxcbiAgICAgICAgJ8OfJzogJ3NzJyxcbiAgICAgICAgJ8OgJzogJ2EnLFxuICAgICAgICAnw6EnOiAnYScsXG4gICAgICAgICfDoic6ICdhJyxcbiAgICAgICAgJ8OjJzogJ2EnLFxuICAgICAgICAnw6QnOiAnYWUnLFxuICAgICAgICAnw6UnOiAnYScsXG4gICAgICAgICfDpic6ICdhZScsXG4gICAgICAgICfDpyc6ICdjJyxcbiAgICAgICAgJ8OoJzogJ2UnLFxuICAgICAgICAnw6knOiAnZScsXG4gICAgICAgICfDqic6ICdlJyxcbiAgICAgICAgJ8OrJzogJ2UnLFxuICAgICAgICAnw6wnOiAnaScsXG4gICAgICAgICfDrSc6ICdpJyxcbiAgICAgICAgJ8OuJzogJ2knLFxuICAgICAgICAnw68nOiAnaScsXG4gICAgICAgICfDsCc6ICdkJyxcbiAgICAgICAgJ8OxJzogJ24nLFxuICAgICAgICAnw7InOiAnbycsXG4gICAgICAgICfDsyc6ICdvJyxcbiAgICAgICAgJ8O0JzogJ28nLFxuICAgICAgICAnw7UnOiAnbycsXG4gICAgICAgICfDtic6ICdvZScsXG4gICAgICAgICfFkSc6ICdvJyxcbiAgICAgICAgJ8O4JzogJ28nLFxuICAgICAgICAnw7knOiAndScsXG4gICAgICAgICfDuic6ICd1JyxcbiAgICAgICAgJ8O7JzogJ3UnLFxuICAgICAgICAnw7wnOiAndWUnLFxuICAgICAgICAnxbEnOiAndScsXG4gICAgICAgICfDvSc6ICd5JyxcbiAgICAgICAgJ8O+JzogJ3RoJyxcbiAgICAgICAgJ8O/JzogJ3knLFxuICAgICAgICAn4bqeJzogJ1NTJyxcblxuICAgICAgICAvLyBsYW5ndWFnZSBzcGVjaWZpY1xuXG4gICAgICAgIC8vIEFyYWJpY1xuICAgICAgICAn2KcnOiAnYScsXG4gICAgICAgICfYoyc6ICdhJyxcbiAgICAgICAgJ9ilJzogJ2knLFxuICAgICAgICAn2KInOiAnYWEnLFxuICAgICAgICAn2KQnOiAndScsXG4gICAgICAgICfYpic6ICdlJyxcbiAgICAgICAgJ9ihJzogJ2EnLFxuICAgICAgICAn2KgnOiAnYicsXG4gICAgICAgICfYqic6ICd0JyxcbiAgICAgICAgJ9irJzogJ3RoJyxcbiAgICAgICAgJ9isJzogJ2onLFxuICAgICAgICAn2K0nOiAnaCcsXG4gICAgICAgICfYric6ICdraCcsXG4gICAgICAgICfYryc6ICdkJyxcbiAgICAgICAgJ9iwJzogJ3RoJyxcbiAgICAgICAgJ9ixJzogJ3InLFxuICAgICAgICAn2LInOiAneicsXG4gICAgICAgICfYsyc6ICdzJyxcbiAgICAgICAgJ9i0JzogJ3NoJyxcbiAgICAgICAgJ9i1JzogJ3MnLFxuICAgICAgICAn2LYnOiAnZGgnLFxuICAgICAgICAn2LcnOiAndCcsXG4gICAgICAgICfYuCc6ICd6JyxcbiAgICAgICAgJ9i5JzogJ2EnLFxuICAgICAgICAn2LonOiAnZ2gnLFxuICAgICAgICAn2YEnOiAnZicsXG4gICAgICAgICfZgic6ICdxJyxcbiAgICAgICAgJ9mDJzogJ2snLFxuICAgICAgICAn2YQnOiAnbCcsXG4gICAgICAgICfZhSc6ICdtJyxcbiAgICAgICAgJ9mGJzogJ24nLFxuICAgICAgICAn2YcnOiAnaCcsXG4gICAgICAgICfZiCc6ICd3JyxcbiAgICAgICAgJ9mKJzogJ3knLFxuICAgICAgICAn2YknOiAnYScsXG4gICAgICAgICfYqSc6ICdoJyxcbiAgICAgICAgJ++7uyc6ICdsYScsXG4gICAgICAgICfvu7cnOiAnbGFhJyxcbiAgICAgICAgJ++7uSc6ICdsYWknLFxuICAgICAgICAn77u1JzogJ2xhYScsXG5cbiAgICAgICAgLy8gUGVyc2lhbiBhZGRpdGlvbmFsIGNoYXJhY3RlcnMgdGhhbiBBcmFiaWNcbiAgICAgICAgJ9qvJzogJ2cnLFxuICAgICAgICAn2oYnOiAnY2gnLFxuICAgICAgICAn2b4nOiAncCcsXG4gICAgICAgICfamCc6ICd6aCcsXG4gICAgICAgICfaqSc6ICdrJyxcbiAgICAgICAgJ9uMJzogJ3knLFxuXG4gICAgICAgIC8vIEFyYWJpYyBkaWFjdHJpY3NcbiAgICAgICAgJ9mOJzogJ2EnLFxuICAgICAgICAn2YsnOiAnYW4nLFxuICAgICAgICAn2ZAnOiAnZScsXG4gICAgICAgICfZjSc6ICdlbicsXG4gICAgICAgICfZjyc6ICd1JyxcbiAgICAgICAgJ9mMJzogJ29uJyxcbiAgICAgICAgJ9mSJzogJycsXG5cbiAgICAgICAgLy8gQXJhYmljIG51bWJlcnNcbiAgICAgICAgJ9mgJzogJzAnLFxuICAgICAgICAn2aEnOiAnMScsXG4gICAgICAgICfZoic6ICcyJyxcbiAgICAgICAgJ9mjJzogJzMnLFxuICAgICAgICAn2aQnOiAnNCcsXG4gICAgICAgICfZpSc6ICc1JyxcbiAgICAgICAgJ9mmJzogJzYnLFxuICAgICAgICAn2acnOiAnNycsXG4gICAgICAgICfZqCc6ICc4JyxcbiAgICAgICAgJ9mpJzogJzknLFxuXG4gICAgICAgIC8vIFBlcnNpYW4gbnVtYmVyc1xuICAgICAgICAn27AnOiAnMCcsXG4gICAgICAgICfbsSc6ICcxJyxcbiAgICAgICAgJ9uyJzogJzInLFxuICAgICAgICAn27MnOiAnMycsXG4gICAgICAgICfbtCc6ICc0JyxcbiAgICAgICAgJ9u1JzogJzUnLFxuICAgICAgICAn27YnOiAnNicsXG4gICAgICAgICfbtyc6ICc3JyxcbiAgICAgICAgJ9u4JzogJzgnLFxuICAgICAgICAn27knOiAnOScsXG5cbiAgICAgICAgLy8gQnVybWVzZSBjb25zb25hbnRzXG4gICAgICAgICfhgIAnOiAnaycsXG4gICAgICAgICfhgIEnOiAna2gnLFxuICAgICAgICAn4YCCJzogJ2cnLFxuICAgICAgICAn4YCDJzogJ2dhJyxcbiAgICAgICAgJ+GAhCc6ICduZycsXG4gICAgICAgICfhgIUnOiAncycsXG4gICAgICAgICfhgIYnOiAnc2EnLFxuICAgICAgICAn4YCHJzogJ3onLFxuICAgICAgICAn4YCF4YC7JzogJ3phJyxcbiAgICAgICAgJ+GAiic6ICdueScsXG4gICAgICAgICfhgIsnOiAndCcsXG4gICAgICAgICfhgIwnOiAndGEnLFxuICAgICAgICAn4YCNJzogJ2QnLFxuICAgICAgICAn4YCOJzogJ2RhJyxcbiAgICAgICAgJ+GAjyc6ICduYScsXG4gICAgICAgICfhgJAnOiAndCcsXG4gICAgICAgICfhgJEnOiAndGEnLFxuICAgICAgICAn4YCSJzogJ2QnLFxuICAgICAgICAn4YCTJzogJ2RhJyxcbiAgICAgICAgJ+GAlCc6ICduJyxcbiAgICAgICAgJ+GAlSc6ICdwJyxcbiAgICAgICAgJ+GAlic6ICdwYScsXG4gICAgICAgICfhgJcnOiAnYicsXG4gICAgICAgICfhgJgnOiAnYmEnLFxuICAgICAgICAn4YCZJzogJ20nLFxuICAgICAgICAn4YCaJzogJ3knLFxuICAgICAgICAn4YCbJzogJ3lhJyxcbiAgICAgICAgJ+GAnCc6ICdsJyxcbiAgICAgICAgJ+GAnSc6ICd3JyxcbiAgICAgICAgJ+GAnic6ICd0aCcsXG4gICAgICAgICfhgJ8nOiAnaCcsXG4gICAgICAgICfhgKAnOiAnbGEnLFxuICAgICAgICAn4YChJzogJ2EnLFxuICAgICAgICAvLyBjb25zb25hbnQgY2hhcmFjdGVyIGNvbWJvc1xuICAgICAgICAn4YC8JzogJ3knLFxuICAgICAgICAn4YC7JzogJ3lhJyxcbiAgICAgICAgJ+GAvSc6ICd3JyxcbiAgICAgICAgJ+GAvOGAvSc6ICd5dycsXG4gICAgICAgICfhgLvhgL0nOiAneXdhJyxcbiAgICAgICAgJ+GAvic6ICdoJyxcbiAgICAgICAgLy8gaW5kZXBlbmRlbnQgdm93ZWxzXG4gICAgICAgICfhgKcnOiAnZScsXG4gICAgICAgICfhgY8nOiAnLWUnLFxuICAgICAgICAn4YCjJzogJ2knLFxuICAgICAgICAn4YCkJzogJy1pJyxcbiAgICAgICAgJ+GAiSc6ICd1JyxcbiAgICAgICAgJ+GApic6ICctdScsXG4gICAgICAgICfhgKknOiAnYXcnLFxuICAgICAgICAn4YCe4YC84YCx4YCsJzogJ2F3JyxcbiAgICAgICAgJ+GAqic6ICdhdycsXG4gICAgICAgIC8vIG51bWJlcnNcbiAgICAgICAgJ+GBgCc6ICcwJyxcbiAgICAgICAgJ+GBgSc6ICcxJyxcbiAgICAgICAgJ+GBgic6ICcyJyxcbiAgICAgICAgJ+GBgyc6ICczJyxcbiAgICAgICAgJ+GBhCc6ICc0JyxcbiAgICAgICAgJ+GBhSc6ICc1JyxcbiAgICAgICAgJ+GBhic6ICc2JyxcbiAgICAgICAgJ+GBhyc6ICc3JyxcbiAgICAgICAgJ+GBiCc6ICc4JyxcbiAgICAgICAgJ+GBiSc6ICc5JyxcbiAgICAgICAgLy8gdmlyYW1hIGFuZCB0b25lIG1hcmtzIHdoaWNoIGFyZSBzaWxlbnQgaW4gdHJhbnNsaXRlcmF0aW9uXG4gICAgICAgICfhgLknOiAnJyxcbiAgICAgICAgJ+GAtyc6ICcnLFxuICAgICAgICAn4YC4JzogJycsXG5cbiAgICAgICAgLy8gQ3plY2hcbiAgICAgICAgJ8SNJzogJ2MnLFxuICAgICAgICAnxI8nOiAnZCcsXG4gICAgICAgICfEmyc6ICdlJyxcbiAgICAgICAgJ8WIJzogJ24nLFxuICAgICAgICAnxZknOiAncicsXG4gICAgICAgICfFoSc6ICdzJyxcbiAgICAgICAgJ8WlJzogJ3QnLFxuICAgICAgICAnxa8nOiAndScsXG4gICAgICAgICfFvic6ICd6JyxcbiAgICAgICAgJ8SMJzogJ0MnLFxuICAgICAgICAnxI4nOiAnRCcsXG4gICAgICAgICfEmic6ICdFJyxcbiAgICAgICAgJ8WHJzogJ04nLFxuICAgICAgICAnxZgnOiAnUicsXG4gICAgICAgICfFoCc6ICdTJyxcbiAgICAgICAgJ8WkJzogJ1QnLFxuICAgICAgICAnxa4nOiAnVScsXG4gICAgICAgICfFvSc6ICdaJyxcblxuICAgICAgICAvLyBEaGl2ZWhpXG4gICAgICAgICfegCc6ICdoJyxcbiAgICAgICAgJ96BJzogJ3NoJyxcbiAgICAgICAgJ96CJzogJ24nLFxuICAgICAgICAn3oMnOiAncicsXG4gICAgICAgICfehCc6ICdiJyxcbiAgICAgICAgJ96FJzogJ2xoJyxcbiAgICAgICAgJ96GJzogJ2snLFxuICAgICAgICAn3ocnOiAnYScsXG4gICAgICAgICfeiCc6ICd2JyxcbiAgICAgICAgJ96JJzogJ20nLFxuICAgICAgICAn3oonOiAnZicsXG4gICAgICAgICfeiyc6ICdkaCcsXG4gICAgICAgICfejCc6ICd0aCcsXG4gICAgICAgICfejSc6ICdsJyxcbiAgICAgICAgJ96OJzogJ2cnLFxuICAgICAgICAn3o8nOiAnZ24nLFxuICAgICAgICAn3pAnOiAncycsXG4gICAgICAgICfekSc6ICdkJyxcbiAgICAgICAgJ96SJzogJ3onLFxuICAgICAgICAn3pMnOiAndCcsXG4gICAgICAgICfelCc6ICd5JyxcbiAgICAgICAgJ96VJzogJ3AnLFxuICAgICAgICAn3pYnOiAnaicsXG4gICAgICAgICfelyc6ICdjaCcsXG4gICAgICAgICfemCc6ICd0dCcsXG4gICAgICAgICfemSc6ICdoaCcsXG4gICAgICAgICfemic6ICdraCcsXG4gICAgICAgICfemyc6ICd0aCcsXG4gICAgICAgICfenCc6ICd6JyxcbiAgICAgICAgJ96dJzogJ3NoJyxcbiAgICAgICAgJ96eJzogJ3MnLFxuICAgICAgICAn3p8nOiAnZCcsXG4gICAgICAgICfeoCc6ICd0JyxcbiAgICAgICAgJ96hJzogJ3onLFxuICAgICAgICAn3qInOiAnYScsXG4gICAgICAgICfeoyc6ICdnaCcsXG4gICAgICAgICfepCc6ICdxJyxcbiAgICAgICAgJ96lJzogJ3cnLFxuICAgICAgICAn3qYnOiAnYScsXG4gICAgICAgICfepyc6ICdhYScsXG4gICAgICAgICfeqCc6ICdpJyxcbiAgICAgICAgJ96pJzogJ2VlJyxcbiAgICAgICAgJ96qJzogJ3UnLFxuICAgICAgICAn3qsnOiAnb28nLFxuICAgICAgICAn3qwnOiAnZScsXG4gICAgICAgICferSc6ICdleScsXG4gICAgICAgICferic6ICdvJyxcbiAgICAgICAgJ96vJzogJ29hJyxcbiAgICAgICAgJ96wJzogJycsXG5cbiAgICAgICAgLy8gR2VvcmdpYW4gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm9tYW5pemF0aW9uX29mX0dlb3JnaWFuXG4gICAgICAgIC8vIE5hdGlvbmFsIHN5c3RlbSAoMjAwMilcbiAgICAgICAgJ+GDkCc6ICdhJyxcbiAgICAgICAgJ+GDkSc6ICdiJyxcbiAgICAgICAgJ+GDkic6ICdnJyxcbiAgICAgICAgJ+GDkyc6ICdkJyxcbiAgICAgICAgJ+GDlCc6ICdlJyxcbiAgICAgICAgJ+GDlSc6ICd2JyxcbiAgICAgICAgJ+GDlic6ICd6JyxcbiAgICAgICAgJ+GDlyc6ICd0JyxcbiAgICAgICAgJ+GDmCc6ICdpJyxcbiAgICAgICAgJ+GDmSc6ICdrJyxcbiAgICAgICAgJ+GDmic6ICdsJyxcbiAgICAgICAgJ+GDmyc6ICdtJyxcbiAgICAgICAgJ+GDnCc6ICduJyxcbiAgICAgICAgJ+GDnSc6ICdvJyxcbiAgICAgICAgJ+GDnic6ICdwJyxcbiAgICAgICAgJ+GDnyc6ICd6aCcsXG4gICAgICAgICfhg6AnOiAncicsXG4gICAgICAgICfhg6EnOiAncycsXG4gICAgICAgICfhg6InOiAndCcsXG4gICAgICAgICfhg6MnOiAndScsXG4gICAgICAgICfhg6QnOiAncCcsXG4gICAgICAgICfhg6UnOiAnaycsXG4gICAgICAgICfhg6YnOiAnZ2gnLFxuICAgICAgICAn4YOnJzogJ3EnLFxuICAgICAgICAn4YOoJzogJ3NoJyxcbiAgICAgICAgJ+GDqSc6ICdjaCcsXG4gICAgICAgICfhg6onOiAndHMnLFxuICAgICAgICAn4YOrJzogJ2R6JyxcbiAgICAgICAgJ+GDrCc6ICd0cycsXG4gICAgICAgICfhg60nOiAnY2gnLFxuICAgICAgICAn4YOuJzogJ2toJyxcbiAgICAgICAgJ+GDryc6ICdqJyxcbiAgICAgICAgJ+GDsCc6ICdoJyxcblxuICAgICAgICAvLyBHcmVla1xuICAgICAgICAnzrEnOiAnYScsXG4gICAgICAgICfOsic6ICd2JyxcbiAgICAgICAgJ86zJzogJ2cnLFxuICAgICAgICAnzrQnOiAnZCcsXG4gICAgICAgICfOtSc6ICdlJyxcbiAgICAgICAgJ862JzogJ3onLFxuICAgICAgICAnzrcnOiAnaScsXG4gICAgICAgICfOuCc6ICd0aCcsXG4gICAgICAgICfOuSc6ICdpJyxcbiAgICAgICAgJ866JzogJ2snLFxuICAgICAgICAnzrsnOiAnbCcsXG4gICAgICAgICfOvCc6ICdtJyxcbiAgICAgICAgJ869JzogJ24nLFxuICAgICAgICAnzr4nOiAna3MnLFxuICAgICAgICAnzr8nOiAnbycsXG4gICAgICAgICfPgCc6ICdwJyxcbiAgICAgICAgJ8+BJzogJ3InLFxuICAgICAgICAnz4MnOiAncycsXG4gICAgICAgICfPhCc6ICd0JyxcbiAgICAgICAgJ8+FJzogJ3knLFxuICAgICAgICAnz4YnOiAnZicsXG4gICAgICAgICfPhyc6ICd4JyxcbiAgICAgICAgJ8+IJzogJ3BzJyxcbiAgICAgICAgJ8+JJzogJ28nLFxuICAgICAgICAnzqwnOiAnYScsXG4gICAgICAgICfOrSc6ICdlJyxcbiAgICAgICAgJ86vJzogJ2knLFxuICAgICAgICAnz4wnOiAnbycsXG4gICAgICAgICfPjSc6ICd5JyxcbiAgICAgICAgJ86uJzogJ2knLFxuICAgICAgICAnz44nOiAnbycsXG4gICAgICAgICfPgic6ICdzJyxcbiAgICAgICAgJ8+KJzogJ2knLFxuICAgICAgICAnzrAnOiAneScsXG4gICAgICAgICfPiyc6ICd5JyxcbiAgICAgICAgJ86QJzogJ2knLFxuICAgICAgICAnzpEnOiAnQScsXG4gICAgICAgICfOkic6ICdCJyxcbiAgICAgICAgJ86TJzogJ0cnLFxuICAgICAgICAnzpQnOiAnRCcsXG4gICAgICAgICfOlSc6ICdFJyxcbiAgICAgICAgJ86WJzogJ1onLFxuICAgICAgICAnzpcnOiAnSScsXG4gICAgICAgICfOmCc6ICdUSCcsXG4gICAgICAgICfOmSc6ICdJJyxcbiAgICAgICAgJ86aJzogJ0snLFxuICAgICAgICAnzpsnOiAnTCcsXG4gICAgICAgICfOnCc6ICdNJyxcbiAgICAgICAgJ86dJzogJ04nLFxuICAgICAgICAnzp4nOiAnS1MnLFxuICAgICAgICAnzp8nOiAnTycsXG4gICAgICAgICfOoCc6ICdQJyxcbiAgICAgICAgJ86hJzogJ1InLFxuICAgICAgICAnzqMnOiAnUycsXG4gICAgICAgICfOpCc6ICdUJyxcbiAgICAgICAgJ86lJzogJ1knLFxuICAgICAgICAnzqYnOiAnRicsXG4gICAgICAgICfOpyc6ICdYJyxcbiAgICAgICAgJ86oJzogJ1BTJyxcbiAgICAgICAgJ86pJzogJ08nLFxuICAgICAgICAnzoYnOiAnQScsXG4gICAgICAgICfOiCc6ICdFJyxcbiAgICAgICAgJ86KJzogJ0knLFxuICAgICAgICAnzownOiAnTycsXG4gICAgICAgICfOjic6ICdZJyxcbiAgICAgICAgJ86JJzogJ0knLFxuICAgICAgICAnzo8nOiAnTycsXG4gICAgICAgICfOqic6ICdJJyxcbiAgICAgICAgJ86rJzogJ1knLFxuXG4gICAgICAgIC8vIExhdHZpYW5cbiAgICAgICAgJ8SBJzogJ2EnLFxuICAgICAgICAvLyAnxI0nOiAnYycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAnxJMnOiAnZScsXG4gICAgICAgICfEoyc6ICdnJyxcbiAgICAgICAgJ8SrJzogJ2knLFxuICAgICAgICAnxLcnOiAnaycsXG4gICAgICAgICfEvCc6ICdsJyxcbiAgICAgICAgJ8WGJzogJ24nLFxuICAgICAgICAvLyAnxaEnOiAncycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAnxasnOiAndScsXG4gICAgICAgIC8vICfFvic6ICd6JywgLy8gZHVwbGljYXRlXG4gICAgICAgICfEgCc6ICdBJyxcbiAgICAgICAgLy8gJ8SMJzogJ0MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ8SSJzogJ0UnLFxuICAgICAgICAnxKInOiAnRycsXG4gICAgICAgICfEqic6ICdJJyxcbiAgICAgICAgJ8S2JzogJ2snLFxuICAgICAgICAnxLsnOiAnTCcsXG4gICAgICAgICfFhSc6ICdOJyxcbiAgICAgICAgLy8gJ8WgJzogJ1MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ8WqJzogJ1UnLFxuICAgICAgICAvLyAnxb0nOiAnWicsIC8vIGR1cGxpY2F0ZVxuXG4gICAgICAgIC8vIE1hY2Vkb25pYW5cbiAgICAgICAgJ9CMJzogJ0tqJyxcbiAgICAgICAgJ9GcJzogJ2tqJyxcbiAgICAgICAgJ9CJJzogJ0xqJyxcbiAgICAgICAgJ9GZJzogJ2xqJyxcbiAgICAgICAgJ9CKJzogJ05qJyxcbiAgICAgICAgJ9GaJzogJ25qJyxcbiAgICAgICAgJ9Ci0YEnOiAnVHMnLFxuICAgICAgICAn0YLRgSc6ICd0cycsXG5cbiAgICAgICAgLy8gUG9saXNoXG4gICAgICAgICfEhSc6ICdhJyxcbiAgICAgICAgJ8SHJzogJ2MnLFxuICAgICAgICAnxJknOiAnZScsXG4gICAgICAgICfFgic6ICdsJyxcbiAgICAgICAgJ8WEJzogJ24nLFxuICAgICAgICAvLyAnw7MnOiAnbycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAnxZsnOiAncycsXG4gICAgICAgICfFuic6ICd6JyxcbiAgICAgICAgJ8W8JzogJ3onLFxuICAgICAgICAnxIQnOiAnQScsXG4gICAgICAgICfEhic6ICdDJyxcbiAgICAgICAgJ8SYJzogJ0UnLFxuICAgICAgICAnxYEnOiAnTCcsXG4gICAgICAgICfFgyc6ICdOJyxcbiAgICAgICAgJ8WaJzogJ1MnLFxuICAgICAgICAnxbknOiAnWicsXG4gICAgICAgICfFuyc6ICdaJyxcblxuICAgICAgICAvLyBVa3JhbmlhblxuICAgICAgICAn0IQnOiAnWWUnLFxuICAgICAgICAn0IYnOiAnSScsXG4gICAgICAgICfQhyc6ICdZaScsXG4gICAgICAgICfSkCc6ICdHJyxcbiAgICAgICAgJ9GUJzogJ3llJyxcbiAgICAgICAgJ9GWJzogJ2knLFxuICAgICAgICAn0ZcnOiAneWknLFxuICAgICAgICAn0pEnOiAnZycsXG5cbiAgICAgICAgLy8gUm9tYW5pYW5cbiAgICAgICAgJ8SDJzogJ2EnLFxuICAgICAgICAnxIInOiAnQScsXG4gICAgICAgICfImSc6ICdzJyxcbiAgICAgICAgJ8iYJzogJ1MnLFxuICAgICAgICAvLyAnxZ8nOiAncycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAvLyAnxZ4nOiAnUycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAnyJsnOiAndCcsXG4gICAgICAgICfImic6ICdUJyxcbiAgICAgICAgJ8WjJzogJ3QnLFxuICAgICAgICAnxaInOiAnVCcsXG5cbiAgICAgICAgLy8gUnVzc2lhbiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb21hbml6YXRpb25fb2ZfUnVzc2lhblxuICAgICAgICAvLyBJQ0FPXG5cbiAgICAgICAgJ9CwJzogJ2EnLFxuICAgICAgICAn0LEnOiAnYicsXG4gICAgICAgICfQsic6ICd2JyxcbiAgICAgICAgJ9CzJzogJ2cnLFxuICAgICAgICAn0LQnOiAnZCcsXG4gICAgICAgICfQtSc6ICdlJyxcbiAgICAgICAgJ9GRJzogJ3lvJyxcbiAgICAgICAgJ9C2JzogJ3poJyxcbiAgICAgICAgJ9C3JzogJ3onLFxuICAgICAgICAn0LgnOiAnaScsXG4gICAgICAgICfQuSc6ICdpJyxcbiAgICAgICAgJ9C6JzogJ2snLFxuICAgICAgICAn0LsnOiAnbCcsXG4gICAgICAgICfQvCc6ICdtJyxcbiAgICAgICAgJ9C9JzogJ24nLFxuICAgICAgICAn0L4nOiAnbycsXG4gICAgICAgICfQvyc6ICdwJyxcbiAgICAgICAgJ9GAJzogJ3InLFxuICAgICAgICAn0YEnOiAncycsXG4gICAgICAgICfRgic6ICd0JyxcbiAgICAgICAgJ9GDJzogJ3UnLFxuICAgICAgICAn0YQnOiAnZicsXG4gICAgICAgICfRhSc6ICdraCcsXG4gICAgICAgICfRhic6ICdjJyxcbiAgICAgICAgJ9GHJzogJ2NoJyxcbiAgICAgICAgJ9GIJzogJ3NoJyxcbiAgICAgICAgJ9GJJzogJ3NoJyxcbiAgICAgICAgJ9GKJzogJycsXG4gICAgICAgICfRiyc6ICd5JyxcbiAgICAgICAgJ9GMJzogJycsXG4gICAgICAgICfRjSc6ICdlJyxcbiAgICAgICAgJ9GOJzogJ3l1JyxcbiAgICAgICAgJ9GPJzogJ3lhJyxcbiAgICAgICAgJ9CQJzogJ0EnLFxuICAgICAgICAn0JEnOiAnQicsXG4gICAgICAgICfQkic6ICdWJyxcbiAgICAgICAgJ9CTJzogJ0cnLFxuICAgICAgICAn0JQnOiAnRCcsXG4gICAgICAgICfQlSc6ICdFJyxcbiAgICAgICAgJ9CBJzogJ1lvJyxcbiAgICAgICAgJ9CWJzogJ1poJyxcbiAgICAgICAgJ9CXJzogJ1onLFxuICAgICAgICAn0JgnOiAnSScsXG4gICAgICAgICfQmSc6ICdJJyxcbiAgICAgICAgJ9CaJzogJ0snLFxuICAgICAgICAn0JsnOiAnTCcsXG4gICAgICAgICfQnCc6ICdNJyxcbiAgICAgICAgJ9CdJzogJ04nLFxuICAgICAgICAn0J4nOiAnTycsXG4gICAgICAgICfQnyc6ICdQJyxcbiAgICAgICAgJ9CgJzogJ1InLFxuICAgICAgICAn0KEnOiAnUycsXG4gICAgICAgICfQoic6ICdUJyxcbiAgICAgICAgJ9CjJzogJ1UnLFxuICAgICAgICAn0KQnOiAnRicsXG4gICAgICAgICfQpSc6ICdLaCcsXG4gICAgICAgICfQpic6ICdDJyxcbiAgICAgICAgJ9CnJzogJ0NoJyxcbiAgICAgICAgJ9CoJzogJ1NoJyxcbiAgICAgICAgJ9CpJzogJ1NoJyxcbiAgICAgICAgJ9CqJzogJycsXG4gICAgICAgICfQqyc6ICdZJyxcbiAgICAgICAgJ9CsJzogJycsXG4gICAgICAgICfQrSc6ICdFJyxcbiAgICAgICAgJ9CuJzogJ1l1JyxcbiAgICAgICAgJ9CvJzogJ1lhJyxcblxuICAgICAgICAvLyBTZXJiaWFuXG4gICAgICAgICfRkic6ICdkaicsXG4gICAgICAgICfRmCc6ICdqJyxcbiAgICAgICAgLy8gJ9GZJzogJ2xqJywgIC8vIGR1cGxpY2F0ZVxuICAgICAgICAvLyAn0ZonOiAnbmonLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ9GbJzogJ2MnLFxuICAgICAgICAn0Z8nOiAnZHonLFxuICAgICAgICAn0IInOiAnRGonLFxuICAgICAgICAn0IgnOiAnaicsXG4gICAgICAgIC8vICfQiSc6ICdMaicsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAvLyAn0IonOiAnTmonLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ9CLJzogJ0MnLFxuICAgICAgICAn0I8nOiAnRHonLFxuXG4gICAgICAgIC8vIFNsb3Zha1xuICAgICAgICAnxL4nOiAnbCcsXG4gICAgICAgICfEuic6ICdsJyxcbiAgICAgICAgJ8WVJzogJ3InLFxuICAgICAgICAnxL0nOiAnTCcsXG4gICAgICAgICfEuSc6ICdMJyxcbiAgICAgICAgJ8WUJzogJ1InLFxuXG4gICAgICAgIC8vIFR1cmtpc2hcbiAgICAgICAgJ8WfJzogJ3MnLFxuICAgICAgICAnxZ4nOiAnUycsXG4gICAgICAgICfEsSc6ICdpJyxcbiAgICAgICAgJ8SwJzogJ0knLFxuICAgICAgICAvLyAnw6cnOiAnYycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAvLyAnw4cnOiAnQycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAvLyAnw7wnOiAndScsIC8vIGR1cGxpY2F0ZSwgc2VlIGxhbmdDaGFyTWFwXG4gICAgICAgIC8vICfDnCc6ICdVJywgLy8gZHVwbGljYXRlLCBzZWUgbGFuZ0NoYXJNYXBcbiAgICAgICAgLy8gJ8O2JzogJ28nLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAvLyAnw5YnOiAnTycsIC8vIGR1cGxpY2F0ZSwgc2VlIGxhbmdDaGFyTWFwXG4gICAgICAgICfEnyc6ICdnJyxcbiAgICAgICAgJ8SeJzogJ0cnLFxuXG4gICAgICAgIC8vIFZpZXRuYW1lc2VcbiAgICAgICAgJ+G6oyc6ICdhJyxcbiAgICAgICAgJ+G6oic6ICdBJyxcbiAgICAgICAgJ+G6syc6ICdhJyxcbiAgICAgICAgJ+G6sic6ICdBJyxcbiAgICAgICAgJ+G6qSc6ICdhJyxcbiAgICAgICAgJ+G6qCc6ICdBJyxcbiAgICAgICAgJ8SRJzogJ2QnLFxuICAgICAgICAnxJAnOiAnRCcsXG4gICAgICAgICfhurknOiAnZScsXG4gICAgICAgICfhurgnOiAnRScsXG4gICAgICAgICfhur0nOiAnZScsXG4gICAgICAgICfhurwnOiAnRScsXG4gICAgICAgICfhursnOiAnZScsXG4gICAgICAgICfhuronOiAnRScsXG4gICAgICAgICfhur8nOiAnZScsXG4gICAgICAgICfhur4nOiAnRScsXG4gICAgICAgICfhu4EnOiAnZScsXG4gICAgICAgICfhu4AnOiAnRScsXG4gICAgICAgICfhu4cnOiAnZScsXG4gICAgICAgICfhu4YnOiAnRScsXG4gICAgICAgICfhu4UnOiAnZScsXG4gICAgICAgICfhu4QnOiAnRScsXG4gICAgICAgICfhu4MnOiAnZScsXG4gICAgICAgICfhu4InOiAnRScsXG4gICAgICAgICfhu48nOiAnbycsXG4gICAgICAgICfhu40nOiAnbycsXG4gICAgICAgICfhu4wnOiAnbycsXG4gICAgICAgICfhu5EnOiAnbycsXG4gICAgICAgICfhu5AnOiAnTycsXG4gICAgICAgICfhu5MnOiAnbycsXG4gICAgICAgICfhu5InOiAnTycsXG4gICAgICAgICfhu5UnOiAnbycsXG4gICAgICAgICfhu5QnOiAnTycsXG4gICAgICAgICfhu5knOiAnbycsXG4gICAgICAgICfhu5gnOiAnTycsXG4gICAgICAgICfhu5cnOiAnbycsXG4gICAgICAgICfhu5YnOiAnTycsXG4gICAgICAgICfGoSc6ICdvJyxcbiAgICAgICAgJ8agJzogJ08nLFxuICAgICAgICAn4bubJzogJ28nLFxuICAgICAgICAn4buaJzogJ08nLFxuICAgICAgICAn4budJzogJ28nLFxuICAgICAgICAn4bucJzogJ08nLFxuICAgICAgICAn4bujJzogJ28nLFxuICAgICAgICAn4buiJzogJ08nLFxuICAgICAgICAn4buhJzogJ28nLFxuICAgICAgICAn4bugJzogJ08nLFxuICAgICAgICAn4bueJzogJ28nLFxuICAgICAgICAn4bufJzogJ28nLFxuICAgICAgICAn4buLJzogJ2knLFxuICAgICAgICAn4buKJzogJ0knLFxuICAgICAgICAnxKknOiAnaScsXG4gICAgICAgICfEqCc6ICdJJyxcbiAgICAgICAgJ+G7iSc6ICdpJyxcbiAgICAgICAgJ+G7iCc6ICdpJyxcbiAgICAgICAgJ+G7pyc6ICd1JyxcbiAgICAgICAgJ+G7pic6ICdVJyxcbiAgICAgICAgJ+G7pSc6ICd1JyxcbiAgICAgICAgJ+G7pCc6ICdVJyxcbiAgICAgICAgJ8WpJzogJ3UnLFxuICAgICAgICAnxagnOiAnVScsXG4gICAgICAgICfGsCc6ICd1JyxcbiAgICAgICAgJ8avJzogJ1UnLFxuICAgICAgICAn4bupJzogJ3UnLFxuICAgICAgICAn4buoJzogJ1UnLFxuICAgICAgICAn4burJzogJ3UnLFxuICAgICAgICAn4buqJzogJ1UnLFxuICAgICAgICAn4buxJzogJ3UnLFxuICAgICAgICAn4buwJzogJ1UnLFxuICAgICAgICAn4buvJzogJ3UnLFxuICAgICAgICAn4buuJzogJ1UnLFxuICAgICAgICAn4butJzogJ3UnLFxuICAgICAgICAn4busJzogJ8awJyxcbiAgICAgICAgJ+G7tyc6ICd5JyxcbiAgICAgICAgJ+G7tic6ICd5JyxcbiAgICAgICAgJ+G7syc6ICd5JyxcbiAgICAgICAgJ+G7sic6ICdZJyxcbiAgICAgICAgJ+G7tSc6ICd5JyxcbiAgICAgICAgJ+G7tCc6ICdZJyxcbiAgICAgICAgJ+G7uSc6ICd5JyxcbiAgICAgICAgJ+G7uCc6ICdZJyxcbiAgICAgICAgJ+G6oSc6ICdhJyxcbiAgICAgICAgJ+G6oCc6ICdBJyxcbiAgICAgICAgJ+G6pSc6ICdhJyxcbiAgICAgICAgJ+G6pCc6ICdBJyxcbiAgICAgICAgJ+G6pyc6ICdhJyxcbiAgICAgICAgJ+G6pic6ICdBJyxcbiAgICAgICAgJ+G6rSc6ICdhJyxcbiAgICAgICAgJ+G6rCc6ICdBJyxcbiAgICAgICAgJ+G6qyc6ICdhJyxcbiAgICAgICAgJ+G6qic6ICdBJyxcbiAgICAgICAgLy8gJ8SDJzogJ2EnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ8SCJzogJ0EnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgJ+G6ryc6ICdhJyxcbiAgICAgICAgJ+G6ric6ICdBJyxcbiAgICAgICAgJ+G6sSc6ICdhJyxcbiAgICAgICAgJ+G6sCc6ICdBJyxcbiAgICAgICAgJ+G6tyc6ICdhJyxcbiAgICAgICAgJ+G6tic6ICdBJyxcbiAgICAgICAgJ+G6tSc6ICdhJyxcbiAgICAgICAgJ+G6tCc6ICdBJyxcbiAgICAgICAgXCLik6pcIjogXCIwXCIsXG4gICAgICAgIFwi4pGgXCI6IFwiMVwiLFxuICAgICAgICBcIuKRoVwiOiBcIjJcIixcbiAgICAgICAgXCLikaJcIjogXCIzXCIsXG4gICAgICAgIFwi4pGjXCI6IFwiNFwiLFxuICAgICAgICBcIuKRpFwiOiBcIjVcIixcbiAgICAgICAgXCLikaVcIjogXCI2XCIsXG4gICAgICAgIFwi4pGmXCI6IFwiN1wiLFxuICAgICAgICBcIuKRp1wiOiBcIjhcIixcbiAgICAgICAgXCLikahcIjogXCI5XCIsXG4gICAgICAgIFwi4pGpXCI6IFwiMTBcIixcbiAgICAgICAgXCLikapcIjogXCIxMVwiLFxuICAgICAgICBcIuKRq1wiOiBcIjEyXCIsXG4gICAgICAgIFwi4pGsXCI6IFwiMTNcIixcbiAgICAgICAgXCLika1cIjogXCIxNFwiLFxuICAgICAgICBcIuKRrlwiOiBcIjE1XCIsXG4gICAgICAgIFwi4pGvXCI6IFwiMTZcIixcbiAgICAgICAgXCLikbBcIjogXCIxN1wiLFxuICAgICAgICBcIuKRsVwiOiBcIjE4XCIsXG4gICAgICAgIFwi4pGyXCI6IFwiMThcIixcbiAgICAgICAgXCLikbNcIjogXCIxOFwiLFxuXG4gICAgICAgIFwi4pO1XCI6IFwiMVwiLFxuICAgICAgICBcIuKTtlwiOiBcIjJcIixcbiAgICAgICAgXCLik7dcIjogXCIzXCIsXG4gICAgICAgIFwi4pO4XCI6IFwiNFwiLFxuICAgICAgICBcIuKTuVwiOiBcIjVcIixcbiAgICAgICAgXCLik7pcIjogXCI2XCIsXG4gICAgICAgIFwi4pO7XCI6IFwiN1wiLFxuICAgICAgICBcIuKTvFwiOiBcIjhcIixcbiAgICAgICAgXCLik71cIjogXCI5XCIsXG4gICAgICAgIFwi4pO+XCI6IFwiMTBcIixcblxuICAgICAgICBcIuKTv1wiOiBcIjBcIixcbiAgICAgICAgXCLik6tcIjogXCIxMVwiLFxuICAgICAgICBcIuKTrFwiOiBcIjEyXCIsXG4gICAgICAgIFwi4pOtXCI6IFwiMTNcIixcbiAgICAgICAgXCLik65cIjogXCIxNFwiLFxuICAgICAgICBcIuKTr1wiOiBcIjE1XCIsXG4gICAgICAgIFwi4pOwXCI6IFwiMTZcIixcbiAgICAgICAgXCLik7FcIjogXCIxN1wiLFxuICAgICAgICBcIuKTslwiOiBcIjE4XCIsXG4gICAgICAgIFwi4pOzXCI6IFwiMTlcIixcbiAgICAgICAgXCLik7RcIjogXCIyMFwiLFxuXG4gICAgICAgIFwi4pK2XCI6IFwiQVwiLFxuICAgICAgICBcIuKSt1wiOiBcIkJcIixcbiAgICAgICAgXCLikrhcIjogXCJDXCIsXG4gICAgICAgIFwi4pK5XCI6IFwiRFwiLFxuICAgICAgICBcIuKSulwiOiBcIkVcIixcbiAgICAgICAgXCLikrtcIjogXCJGXCIsXG4gICAgICAgIFwi4pK8XCI6IFwiR1wiLFxuICAgICAgICBcIuKSvVwiOiBcIkhcIixcbiAgICAgICAgXCLikr5cIjogXCJJXCIsXG4gICAgICAgIFwi4pK/XCI6IFwiSlwiLFxuICAgICAgICBcIuKTgFwiOiBcIktcIixcbiAgICAgICAgXCLik4FcIjogXCJMXCIsXG4gICAgICAgIFwi4pOCXCI6IFwiTVwiLFxuICAgICAgICBcIuKTg1wiOiBcIk5cIixcbiAgICAgICAgXCLik4RcIjogXCJPXCIsXG4gICAgICAgIFwi4pOFXCI6IFwiUFwiLFxuICAgICAgICBcIuKThlwiOiBcIlFcIixcbiAgICAgICAgXCLik4dcIjogXCJSXCIsXG4gICAgICAgIFwi4pOIXCI6IFwiU1wiLFxuICAgICAgICBcIuKTiVwiOiBcIlRcIixcbiAgICAgICAgXCLik4pcIjogXCJVXCIsXG4gICAgICAgIFwi4pOLXCI6IFwiVlwiLFxuICAgICAgICBcIuKTjFwiOiBcIldcIixcbiAgICAgICAgXCLik41cIjogXCJYXCIsXG4gICAgICAgIFwi4pOOXCI6IFwiWVwiLFxuICAgICAgICBcIuKTj1wiOiBcIlpcIixcblxuICAgICAgICBcIuKTkFwiOiBcImFcIixcbiAgICAgICAgXCLik5FcIjogXCJiXCIsXG4gICAgICAgIFwi4pOSXCI6IFwiY1wiLFxuICAgICAgICBcIuKTk1wiOiBcImRcIixcbiAgICAgICAgXCLik5RcIjogXCJlXCIsXG4gICAgICAgIFwi4pOVXCI6IFwiZlwiLFxuICAgICAgICBcIuKTllwiOiBcImdcIixcbiAgICAgICAgXCLik5dcIjogXCJoXCIsXG4gICAgICAgIFwi4pOYXCI6IFwiaVwiLFxuICAgICAgICBcIuKTmVwiOiBcImpcIixcbiAgICAgICAgXCLik5pcIjogXCJrXCIsXG4gICAgICAgIFwi4pObXCI6IFwibFwiLFxuICAgICAgICBcIuKTnFwiOiBcIm1cIixcbiAgICAgICAgXCLik51cIjogXCJuXCIsXG4gICAgICAgIFwi4pOeXCI6IFwib1wiLFxuICAgICAgICBcIuKTn1wiOiBcInBcIixcbiAgICAgICAgXCLik6BcIjogXCJxXCIsXG4gICAgICAgIFwi4pOhXCI6IFwiclwiLFxuICAgICAgICBcIuKTolwiOiBcInNcIixcbiAgICAgICAgXCLik6NcIjogXCJ0XCIsXG4gICAgICAgIFwi4pOkXCI6IFwidVwiLFxuICAgICAgICBcIuKTplwiOiBcInZcIixcbiAgICAgICAgXCLik6VcIjogXCJ3XCIsXG4gICAgICAgIFwi4pOnXCI6IFwieFwiLFxuICAgICAgICBcIuKTqFwiOiBcInlcIixcbiAgICAgICAgXCLik6lcIjogXCJ6XCIsXG5cbiAgICAgICAgLy8gc3ltYm9sc1xuICAgICAgICAn4oCcJzogJ1wiJyxcbiAgICAgICAgJ+KAnSc6ICdcIicsXG4gICAgICAgICfigJgnOiBcIidcIixcbiAgICAgICAgJ+KAmSc6IFwiJ1wiLFxuICAgICAgICAn4oiCJzogJ2QnLFxuICAgICAgICAnxpInOiAnZicsXG4gICAgICAgICfihKInOiAnKFRNKScsXG4gICAgICAgICfCqSc6ICcoQyknLFxuICAgICAgICAnxZMnOiAnb2UnLFxuICAgICAgICAnxZInOiAnT0UnLFxuICAgICAgICAnwq4nOiAnKFIpJyxcbiAgICAgICAgJ+KAoCc6ICcrJyxcbiAgICAgICAgJ+KEoCc6ICcoU00pJyxcbiAgICAgICAgJ+KApic6ICcuLi4nLFxuICAgICAgICAny5onOiAnbycsXG4gICAgICAgICfCuic6ICdvJyxcbiAgICAgICAgJ8KqJzogJ2EnLFxuICAgICAgICAn4oCiJzogJyonLFxuICAgICAgICAn4YGKJzogJywnLFxuICAgICAgICAn4YGLJzogJy4nLFxuXG4gICAgICAgIC8vIGN1cnJlbmN5XG4gICAgICAgICckJzogJ1VTRCcsXG4gICAgICAgICfigqwnOiAnRVVSJyxcbiAgICAgICAgJ+KCoic6ICdCUk4nLFxuICAgICAgICAn4oKjJzogJ0ZSRicsXG4gICAgICAgICfCoyc6ICdHQlAnLFxuICAgICAgICAn4oKkJzogJ0lUTCcsXG4gICAgICAgICfigqYnOiAnTkdOJyxcbiAgICAgICAgJ+KCpyc6ICdFU1AnLFxuICAgICAgICAn4oKpJzogJ0tSVycsXG4gICAgICAgICfigqonOiAnSUxTJyxcbiAgICAgICAgJ+KCqyc6ICdWTkQnLFxuICAgICAgICAn4oKtJzogJ0xBSycsXG4gICAgICAgICfigq4nOiAnTU5UJyxcbiAgICAgICAgJ+KCryc6ICdHUkQnLFxuICAgICAgICAn4oKxJzogJ0FSUycsXG4gICAgICAgICfigrInOiAnUFlHJyxcbiAgICAgICAgJ+KCsyc6ICdBUkEnLFxuICAgICAgICAn4oK0JzogJ1VBSCcsXG4gICAgICAgICfigrUnOiAnR0hTJyxcbiAgICAgICAgJ8KiJzogJ2NlbnQnLFxuICAgICAgICAnwqUnOiAnQ05ZJyxcbiAgICAgICAgJ+WFgyc6ICdDTlknLFxuICAgICAgICAn5YaGJzogJ1lFTicsXG4gICAgICAgICfvt7wnOiAnSVJSJyxcbiAgICAgICAgJ+KCoCc6ICdFV0UnLFxuICAgICAgICAn4Li/JzogJ1RIQicsXG4gICAgICAgICfigqgnOiAnSU5SJyxcbiAgICAgICAgJ+KCuSc6ICdJTlInLFxuICAgICAgICAn4oKwJzogJ1BGJyxcbiAgICAgICAgJ+KCuic6ICdUUlknLFxuICAgICAgICAn2IsnOiAnQUZOJyxcbiAgICAgICAgJ+KCvCc6ICdBWk4nLFxuICAgICAgICAn0LvQsic6ICdCR04nLFxuICAgICAgICAn4Z+bJzogJ0tIUicsXG4gICAgICAgICfigqEnOiAnQ1JDJyxcbiAgICAgICAgJ+KCuCc6ICdLWlQnLFxuICAgICAgICAn0LTQtdC9JzogJ01LRCcsXG4gICAgICAgICd6xYInOiAnUExOJyxcbiAgICAgICAgJ+KCvSc6ICdSVUInLFxuICAgICAgICAn4oK+JzogJ0dFTCdcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzcGVjaWFsIGxvb2sgYWhlYWQgY2hhcmFjdGVyIGFycmF5XG4gICAgICogVGhlc2UgY2hhcmFjdGVycyBmb3JtIHdpdGggY29uc29uYW50cyB0byBiZWNvbWUgJ3NpbmdsZScvY29uc29uYW50IGNvbWJvXG4gICAgICogQHR5cGUgW0FycmF5XVxuICAgICAqL1xuICAgIHZhciBsb29rQWhlYWRDaGFyQXJyYXkgPSBbXG4gICAgICAgIC8vIGJ1cm1lc2VcbiAgICAgICAgJ+GAuicsXG5cbiAgICAgICAgLy8gRGhpdmVoaVxuICAgICAgICAn3rAnXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIGRpYXRyaWNNYXAgZm9yIGxhbmd1YWdlcyB3aGVyZSB0cmFuc2xpdGVyYXRpb24gY2hhbmdlcyBlbnRpcmVseSBhcyBtb3JlIGRpYXRyaWNzIGFyZSBhZGRlZFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGRpYXRyaWNNYXAgPSB7XG4gICAgICAgIC8vIEJ1cm1lc2VcbiAgICAgICAgLy8gZGVwZW5kZW50IHZvd2Vsc1xuICAgICAgICAn4YCsJzogJ2EnLFxuICAgICAgICAn4YCrJzogJ2EnLFxuICAgICAgICAn4YCxJzogJ2UnLFxuICAgICAgICAn4YCyJzogJ2UnLFxuICAgICAgICAn4YCtJzogJ2knLFxuICAgICAgICAn4YCuJzogJ2knLFxuICAgICAgICAn4YCt4YCvJzogJ28nLFxuICAgICAgICAn4YCvJzogJ3UnLFxuICAgICAgICAn4YCwJzogJ3UnLFxuICAgICAgICAn4YCx4YCr4YCE4YC6JzogJ2F1bmcnLFxuICAgICAgICAn4YCx4YCsJzogJ2F3JyxcbiAgICAgICAgJ+GAseGArOGAuic6ICdhdycsXG4gICAgICAgICfhgLHhgKsnOiAnYXcnLFxuICAgICAgICAn4YCx4YCr4YC6JzogJ2F3JyxcbiAgICAgICAgJ+GAuic6ICfhgLonLCAvLyB0aGlzIGlzIHNwZWNpYWwgY2FzZSBidXQgdGhlIGNoYXJhY3RlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBsYXRpbiBpbiB0aGUgY29kZVxuICAgICAgICAn4YCA4YC6JzogJ2V0JyxcbiAgICAgICAgJ+GAreGAr+GAgOGAuic6ICdhaWsnLFxuICAgICAgICAn4YCx4YCs4YCA4YC6JzogJ2F1aycsXG4gICAgICAgICfhgIThgLonOiAnaW4nLFxuICAgICAgICAn4YCt4YCv4YCE4YC6JzogJ2FpbmcnLFxuICAgICAgICAn4YCx4YCs4YCE4YC6JzogJ2F1bmcnLFxuICAgICAgICAn4YCF4YC6JzogJ2l0JyxcbiAgICAgICAgJ+GAiuGAuic6ICdpJyxcbiAgICAgICAgJ+GAkOGAuic6ICdhdCcsXG4gICAgICAgICfhgK3hgJDhgLonOiAnZWlrJyxcbiAgICAgICAgJ+GAr+GAkOGAuic6ICdvaycsXG4gICAgICAgICfhgL3hgJDhgLonOiAndXQnLFxuICAgICAgICAn4YCx4YCQ4YC6JzogJ2l0JyxcbiAgICAgICAgJ+GAkuGAuic6ICdkJyxcbiAgICAgICAgJ+GAreGAr+GAkuGAuic6ICdvaycsXG4gICAgICAgICfhgK/hgJLhgLonOiAnYWl0JyxcbiAgICAgICAgJ+GAlOGAuic6ICdhbicsXG4gICAgICAgICfhgKzhgJThgLonOiAnYW4nLFxuICAgICAgICAn4YCt4YCU4YC6JzogJ2VpbicsXG4gICAgICAgICfhgK/hgJThgLonOiAnb24nLFxuICAgICAgICAn4YC94YCU4YC6JzogJ3VuJyxcbiAgICAgICAgJ+GAleGAuic6ICdhdCcsXG4gICAgICAgICfhgK3hgJXhgLonOiAnZWlrJyxcbiAgICAgICAgJ+GAr+GAleGAuic6ICdvaycsXG4gICAgICAgICfhgL3hgJXhgLonOiAndXQnLFxuICAgICAgICAn4YCU4YC64YCv4YCV4YC6JzogJ251YicsXG4gICAgICAgICfhgJnhgLonOiAnYW4nLFxuICAgICAgICAn4YCt4YCZ4YC6JzogJ2VpbicsXG4gICAgICAgICfhgK/hgJnhgLonOiAnb24nLFxuICAgICAgICAn4YC94YCZ4YC6JzogJ3VuJyxcbiAgICAgICAgJ+GAmuGAuic6ICdlJyxcbiAgICAgICAgJ+GAreGAr+GAnOGAuic6ICdvbCcsXG4gICAgICAgICfhgInhgLonOiAnaW4nLFxuICAgICAgICAn4YC2JzogJ2FuJyxcbiAgICAgICAgJ+GAreGAtic6ICdlaW4nLFxuICAgICAgICAn4YCv4YC2JzogJ29uJyxcblxuICAgICAgICAvLyBEaGl2ZWhpXG4gICAgICAgICfept6H3rAnOiAnYWgnLFxuICAgICAgICAn3qbegd6wJzogJ2FoJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBsYW5nQ2hhck1hcCBsYW5ndWFnZSBzcGVjaWZpYyBjaGFyYWN0ZXJzIHRyYW5zbGF0aW9uc1xuICAgICAqIEB0eXBlICAge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgbGFuZ0NoYXJNYXAgPSB7XG4gICAgICAgICdlbic6IHt9LCAvLyBkZWZhdWx0IGxhbmd1YWdlXG5cbiAgICAgICAgJ2F6JzogeyAvLyBBemVyYmFpamFuaVxuICAgICAgICAgICAgJ8OnJzogJ2MnLFxuICAgICAgICAgICAgJ8mZJzogJ2UnLFxuICAgICAgICAgICAgJ8SfJzogJ2cnLFxuICAgICAgICAgICAgJ8SxJzogJ2knLFxuICAgICAgICAgICAgJ8O2JzogJ28nLFxuICAgICAgICAgICAgJ8WfJzogJ3MnLFxuICAgICAgICAgICAgJ8O8JzogJ3UnLFxuICAgICAgICAgICAgJ8OHJzogJ0MnLFxuICAgICAgICAgICAgJ8aPJzogJ0UnLFxuICAgICAgICAgICAgJ8SeJzogJ0cnLFxuICAgICAgICAgICAgJ8SwJzogJ0knLFxuICAgICAgICAgICAgJ8OWJzogJ08nLFxuICAgICAgICAgICAgJ8WeJzogJ1MnLFxuICAgICAgICAgICAgJ8OcJzogJ1UnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2NzJzogeyAvLyBDemVjaFxuICAgICAgICAgICAgJ8SNJzogJ2MnLFxuICAgICAgICAgICAgJ8SPJzogJ2QnLFxuICAgICAgICAgICAgJ8SbJzogJ2UnLFxuICAgICAgICAgICAgJ8WIJzogJ24nLFxuICAgICAgICAgICAgJ8WZJzogJ3InLFxuICAgICAgICAgICAgJ8WhJzogJ3MnLFxuICAgICAgICAgICAgJ8WlJzogJ3QnLFxuICAgICAgICAgICAgJ8WvJzogJ3UnLFxuICAgICAgICAgICAgJ8W+JzogJ3onLFxuICAgICAgICAgICAgJ8SMJzogJ0MnLFxuICAgICAgICAgICAgJ8SOJzogJ0QnLFxuICAgICAgICAgICAgJ8SaJzogJ0UnLFxuICAgICAgICAgICAgJ8WHJzogJ04nLFxuICAgICAgICAgICAgJ8WYJzogJ1InLFxuICAgICAgICAgICAgJ8WgJzogJ1MnLFxuICAgICAgICAgICAgJ8WkJzogJ1QnLFxuICAgICAgICAgICAgJ8WuJzogJ1UnLFxuICAgICAgICAgICAgJ8W9JzogJ1onXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2ZpJzogeyAvLyBGaW5uaXNoXG4gICAgICAgICAgICAvLyAnw6UnOiAnYScsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgICAgLy8gJ8OFJzogJ0EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgICfDpCc6ICdhJywgLy8gb2tcbiAgICAgICAgICAgICfDhCc6ICdBJywgLy8gb2tcbiAgICAgICAgICAgICfDtic6ICdvJywgLy8gb2tcbiAgICAgICAgICAgICfDlic6ICdPJyAvLyBva1xuICAgICAgICB9LFxuXG4gICAgICAgICdodSc6IHsgLy8gSHVuZ2FyaWFuXG4gICAgICAgICAgICAnw6QnOiAnYScsIC8vIG9rXG4gICAgICAgICAgICAnw4QnOiAnQScsIC8vIG9rXG4gICAgICAgICAgICAvLyAnw6EnOiAnYScsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgICAgLy8gJ8OBJzogJ0EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgICfDtic6ICdvJywgLy8gb2tcbiAgICAgICAgICAgICfDlic6ICdPJywgLy8gb2tcbiAgICAgICAgICAgIC8vICfFkSc6ICdvJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgICAvLyAnxZAnOiAnTycsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgICAgJ8O8JzogJ3UnLFxuICAgICAgICAgICAgJ8OcJzogJ1UnLFxuICAgICAgICAgICAgJ8WxJzogJ3UnLFxuICAgICAgICAgICAgJ8WwJzogJ1UnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2x0JzogeyAvLyBMaXRodWFuaWFuXG4gICAgICAgICAgICAnxIUnOiAnYScsXG4gICAgICAgICAgICAnxI0nOiAnYycsXG4gICAgICAgICAgICAnxJknOiAnZScsXG4gICAgICAgICAgICAnxJcnOiAnZScsXG4gICAgICAgICAgICAnxK8nOiAnaScsXG4gICAgICAgICAgICAnxaEnOiAncycsXG4gICAgICAgICAgICAnxbMnOiAndScsXG4gICAgICAgICAgICAnxasnOiAndScsXG4gICAgICAgICAgICAnxb4nOiAneicsXG4gICAgICAgICAgICAnxIQnOiAnQScsXG4gICAgICAgICAgICAnxIwnOiAnQycsXG4gICAgICAgICAgICAnxJgnOiAnRScsXG4gICAgICAgICAgICAnxJYnOiAnRScsXG4gICAgICAgICAgICAnxK4nOiAnSScsXG4gICAgICAgICAgICAnxaAnOiAnUycsXG4gICAgICAgICAgICAnxbInOiAnVScsXG4gICAgICAgICAgICAnxaonOiAnVSdcbiAgICAgICAgfSxcblxuICAgICAgICAnbHYnOiB7IC8vIExhdHZpYW5cbiAgICAgICAgICAgICfEgSc6ICdhJyxcbiAgICAgICAgICAgICfEjSc6ICdjJyxcbiAgICAgICAgICAgICfEkyc6ICdlJyxcbiAgICAgICAgICAgICfEoyc6ICdnJyxcbiAgICAgICAgICAgICfEqyc6ICdpJyxcbiAgICAgICAgICAgICfEtyc6ICdrJyxcbiAgICAgICAgICAgICfEvCc6ICdsJyxcbiAgICAgICAgICAgICfFhic6ICduJyxcbiAgICAgICAgICAgICfFoSc6ICdzJyxcbiAgICAgICAgICAgICfFqyc6ICd1JyxcbiAgICAgICAgICAgICfFvic6ICd6JyxcbiAgICAgICAgICAgICfEgCc6ICdBJyxcbiAgICAgICAgICAgICfEjCc6ICdDJyxcbiAgICAgICAgICAgICfEkic6ICdFJyxcbiAgICAgICAgICAgICfEoic6ICdHJyxcbiAgICAgICAgICAgICfEqic6ICdpJyxcbiAgICAgICAgICAgICfEtic6ICdrJyxcbiAgICAgICAgICAgICfEuyc6ICdMJyxcbiAgICAgICAgICAgICfFhSc6ICdOJyxcbiAgICAgICAgICAgICfFoCc6ICdTJyxcbiAgICAgICAgICAgICfFqic6ICd1JyxcbiAgICAgICAgICAgICfFvSc6ICdaJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdwbCc6IHsgLy8gUG9saXNoXG4gICAgICAgICAgICAnxIUnOiAnYScsXG4gICAgICAgICAgICAnxIcnOiAnYycsXG4gICAgICAgICAgICAnxJknOiAnZScsXG4gICAgICAgICAgICAnxYInOiAnbCcsXG4gICAgICAgICAgICAnxYQnOiAnbicsXG4gICAgICAgICAgICAnw7MnOiAnbycsXG4gICAgICAgICAgICAnxZsnOiAncycsXG4gICAgICAgICAgICAnxbonOiAneicsXG4gICAgICAgICAgICAnxbwnOiAneicsXG4gICAgICAgICAgICAnxIQnOiAnQScsXG4gICAgICAgICAgICAnxIYnOiAnQycsXG4gICAgICAgICAgICAnxJgnOiAnZScsXG4gICAgICAgICAgICAnxYEnOiAnTCcsXG4gICAgICAgICAgICAnxYMnOiAnTicsXG4gICAgICAgICAgICAnw5MnOiAnTycsXG4gICAgICAgICAgICAnxZonOiAnUycsXG4gICAgICAgICAgICAnxbknOiAnWicsXG4gICAgICAgICAgICAnxbsnOiAnWidcbiAgICAgICAgfSxcblxuICAgICAgICAnc3YnOiB7IC8vIFN3ZWRpc2hcbiAgICAgICAgICAgIC8vICfDpSc6ICdhJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgICAvLyAnw4UnOiAnQScsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgICAgJ8OkJzogJ2EnLCAvLyBva1xuICAgICAgICAgICAgJ8OEJzogJ0EnLCAvLyBva1xuICAgICAgICAgICAgJ8O2JzogJ28nLCAvLyBva1xuICAgICAgICAgICAgJ8OWJzogJ08nIC8vIG9rXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3NrJzogeyAvLyBTbG92YWtcbiAgICAgICAgICAgICfDpCc6ICdhJyxcbiAgICAgICAgICAgICfDhCc6ICdBJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdzcic6IHsgLy8gU2VyYmlhblxuICAgICAgICAgICAgJ9GZJzogJ2xqJyxcbiAgICAgICAgICAgICfRmic6ICduaicsXG4gICAgICAgICAgICAn0IknOiAnTGonLFxuICAgICAgICAgICAgJ9CKJzogJ05qJyxcbiAgICAgICAgICAgICfEkSc6ICdkaicsXG4gICAgICAgICAgICAnxJAnOiAnRGonXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3RyJzogeyAvLyBUdXJraXNoXG4gICAgICAgICAgICAnw5wnOiAnVScsXG4gICAgICAgICAgICAnw5YnOiAnTycsXG4gICAgICAgICAgICAnw7wnOiAndScsXG4gICAgICAgICAgICAnw7YnOiAnbydcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzeW1ib2xNYXAgbGFuZ3VhZ2Ugc3BlY2lmaWMgc3ltYm9sIHRyYW5zbGF0aW9uc1xuICAgICAqIHRyYW5zbGF0aW9ucyBtdXN0IGJlIHRyYW5zbGl0ZXJhdGVkIGFscmVhZHlcbiAgICAgKiBAdHlwZSAgIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJ2FyJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2xhLW5paGF5YScsXG4gICAgICAgICAgICAn4pmlJzogJ2hvYicsXG4gICAgICAgICAgICAnJic6ICd3YScsXG4gICAgICAgICAgICAnfCc6ICdhdycsXG4gICAgICAgICAgICAnPCc6ICdhcWFsLW1lbicsXG4gICAgICAgICAgICAnPic6ICdha2Jhci1tZW4nLFxuICAgICAgICAgICAgJ+KIkSc6ICdtYWptb3UnLFxuICAgICAgICAgICAgJ8KkJzogJ29tbGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2F6Jzoge30sXG5cbiAgICAgICAgJ2NhJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2luZmluaXQnLFxuICAgICAgICAgICAgJ+KZpSc6ICdhbW9yJyxcbiAgICAgICAgICAgICcmJzogJ2knLFxuICAgICAgICAgICAgJ3wnOiAnbycsXG4gICAgICAgICAgICAnPCc6ICdtZW55cyBxdWUnLFxuICAgICAgICAgICAgJz4nOiAnbWVzIHF1ZScsXG4gICAgICAgICAgICAn4oiRJzogJ3N1bWEgZGVscycsXG4gICAgICAgICAgICAnwqQnOiAnbW9uZWRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdjcyc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICduZWtvbmVjbm8nLFxuICAgICAgICAgICAgJ+KZpSc6ICdsYXNrYScsXG4gICAgICAgICAgICAnJic6ICdhJyxcbiAgICAgICAgICAgICd8JzogJ25lYm8nLFxuICAgICAgICAgICAgJzwnOiAnbWVuc2kgbmV6JyxcbiAgICAgICAgICAgICc+JzogJ3ZldHNpIG5leicsXG4gICAgICAgICAgICAn4oiRJzogJ3NvdWNldCcsXG4gICAgICAgICAgICAnwqQnOiAnbWVuYSdcbiAgICAgICAgfSxcblxuICAgICAgICAnZGUnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAndW5lbmRsaWNoJyxcbiAgICAgICAgICAgICfimaUnOiAnTGllYmUnLFxuICAgICAgICAgICAgJyYnOiAndW5kJyxcbiAgICAgICAgICAgICd8JzogJ29kZXInLFxuICAgICAgICAgICAgJzwnOiAna2xlaW5lciBhbHMnLFxuICAgICAgICAgICAgJz4nOiAnZ3JvZXNzZXIgYWxzJyxcbiAgICAgICAgICAgICfiiJEnOiAnU3VtbWUgdm9uJyxcbiAgICAgICAgICAgICfCpCc6ICdXYWVocnVuZydcbiAgICAgICAgfSxcblxuICAgICAgICAnZHYnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAna29sdW51bGFhJyxcbiAgICAgICAgICAgICfimaUnOiAnbG9hYmknLFxuICAgICAgICAgICAgJyYnOiAnYWFpJyxcbiAgICAgICAgICAgICd8JzogJ25vb25lZScsXG4gICAgICAgICAgICAnPCc6ICdhaCB2dXJlIGt1ZGEnLFxuICAgICAgICAgICAgJz4nOiAnYWggdnVyZSBib2R1JyxcbiAgICAgICAgICAgICfiiJEnOiAnanVtdWxhJyxcbiAgICAgICAgICAgICfCpCc6ICdmYWlzYWEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2VuJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2luZmluaXR5JyxcbiAgICAgICAgICAgICfimaUnOiAnbG92ZScsXG4gICAgICAgICAgICAnJic6ICdhbmQnLFxuICAgICAgICAgICAgJ3wnOiAnb3InLFxuICAgICAgICAgICAgJzwnOiAnbGVzcyB0aGFuJyxcbiAgICAgICAgICAgICc+JzogJ2dyZWF0ZXIgdGhhbicsXG4gICAgICAgICAgICAn4oiRJzogJ3N1bScsXG4gICAgICAgICAgICAnwqQnOiAnY3VycmVuY3knXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2VzJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2luZmluaXRvJyxcbiAgICAgICAgICAgICfimaUnOiAnYW1vcicsXG4gICAgICAgICAgICAnJic6ICd5JyxcbiAgICAgICAgICAgICd8JzogJ3UnLFxuICAgICAgICAgICAgJzwnOiAnbWVub3MgcXVlJyxcbiAgICAgICAgICAgICc+JzogJ21hcyBxdWUnLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW1hIGRlIGxvcycsXG4gICAgICAgICAgICAnwqQnOiAnbW9uZWRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdmYSc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdiaS1uYWhheWF0JyxcbiAgICAgICAgICAgICfimaUnOiAnZXNoZ2gnLFxuICAgICAgICAgICAgJyYnOiAndmEnLFxuICAgICAgICAgICAgJ3wnOiAneWEnLFxuICAgICAgICAgICAgJzwnOiAna2FtdGFyLWF6JyxcbiAgICAgICAgICAgICc+JzogJ2Jpc2h0YXItYXonLFxuICAgICAgICAgICAgJ+KIkSc6ICdtYWptb29lJyxcbiAgICAgICAgICAgICfCpCc6ICd2YWhlZCdcbiAgICAgICAgfSxcblxuICAgICAgICAnZmknOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnYWFyZXR0b215eXMnLFxuICAgICAgICAgICAgJ+KZpSc6ICdyYWtrYXVzJyxcbiAgICAgICAgICAgICcmJzogJ2phJyxcbiAgICAgICAgICAgICd8JzogJ3RhaScsXG4gICAgICAgICAgICAnPCc6ICdwaWVuZW1waSBrdWluJyxcbiAgICAgICAgICAgICc+JzogJ3N1dXJlbXBpIGt1aW4nLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW1tYScsXG4gICAgICAgICAgICAnwqQnOiAndmFsdXV0dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2ZyJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2luZmluaW1lbnQnLFxuICAgICAgICAgICAgJ+KZpSc6ICdBbW91cicsXG4gICAgICAgICAgICAnJic6ICdldCcsXG4gICAgICAgICAgICAnfCc6ICdvdScsXG4gICAgICAgICAgICAnPCc6ICdtb2lucyBxdWUnLFxuICAgICAgICAgICAgJz4nOiAnc3VwZXJpZXVyZSBhJyxcbiAgICAgICAgICAgICfiiJEnOiAnc29tbWUgZGVzJyxcbiAgICAgICAgICAgICfCpCc6ICdtb25uYWllJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdnZSc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICd1c2FzcnVsb2JhJyxcbiAgICAgICAgICAgICfimaUnOiAnc2lxdmFydWxpJyxcbiAgICAgICAgICAgICcmJzogJ2RhJyxcbiAgICAgICAgICAgICd8JzogJ2FuJyxcbiAgICAgICAgICAgICc8JzogJ25ha2xlYmknLFxuICAgICAgICAgICAgJz4nOiAnbWV0aScsXG4gICAgICAgICAgICAn4oiRJzogJ2phbWknLFxuICAgICAgICAgICAgJ8KkJzogJ3ZhbHV0YSdcbiAgICAgICAgfSxcblxuICAgICAgICAnZ3InOiB7fSxcblxuICAgICAgICAnaHUnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAndmVndGVsZW4nLFxuICAgICAgICAgICAgJ+KZpSc6ICdzemVyZWxlbScsXG4gICAgICAgICAgICAnJic6ICdlcycsXG4gICAgICAgICAgICAnfCc6ICd2YWd5JyxcbiAgICAgICAgICAgICc8JzogJ2tpc2ViYiBtaW50JyxcbiAgICAgICAgICAgICc+JzogJ25hZ3lvYmIgbWludCcsXG4gICAgICAgICAgICAn4oiRJzogJ3N6dW1tYScsXG4gICAgICAgICAgICAnwqQnOiAncGVuem5lbSdcbiAgICAgICAgfSxcblxuICAgICAgICAnaXQnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnaW5maW5pdG8nLFxuICAgICAgICAgICAgJ+KZpSc6ICdhbW9yZScsXG4gICAgICAgICAgICAnJic6ICdlJyxcbiAgICAgICAgICAgICd8JzogJ28nLFxuICAgICAgICAgICAgJzwnOiAnbWlub3JlIGRpJyxcbiAgICAgICAgICAgICc+JzogJ21hZ2dpb3JlIGRpJyxcbiAgICAgICAgICAgICfiiJEnOiAnc29tbWEnLFxuICAgICAgICAgICAgJ8KkJzogJ21vbmV0YSdcbiAgICAgICAgfSxcblxuICAgICAgICAnbHQnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnYmVnYWx5YmUnLFxuICAgICAgICAgICAgJ+KZpSc6ICdtZWlsZScsXG4gICAgICAgICAgICAnJic6ICdpcicsXG4gICAgICAgICAgICAnfCc6ICdhcicsXG4gICAgICAgICAgICAnPCc6ICdtYXppYXUgbmVpJyxcbiAgICAgICAgICAgICc+JzogJ2RhdWdpYXUgbmVpJyxcbiAgICAgICAgICAgICfiiJEnOiAnc3VtYScsXG4gICAgICAgICAgICAnwqQnOiAndmFsaXV0YSdcbiAgICAgICAgfSxcblxuICAgICAgICAnbHYnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnYmV6Z2FsaWJhJyxcbiAgICAgICAgICAgICfimaUnOiAnbWlsZXN0aWJhJyxcbiAgICAgICAgICAgICcmJzogJ3VuJyxcbiAgICAgICAgICAgICd8JzogJ3ZhaScsXG4gICAgICAgICAgICAnPCc6ICdtYXphayBuZWthJyxcbiAgICAgICAgICAgICc+JzogJ2xpZWxha3MgbmVrYScsXG4gICAgICAgICAgICAn4oiRJzogJ3N1bW1hJyxcbiAgICAgICAgICAgICfCpCc6ICd2YWx1dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ215Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdrd2Foa2h5YWV0JyxcbiAgICAgICAgICAgICfiiJ4nOiAnYXNhb25hc21lJyxcbiAgICAgICAgICAgICfimaUnOiAnYWtoeWFpdCcsXG4gICAgICAgICAgICAnJic6ICduaGluJyxcbiAgICAgICAgICAgICd8JzogJ3RobycsXG4gICAgICAgICAgICAnPCc6ICduZ2V0aGF3JyxcbiAgICAgICAgICAgICc+JzogJ2t5aXRoYXcnLFxuICAgICAgICAgICAgJ+KIkSc6ICdwYXVuZ2xkJyxcbiAgICAgICAgICAgICfCpCc6ICduZ3dla3llJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdtayc6IHt9LFxuXG4gICAgICAgICdubCc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdvbmVpbmRpZycsXG4gICAgICAgICAgICAn4pmlJzogJ2xpZWZkZScsXG4gICAgICAgICAgICAnJic6ICdlbicsXG4gICAgICAgICAgICAnfCc6ICdvZicsXG4gICAgICAgICAgICAnPCc6ICdrbGVpbmVyIGRhbicsXG4gICAgICAgICAgICAnPic6ICdncm90ZXIgZGFuJyxcbiAgICAgICAgICAgICfiiJEnOiAnc29tJyxcbiAgICAgICAgICAgICfCpCc6ICd2YWx1dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3BsJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ25pZXNrb25jem9ub3NjJyxcbiAgICAgICAgICAgICfimaUnOiAnbWlsb3NjJyxcbiAgICAgICAgICAgICcmJzogJ2knLFxuICAgICAgICAgICAgJ3wnOiAnbHViJyxcbiAgICAgICAgICAgICc8JzogJ21uaWVqc3plIG5peicsXG4gICAgICAgICAgICAnPic6ICd3aWVrc3plIG5peicsXG4gICAgICAgICAgICAn4oiRJzogJ3N1bWEnLFxuICAgICAgICAgICAgJ8KkJzogJ3dhbHV0YSdcbiAgICAgICAgfSxcblxuICAgICAgICAncHQnOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAnaW5maW5pdG8nLFxuICAgICAgICAgICAgJ+KZpSc6ICdhbW9yJyxcbiAgICAgICAgICAgICcmJzogJ2UnLFxuICAgICAgICAgICAgJ3wnOiAnb3UnLFxuICAgICAgICAgICAgJzwnOiAnbWVub3IgcXVlJyxcbiAgICAgICAgICAgICc+JzogJ21haW9yIHF1ZScsXG4gICAgICAgICAgICAn4oiRJzogJ3NvbWEnLFxuICAgICAgICAgICAgJ8KkJzogJ21vZWRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdybyc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdpbmZpbml0JyxcbiAgICAgICAgICAgICfimaUnOiAnZHJhZ29zdGUnLFxuICAgICAgICAgICAgJyYnOiAnc2knLFxuICAgICAgICAgICAgJ3wnOiAnc2F1JyxcbiAgICAgICAgICAgICc8JzogJ21haSBtaWMgY2EnLFxuICAgICAgICAgICAgJz4nOiAnbWFpIG1hcmUgY2EnLFxuICAgICAgICAgICAgJ+KIkSc6ICdzdW1hJyxcbiAgICAgICAgICAgICfCpCc6ICd2YWx1dGEnXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3J1Jzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2Jlc2tvbmVjaG5vJyxcbiAgICAgICAgICAgICfimaUnOiAnbHVib3YnLFxuICAgICAgICAgICAgJyYnOiAnaScsXG4gICAgICAgICAgICAnfCc6ICdpbGknLFxuICAgICAgICAgICAgJzwnOiAnbWVuc2hlJyxcbiAgICAgICAgICAgICc+JzogJ2JvbHNoZScsXG4gICAgICAgICAgICAn4oiRJzogJ3N1bW1hJyxcbiAgICAgICAgICAgICfCpCc6ICd2YWxqdXRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdzayc6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICduZWtvbmVjbm8nLFxuICAgICAgICAgICAgJ+KZpSc6ICdsYXNrYScsXG4gICAgICAgICAgICAnJic6ICdhJyxcbiAgICAgICAgICAgICd8JzogJ2FsZWJvJyxcbiAgICAgICAgICAgICc8JzogJ21lbmVqIGFrbycsXG4gICAgICAgICAgICAnPic6ICd2aWFjIGFrbycsXG4gICAgICAgICAgICAn4oiRJzogJ3N1Y2V0JyxcbiAgICAgICAgICAgICfCpCc6ICdtZW5hJ1xuICAgICAgICB9LFxuXG4gICAgICAgICdzcic6IHt9LFxuXG4gICAgICAgICd0cic6IHtcbiAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgJ+KInic6ICdzb25zdXpsdWsnLFxuICAgICAgICAgICAgJ+KZpSc6ICdhc2snLFxuICAgICAgICAgICAgJyYnOiAndmUnLFxuICAgICAgICAgICAgJ3wnOiAndmV5YScsXG4gICAgICAgICAgICAnPCc6ICdrdWN1a3R1cicsXG4gICAgICAgICAgICAnPic6ICdidXl1a3R1cicsXG4gICAgICAgICAgICAn4oiRJzogJ3RvcGxhbScsXG4gICAgICAgICAgICAnwqQnOiAncGFyYSBiaXJpbWknXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3VrJzoge1xuICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAn4oieJzogJ2JlemtpbmVjaG5pc3QnLFxuICAgICAgICAgICAgJ+KZpSc6ICdsdWJvdicsXG4gICAgICAgICAgICAnJic6ICdpJyxcbiAgICAgICAgICAgICd8JzogJ2FibycsXG4gICAgICAgICAgICAnPCc6ICdtZW5zaGUnLFxuICAgICAgICAgICAgJz4nOiAnYmlsc2hlJyxcbiAgICAgICAgICAgICfiiJEnOiAnc3VtYScsXG4gICAgICAgICAgICAnwqQnOiAndmFsanV0YSdcbiAgICAgICAgfSxcblxuICAgICAgICAndm4nOiB7XG4gICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICfiiJ4nOiAndm8gY3VjJyxcbiAgICAgICAgICAgICfimaUnOiAneWV1JyxcbiAgICAgICAgICAgICcmJzogJ3ZhJyxcbiAgICAgICAgICAgICd8JzogJ2hvYWMnLFxuICAgICAgICAgICAgJzwnOiAnbmhvIGhvbicsXG4gICAgICAgICAgICAnPic6ICdsb24gaG9uJyxcbiAgICAgICAgICAgICfiiJEnOiAndG9uZycsXG4gICAgICAgICAgICAnwqQnOiAndGllbiB0ZSdcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXJpY0NoYXJzID0gWyc7JywgJz8nLCAnOicsICdAJywgJyYnLCAnPScsICcrJywgJyQnLCAnLCcsICcvJ10uam9pbignJyk7XG5cbiAgICB2YXIgdXJpY05vU2xhc2hDaGFycyA9IFsnOycsICc/JywgJzonLCAnQCcsICcmJywgJz0nLCAnKycsICckJywgJywnXS5qb2luKCcnKTtcblxuICAgIHZhciBtYXJrQ2hhcnMgPSBbJy4nLCAnIScsICd+JywgJyonLCBcIidcIiwgJygnLCAnKSddLmpvaW4oJycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0U2x1Z1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaW5wdXQgaW5wdXQgc3RyaW5nXG4gICAgICogQHBhcmFtICB7b2JqZWN0fHN0cmluZ30gb3B0cyBjb25maWcgb2JqZWN0IG9yIHNlcGFyYXRvciBzdHJpbmcvY2hhclxuICAgICAqIEBhcGkgICAgcHVibGljXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgc2x1Z2dpZmllZCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgZ2V0U2x1ZyA9IGZ1bmN0aW9uIGdldFNsdWcoaW5wdXQsIG9wdHMpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICctJztcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgZGlhdHJpY1N0cmluZyA9ICcnO1xuICAgICAgICB2YXIgY29udmVydFN5bWJvbHMgPSB0cnVlO1xuICAgICAgICB2YXIgY3VzdG9tUmVwbGFjZW1lbnRzID0ge307XG4gICAgICAgIHZhciBtYWludGFpbkNhc2U7XG4gICAgICAgIHZhciB0aXRsZUNhc2U7XG4gICAgICAgIHZhciB0cnVuY2F0ZTtcbiAgICAgICAgdmFyIHVyaWNGbGFnO1xuICAgICAgICB2YXIgdXJpY05vU2xhc2hGbGFnO1xuICAgICAgICB2YXIgbWFya0ZsYWc7XG4gICAgICAgIHZhciBzeW1ib2w7XG4gICAgICAgIHZhciBsYW5nQ2hhcjtcbiAgICAgICAgdmFyIGx1Y2t5O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGNoO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgdmFyIGxhc3RDaGFyV2FzU3ltYm9sO1xuICAgICAgICB2YXIgbGFzdENoYXJXYXNEaWF0cmljO1xuICAgICAgICB2YXIgYWxsb3dlZENoYXJzID0gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG9wdHM7XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2wgPSBzeW1ib2xNYXAuZW47XG4gICAgICAgIGxhbmdDaGFyID0gbGFuZ0NoYXJNYXAuZW47XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbWFpbnRhaW5DYXNlID0gb3B0cy5tYWludGFpbkNhc2UgfHwgZmFsc2U7XG4gICAgICAgICAgICBjdXN0b21SZXBsYWNlbWVudHMgPSAob3B0cy5jdXN0b20gJiYgdHlwZW9mIG9wdHMuY3VzdG9tID09PSAnb2JqZWN0JykgPyBvcHRzLmN1c3RvbSA6IGN1c3RvbVJlcGxhY2VtZW50cztcbiAgICAgICAgICAgIHRydW5jYXRlID0gKCtvcHRzLnRydW5jYXRlID4gMSAmJiBvcHRzLnRydW5jYXRlKSB8fCBmYWxzZTtcbiAgICAgICAgICAgIHVyaWNGbGFnID0gb3B0cy51cmljIHx8IGZhbHNlO1xuICAgICAgICAgICAgdXJpY05vU2xhc2hGbGFnID0gb3B0cy51cmljTm9TbGFzaCB8fCBmYWxzZTtcbiAgICAgICAgICAgIG1hcmtGbGFnID0gb3B0cy5tYXJrIHx8IGZhbHNlO1xuICAgICAgICAgICAgY29udmVydFN5bWJvbHMgPSAob3B0cy5zeW1ib2xzID09PSBmYWxzZSB8fCBvcHRzLmxhbmcgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG9wdHMuc2VwYXJhdG9yIHx8IHNlcGFyYXRvcjtcblxuICAgICAgICAgICAgaWYgKHVyaWNGbGFnKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZENoYXJzICs9IHVyaWNDaGFycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVyaWNOb1NsYXNoRmxhZykge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRDaGFycyArPSB1cmljTm9TbGFzaENoYXJzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFya0ZsYWcpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hhcnMgKz0gbWFya0NoYXJzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzeW1ib2wgPSAob3B0cy5sYW5nICYmIHN5bWJvbE1hcFtvcHRzLmxhbmddICYmIGNvbnZlcnRTeW1ib2xzKSA/XG4gICAgICAgICAgICAgICAgc3ltYm9sTWFwW29wdHMubGFuZ10gOiAoY29udmVydFN5bWJvbHMgPyBzeW1ib2xNYXAuZW4gOiB7fSk7XG5cbiAgICAgICAgICAgIGxhbmdDaGFyID0gKG9wdHMubGFuZyAmJiBsYW5nQ2hhck1hcFtvcHRzLmxhbmddKSA/XG4gICAgICAgICAgICAgICAgbGFuZ0NoYXJNYXBbb3B0cy5sYW5nXSA6XG4gICAgICAgICAgICAgICAgb3B0cy5sYW5nID09PSBmYWxzZSB8fCBvcHRzLmxhbmcgPT09IHRydWUgPyB7fSA6IGxhbmdDaGFyTWFwLmVuO1xuXG4gICAgICAgICAgICAvLyBpZiB0aXRsZUNhc2UgY29uZmlnIGlzIGFuIEFycmF5LCByZXdyaXRlIHRvIG9iamVjdCBmb3JtYXRcbiAgICAgICAgICAgIGlmIChvcHRzLnRpdGxlQ2FzZSAmJiB0eXBlb2Ygb3B0cy50aXRsZUNhc2UubGVuZ3RoID09PSAnbnVtYmVyJyAmJiBBcnJheS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRzLnRpdGxlQ2FzZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnRpdGxlQ2FzZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVJlcGxhY2VtZW50c1t2ICsgJyddID0gdiArICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGl0bGVDYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGl0bGVDYXNlID0gISFvcHRzLnRpdGxlQ2FzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgY3VzdG9tIGNvbmZpZyBpcyBhbiBBcnJheSwgcmV3cml0ZSB0byBvYmplY3QgZm9ybWF0XG4gICAgICAgICAgICBpZiAob3B0cy5jdXN0b20gJiYgdHlwZW9mIG9wdHMuY3VzdG9tLmxlbmd0aCA9PT0gJ251bWJlcicgJiYgQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0cy5jdXN0b20pKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jdXN0b20uZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXBsYWNlbWVudHNbdiArICcnXSA9IHYgKyAnJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3VzdG9tIHJlcGxhY2VtZW50c1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3VzdG9tUmVwbGFjZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdmFyIHI7XG5cbiAgICAgICAgICAgICAgICBpZiAodi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyBlc2NhcGVDaGFycyh2KSArICdcXFxcYicsICdnaScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBuZXcgUmVnRXhwKGVzY2FwZUNoYXJzKHYpLCAnZ2knKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UociwgY3VzdG9tUmVwbGFjZW1lbnRzW3ZdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhZGQgYWxsIGN1c3RvbSByZXBsYWNlbWVudCB0byBhbGxvd2VkIGNoYXJsaXN0XG4gICAgICAgICAgICBmb3IgKGNoIGluIGN1c3RvbVJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRDaGFycyArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFsbG93ZWRDaGFycyArPSBzZXBhcmF0b3I7XG5cbiAgICAgICAgLy8gZXNjYXBlIGFsbCBuZWNlc3NhcnkgY2hhcnNcbiAgICAgICAgYWxsb3dlZENoYXJzID0gZXNjYXBlQ2hhcnMoYWxsb3dlZENoYXJzKTtcblxuICAgICAgICAvLyB0cmltIHdoaXRlc3BhY2VzXG4gICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCAnJyk7XG5cbiAgICAgICAgbGFzdENoYXJXYXNTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgbGFzdENoYXJXYXNEaWF0cmljID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY2ggPSBpbnB1dFtpXTtcblxuICAgICAgICAgICAgaWYgKGlzUmVwbGFjZWRDdXN0b21DaGFyKGNoLCBjdXN0b21SZXBsYWNlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgY29udmVydCBhIGFscmVhZHkgY29udmVydGVkIGNoYXJcbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc1N5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYW5nQ2hhcltjaF0pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGxhbmd1YWdlIHNwZWNpZmljIGRpYWN0cmljcyBjaGFycyBjb252ZXJzaW9uXG4gICAgICAgICAgICAgICAgY2ggPSBsYXN0Q2hhcldhc1N5bWJvbCAmJiBsYW5nQ2hhcltjaF0ubWF0Y2goL1tBLVphLXowLTldLykgPyAnICcgKyBsYW5nQ2hhcltjaF0gOiBsYW5nQ2hhcltjaF07XG5cbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc1N5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCBpbiBjaGFyTWFwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRyYW5zbGl0ZXJhdGlvbiBjaGFuZ2VzIGVudGlyZWx5IHdoZW4gc29tZSBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGFkZGVkXG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbCAmJiBsb29rQWhlYWRDaGFyQXJyYXkuaW5kZXhPZihpbnB1dFtpICsgMV0pID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlhdHJpY1N0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RDaGFyV2FzRGlhdHJpYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IGRpYXRyaWNNYXBbZGlhdHJpY1N0cmluZ10gKyBjaGFyTWFwW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgZGlhdHJpY1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgZGlhY3RyaWNzIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgIGNoID0gbGFzdENoYXJXYXNTeW1ib2wgJiYgY2hhck1hcFtjaF0ubWF0Y2goL1tBLVphLXowLTldLykgPyAnICcgKyBjaGFyTWFwW2NoXSA6IGNoYXJNYXBbY2hdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGFzdENoYXJXYXNEaWF0cmljID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoIGluIGRpYXRyaWNNYXApIHtcbiAgICAgICAgICAgICAgICBkaWF0cmljU3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gZW5kIG9mIHN0cmluZywgcHV0IHRoZSB3aG9sZSBtZWFuaW5nZnVsIHdvcmRcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc0RpYXRyaWMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHN5bWJvbCBjaGFyc1xuICAgICAgICAgICAgICAgIHN5bWJvbFtjaF0gJiYgISh1cmljRmxhZyAmJiB1cmljQ2hhcnNcbiAgICAgICAgICAgICAgICAgICAgLmluZGV4T2YoY2gpICE9PSAtMSkgJiYgISh1cmljTm9TbGFzaEZsYWcgJiYgdXJpY05vU2xhc2hDaGFyc1xuICAgICAgICAgICAgICAgICAgICAvLyAuaW5kZXhPZihjaCkgIT09IC0xKSAmJiAhKG1hcmtGbGFnICYmIG1hcmtDaGFyc1xuICAgICAgICAgICAgICAgICAgICAuaW5kZXhPZihjaCkgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIGNoID0gbGFzdENoYXJXYXNTeW1ib2wgfHwgcmVzdWx0LnN1YnN0cigtMSkubWF0Y2goL1tBLVphLXowLTldLykgPyBzZXBhcmF0b3IgKyBzeW1ib2xbY2hdIDogc3ltYm9sW2NoXTtcbiAgICAgICAgICAgICAgICBjaCArPSBpbnB1dFtpICsgMV0gIT09IHZvaWQgMCAmJiBpbnB1dFtpICsgMV0ubWF0Y2goL1tBLVphLXowLTldLykgPyBzZXBhcmF0b3IgOiAnJztcblxuICAgICAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDaGFyV2FzRGlhdHJpYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IGRpYXRyaWNNYXBbZGlhdHJpY1N0cmluZ10gKyBjaDtcbiAgICAgICAgICAgICAgICAgICAgZGlhdHJpY1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc0RpYXRyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RDaGFyV2FzU3ltYm9sICYmICgvW0EtWmEtejAtOV0vLnRlc3QoY2gpIHx8IHJlc3VsdC5zdWJzdHIoLTEpLm1hdGNoKC9BLVphLXowLTldLykpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgbGF0aW4gY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgY2ggPSAnICcgKyBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdENoYXJXYXNTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIGFsbG93ZWQgY2hhcnNcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1teXFxcXHdcXFxccycgKyBhbGxvd2VkQ2hhcnMgKyAnXy1dJywgJ2cnKSwgc2VwYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aXRsZUNhc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC8oXFx3KShcXFMqKS9nLCBmdW5jdGlvbiAoXywgaSwgcikge1xuICAgICAgICAgICAgICAgIHZhciBqID0gaS50b1VwcGVyQ2FzZSgpICsgKHIgIT09IG51bGwgPyByIDogJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmtleXMoY3VzdG9tUmVwbGFjZW1lbnRzKS5pbmRleE9mKGoudG9Mb3dlckNhc2UoKSkgPCAwKSA/IGogOiBqLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsaW1pbmF0ZSBkdXBsaWNhdGUgc2VwYXJhdG9yc1xuICAgICAgICAvLyBhZGQgc2VwYXJhdG9yXG4gICAgICAgIC8vIHRyaW0gc2VwYXJhdG9ycyBmcm9tIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xccysvZywgc2VwYXJhdG9yKVxuICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXCcgKyBzZXBhcmF0b3IgKyAnKycsICdnJyksIHNlcGFyYXRvcilcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJyheXFxcXCcgKyBzZXBhcmF0b3IgKyAnK3xcXFxcJyArIHNlcGFyYXRvciArICcrJCknLCAnZycpLCAnJyk7XG5cbiAgICAgICAgaWYgKHRydW5jYXRlICYmIHJlc3VsdC5sZW5ndGggPiB0cnVuY2F0ZSkge1xuICAgICAgICAgICAgbHVja3kgPSByZXN1bHQuY2hhckF0KHRydW5jYXRlKSA9PT0gc2VwYXJhdG9yO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHRydW5jYXRlKTtcblxuICAgICAgICAgICAgaWYgKCFsdWNreSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1haW50YWluQ2FzZSAmJiAhdGl0bGVDYXNlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZVNsdWcgY3VycmllZChvcHRzKShpbnB1dClcbiAgICAgKiBAcGFyYW0gICB7b2JqZWN0fHN0cmluZ30gb3B0cyBjb25maWcgb2JqZWN0IG9yIGlucHV0IHN0cmluZ1xuICAgICAqIEByZXR1cm4gIHtGdW5jdGlvbn0gZnVuY3Rpb24gZ2V0U2x1Z1dpdGhDb25maWcoKVxuICAgICAqKi9cbiAgICB2YXIgY3JlYXRlU2x1ZyA9IGZ1bmN0aW9uIGNyZWF0ZVNsdWcob3B0cykge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRTbHVnV2l0aENvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSBpbnB1dCBzdHJpbmdcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ30gc2x1ZyBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRTbHVnV2l0aENvbmZpZyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFNsdWcoaW5wdXQsIG9wdHMpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBlc2NhcGUgQ2hhcnNcbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSBpbnB1dCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgZXNjYXBlQ2hhcnMgPSBmdW5jdGlvbiBlc2NhcGVDaGFycyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy1cXFxcXiQqKz8uKCl8W1xcXXt9XFwvXS9nLCAnXFxcXCQmJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoZSBjaGFyIGlzIGFuIGFscmVhZHkgY29udmVydGVkIGNoYXIgZnJvbSBjdXN0b20gbGlzdFxuICAgICAqIEBwYXJhbSAgIHtjaGFyfSBjaCBjaGFyYWN0ZXIgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSBjdXN0b21SZXBsYWNlbWVudHMgY3VzdG9tIHRyYW5zbGF0aW9uIG1hcFxuICAgICAqL1xuICAgIHZhciBpc1JlcGxhY2VkQ3VzdG9tQ2hhciA9IGZ1bmN0aW9uIChjaCwgY3VzdG9tUmVwbGFjZW1lbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGMgaW4gY3VzdG9tUmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tUmVwbGFjZW1lbnRzW2NdID09PSBjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXG4gICAgICAgIC8vIGV4cG9ydCBmdW5jdGlvbnMgZm9yIHVzZSBpbiBOb2RlXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0U2x1ZztcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlU2x1ZyA9IGNyZWF0ZVNsdWc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cbiAgICAgICAgLy8gZXhwb3J0IGZ1bmN0aW9uIGZvciB1c2UgaW4gQU1EXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFNsdWc7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gZG9uJ3Qgb3ZlcndyaXRlIGdsb2JhbCBpZiBleGlzdHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyb290LmdldFNsdWcgfHwgcm9vdC5jcmVhdGVTbHVnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ3NwZWFraW5ndXJsOiBnbG9iYWxzIGV4aXN0cyAvKGdldFNsdWd8Y3JlYXRlU2x1ZykvJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdC5nZXRTbHVnID0gZ2V0U2x1ZztcbiAgICAgICAgICAgICAgICByb290LmNyZWF0ZVNsdWcgPSBjcmVhdGVTbHVnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbn0pKHRoaXMpOyIsIi8vIFRpbnlDb2xvciB2MS40LjFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZ3JpbnMvVGlueUNvbG9yXG4vLyBCcmlhbiBHcmluc3RlYWQsIE1JVCBMaWNlbnNlXG5cbihmdW5jdGlvbihNYXRoKSB7XG5cbnZhciB0cmltTGVmdCA9IC9eXFxzKy8sXG4gICAgdHJpbVJpZ2h0ID0gL1xccyskLyxcbiAgICB0aW55Q291bnRlciA9IDAsXG4gICAgbWF0aFJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICBtYXRoTWluID0gTWF0aC5taW4sXG4gICAgbWF0aE1heCA9IE1hdGgubWF4LFxuICAgIG1hdGhSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuZnVuY3Rpb24gdGlueWNvbG9yIChjb2xvciwgb3B0cykge1xuXG4gICAgY29sb3IgPSAoY29sb3IpID8gY29sb3IgOiAnJztcbiAgICBvcHRzID0gb3B0cyB8fCB7IH07XG5cbiAgICAvLyBJZiBpbnB1dCBpcyBhbHJlYWR5IGEgdGlueWNvbG9yLCByZXR1cm4gaXRzZWxmXG4gICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgdGlueWNvbG9yKSB7XG4gICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBhcmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGNhbGwgdXNpbmcgbmV3IGluc3RlYWRcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgdGlueWNvbG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IGlucHV0VG9SR0IoY29sb3IpO1xuICAgIHRoaXMuX29yaWdpbmFsSW5wdXQgPSBjb2xvcixcbiAgICB0aGlzLl9yID0gcmdiLnIsXG4gICAgdGhpcy5fZyA9IHJnYi5nLFxuICAgIHRoaXMuX2IgPSByZ2IuYixcbiAgICB0aGlzLl9hID0gcmdiLmEsXG4gICAgdGhpcy5fcm91bmRBID0gbWF0aFJvdW5kKDEwMCp0aGlzLl9hKSAvIDEwMCxcbiAgICB0aGlzLl9mb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCByZ2IuZm9ybWF0O1xuICAgIHRoaXMuX2dyYWRpZW50VHlwZSA9IG9wdHMuZ3JhZGllbnRUeXBlO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHRoZSByYW5nZSBvZiBbMCwyNTVdIGNvbWUgYmFjayBpbiBbMCwxXS5cbiAgICAvLyBQb3RlbnRpYWxseSBsb3NlIGEgbGl0dGxlIGJpdCBvZiBwcmVjaXNpb24gaGVyZSwgYnV0IHdpbGwgZml4IGlzc3VlcyB3aGVyZVxuICAgIC8vIC41IGdldHMgaW50ZXJwcmV0ZWQgYXMgaGFsZiBvZiB0aGUgdG90YWwsIGluc3RlYWQgb2YgaGFsZiBvZiAxXG4gICAgLy8gSWYgaXQgd2FzIHN1cHBvc2VkIHRvIGJlIDEyOCwgdGhpcyB3YXMgYWxyZWFkeSB0YWtlbiBjYXJlIG9mIGJ5IGBpbnB1dFRvUmdiYFxuICAgIGlmICh0aGlzLl9yIDwgMSkgeyB0aGlzLl9yID0gbWF0aFJvdW5kKHRoaXMuX3IpOyB9XG4gICAgaWYgKHRoaXMuX2cgPCAxKSB7IHRoaXMuX2cgPSBtYXRoUm91bmQodGhpcy5fZyk7IH1cbiAgICBpZiAodGhpcy5fYiA8IDEpIHsgdGhpcy5fYiA9IG1hdGhSb3VuZCh0aGlzLl9iKTsgfVxuXG4gICAgdGhpcy5fb2sgPSByZ2Iub2s7XG4gICAgdGhpcy5fdGNfaWQgPSB0aW55Q291bnRlcisrO1xufVxuXG50aW55Y29sb3IucHJvdG90eXBlID0ge1xuICAgIGlzRGFyazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJyaWdodG5lc3MoKSA8IDEyODtcbiAgICB9LFxuICAgIGlzTGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEYXJrKCk7XG4gICAgfSxcbiAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29rO1xuICAgIH0sXG4gICAgZ2V0T3JpZ2luYWxJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxJbnB1dDtcbiAgICB9LFxuICAgIGdldEZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XG4gICAgfSxcbiAgICBnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgIH0sXG4gICAgZ2V0QnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vaHR0cDovL3d3dy53My5vcmcvVFIvQUVSVCNjb2xvci1jb250cmFzdFxuICAgICAgICB2YXIgcmdiID0gdGhpcy50b1JnYigpO1xuICAgICAgICByZXR1cm4gKHJnYi5yICogMjk5ICsgcmdiLmcgKiA1ODcgKyByZ2IuYiAqIDExNCkgLyAxMDAwO1xuICAgIH0sXG4gICAgZ2V0THVtaW5hbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHZhciBSc1JHQiwgR3NSR0IsIEJzUkdCLCBSLCBHLCBCO1xuICAgICAgICBSc1JHQiA9IHJnYi5yLzI1NTtcbiAgICAgICAgR3NSR0IgPSByZ2IuZy8yNTU7XG4gICAgICAgIEJzUkdCID0gcmdiLmIvMjU1O1xuXG4gICAgICAgIGlmIChSc1JHQiA8PSAwLjAzOTI4KSB7UiA9IFJzUkdCIC8gMTIuOTI7fSBlbHNlIHtSID0gTWF0aC5wb3coKChSc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIGlmIChHc1JHQiA8PSAwLjAzOTI4KSB7RyA9IEdzUkdCIC8gMTIuOTI7fSBlbHNlIHtHID0gTWF0aC5wb3coKChHc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIGlmIChCc1JHQiA8PSAwLjAzOTI4KSB7QiA9IEJzUkdCIC8gMTIuOTI7fSBlbHNlIHtCID0gTWF0aC5wb3coKChCc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIHJldHVybiAoMC4yMTI2ICogUikgKyAoMC43MTUyICogRykgKyAoMC4wNzIyICogQik7XG4gICAgfSxcbiAgICBzZXRBbHBoYTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYSA9IGJvdW5kQWxwaGEodmFsdWUpO1xuICAgICAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvSHN2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICByZXR1cm4geyBoOiBoc3YuaCAqIDM2MCwgczogaHN2LnMsIHY6IGhzdi52LCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b0hzdlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc3YgPSByZ2JUb0hzdih0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgdmFyIGggPSBtYXRoUm91bmQoaHN2LmggKiAzNjApLCBzID0gbWF0aFJvdW5kKGhzdi5zICogMTAwKSwgdiA9IG1hdGhSb3VuZChoc3YudiAqIDEwMCk7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJoc3YoXCIgICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdiArIFwiJSlcIiA6XG4gICAgICAgICAgXCJoc3ZhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdiArIFwiJSwgXCIrIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9Ic2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzbC5oICogMzYwLCBzOiBoc2wucywgbDogaHNsLmwsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHNsU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzbCA9IHJnYlRvSHNsKHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc2wuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHNsLnMgKiAxMDApLCBsID0gbWF0aFJvdW5kKGhzbC5sICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzbChcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzbGEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hleDogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICByZXR1cm4gcmdiVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgYWxsb3czQ2hhcik7XG4gICAgfSxcbiAgICB0b0hleFN0cmluZzogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy50b0hleChhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4ODogZnVuY3Rpb24oYWxsb3c0Q2hhcikge1xuICAgICAgICByZXR1cm4gcmdiYVRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRoaXMuX2EsIGFsbG93NENoYXIpO1xuICAgIH0sXG4gICAgdG9IZXg4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzRDaGFyKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4OChhbGxvdzRDaGFyKTtcbiAgICB9LFxuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKHRoaXMuX3IpLCBnOiBtYXRoUm91bmQodGhpcy5fZyksIGI6IG1hdGhSb3VuZCh0aGlzLl9iKSwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9SZ2JTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwicmdiKFwiICArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiKVwiIDpcbiAgICAgICAgICBcInJnYmEoXCIgKyBtYXRoUm91bmQodGhpcy5fcikgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fZykgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fYikgKyBcIiwgXCIgKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvUGVyY2VudGFnZVJnYjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGc6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlXCIsIGI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvUGVyY2VudGFnZVJnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9OYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2EgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXhOYW1lc1tyZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0cnVlKV0gfHwgZmFsc2U7XG4gICAgfSxcbiAgICB0b0ZpbHRlcjogZnVuY3Rpb24oc2Vjb25kQ29sb3IpIHtcbiAgICAgICAgdmFyIGhleDhTdHJpbmcgPSAnIycgKyByZ2JhVG9BcmdiSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRoaXMuX2EpO1xuICAgICAgICB2YXIgc2Vjb25kSGV4OFN0cmluZyA9IGhleDhTdHJpbmc7XG4gICAgICAgIHZhciBncmFkaWVudFR5cGUgPSB0aGlzLl9ncmFkaWVudFR5cGUgPyBcIkdyYWRpZW50VHlwZSA9IDEsIFwiIDogXCJcIjtcblxuICAgICAgICBpZiAoc2Vjb25kQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGlueWNvbG9yKHNlY29uZENvbG9yKTtcbiAgICAgICAgICAgIHNlY29uZEhleDhTdHJpbmcgPSAnIycgKyByZ2JhVG9BcmdiSGV4KHMuX3IsIHMuX2csIHMuX2IsIHMuX2EpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KFwiK2dyYWRpZW50VHlwZStcInN0YXJ0Q29sb3JzdHI9XCIraGV4OFN0cmluZytcIixlbmRDb2xvcnN0cj1cIitzZWNvbmRIZXg4U3RyaW5nK1wiKVwiO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgZm9ybWF0U2V0ID0gISFmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLl9mb3JtYXQ7XG5cbiAgICAgICAgdmFyIGZvcm1hdHRlZFN0cmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFzQWxwaGEgPSB0aGlzLl9hIDwgMSAmJiB0aGlzLl9hID49IDA7XG4gICAgICAgIHZhciBuZWVkc0FscGhhRm9ybWF0ID0gIWZvcm1hdFNldCAmJiBoYXNBbHBoYSAmJiAoZm9ybWF0ID09PSBcImhleFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg2XCIgfHwgZm9ybWF0ID09PSBcImhleDNcIiB8fCBmb3JtYXQgPT09IFwiaGV4NFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg4XCIgfHwgZm9ybWF0ID09PSBcIm5hbWVcIik7XG5cbiAgICAgICAgaWYgKG5lZWRzQWxwaGFGb3JtYXQpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgXCJ0cmFuc3BhcmVudFwiLCBhbGwgb3RoZXIgbm9uLWFscGhhIGZvcm1hdHNcbiAgICAgICAgICAgIC8vIHdpbGwgcmV0dXJuIHJnYmEgd2hlbiB0aGVyZSBpcyB0cmFuc3BhcmVuY3kuXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIiAmJiB0aGlzLl9hID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9OYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicmdiXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcInByZ2JcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1BlcmNlbnRhZ2VSZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg2XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDNcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDRcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXg4XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXg4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9OYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc2xcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzbFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaHN2XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic3ZTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdHJpbmcgfHwgdGhpcy50b0hleFN0cmluZygpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGlueWNvbG9yKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIF9hcHBseU1vZGlmaWNhdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gZm4uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgICAgIHRoaXMuX3IgPSBjb2xvci5fcjtcbiAgICAgICAgdGhpcy5fZyA9IGNvbG9yLl9nO1xuICAgICAgICB0aGlzLl9iID0gY29sb3IuX2I7XG4gICAgICAgIHRoaXMuc2V0QWxwaGEoY29sb3IuX2EpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGxpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24obGlnaHRlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGJyaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGJyaWdodGVuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZGFya2VuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGRhcmtlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGRlc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGVzYXR1cmF0ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKHNhdHVyYXRlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZ3JleXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGdyZXlzY2FsZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNwaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc3BpbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5Q29tYmluYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICB9LFxuICAgIGFuYWxvZ291czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKGFuYWxvZ291cywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihjb21wbGVtZW50LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbW9ub2Nocm9tYXRpYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKG1vbm9jaHJvbWF0aWMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzcGxpdGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihzcGxpdGNvbXBsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0cmlhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHRyaWFkLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgdGV0cmFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24odGV0cmFkLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbi8vIElmIGlucHV0IGlzIGFuIG9iamVjdCwgZm9yY2UgMSBpbnRvIFwiMS4wXCIgdG8gaGFuZGxlIHJhdGlvcyBwcm9wZXJseVxuLy8gU3RyaW5nIGlucHV0IHJlcXVpcmVzIFwiMS4wXCIgYXMgaW5wdXQsIHNvIDEgd2lsbCBiZSB0cmVhdGVkIGFzIDFcbnRpbnljb2xvci5mcm9tUmF0aW8gPSBmdW5jdGlvbihjb2xvciwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgbmV3Q29sb3IgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBjb2xvcikge1xuICAgICAgICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29sb3JbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2xvcltpXSA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3JbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IG5ld0NvbG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IsIG9wdHMpO1xufTtcblxuLy8gR2l2ZW4gYSBzdHJpbmcgb3Igb2JqZWN0LCBjb252ZXJ0IHRoYXQgaW5wdXQgdG8gUkdCXG4vLyBQb3NzaWJsZSBzdHJpbmcgaW5wdXRzOlxuLy9cbi8vICAgICBcInJlZFwiXG4vLyAgICAgXCIjZjAwXCIgb3IgXCJmMDBcIlxuLy8gICAgIFwiI2ZmMDAwMFwiIG9yIFwiZmYwMDAwXCJcbi8vICAgICBcIiNmZjAwMDAwMFwiIG9yIFwiZmYwMDAwMDBcIlxuLy8gICAgIFwicmdiIDI1NSAwIDBcIiBvciBcInJnYiAoMjU1LCAwLCAwKVwiXG4vLyAgICAgXCJyZ2IgMS4wIDAgMFwiIG9yIFwicmdiICgxLCAwLCAwKVwiXG4vLyAgICAgXCJyZ2JhICgyNTUsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDI1NSwgMCwgMCwgMVwiXG4vLyAgICAgXCJyZ2JhICgxLjAsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDEuMCwgMCwgMCwgMVwiXG4vLyAgICAgXCJoc2woMCwgMTAwJSwgNTAlKVwiIG9yIFwiaHNsIDAgMTAwJSA1MCVcIlxuLy8gICAgIFwiaHNsYSgwLCAxMDAlLCA1MCUsIDEpXCIgb3IgXCJoc2xhIDAgMTAwJSA1MCUsIDFcIlxuLy8gICAgIFwiaHN2KDAsIDEwMCUsIDEwMCUpXCIgb3IgXCJoc3YgMCAxMDAlIDEwMCVcIlxuLy9cbmZ1bmN0aW9uIGlucHV0VG9SR0IoY29sb3IpIHtcblxuICAgIHZhciByZ2IgPSB7IHI6IDAsIGc6IDAsIGI6IDAgfTtcbiAgICB2YXIgYSA9IDE7XG4gICAgdmFyIHMgPSBudWxsO1xuICAgIHZhciB2ID0gbnVsbDtcbiAgICB2YXIgbCA9IG51bGw7XG4gICAgdmFyIG9rID0gZmFsc2U7XG4gICAgdmFyIGZvcm1hdCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbG9yID0gc3RyaW5nSW5wdXRUb09iamVjdChjb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5yKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5nKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5iKSkge1xuICAgICAgICAgICAgcmdiID0gcmdiVG9SZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBTdHJpbmcoY29sb3Iucikuc3Vic3RyKC0xKSA9PT0gXCIlXCIgPyBcInByZ2JcIiA6IFwicmdiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZENTU1VuaXQoY29sb3IuaCkgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IucykgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IudikpIHtcbiAgICAgICAgICAgIHMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICAgICAgdiA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iudik7XG4gICAgICAgICAgICByZ2IgPSBoc3ZUb1JnYihjb2xvci5oLCBzLCB2KTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiaHN2XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZENTU1VuaXQoY29sb3IuaCkgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IucykgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IubCkpIHtcbiAgICAgICAgICAgIHMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICAgICAgbCA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3IubCk7XG4gICAgICAgICAgICByZ2IgPSBoc2xUb1JnYihjb2xvci5oLCBzLCBsKTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiaHNsXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJhXCIpKSB7XG4gICAgICAgICAgICBhID0gY29sb3IuYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGEgPSBib3VuZEFscGhhKGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2s6IG9rLFxuICAgICAgICBmb3JtYXQ6IGNvbG9yLmZvcm1hdCB8fCBmb3JtYXQsXG4gICAgICAgIHI6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5yLCAwKSksXG4gICAgICAgIGc6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5nLCAwKSksXG4gICAgICAgIGI6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5iLCAwKSksXG4gICAgICAgIGE6IGFcbiAgICB9O1xufVxuXG5cbi8vIENvbnZlcnNpb24gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBgcmdiVG9Ic2xgLCBgcmdiVG9Ic3ZgLCBgaHNsVG9SZ2JgLCBgaHN2VG9SZ2JgIG1vZGlmaWVkIGZyb206XG4vLyA8aHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdD5cblxuLy8gYHJnYlRvUmdiYFxuLy8gSGFuZGxlIGJvdW5kcyAvIHBlcmNlbnRhZ2UgY2hlY2tpbmcgdG8gY29uZm9ybSB0byBDU1MgY29sb3Igc3BlY1xuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvPlxuLy8gKkFzc3VtZXM6KiByLCBnLCBiIGluIFswLCAyNTVdIG9yIFswLCAxXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiBbMCwgMjU1XVxuZnVuY3Rpb24gcmdiVG9SZ2IociwgZywgYil7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogYm91bmQwMShyLCAyNTUpICogMjU1LFxuICAgICAgICBnOiBib3VuZDAxKGcsIDI1NSkgKiAyNTUsXG4gICAgICAgIGI6IGJvdW5kMDEoYiwgMjU1KSAqIDI1NVxuICAgIH07XG59XG5cbi8vIGByZ2JUb0hzbGBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU0wuXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgaCwgcywgbCB9IGluIFswLDFdXG5mdW5jdGlvbiByZ2JUb0hzbChyLCBnLCBiKSB7XG5cbiAgICByID0gYm91bmQwMShyLCAyNTUpO1xuICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgYiA9IGJvdW5kMDEoYiwgMjU1KTtcblxuICAgIHZhciBtYXggPSBtYXRoTWF4KHIsIGcsIGIpLCBtaW4gPSBtYXRoTWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYobWF4ID09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgIHN3aXRjaChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cblxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIGw6IGwgfTtcbn1cblxuLy8gYGhzbFRvUmdiYFxuLy8gQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi5cbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCBsIGFyZSBjb250YWluZWQgWzAsIDFdIG9yIFswLCAxMDBdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIHRoZSBzZXQgWzAsIDI1NV1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgICB2YXIgciwgZywgYjtcblxuICAgIGggPSBib3VuZDAxKGgsIDM2MCk7XG4gICAgcyA9IGJvdW5kMDEocywgMTAwKTtcbiAgICBsID0gYm91bmQwMShsLCAxMDApO1xuXG4gICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgaWYocyA9PT0gMCkge1xuICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcbiAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfTtcbn1cblxuLy8gYHJnYlRvSHN2YFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTVlxuLy8gKkFzc3VtZXM6KiByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgaCwgcywgdiB9IGluIFswLDFdXG5mdW5jdGlvbiByZ2JUb0hzdihyLCBnLCBiKSB7XG5cbiAgICByID0gYm91bmQwMShyLCAyNTUpO1xuICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgYiA9IGJvdW5kMDEoYiwgMjU1KTtcblxuICAgIHZhciBtYXggPSBtYXRoTWF4KHIsIGcsIGIpLCBtaW4gPSBtYXRoTWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCB2ID0gbWF4O1xuXG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xuXG4gICAgaWYobWF4ID09IG1pbikge1xuICAgICAgICBoID0gMDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCB2OiB2IH07XG59XG5cbi8vIGBoc3ZUb1JnYmBcbi8vIENvbnZlcnRzIGFuIEhTViBjb2xvciB2YWx1ZSB0byBSR0IuXG4vLyAqQXNzdW1lczoqIGggaXMgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMzYwXSBhbmQgcyBhbmQgdiBhcmUgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMTAwXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiB0aGUgc2V0IFswLCAyNTVdXG4gZnVuY3Rpb24gaHN2VG9SZ2IoaCwgcywgdikge1xuXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKSAqIDY7XG4gICAgcyA9IGJvdW5kMDEocywgMTAwKTtcbiAgICB2ID0gYm91bmQwMSh2LCAxMDApO1xuXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKGgpLFxuICAgICAgICBmID0gaCAtIGksXG4gICAgICAgIHAgPSB2ICogKDEgLSBzKSxcbiAgICAgICAgcSA9IHYgKiAoMSAtIGYgKiBzKSxcbiAgICAgICAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKSxcbiAgICAgICAgbW9kID0gaSAlIDYsXG4gICAgICAgIHIgPSBbdiwgcSwgcCwgcCwgdCwgdl1bbW9kXSxcbiAgICAgICAgZyA9IFt0LCB2LCB2LCBxLCBwLCBwXVttb2RdLFxuICAgICAgICBiID0gW3AsIHAsIHQsIHYsIHYsIHFdW21vZF07XG5cbiAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XG59XG5cbi8vIGByZ2JUb0hleGBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB0byBoZXhcbi8vIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdXG4vLyBSZXR1cm5zIGEgMyBvciA2IGNoYXJhY3RlciBoZXhcbmZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIsIGFsbG93M0NoYXIpIHtcblxuICAgIHZhciBoZXggPSBbXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSlcbiAgICBdO1xuXG4gICAgLy8gUmV0dXJuIGEgMyBjaGFyYWN0ZXIgaGV4IGlmIHBvc3NpYmxlXG4gICAgaWYgKGFsbG93M0NoYXIgJiYgaGV4WzBdLmNoYXJBdCgwKSA9PSBoZXhbMF0uY2hhckF0KDEpICYmIGhleFsxXS5jaGFyQXQoMCkgPT0gaGV4WzFdLmNoYXJBdCgxKSAmJiBoZXhbMl0uY2hhckF0KDApID09IGhleFsyXS5jaGFyQXQoMSkpIHtcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGByZ2JhVG9IZXhgXG4vLyBDb252ZXJ0cyBhbiBSR0JBIGNvbG9yIHBsdXMgYWxwaGEgdHJhbnNwYXJlbmN5IHRvIGhleFxuLy8gQXNzdW1lcyByLCBnLCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBhbmRcbi8vIGEgaW4gWzAsIDFdLiBSZXR1cm5zIGEgNCBvciA4IGNoYXJhY3RlciByZ2JhIGhleFxuZnVuY3Rpb24gcmdiYVRvSGV4KHIsIGcsIGIsIGEsIGFsbG93NENoYXIpIHtcblxuICAgIHZhciBoZXggPSBbXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIoY29udmVydERlY2ltYWxUb0hleChhKSlcbiAgICBdO1xuXG4gICAgLy8gUmV0dXJuIGEgNCBjaGFyYWN0ZXIgaGV4IGlmIHBvc3NpYmxlXG4gICAgaWYgKGFsbG93NENoYXIgJiYgaGV4WzBdLmNoYXJBdCgwKSA9PSBoZXhbMF0uY2hhckF0KDEpICYmIGhleFsxXS5jaGFyQXQoMCkgPT0gaGV4WzFdLmNoYXJBdCgxKSAmJiBoZXhbMl0uY2hhckF0KDApID09IGhleFsyXS5jaGFyQXQoMSkgJiYgaGV4WzNdLmNoYXJBdCgwKSA9PSBoZXhbM10uY2hhckF0KDEpKSB7XG4gICAgICAgIHJldHVybiBoZXhbMF0uY2hhckF0KDApICsgaGV4WzFdLmNoYXJBdCgwKSArIGhleFsyXS5jaGFyQXQoMCkgKyBoZXhbM10uY2hhckF0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYHJnYmFUb0FyZ2JIZXhgXG4vLyBDb252ZXJ0cyBhbiBSR0JBIGNvbG9yIHRvIGFuIEFSR0IgSGV4OCBzdHJpbmdcbi8vIFJhcmVseSB1c2VkLCBidXQgcmVxdWlyZWQgZm9yIFwidG9GaWx0ZXIoKVwiXG5mdW5jdGlvbiByZ2JhVG9BcmdiSGV4KHIsIGcsIGIsIGEpIHtcblxuICAgIHZhciBoZXggPSBbXG4gICAgICAgIHBhZDIoY29udmVydERlY2ltYWxUb0hleChhKSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSlcbiAgICBdO1xuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgZXF1YWxzYFxuLy8gQ2FuIGJlIGNhbGxlZCB3aXRoIGFueSB0aW55Y29sb3IgaW5wdXRcbnRpbnljb2xvci5lcXVhbHMgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIpIHtcbiAgICBpZiAoIWNvbG9yMSB8fCAhY29sb3IyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IxKS50b1JnYlN0cmluZygpID09IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiU3RyaW5nKCk7XG59O1xuXG50aW55Y29sb3IucmFuZG9tID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvci5mcm9tUmF0aW8oe1xuICAgICAgICByOiBtYXRoUmFuZG9tKCksXG4gICAgICAgIGc6IG1hdGhSYW5kb20oKSxcbiAgICAgICAgYjogbWF0aFJhbmRvbSgpXG4gICAgfSk7XG59O1xuXG5cbi8vIE1vZGlmaWNhdGlvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoYW5rcyB0byBsZXNzLmpzIGZvciBzb21lIG9mIHRoZSBiYXNpY3MgaGVyZVxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGhlYWQvbGVzcy5qcy9ibG9iL21hc3Rlci9saWIvbGVzcy9mdW5jdGlvbnMuanM+XG5cbmZ1bmN0aW9uIGRlc2F0dXJhdGUoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLnMgLT0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5zID0gY2xhbXAwMShoc2wucyk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiBzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wucyArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIGdyZXlzY2FsZShjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmRlc2F0dXJhdGUoMTAwKTtcbn1cblxuZnVuY3Rpb24gbGlnaHRlbiAoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmwgKz0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5sID0gY2xhbXAwMShoc2wubCk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiBicmlnaHRlbihjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIHJnYiA9IHRpbnljb2xvcihjb2xvcikudG9SZ2IoKTtcbiAgICByZ2IuciA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5yIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmdiLmcgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuZyAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJnYi5iID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLmIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKHJnYik7XG59XG5cbmZ1bmN0aW9uIGRhcmtlbiAoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmwgLT0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5sID0gY2xhbXAwMShoc2wubCk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG4vLyBTcGluIHRha2VzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgYW1vdW50IHdpdGhpbiBbLTM2MCwgMzYwXSBpbmRpY2F0aW5nIHRoZSBjaGFuZ2Ugb2YgaHVlLlxuLy8gVmFsdWVzIG91dHNpZGUgb2YgdGhpcyByYW5nZSB3aWxsIGJlIHdyYXBwZWQgaW50byB0aGlzIHJhbmdlLlxuZnVuY3Rpb24gc3Bpbihjb2xvciwgYW1vdW50KSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaHVlID0gKGhzbC5oICsgYW1vdW50KSAlIDM2MDtcbiAgICBoc2wuaCA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG4vLyBDb21iaW5hdGlvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGpRdWVyeSB4Q29sb3IgZm9yIHNvbWUgb2YgdGhlIGlkZWFzIGJlaGluZCB0aGVzZVxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmZ1c2lvbi9qUXVlcnkteGNvbG9yL2Jsb2IvbWFzdGVyL2pxdWVyeS54Y29sb3IuanM+XG5cbmZ1bmN0aW9uIGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5oID0gKGhzbC5oICsgMTgwKSAlIDM2MDtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHRyaWFkKGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTIwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI0MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHRldHJhZChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDkwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDE4MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyNzApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBzcGxpdGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyA3MikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDIxNikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gYW5hbG9nb3VzKGNvbG9yLCByZXN1bHRzLCBzbGljZXMpIHtcbiAgICByZXN1bHRzID0gcmVzdWx0cyB8fCA2O1xuICAgIHNsaWNlcyA9IHNsaWNlcyB8fCAzMDtcblxuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIHBhcnQgPSAzNjAgLyBzbGljZXM7XG4gICAgdmFyIHJldCA9IFt0aW55Y29sb3IoY29sb3IpXTtcblxuICAgIGZvciAoaHNsLmggPSAoKGhzbC5oIC0gKHBhcnQgKiByZXN1bHRzID4+IDEpKSArIDcyMCkgJSAzNjA7IC0tcmVzdWx0czsgKSB7XG4gICAgICAgIGhzbC5oID0gKGhzbC5oICsgcGFydCkgJSAzNjA7XG4gICAgICAgIHJldC5wdXNoKHRpbnljb2xvcihoc2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbW9ub2Nocm9tYXRpYyhjb2xvciwgcmVzdWx0cykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XG4gICAgdmFyIGhzdiA9IHRpbnljb2xvcihjb2xvcikudG9Ic3YoKTtcbiAgICB2YXIgaCA9IGhzdi5oLCBzID0gaHN2LnMsIHYgPSBoc3YudjtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIG1vZGlmaWNhdGlvbiA9IDEgLyByZXN1bHRzO1xuXG4gICAgd2hpbGUgKHJlc3VsdHMtLSkge1xuICAgICAgICByZXQucHVzaCh0aW55Y29sb3IoeyBoOiBoLCBzOiBzLCB2OiB2fSkpO1xuICAgICAgICB2ID0gKHYgKyBtb2RpZmljYXRpb24pICUgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnRpbnljb2xvci5taXggPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCA1MCk7XG5cbiAgICB2YXIgcmdiMSA9IHRpbnljb2xvcihjb2xvcjEpLnRvUmdiKCk7XG4gICAgdmFyIHJnYjIgPSB0aW55Y29sb3IoY29sb3IyKS50b1JnYigpO1xuXG4gICAgdmFyIHAgPSBhbW91bnQgLyAxMDA7XG5cbiAgICB2YXIgcmdiYSA9IHtcbiAgICAgICAgcjogKChyZ2IyLnIgLSByZ2IxLnIpICogcCkgKyByZ2IxLnIsXG4gICAgICAgIGc6ICgocmdiMi5nIC0gcmdiMS5nKSAqIHApICsgcmdiMS5nLFxuICAgICAgICBiOiAoKHJnYjIuYiAtIHJnYjEuYikgKiBwKSArIHJnYjEuYixcbiAgICAgICAgYTogKChyZ2IyLmEgLSByZ2IxLmEpICogcCkgKyByZ2IxLmFcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRpbnljb2xvcihyZ2JhKTtcbn07XG5cblxuLy8gUmVhZGFiaWxpdHkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmIChXQ0FHIFZlcnNpb24gMilcblxuLy8gYGNvbnRyYXN0YFxuLy8gQW5hbHl6ZSB0aGUgMiBjb2xvcnMgYW5kIHJldHVybnMgdGhlIGNvbG9yIGNvbnRyYXN0IGRlZmluZWQgYnkgKFdDQUcgVmVyc2lvbiAyKVxudGlueWNvbG9yLnJlYWRhYmlsaXR5ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcbiAgICB2YXIgYzEgPSB0aW55Y29sb3IoY29sb3IxKTtcbiAgICB2YXIgYzIgPSB0aW55Y29sb3IoY29sb3IyKTtcbiAgICByZXR1cm4gKE1hdGgubWF4KGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KSAvIChNYXRoLm1pbihjMS5nZXRMdW1pbmFuY2UoKSxjMi5nZXRMdW1pbmFuY2UoKSkrMC4wNSk7XG59O1xuXG4vLyBgaXNSZWFkYWJsZWBcbi8vIEVuc3VyZSB0aGF0IGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgY29tYmluYXRpb25zIG1lZXQgV0NBRzIgZ3VpZGVsaW5lcy5cbi8vIFRoZSB0aGlyZCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBPYmplY3QuXG4vLyAgICAgIHRoZSAnbGV2ZWwnIHByb3BlcnR5IHN0YXRlcyAnQUEnIG9yICdBQUEnIC0gaWYgbWlzc2luZyBvciBpbnZhbGlkLCBpdCBkZWZhdWx0cyB0byAnQUEnO1xuLy8gICAgICB0aGUgJ3NpemUnIHByb3BlcnR5IHN0YXRlcyAnbGFyZ2UnIG9yICdzbWFsbCcgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdzbWFsbCcuXG4vLyBJZiB0aGUgZW50aXJlIG9iamVjdCBpcyBhYnNlbnQsIGlzUmVhZGFibGUgZGVmYXVsdHMgdG8ge2xldmVsOlwiQUFcIixzaXplOlwic21hbGxcIn0uXG5cbi8vICpFeGFtcGxlKlxuLy8gICAgdGlueWNvbG9yLmlzUmVhZGFibGUoXCIjMDAwXCIsIFwiIzExMVwiKSA9PiBmYWxzZVxuLy8gICAgdGlueWNvbG9yLmlzUmVhZGFibGUoXCIjMDAwXCIsIFwiIzExMVwiLHtsZXZlbDpcIkFBXCIsc2l6ZTpcImxhcmdlXCJ9KSA9PiBmYWxzZVxudGlueWNvbG9yLmlzUmVhZGFibGUgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgd2NhZzIpIHtcbiAgICB2YXIgcmVhZGFiaWxpdHkgPSB0aW55Y29sb3IucmVhZGFiaWxpdHkoY29sb3IxLCBjb2xvcjIpO1xuICAgIHZhciB3Y2FnMlBhcm1zLCBvdXQ7XG5cbiAgICBvdXQgPSBmYWxzZTtcblxuICAgIHdjYWcyUGFybXMgPSB2YWxpZGF0ZVdDQUcyUGFybXMod2NhZzIpO1xuICAgIHN3aXRjaCAod2NhZzJQYXJtcy5sZXZlbCArIHdjYWcyUGFybXMuc2l6ZSkge1xuICAgICAgICBjYXNlIFwiQUFzbWFsbFwiOlxuICAgICAgICBjYXNlIFwiQUFBbGFyZ2VcIjpcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDQuNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQUFBc21hbGxcIjpcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcblxufTtcblxuLy8gYG1vc3RSZWFkYWJsZWBcbi8vIEdpdmVuIGEgYmFzZSBjb2xvciBhbmQgYSBsaXN0IG9mIHBvc3NpYmxlIGZvcmVncm91bmQgb3IgYmFja2dyb3VuZFxuLy8gY29sb3JzIGZvciB0aGF0IGJhc2UsIHJldHVybnMgdGhlIG1vc3QgcmVhZGFibGUgY29sb3IuXG4vLyBPcHRpb25hbGx5IHJldHVybnMgQmxhY2sgb3IgV2hpdGUgaWYgdGhlIG1vc3QgcmVhZGFibGUgY29sb3IgaXMgdW5yZWFkYWJsZS5cbi8vICpFeGFtcGxlKlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOmZhbHNlfSkudG9IZXhTdHJpbmcoKTsgLy8gXCIjMTEyMjU1XCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUodGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiMxMjNcIiwgW1wiIzEyNFwiLCBcIiMxMjVcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlfSkudG9IZXhTdHJpbmcoKTsgIC8vIFwiI2ZmZmZmZlwiXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiI2E4MDE1YVwiLCBbXCIjZmFmM2YzXCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6dHJ1ZSxsZXZlbDpcIkFBQVwiLHNpemU6XCJsYXJnZVwifSkudG9IZXhTdHJpbmcoKTsgLy8gXCIjZmFmM2YzXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcInNtYWxsXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmZmZmZmZcIlxudGlueWNvbG9yLm1vc3RSZWFkYWJsZSA9IGZ1bmN0aW9uKGJhc2VDb2xvciwgY29sb3JMaXN0LCBhcmdzKSB7XG4gICAgdmFyIGJlc3RDb2xvciA9IG51bGw7XG4gICAgdmFyIGJlc3RTY29yZSA9IDA7XG4gICAgdmFyIHJlYWRhYmlsaXR5O1xuICAgIHZhciBpbmNsdWRlRmFsbGJhY2tDb2xvcnMsIGxldmVsLCBzaXplIDtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBpbmNsdWRlRmFsbGJhY2tDb2xvcnMgPSBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycyA7XG4gICAgbGV2ZWwgPSBhcmdzLmxldmVsO1xuICAgIHNpemUgPSBhcmdzLnNpemU7XG5cbiAgICBmb3IgKHZhciBpPSAwOyBpIDwgY29sb3JMaXN0Lmxlbmd0aCA7IGkrKykge1xuICAgICAgICByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShiYXNlQ29sb3IsIGNvbG9yTGlzdFtpXSk7XG4gICAgICAgIGlmIChyZWFkYWJpbGl0eSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgYmVzdFNjb3JlID0gcmVhZGFiaWxpdHk7XG4gICAgICAgICAgICBiZXN0Q29sb3IgPSB0aW55Y29sb3IoY29sb3JMaXN0W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aW55Y29sb3IuaXNSZWFkYWJsZShiYXNlQ29sb3IsIGJlc3RDb2xvciwge1wibGV2ZWxcIjpsZXZlbCxcInNpemVcIjpzaXplfSkgfHwgIWluY2x1ZGVGYWxsYmFja0NvbG9ycykge1xuICAgICAgICByZXR1cm4gYmVzdENvbG9yO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJncy5pbmNsdWRlRmFsbGJhY2tDb2xvcnM9ZmFsc2U7XG4gICAgICAgIHJldHVybiB0aW55Y29sb3IubW9zdFJlYWRhYmxlKGJhc2VDb2xvcixbXCIjZmZmXCIsIFwiIzAwMFwiXSxhcmdzKTtcbiAgICB9XG59O1xuXG5cbi8vIEJpZyBMaXN0IG9mIENvbG9yc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yPlxudmFyIG5hbWVzID0gdGlueWNvbG9yLm5hbWVzID0ge1xuICAgIGFsaWNlYmx1ZTogXCJmMGY4ZmZcIixcbiAgICBhbnRpcXVld2hpdGU6IFwiZmFlYmQ3XCIsXG4gICAgYXF1YTogXCIwZmZcIixcbiAgICBhcXVhbWFyaW5lOiBcIjdmZmZkNFwiLFxuICAgIGF6dXJlOiBcImYwZmZmZlwiLFxuICAgIGJlaWdlOiBcImY1ZjVkY1wiLFxuICAgIGJpc3F1ZTogXCJmZmU0YzRcIixcbiAgICBibGFjazogXCIwMDBcIixcbiAgICBibGFuY2hlZGFsbW9uZDogXCJmZmViY2RcIixcbiAgICBibHVlOiBcIjAwZlwiLFxuICAgIGJsdWV2aW9sZXQ6IFwiOGEyYmUyXCIsXG4gICAgYnJvd246IFwiYTUyYTJhXCIsXG4gICAgYnVybHl3b29kOiBcImRlYjg4N1wiLFxuICAgIGJ1cm50c2llbm5hOiBcImVhN2U1ZFwiLFxuICAgIGNhZGV0Ymx1ZTogXCI1ZjllYTBcIixcbiAgICBjaGFydHJldXNlOiBcIjdmZmYwMFwiLFxuICAgIGNob2NvbGF0ZTogXCJkMjY5MWVcIixcbiAgICBjb3JhbDogXCJmZjdmNTBcIixcbiAgICBjb3JuZmxvd2VyYmx1ZTogXCI2NDk1ZWRcIixcbiAgICBjb3Juc2lsazogXCJmZmY4ZGNcIixcbiAgICBjcmltc29uOiBcImRjMTQzY1wiLFxuICAgIGN5YW46IFwiMGZmXCIsXG4gICAgZGFya2JsdWU6IFwiMDAwMDhiXCIsXG4gICAgZGFya2N5YW46IFwiMDA4YjhiXCIsXG4gICAgZGFya2dvbGRlbnJvZDogXCJiODg2MGJcIixcbiAgICBkYXJrZ3JheTogXCJhOWE5YTlcIixcbiAgICBkYXJrZ3JlZW46IFwiMDA2NDAwXCIsXG4gICAgZGFya2dyZXk6IFwiYTlhOWE5XCIsXG4gICAgZGFya2toYWtpOiBcImJkYjc2YlwiLFxuICAgIGRhcmttYWdlbnRhOiBcIjhiMDA4YlwiLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiBcIjU1NmIyZlwiLFxuICAgIGRhcmtvcmFuZ2U6IFwiZmY4YzAwXCIsXG4gICAgZGFya29yY2hpZDogXCI5OTMyY2NcIixcbiAgICBkYXJrcmVkOiBcIjhiMDAwMFwiLFxuICAgIGRhcmtzYWxtb246IFwiZTk5NjdhXCIsXG4gICAgZGFya3NlYWdyZWVuOiBcIjhmYmM4ZlwiLFxuICAgIGRhcmtzbGF0ZWJsdWU6IFwiNDgzZDhiXCIsXG4gICAgZGFya3NsYXRlZ3JheTogXCIyZjRmNGZcIixcbiAgICBkYXJrc2xhdGVncmV5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmt0dXJxdW9pc2U6IFwiMDBjZWQxXCIsXG4gICAgZGFya3Zpb2xldDogXCI5NDAwZDNcIixcbiAgICBkZWVwcGluazogXCJmZjE0OTNcIixcbiAgICBkZWVwc2t5Ymx1ZTogXCIwMGJmZmZcIixcbiAgICBkaW1ncmF5OiBcIjY5Njk2OVwiLFxuICAgIGRpbWdyZXk6IFwiNjk2OTY5XCIsXG4gICAgZG9kZ2VyYmx1ZTogXCIxZTkwZmZcIixcbiAgICBmaXJlYnJpY2s6IFwiYjIyMjIyXCIsXG4gICAgZmxvcmFsd2hpdGU6IFwiZmZmYWYwXCIsXG4gICAgZm9yZXN0Z3JlZW46IFwiMjI4YjIyXCIsXG4gICAgZnVjaHNpYTogXCJmMGZcIixcbiAgICBnYWluc2Jvcm86IFwiZGNkY2RjXCIsXG4gICAgZ2hvc3R3aGl0ZTogXCJmOGY4ZmZcIixcbiAgICBnb2xkOiBcImZmZDcwMFwiLFxuICAgIGdvbGRlbnJvZDogXCJkYWE1MjBcIixcbiAgICBncmF5OiBcIjgwODA4MFwiLFxuICAgIGdyZWVuOiBcIjAwODAwMFwiLFxuICAgIGdyZWVueWVsbG93OiBcImFkZmYyZlwiLFxuICAgIGdyZXk6IFwiODA4MDgwXCIsXG4gICAgaG9uZXlkZXc6IFwiZjBmZmYwXCIsXG4gICAgaG90cGluazogXCJmZjY5YjRcIixcbiAgICBpbmRpYW5yZWQ6IFwiY2Q1YzVjXCIsXG4gICAgaW5kaWdvOiBcIjRiMDA4MlwiLFxuICAgIGl2b3J5OiBcImZmZmZmMFwiLFxuICAgIGtoYWtpOiBcImYwZTY4Y1wiLFxuICAgIGxhdmVuZGVyOiBcImU2ZTZmYVwiLFxuICAgIGxhdmVuZGVyYmx1c2g6IFwiZmZmMGY1XCIsXG4gICAgbGF3bmdyZWVuOiBcIjdjZmMwMFwiLFxuICAgIGxlbW9uY2hpZmZvbjogXCJmZmZhY2RcIixcbiAgICBsaWdodGJsdWU6IFwiYWRkOGU2XCIsXG4gICAgbGlnaHRjb3JhbDogXCJmMDgwODBcIixcbiAgICBsaWdodGN5YW46IFwiZTBmZmZmXCIsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiZmFmYWQyXCIsXG4gICAgbGlnaHRncmF5OiBcImQzZDNkM1wiLFxuICAgIGxpZ2h0Z3JlZW46IFwiOTBlZTkwXCIsXG4gICAgbGlnaHRncmV5OiBcImQzZDNkM1wiLFxuICAgIGxpZ2h0cGluazogXCJmZmI2YzFcIixcbiAgICBsaWdodHNhbG1vbjogXCJmZmEwN2FcIixcbiAgICBsaWdodHNlYWdyZWVuOiBcIjIwYjJhYVwiLFxuICAgIGxpZ2h0c2t5Ymx1ZTogXCI4N2NlZmFcIixcbiAgICBsaWdodHNsYXRlZ3JheTogXCI3ODlcIixcbiAgICBsaWdodHNsYXRlZ3JleTogXCI3ODlcIixcbiAgICBsaWdodHN0ZWVsYmx1ZTogXCJiMGM0ZGVcIixcbiAgICBsaWdodHllbGxvdzogXCJmZmZmZTBcIixcbiAgICBsaW1lOiBcIjBmMFwiLFxuICAgIGxpbWVncmVlbjogXCIzMmNkMzJcIixcbiAgICBsaW5lbjogXCJmYWYwZTZcIixcbiAgICBtYWdlbnRhOiBcImYwZlwiLFxuICAgIG1hcm9vbjogXCI4MDAwMDBcIixcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBcIjY2Y2RhYVwiLFxuICAgIG1lZGl1bWJsdWU6IFwiMDAwMGNkXCIsXG4gICAgbWVkaXVtb3JjaGlkOiBcImJhNTVkM1wiLFxuICAgIG1lZGl1bXB1cnBsZTogXCI5MzcwZGJcIixcbiAgICBtZWRpdW1zZWFncmVlbjogXCIzY2IzNzFcIixcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFwiN2I2OGVlXCIsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiMDBmYTlhXCIsXG4gICAgbWVkaXVtdHVycXVvaXNlOiBcIjQ4ZDFjY1wiLFxuICAgIG1lZGl1bXZpb2xldHJlZDogXCJjNzE1ODVcIixcbiAgICBtaWRuaWdodGJsdWU6IFwiMTkxOTcwXCIsXG4gICAgbWludGNyZWFtOiBcImY1ZmZmYVwiLFxuICAgIG1pc3R5cm9zZTogXCJmZmU0ZTFcIixcbiAgICBtb2NjYXNpbjogXCJmZmU0YjVcIixcbiAgICBuYXZham93aGl0ZTogXCJmZmRlYWRcIixcbiAgICBuYXZ5OiBcIjAwMDA4MFwiLFxuICAgIG9sZGxhY2U6IFwiZmRmNWU2XCIsXG4gICAgb2xpdmU6IFwiODA4MDAwXCIsXG4gICAgb2xpdmVkcmFiOiBcIjZiOGUyM1wiLFxuICAgIG9yYW5nZTogXCJmZmE1MDBcIixcbiAgICBvcmFuZ2VyZWQ6IFwiZmY0NTAwXCIsXG4gICAgb3JjaGlkOiBcImRhNzBkNlwiLFxuICAgIHBhbGVnb2xkZW5yb2Q6IFwiZWVlOGFhXCIsXG4gICAgcGFsZWdyZWVuOiBcIjk4ZmI5OFwiLFxuICAgIHBhbGV0dXJxdW9pc2U6IFwiYWZlZWVlXCIsXG4gICAgcGFsZXZpb2xldHJlZDogXCJkYjcwOTNcIixcbiAgICBwYXBheWF3aGlwOiBcImZmZWZkNVwiLFxuICAgIHBlYWNocHVmZjogXCJmZmRhYjlcIixcbiAgICBwZXJ1OiBcImNkODUzZlwiLFxuICAgIHBpbms6IFwiZmZjMGNiXCIsXG4gICAgcGx1bTogXCJkZGEwZGRcIixcbiAgICBwb3dkZXJibHVlOiBcImIwZTBlNlwiLFxuICAgIHB1cnBsZTogXCI4MDAwODBcIixcbiAgICByZWJlY2NhcHVycGxlOiBcIjY2MzM5OVwiLFxuICAgIHJlZDogXCJmMDBcIixcbiAgICByb3N5YnJvd246IFwiYmM4ZjhmXCIsXG4gICAgcm95YWxibHVlOiBcIjQxNjllMVwiLFxuICAgIHNhZGRsZWJyb3duOiBcIjhiNDUxM1wiLFxuICAgIHNhbG1vbjogXCJmYTgwNzJcIixcbiAgICBzYW5keWJyb3duOiBcImY0YTQ2MFwiLFxuICAgIHNlYWdyZWVuOiBcIjJlOGI1N1wiLFxuICAgIHNlYXNoZWxsOiBcImZmZjVlZVwiLFxuICAgIHNpZW5uYTogXCJhMDUyMmRcIixcbiAgICBzaWx2ZXI6IFwiYzBjMGMwXCIsXG4gICAgc2t5Ymx1ZTogXCI4N2NlZWJcIixcbiAgICBzbGF0ZWJsdWU6IFwiNmE1YWNkXCIsXG4gICAgc2xhdGVncmF5OiBcIjcwODA5MFwiLFxuICAgIHNsYXRlZ3JleTogXCI3MDgwOTBcIixcbiAgICBzbm93OiBcImZmZmFmYVwiLFxuICAgIHNwcmluZ2dyZWVuOiBcIjAwZmY3ZlwiLFxuICAgIHN0ZWVsYmx1ZTogXCI0NjgyYjRcIixcbiAgICB0YW46IFwiZDJiNDhjXCIsXG4gICAgdGVhbDogXCIwMDgwODBcIixcbiAgICB0aGlzdGxlOiBcImQ4YmZkOFwiLFxuICAgIHRvbWF0bzogXCJmZjYzNDdcIixcbiAgICB0dXJxdW9pc2U6IFwiNDBlMGQwXCIsXG4gICAgdmlvbGV0OiBcImVlODJlZVwiLFxuICAgIHdoZWF0OiBcImY1ZGViM1wiLFxuICAgIHdoaXRlOiBcImZmZlwiLFxuICAgIHdoaXRlc21va2U6IFwiZjVmNWY1XCIsXG4gICAgeWVsbG93OiBcImZmMFwiLFxuICAgIHllbGxvd2dyZWVuOiBcIjlhY2QzMlwiXG59O1xuXG4vLyBNYWtlIGl0IGVhc3kgdG8gYWNjZXNzIGNvbG9ycyB2aWEgYGhleE5hbWVzW2hleF1gXG52YXIgaGV4TmFtZXMgPSB0aW55Y29sb3IuaGV4TmFtZXMgPSBmbGlwKG5hbWVzKTtcblxuXG4vLyBVdGlsaXRpZXNcbi8vIC0tLS0tLS0tLVxuXG4vLyBgeyAnbmFtZTEnOiAndmFsMScgfWAgYmVjb21lcyBgeyAndmFsMSc6ICduYW1lMScgfWBcbmZ1bmN0aW9uIGZsaXAobykge1xuICAgIHZhciBmbGlwcGVkID0geyB9O1xuICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgZmxpcHBlZFtvW2ldXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsaXBwZWQ7XG59XG5cbi8vIFJldHVybiBhIHZhbGlkIGFscGhhIHZhbHVlIFswLDFdIHdpdGggYWxsIGludmFsaWQgdmFsdWVzIGJlaW5nIHNldCB0byAxXG5mdW5jdGlvbiBib3VuZEFscGhhKGEpIHtcbiAgICBhID0gcGFyc2VGbG9hdChhKTtcblxuICAgIGlmIChpc05hTihhKSB8fCBhIDwgMCB8fCBhID4gMSkge1xuICAgICAgICBhID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuLy8gVGFrZSBpbnB1dCBmcm9tIFswLCBuXSBhbmQgcmV0dXJuIGl0IGFzIFswLCAxXVxuZnVuY3Rpb24gYm91bmQwMShuLCBtYXgpIHtcbiAgICBpZiAoaXNPbmVQb2ludFplcm8obikpIHsgbiA9IFwiMTAwJVwiOyB9XG5cbiAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBpc1BlcmNlbnRhZ2Uobik7XG4gICAgbiA9IG1hdGhNaW4obWF4LCBtYXRoTWF4KDAsIHBhcnNlRmxvYXQobikpKTtcblxuICAgIC8vIEF1dG9tYXRpY2FsbHkgY29udmVydCBwZXJjZW50YWdlIGludG8gbnVtYmVyXG4gICAgaWYgKHByb2Nlc3NQZXJjZW50KSB7XG4gICAgICAgIG4gPSBwYXJzZUludChuICogbWF4LCAxMCkgLyAxMDA7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yc1xuICAgIGlmICgoTWF0aC5hYnMobiAtIG1heCkgPCAwLjAwMDAwMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIFswLCAxXSByYW5nZSBpZiBpdCBpc24ndCBhbHJlYWR5XG4gICAgcmV0dXJuIChuICUgbWF4KSAvIHBhcnNlRmxvYXQobWF4KTtcbn1cblxuLy8gRm9yY2UgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG5mdW5jdGlvbiBjbGFtcDAxKHZhbCkge1xuICAgIHJldHVybiBtYXRoTWluKDEsIG1hdGhNYXgoMCwgdmFsKSk7XG59XG5cbi8vIFBhcnNlIGEgYmFzZS0xNiBoZXggdmFsdWUgaW50byBhIGJhc2UtMTAgaW50ZWdlclxuZnVuY3Rpb24gcGFyc2VJbnRGcm9tSGV4KHZhbCkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDE2KTtcbn1cblxuLy8gTmVlZCB0byBoYW5kbGUgMS4wIGFzIDEwMCUsIHNpbmNlIG9uY2UgaXQgaXMgYSBudW1iZXIsIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiBpdCBhbmQgMVxuLy8gPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQyMjA3Mi9qYXZhc2NyaXB0LWhvdy10by1kZXRlY3QtbnVtYmVyLWFzLWEtZGVjaW1hbC1pbmNsdWRpbmctMS0wPlxuZnVuY3Rpb24gaXNPbmVQb2ludFplcm8obikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZignLicpICE9IC0xICYmIHBhcnNlRmxvYXQobikgPT09IDE7XG59XG5cbi8vIENoZWNrIHRvIHNlZSBpZiBzdHJpbmcgcGFzc2VkIGluIGlzIGEgcGVyY2VudGFnZVxuZnVuY3Rpb24gaXNQZXJjZW50YWdlKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCclJykgIT0gLTE7XG59XG5cbi8vIEZvcmNlIGEgaGV4IHZhbHVlIHRvIGhhdmUgMiBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBwYWQyKGMpIHtcbiAgICByZXR1cm4gYy5sZW5ndGggPT0gMSA/ICcwJyArIGMgOiAnJyArIGM7XG59XG5cbi8vIFJlcGxhY2UgYSBkZWNpbWFsIHdpdGggaXQncyBwZXJjZW50YWdlIHZhbHVlXG5mdW5jdGlvbiBjb252ZXJ0VG9QZXJjZW50YWdlKG4pIHtcbiAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgIG4gPSAobiAqIDEwMCkgKyBcIiVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuLy8gQ29udmVydHMgYSBkZWNpbWFsIHRvIGEgaGV4IHZhbHVlXG5mdW5jdGlvbiBjb252ZXJ0RGVjaW1hbFRvSGV4KGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGQpICogMjU1KS50b1N0cmluZygxNik7XG59XG4vLyBDb252ZXJ0cyBhIGhleCB2YWx1ZSB0byBhIGRlY2ltYWxcbmZ1bmN0aW9uIGNvbnZlcnRIZXhUb0RlY2ltYWwoaCkge1xuICAgIHJldHVybiAocGFyc2VJbnRGcm9tSGV4KGgpIC8gMjU1KTtcbn1cblxudmFyIG1hdGNoZXJzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdmFsdWVzLyNpbnRlZ2Vycz5cbiAgICB2YXIgQ1NTX0lOVEVHRVIgPSBcIlstXFxcXCtdP1xcXFxkKyU/XCI7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI251bWJlci12YWx1ZT5cbiAgICB2YXIgQ1NTX05VTUJFUiA9IFwiWy1cXFxcK10/XFxcXGQqXFxcXC5cXFxcZCslP1wiO1xuXG4gICAgLy8gQWxsb3cgcG9zaXRpdmUvbmVnYXRpdmUgaW50ZWdlci9udW1iZXIuICBEb24ndCBjYXB0dXJlIHRoZSBlaXRoZXIvb3IsIGp1c3QgdGhlIGVudGlyZSBvdXRjb21lLlxuICAgIHZhciBDU1NfVU5JVCA9IFwiKD86XCIgKyBDU1NfTlVNQkVSICsgXCIpfCg/OlwiICsgQ1NTX0lOVEVHRVIgKyBcIilcIjtcblxuICAgIC8vIEFjdHVhbCBtYXRjaGluZy5cbiAgICAvLyBQYXJlbnRoZXNlcyBhbmQgY29tbWFzIGFyZSBvcHRpb25hbCwgYnV0IG5vdCByZXF1aXJlZC5cbiAgICAvLyBXaGl0ZXNwYWNlIGNhbiB0YWtlIHRoZSBwbGFjZSBvZiBjb21tYXMgb3Igb3BlbmluZyBwYXJlblxuICAgIHZhciBQRVJNSVNTSVZFX01BVENIMyA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuICAgIHZhciBQRVJNSVNTSVZFX01BVENINCA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1NTX1VOSVQ6IG5ldyBSZWdFeHAoQ1NTX1VOSVQpLFxuICAgICAgICByZ2I6IG5ldyBSZWdFeHAoXCJyZ2JcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgcmdiYTogbmV3IFJlZ0V4cChcInJnYmFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaHNsOiBuZXcgUmVnRXhwKFwiaHNsXCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIGhzbGE6IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhzdjogbmV3IFJlZ0V4cChcImhzdlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICBoc3ZhOiBuZXcgUmVnRXhwKFwiaHN2YVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoZXgzOiAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC8sXG4gICAgICAgIGhleDY6IC9eIz8oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkLyxcbiAgICAgICAgaGV4NDogL14jPyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICAgICAgaGV4ODogL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkL1xuICAgIH07XG59KSgpO1xuXG4vLyBgaXNWYWxpZENTU1VuaXRgXG4vLyBUYWtlIGluIGEgc2luZ2xlIHN0cmluZyAvIG51bWJlciBhbmQgY2hlY2sgdG8gc2VlIGlmIGl0IGxvb2tzIGxpa2UgYSBDU1MgdW5pdFxuLy8gKHNlZSBgbWF0Y2hlcnNgIGFib3ZlIGZvciBkZWZpbml0aW9uKS5cbmZ1bmN0aW9uIGlzVmFsaWRDU1NVbml0KGNvbG9yKSB7XG4gICAgcmV0dXJuICEhbWF0Y2hlcnMuQ1NTX1VOSVQuZXhlYyhjb2xvcik7XG59XG5cbi8vIGBzdHJpbmdJbnB1dFRvT2JqZWN0YFxuLy8gUGVybWlzc2l2ZSBzdHJpbmcgcGFyc2luZy4gIFRha2UgaW4gYSBudW1iZXIgb2YgZm9ybWF0cywgYW5kIG91dHB1dCBhbiBvYmplY3Rcbi8vIGJhc2VkIG9uIGRldGVjdGVkIGZvcm1hdC4gIFJldHVybnMgYHsgciwgZywgYiB9YCBvciBgeyBoLCBzLCBsIH1gIG9yIGB7IGgsIHMsIHZ9YFxuZnVuY3Rpb24gc3RyaW5nSW5wdXRUb09iamVjdChjb2xvcikge1xuXG4gICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKHRyaW1MZWZ0LCcnKS5yZXBsYWNlKHRyaW1SaWdodCwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG5hbWVkID0gZmFsc2U7XG4gICAgaWYgKG5hbWVzW2NvbG9yXSkge1xuICAgICAgICBjb2xvciA9IG5hbWVzW2NvbG9yXTtcbiAgICAgICAgbmFtZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2xvciA9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHJldHVybiB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAsIGZvcm1hdDogXCJuYW1lXCIgfTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gbWF0Y2ggc3RyaW5nIGlucHV0IHVzaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgLy8gS2VlcCBtb3N0IG9mIHRoZSBudW1iZXIgYm91bmRpbmcgb3V0IG9mIHRoaXMgZnVuY3Rpb24gLSBkb24ndCB3b3JyeSBhYm91dCBbMCwxXSBvciBbMCwxMDBdIG9yIFswLDM2MF1cbiAgICAvLyBKdXN0IHJldHVybiBhbiBvYmplY3QgYW5kIGxldCB0aGUgY29udmVyc2lvbiBmdW5jdGlvbnMgaGFuZGxlIHRoYXQuXG4gICAgLy8gVGhpcyB3YXkgdGhlIHJlc3VsdCB3aWxsIGJlIHRoZSBzYW1lIHdoZXRoZXIgdGhlIHRpbnljb2xvciBpcyBpbml0aWFsaXplZCB3aXRoIHN0cmluZyBvciBvYmplY3QuXG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5yZ2IuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc2wuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc3YuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgdjogbWF0Y2hbM10gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdmEuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgdjogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg4LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgYTogY29udmVydEhleFRvRGVjaW1hbChtYXRjaFs0XSksXG4gICAgICAgICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleDhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4Ni5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0pLFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0gKyAnJyArIG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSArICcnICsgbWF0Y2hbMl0pLFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdICsgJycgKyBtYXRjaFszXSksXG4gICAgICAgICAgICBhOiBjb252ZXJ0SGV4VG9EZWNpbWFsKG1hdGNoWzRdICsgJycgKyBtYXRjaFs0XSksXG4gICAgICAgICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleDhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10gKyAnJyArIG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV0NBRzJQYXJtcyhwYXJtcykge1xuICAgIC8vIHJldHVybiB2YWxpZCBXQ0FHMiBwYXJtcyBmb3IgaXNSZWFkYWJsZS5cbiAgICAvLyBJZiBpbnB1dCBwYXJtcyBhcmUgaW52YWxpZCwgcmV0dXJuIHtcImxldmVsXCI6XCJBQVwiLCBcInNpemVcIjpcInNtYWxsXCJ9XG4gICAgdmFyIGxldmVsLCBzaXplO1xuICAgIHBhcm1zID0gcGFybXMgfHwge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn07XG4gICAgbGV2ZWwgPSAocGFybXMubGV2ZWwgfHwgXCJBQVwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIHNpemUgPSAocGFybXMuc2l6ZSB8fCBcInNtYWxsXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxldmVsICE9PSBcIkFBXCIgJiYgbGV2ZWwgIT09IFwiQUFBXCIpIHtcbiAgICAgICAgbGV2ZWwgPSBcIkFBXCI7XG4gICAgfVxuICAgIGlmIChzaXplICE9PSBcInNtYWxsXCIgJiYgc2l6ZSAhPT0gXCJsYXJnZVwiKSB7XG4gICAgICAgIHNpemUgPSBcInNtYWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB7XCJsZXZlbFwiOmxldmVsLCBcInNpemVcIjpzaXplfTtcbn1cblxuLy8gTm9kZTogRXhwb3J0IGZ1bmN0aW9uXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdGlueWNvbG9yO1xufVxuLy8gQU1EL3JlcXVpcmVqczogRGVmaW5lIHRoZSBtb2R1bGVcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7cmV0dXJuIHRpbnljb2xvcjt9KTtcbn1cbi8vIEJyb3dzZXI6IEV4cG9zZSB0byB3aW5kb3dcbmVsc2Uge1xuICAgIHdpbmRvdy50aW55Y29sb3IgPSB0aW55Y29sb3I7XG59XG5cbn0pKE1hdGgpO1xuIiwiLypcbiAqIFRvYXN0clxuICogQ29weXJpZ2h0IDIwMTItMjAxNVxuICogQXV0aG9yczogSm9obiBQYXBhLCBIYW5zIEZqw6RsbGVtYXJrLCBhbmQgVGltIEZlcnJlbGwuXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVXNlLCByZXByb2R1Y3Rpb24sIGRpc3RyaWJ1dGlvbiwgYW5kIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvZGUgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYW5kXG4gKiBjb25kaXRpb25zIG9mIHRoZSBNSVQgbGljZW5zZSwgYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogQVJJQSBTdXBwb3J0OiBHcmV0YSBLcmFmc2lnXG4gKlxuICogUHJvamVjdDogaHR0cHM6Ly9naXRodWIuY29tL0NvZGVTZXZlbi90b2FzdHJcbiAqL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuKGZ1bmN0aW9uIChkZWZpbmUpIHtcbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZnVuY3Rpb24gKCQpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcjtcbiAgICAgICAgICAgIHZhciB0b2FzdElkID0gMDtcbiAgICAgICAgICAgIHZhciB0b2FzdFR5cGUgPSB7XG4gICAgICAgICAgICAgICAgZXJyb3I6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgaW5mbzogJ2luZm8nLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiAnd2FybmluZydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0b2FzdHIgPSB7XG4gICAgICAgICAgICAgICAgY2xlYXI6IGNsZWFyLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBpbmZvOiBpbmZvLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzIuMS40JyxcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiB3YXJuaW5nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNUb2FzdDtcblxuICAgICAgICAgICAgcmV0dXJuIHRvYXN0cjtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGFpbmVyKG9wdGlvbnMsIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0gZ2V0T3B0aW9ucygpOyB9XG4gICAgICAgICAgICAgICAgJGNvbnRhaW5lciA9ICQoJyMnICsgb3B0aW9ucy5jb250YWluZXJJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCRjb250YWluZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIgPSBjcmVhdGVDb250YWluZXIob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpbmZvKG1lc3NhZ2UsIHRpdGxlLCBvcHRpb25zT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9hc3RUeXBlLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2VzcyhtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGdldE9wdGlvbnMoKS5pY29uQ2xhc3Nlcy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUud2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMud2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc092ZXJyaWRlOiBvcHRpb25zT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhcigkdG9hc3RFbGVtZW50LCBjbGVhck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoISRjb250YWluZXIpIHsgZ2V0Q29udGFpbmVyKG9wdGlvbnMpOyB9XG4gICAgICAgICAgICAgICAgaWYgKCFjbGVhclRvYXN0KCR0b2FzdEVsZW1lbnQsIG9wdGlvbnMsIGNsZWFyT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXIob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmUoJHRvYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIGlmICghJGNvbnRhaW5lcikgeyBnZXRDb250YWluZXIob3B0aW9ucyk7IH1cbiAgICAgICAgICAgICAgICBpZiAoJHRvYXN0RWxlbWVudCAmJiAkKCc6Zm9jdXMnLCAkdG9hc3RFbGVtZW50KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVG9hc3QoJHRvYXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRjb250YWluZXIuY2hpbGRyZW4oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGludGVybmFsIGZ1bmN0aW9uc1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhckNvbnRhaW5lciAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciB0b2FzdHNUb0NsZWFyID0gJGNvbnRhaW5lci5jaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b2FzdHNUb0NsZWFyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVG9hc3QoJCh0b2FzdHNUb0NsZWFyW2ldKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhclRvYXN0ICgkdG9hc3RFbGVtZW50LCBvcHRpb25zLCBjbGVhck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9yY2UgPSBjbGVhck9wdGlvbnMgJiYgY2xlYXJPcHRpb25zLmZvcmNlID8gY2xlYXJPcHRpb25zLmZvcmNlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCR0b2FzdEVsZW1lbnQgJiYgKGZvcmNlIHx8ICQoJzpmb2N1cycsICR0b2FzdEVsZW1lbnQpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudFtvcHRpb25zLmhpZGVNZXRob2RdKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmhpZGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5oaWRlRWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgcmVtb3ZlVG9hc3QoJHRvYXN0RWxlbWVudCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgJGNvbnRhaW5lciA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIG9wdGlvbnMuY29udGFpbmVySWQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhvcHRpb25zLnBvc2l0aW9uQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgJGNvbnRhaW5lci5hcHBlbmRUbygkKG9wdGlvbnMudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRjb250YWluZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcFRvRGlzbWlzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9hc3RDbGFzczogJ3RvYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySWQ6ICd0b2FzdC1jb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogZmFsc2UsXG5cbiAgICAgICAgICAgICAgICAgICAgc2hvd01ldGhvZDogJ2ZhZGVJbicsIC8vZmFkZUluLCBzbGlkZURvd24sIGFuZCBzaG93IGFyZSBidWlsdCBpbnRvIGpRdWVyeVxuICAgICAgICAgICAgICAgICAgICBzaG93RHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0Vhc2luZzogJ3N3aW5nJywgLy9zd2luZyBhbmQgbGluZWFyIGFyZSBidWlsdCBpbnRvIGpRdWVyeVxuICAgICAgICAgICAgICAgICAgICBvblNob3duOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVNZXRob2Q6ICdmYWRlT3V0JyxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUR1cmF0aW9uOiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRWFzaW5nOiAnc3dpbmcnLFxuICAgICAgICAgICAgICAgICAgICBvbkhpZGRlbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZU1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRHVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUVhc2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlT25Ib3ZlcjogdHJ1ZSxcblxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFRpbWVPdXQ6IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ3RvYXN0LWVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm86ICd0b2FzdC1pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICd0b2FzdC1zdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmc6ICd0b2FzdC13YXJuaW5nJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6ICd0b2FzdC1pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25DbGFzczogJ3RvYXN0LXRvcC1yaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVPdXQ6IDUwMDAsIC8vIFNldCB0aW1lT3V0IGFuZCBleHRlbmRlZFRpbWVPdXQgdG8gMCB0byBtYWtlIGl0IHN0aWNreVxuICAgICAgICAgICAgICAgICAgICB0aXRsZUNsYXNzOiAndG9hc3QtdGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQ2xhc3M6ICd0b2FzdC1tZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSHRtbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUh0bWw6ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIj4mdGltZXM7PC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VDbGFzczogJ3RvYXN0LWNsb3NlLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgICAgIG5ld2VzdE9uVG9wOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RHVwbGljYXRlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NDbGFzczogJ3RvYXN0LXByb2dyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgcnRsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2goYXJncykge1xuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vdGlmeShtYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaWNvbkNsYXNzID0gbWFwLmljb25DbGFzcyB8fCBvcHRpb25zLmljb25DbGFzcztcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG1hcC5vcHRpb25zT3ZlcnJpZGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQob3B0aW9ucywgbWFwLm9wdGlvbnNPdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzcyA9IG1hcC5vcHRpb25zT3ZlcnJpZGUuaWNvbkNsYXNzIHx8IGljb25DbGFzcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRXhpdChvcHRpb25zLCBtYXApKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgdG9hc3RJZCsrO1xuXG4gICAgICAgICAgICAgICAgJGNvbnRhaW5lciA9IGdldENvbnRhaW5lcihvcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgJHRvYXN0RWxlbWVudCA9ICQoJzxkaXYvPicpO1xuICAgICAgICAgICAgICAgIHZhciAkdGl0bGVFbGVtZW50ID0gJCgnPGRpdi8+Jyk7XG4gICAgICAgICAgICAgICAgdmFyICRtZXNzYWdlRWxlbWVudCA9ICQoJzxkaXYvPicpO1xuICAgICAgICAgICAgICAgIHZhciAkcHJvZ3Jlc3NFbGVtZW50ID0gJCgnPGRpdi8+Jyk7XG4gICAgICAgICAgICAgICAgdmFyICRjbG9zZUVsZW1lbnQgPSAkKG9wdGlvbnMuY2xvc2VIdG1sKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NCYXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1heEhpZGVUaW1lOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0SWQ6IHRvYXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiAndmlzaWJsZScsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBtYXBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcGVyc29uYWxpemVUb2FzdCgpO1xuXG4gICAgICAgICAgICAgICAgZGlzcGxheVRvYXN0KCk7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVFdmVudHMoKTtcblxuICAgICAgICAgICAgICAgIHB1Ymxpc2gocmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcgJiYgY29uc29sZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICR0b2FzdEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlc2NhcGVIdG1sKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBlcnNvbmFsaXplVG9hc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEljb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRDbG9zZUJ1dHRvbigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRQcm9ncmVzc0JhcigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSVEwoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJpYSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldEFyaWEoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmlhVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtYXAuaWNvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0b2FzdC1zdWNjZXNzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvYXN0LWluZm8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFWYWx1ZSA9ICAncG9saXRlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVZhbHVlID0gJ2Fzc2VydGl2ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hdHRyKCdhcmlhLWxpdmUnLCBhcmlhVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50cygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VPbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmhvdmVyKHN0aWNrQXJvdW5kLCBkZWxheWVkSGlkZVRvYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5vbmNsaWNrICYmIG9wdGlvbnMudGFwVG9EaXNtaXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmNsaWNrKGhpZGVUb2FzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZUJ1dHRvbiAmJiAkY2xvc2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY2xvc2VFbGVtZW50LmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5jZWxCdWJibGUgIT09IHVuZGVmaW5lZCAmJiBldmVudC5jYW5jZWxCdWJibGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbkNsb3NlQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNsb3NlQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb2FzdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25jbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb2FzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkaXNwbGF5VG9hc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuaGlkZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnRbb3B0aW9ucy5zaG93TWV0aG9kXShcbiAgICAgICAgICAgICAgICAgICAgICAgIHtkdXJhdGlvbjogb3B0aW9ucy5zaG93RHVyYXRpb24sIGVhc2luZzogb3B0aW9ucy5zaG93RWFzaW5nLCBjb21wbGV0ZTogb3B0aW9ucy5vblNob3dufVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbElkID0gc2V0VGltZW91dChoaWRlVG9hc3QsIG9wdGlvbnMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZSA9IHBhcnNlRmxvYXQob3B0aW9ucy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLmhpZGVFdGEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodXBkYXRlUHJvZ3Jlc3MsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuaWNvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmFkZENsYXNzKG9wdGlvbnMudG9hc3RDbGFzcykuYWRkQ2xhc3MoaWNvbkNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFNlcXVlbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5uZXdlc3RPblRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNvbnRhaW5lci5wcmVwZW5kKCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNvbnRhaW5lci5hcHBlbmQoJHRvYXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRUaXRsZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG1hcC50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVzY2FwZUh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBlc2NhcGVIdG1sKG1hcC50aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGl0bGVFbGVtZW50LmFwcGVuZChzdWZmaXgpLmFkZENsYXNzKG9wdGlvbnMudGl0bGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmFwcGVuZCgkdGl0bGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldE1lc3NhZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG1hcC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXNjYXBlSHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGVzY2FwZUh0bWwobWFwLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJG1lc3NhZ2VFbGVtZW50LmFwcGVuZChzdWZmaXgpLmFkZENsYXNzKG9wdGlvbnMubWVzc2FnZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYXBwZW5kKCRtZXNzYWdlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRDbG9zZUJ1dHRvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjbG9zZUVsZW1lbnQuYWRkQ2xhc3Mob3B0aW9ucy5jbG9zZUNsYXNzKS5hdHRyKCdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5wcmVwZW5kKCRjbG9zZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0UHJvZ3Jlc3NCYXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByb2dyZXNzQmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcHJvZ3Jlc3NFbGVtZW50LmFkZENsYXNzKG9wdGlvbnMucHJvZ3Jlc3NDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnByZXBlbmQoJHByb2dyZXNzRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRSVEwoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJ0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hZGRDbGFzcygncnRsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGRFeGl0KG9wdGlvbnMsIG1hcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50RHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5tZXNzYWdlID09PSBwcmV2aW91c1RvYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVG9hc3QgPSBtYXAubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGlkZVRvYXN0KG92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBvdmVycmlkZSAmJiBvcHRpb25zLmNsb3NlTWV0aG9kICE9PSBmYWxzZSA/IG9wdGlvbnMuY2xvc2VNZXRob2QgOiBvcHRpb25zLmhpZGVNZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG92ZXJyaWRlICYmIG9wdGlvbnMuY2xvc2VEdXJhdGlvbiAhPT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jbG9zZUR1cmF0aW9uIDogb3B0aW9ucy5oaWRlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBlYXNpbmcgPSBvdmVycmlkZSAmJiBvcHRpb25zLmNsb3NlRWFzaW5nICE9PSBmYWxzZSA/IG9wdGlvbnMuY2xvc2VFYXNpbmcgOiBvcHRpb25zLmhpZGVFYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKCc6Zm9jdXMnLCAkdG9hc3RFbGVtZW50KS5sZW5ndGggJiYgIW92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHByb2dyZXNzQmFyLmludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRvYXN0RWxlbWVudFttZXRob2RdKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25IaWRkZW4gJiYgcmVzcG9uc2Uuc3RhdGUgIT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25IaWRkZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdGUgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVsYXllZEhpZGVUb2FzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZU91dCA+IDAgfHwgb3B0aW9ucy5leHRlbmRlZFRpbWVPdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbElkID0gc2V0VGltZW91dChoaWRlVG9hc3QsIG9wdGlvbnMuZXh0ZW5kZWRUaW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lID0gcGFyc2VGbG9hdChvcHRpb25zLmV4dGVuZGVkVGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5oaWRlRXRhID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN0aWNrQXJvdW5kKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLmhpZGVFdGEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnN0b3AodHJ1ZSwgdHJ1ZSlbb3B0aW9ucy5zaG93TWV0aG9kXShcbiAgICAgICAgICAgICAgICAgICAgICAgIHtkdXJhdGlvbjogb3B0aW9ucy5zaG93RHVyYXRpb24sIGVhc2luZzogb3B0aW9ucy5zaG93RWFzaW5nfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudGFnZSA9ICgocHJvZ3Jlc3NCYXIuaGlkZUV0YSAtIChuZXcgRGF0ZSgpLmdldFRpbWUoKSkpIC8gcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWUpICogMTAwO1xuICAgICAgICAgICAgICAgICAgICAkcHJvZ3Jlc3NFbGVtZW50LndpZHRoKHBlcmNlbnRhZ2UgKyAnJScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIGdldERlZmF1bHRzKCksIHRvYXN0ci5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVG9hc3QoJHRvYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICghJGNvbnRhaW5lcikgeyAkY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7IH1cbiAgICAgICAgICAgICAgICBpZiAoJHRvYXN0RWxlbWVudC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCRjb250YWluZXIuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUb2FzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSkoKTtcbiAgICB9KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGRlcHMsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9Ob2RlXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cudG9hc3RyID0gZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbiAgICB9XG59KSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0J5dGVMZW5ndGg7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gcmVxdWlyZSgnLi91dGlsL2Fzc2VydFN0cmluZycpO1xuXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnRTdHJpbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbmZ1bmN0aW9uIGlzQnl0ZUxlbmd0aChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW4gPSB2b2lkIDA7XG4gIHZhciBtYXggPSB2b2lkIDA7XG4gIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBtaW4gPSBvcHRpb25zLm1pbiB8fCAwO1xuICAgIG1heCA9IG9wdGlvbnMubWF4O1xuICB9IGVsc2Uge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpc0J5dGVMZW5ndGgoc3RyLCBtaW4gWywgbWF4XSlcbiAgICBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgbWF4ID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBsZW4gPSBlbmNvZGVVUkkoc3RyKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGggLSAxO1xuICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VtYWlsO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IHJlcXVpcmUoJy4vdXRpbC9hc3NlcnRTdHJpbmcnKTtcblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzZXJ0U3RyaW5nKTtcblxudmFyIF9tZXJnZSA9IHJlcXVpcmUoJy4vdXRpbC9tZXJnZScpO1xuXG52YXIgX21lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlKTtcblxudmFyIF9pc0J5dGVMZW5ndGggPSByZXF1aXJlKCcuL2lzQnl0ZUxlbmd0aCcpO1xuXG52YXIgX2lzQnl0ZUxlbmd0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0J5dGVMZW5ndGgpO1xuXG52YXIgX2lzRlFETiA9IHJlcXVpcmUoJy4vaXNGUUROJyk7XG5cbnZhciBfaXNGUUROMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRlFETik7XG5cbnZhciBfaXNJUCA9IHJlcXVpcmUoJy4vaXNJUCcpO1xuXG52YXIgX2lzSVAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJUCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2VtYWlsX29wdGlvbnMgPSB7XG4gIGFsbG93X2Rpc3BsYXlfbmFtZTogZmFsc2UsXG4gIHJlcXVpcmVfZGlzcGxheV9uYW1lOiBmYWxzZSxcbiAgYWxsb3dfdXRmOF9sb2NhbF9wYXJ0OiB0cnVlLFxuICByZXF1aXJlX3RsZDogdHJ1ZVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xudmFyIGRpc3BsYXlOYW1lID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1thLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLFxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcc10qPCguKyk+JC9pO1xudmFyIGVtYWlsVXNlclBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl0rJC9pO1xudmFyIGdtYWlsVXNlclBhcnQgPSAvXlthLXpcXGRdKyQvO1xudmFyIHF1b3RlZEVtYWlsVXNlciA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl0pKSokL2k7XG52YXIgZW1haWxVc2VyVXRmOFBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rJC9pO1xudmFyIHF1b3RlZEVtYWlsVXNlclV0ZjggPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZVxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkqJC9pO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuZnVuY3Rpb24gaXNFbWFpbChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlMi5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2VtYWlsX29wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lIHx8IG9wdGlvbnMuYWxsb3dfZGlzcGxheV9uYW1lKSB7XG4gICAgdmFyIGRpc3BsYXlfZW1haWwgPSBzdHIubWF0Y2goZGlzcGxheU5hbWUpO1xuICAgIGlmIChkaXNwbGF5X2VtYWlsKSB7XG4gICAgICBzdHIgPSBkaXNwbGF5X2VtYWlsWzFdO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnQCcpO1xuICB2YXIgZG9tYWluID0gcGFydHMucG9wKCk7XG4gIHZhciB1c2VyID0gcGFydHMuam9pbignQCcpO1xuXG4gIHZhciBsb3dlcl9kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcblxuICBpZiAob3B0aW9ucy5kb21haW5fc3BlY2lmaWNfdmFsaWRhdGlvbiAmJiAobG93ZXJfZG9tYWluID09PSAnZ21haWwuY29tJyB8fCBsb3dlcl9kb21haW4gPT09ICdnb29nbGVtYWlsLmNvbScpKSB7XG4gICAgLypcbiAgICAgIFByZXZpb3VzbHkgd2UgcmVtb3ZlZCBkb3RzIGZvciBnbWFpbCBhZGRyZXNzZXMgYmVmb3JlIHZhbGlkYXRpbmcuXG4gICAgICBUaGlzIHdhcyByZW1vdmVkIGJlY2F1c2UgaXQgYWxsb3dzIGBtdWx0aXBsZS4uZG90c0BnbWFpbC5jb21gXG4gICAgICB0byBiZSByZXBvcnRlZCBhcyB2YWxpZCwgYnV0IGl0IGlzIG5vdC5cbiAgICAgIEdtYWlsIG9ubHkgbm9ybWFsaXplcyBzaW5nbGUgZG90cywgcmVtb3ZpbmcgdGhlbSBmcm9tIGhlcmUgaXMgcG9pbnRsZXNzLFxuICAgICAgc2hvdWxkIGJlIGRvbmUgaW4gbm9ybWFsaXplRW1haWxcbiAgICAqL1xuICAgIHVzZXIgPSB1c2VyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBSZW1vdmluZyBzdWItYWRkcmVzcyBmcm9tIHVzZXJuYW1lIGJlZm9yZSBnbWFpbCB2YWxpZGF0aW9uXG4gICAgdmFyIHVzZXJuYW1lID0gdXNlci5zcGxpdCgnKycpWzBdO1xuXG4gICAgLy8gRG90cyBhcmUgbm90IGluY2x1ZGVkIGluIGdtYWlsIGxlbmd0aCByZXN0cmljdGlvblxuICAgIGlmICghKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKHVzZXJuYW1lLnJlcGxhY2UoJy4nLCAnJyksIHsgbWluOiA2LCBtYXg6IDMwIH0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIF91c2VyX3BhcnRzID0gdXNlcm5hbWUuc3BsaXQoJy4nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF91c2VyX3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWdtYWlsVXNlclBhcnQudGVzdChfdXNlcl9wYXJ0c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKHVzZXIsIHsgbWF4OiA2NCB9KSB8fCAhKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKGRvbWFpbiwgeyBtYXg6IDI1NCB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKDAsIF9pc0ZRRE4yLmRlZmF1bHQpKGRvbWFpbiwgeyByZXF1aXJlX3RsZDogb3B0aW9ucy5yZXF1aXJlX3RsZCB9KSkge1xuICAgIGlmICghb3B0aW9ucy5hbGxvd19pcF9kb21haW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoISgwLCBfaXNJUDIuZGVmYXVsdCkoZG9tYWluKSkge1xuICAgICAgaWYgKCFkb21haW4uc3RhcnRzV2l0aCgnWycpIHx8ICFkb21haW4uZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBub0JyYWNrZXRkb21haW4gPSBkb21haW4uc3Vic3RyKDEsIGRvbWFpbi5sZW5ndGggLSAyKTtcblxuICAgICAgaWYgKG5vQnJhY2tldGRvbWFpbi5sZW5ndGggPT09IDAgfHwgISgwLCBfaXNJUDIuZGVmYXVsdCkobm9CcmFja2V0ZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHVzZXJbMF0gPT09ICdcIicpIHtcbiAgICB1c2VyID0gdXNlci5zbGljZSgxLCB1c2VyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IHF1b3RlZEVtYWlsVXNlclV0ZjgudGVzdCh1c2VyKSA6IHF1b3RlZEVtYWlsVXNlci50ZXN0KHVzZXIpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm4gPSBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IGVtYWlsVXNlclV0ZjhQYXJ0IDogZW1haWxVc2VyUGFydDtcblxuICB2YXIgdXNlcl9wYXJ0cyA9IHVzZXIuc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHVzZXJfcGFydHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgaWYgKCFwYXR0ZXJuLnRlc3QodXNlcl9wYXJ0c1tfaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0ZRRE47XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gcmVxdWlyZSgnLi91dGlsL2Fzc2VydFN0cmluZycpO1xuXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnRTdHJpbmcpO1xuXG52YXIgX21lcmdlID0gcmVxdWlyZSgnLi91dGlsL21lcmdlJyk7XG5cbnZhciBfbWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVyZ2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9mcWRuX29wdGlvbnMgPSB7XG4gIHJlcXVpcmVfdGxkOiB0cnVlLFxuICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGlzRlFETihzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlMi5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2ZxZG5fb3B0aW9ucyk7XG5cbiAgLyogUmVtb3ZlIHRoZSBvcHRpb25hbCB0cmFpbGluZyBkb3QgYmVmb3JlIGNoZWNraW5nIHZhbGlkaXR5ICovXG4gIGlmIChvcHRpb25zLmFsbG93X3RyYWlsaW5nX2RvdCAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLicpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgfVxuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJ0c1tpXS5sZW5ndGggPiA2Mykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZXF1aXJlX3RsZCkge1xuICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcbiAgICBpZiAoIXBhcnRzLmxlbmd0aCB8fCAhL14oW2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9fHhuW2EtejAtOS1dezIsfSkkL2kudGVzdCh0bGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGRpc2FsbG93IHNwYWNlc1xuICAgIGlmICgvW1xcc1xcdTIwMDItXFx1MjAwQlxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZcXHVEQjQwXFx1REMyMF0vLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBwYXJ0LCBfaSA9IDA7IF9pIDwgcGFydHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgcGFydCA9IHBhcnRzW19pXTtcbiAgICBpZiAob3B0aW9ucy5hbGxvd191bmRlcnNjb3Jlcykge1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgfVxuICAgIGlmICghL15bYS16XFx1MDBhMS1cXHVmZmZmMC05LV0rJC9pLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZGlzYWxsb3cgZnVsbC13aWR0aCBjaGFyc1xuICAgIGlmICgvW1xcdWZmMDEtXFx1ZmY1ZV0vLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcnRbMF0gPT09ICctJyB8fCBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPT09ICctJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gcmVxdWlyZSgnLi91dGlsL2Fzc2VydFN0cmluZycpO1xuXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnRTdHJpbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaXB2NE1heWJlID0gL14oXFxkezEsM30pXFwuKFxcZHsxLDN9KVxcLihcXGR7MSwzfSlcXC4oXFxkezEsM30pJC87XG52YXIgaXB2NkJsb2NrID0gL15bMC05QS1GXXsxLDR9JC9pO1xuXG5mdW5jdGlvbiBpc0lQKHN0cikge1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG4gIGlmICghdmVyc2lvbikge1xuICAgIHJldHVybiBpc0lQKHN0ciwgNCkgfHwgaXNJUChzdHIsIDYpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc0Jykge1xuICAgIGlmICghaXB2NE1heWJlLnRlc3Qoc3RyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzWzNdIDw9IDI1NTtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAnNicpIHtcbiAgICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KCc6Jyk7XG4gICAgdmFyIGZvdW5kT21pc3Npb25CbG9jayA9IGZhbHNlOyAvLyBtYXJrZXIgdG8gaW5kaWNhdGUgOjpcblxuICAgIC8vIEF0IGxlYXN0IHNvbWUgT1MgYWNjZXB0IHRoZSBsYXN0IDMyIGJpdHMgb2YgYW4gSVB2NiBhZGRyZXNzXG4gICAgLy8gKGkuZS4gMiBvZiB0aGUgYmxvY2tzKSBpbiBJUHY0IG5vdGF0aW9uLCBhbmQgUkZDIDM0OTMgc2F5c1xuICAgIC8vIHRoYXQgJzo6ZmZmZjphLmIuYy5kJyBpcyB2YWxpZCBmb3IgSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzZXMsXG4gICAgLy8gYW5kICc6OmEuYi5jLmQnIGlzIGRlcHJlY2F0ZWQsIGJ1dCBhbHNvIHZhbGlkLlxuICAgIHZhciBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPSBpc0lQKGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0sIDQpO1xuICAgIHZhciBleHBlY3RlZE51bWJlck9mQmxvY2tzID0gZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrID8gNyA6IDg7XG5cbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA+IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBvciBmaW5hbCA6OlxuICAgIGlmIChzdHIgPT09ICc6OicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJzo6Jykge1xuICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICBibG9ja3Muc2hpZnQoKTtcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSAyKSA9PT0gJzo6Jykge1xuICAgICAgYmxvY2tzLnBvcCgpO1xuICAgICAgYmxvY2tzLnBvcCgpO1xuICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gdGVzdCBmb3IgYSA6OiB3aGljaCBjYW4gbm90IGJlIGF0IHRoZSBzdHJpbmcgc3RhcnQvZW5kXG4gICAgICAvLyBzaW5jZSB0aG9zZSBjYXNlcyBoYXZlIGJlZW4gaGFuZGxlZCBhYm92ZVxuICAgICAgaWYgKGJsb2Nrc1tpXSA9PT0gJycgJiYgaSA+IDAgJiYgaSA8IGJsb2Nrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChmb3VuZE9taXNzaW9uQmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG11bHRpcGxlIDo6IGluIGFkZHJlc3NcbiAgICAgICAgfVxuICAgICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgJiYgaSA9PT0gYmxvY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gaXQgaGFzIGJlZW4gY2hlY2tlZCBiZWZvcmUgdGhhdCB0aGUgbGFzdFxuICAgICAgICAvLyBibG9jayBpcyBhIHZhbGlkIElQdjQgYWRkcmVzc1xuICAgICAgfSBlbHNlIGlmICghaXB2NkJsb2NrLnRlc3QoYmxvY2tzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb3VuZE9taXNzaW9uQmxvY2spIHtcbiAgICAgIHJldHVybiBibG9ja3MubGVuZ3RoID49IDE7XG4gICAgfVxuICAgIHJldHVybiBibG9ja3MubGVuZ3RoID09PSBleHBlY3RlZE51bWJlck9mQmxvY2tzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydFN0cmluZztcbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCkge1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuXG4gIGlmICghaXNTdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIGxpYnJhcnkgKHZhbGlkYXRvci5qcykgdmFsaWRhdGVzIHN0cmluZ3Mgb25seScpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtZXJnZTtcbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGRlZmF1bHRzID0gYXJndW1lbnRzWzFdO1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmpba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjt2YXIgZ2V0U2x1Zz1yZXF1aXJlKFwic3BlYWtpbmd1cmxcIiksZXh0UmVnPS9cXC5bMC05YS16XSskLztmdW5jdGlvbiBzbHVnRmlsZW5hbWUoZSl7dmFyIHQ9ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtpZighZXh0UmVnLnRlc3QodCkpcmV0dXJuIGNvbnNvbGUubG9nKFwiW1NMVUdGSUxFTkFNRV0gaW1wb3NzaWJsZSB0byBzbHVnXCIsZSksITE7dmFyIHI9ZXh0UmVnLmV4ZWModClbMF07cmV0dXJuIHQ9dC5yZXBsYWNlKHIsXCJcIiksdD1nZXRTbHVnKHQudHJpbSgpKStyfW1vZHVsZS5leHBvcnRzPXNsdWdGaWxlbmFtZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnNkV2N0Wm1sc1pXNWhiV1V1YW5NaVhTd2libUZ0WlhNaU9sc2laMlYwVTJ4MVp5SXNJbkpsY1hWcGNtVWlMQ0psZUhSU1pXY2lMQ0p6YkhWblJtbHNaVzVoYldVaUxDSnVZVzFsSWl3aVptbHNaVTVoYldVaUxDSjBiMHh2ZDJWeVEyRnpaU0lzSW5SeWFXMGlMQ0owWlhOMElpd2lZMjl1YzI5c1pTSXNJbXh2WnlJc0ltVjRkQ0lzSW1WNFpXTWlMQ0p5WlhCc1lXTmxJaXdpYlc5a2RXeGxJaXdpWlhod2IzSjBjeUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzWVVGRlFTeEpRVUZKUVN4UlFVRlZReXhSUVVGUkxHVkJTV3hDUXl4UFFVRlZMR1ZCUldRc1UwRkJVME1zWVVGQllVTXNSMEZEY0VJc1NVRkJTVU1zUlVGQlowSkVMRVZCUVV0RkxHTkJRV05ETEU5QlMzWkRMRWxCUkc5Q1RDeFBRVUZQVFN4TFFVRk5TQ3hIUVVjdlFpeFBRVVJCU1N4UlFVRlJReXhKUVVGSkxHOURRVUZ4UTA0c1NVRkRNVU1zUlVGRlZDeEpRVUZKVHl4RlFVRm5RbFFzVDBGQlQxVXNTMEZCUzFBc1IwRkJWU3hIUVVjeFF5eFBRVVpCUVN4RlFVRnZRa0VzUlVGQlUxRXNVVUZCVVVZc1JVRkJTeXhKUVVNeFEwNHNSVUZCYjBKTUxGRkJRVk5MTEVWQlFWTkZMRkZCUVZkSkxFVkJTVzVFUnl4UFFVRlBReXhSUVVGVldpSXNJbVpwYkdVaU9pSXZjSEpwZG1GMFpTOTBiWEF2Wm05dkxrZFBSUzl6YUdGeVpXUXZjMngxWnkxbWFXeGxibUZ0WlM1cWN5SjkiLCJcInVzZSBzdHJpY3RcIjt2YXIgdXJsPXJlcXVpcmUoXCJ1cmxcIiksY29uc29sZT1yZXF1aXJlKFwiY29uc29sZS1icm93c2VyaWZ5XCIpLGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGwsJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsdGVtcGxhdGVMb2FkZXI9cmVxdWlyZShcIi4vdGVtcGxhdGUtbG9hZGVyLmpzXCIpO3JlcXVpcmUoXCIuL2tvLWJpbmRpbmdzLmpzXCIpO3ZhciBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyPXJlcXVpcmUoXCIuL3RpbWVkLWNhbGwuanNcIikudGltZWRDYWxsLGFkZFVuZG9TdGFja0V4dGVuc2lvbk1ha2VyPXJlcXVpcmUoXCIuL3VuZG9tYW5hZ2VyL3VuZG9tYWluLmpzXCIpLGNvbG9yUGx1Z2luPXJlcXVpcmUoXCIuL2V4dC9jb2xvci5qc1wiKSx1dGlsUGx1Z2luPXJlcXVpcmUoXCIuL2V4dC91dGlsLmpzXCIpLGlubGluZXJQbHVnaW49cmVxdWlyZShcIi4vZXh0L2lubGluZXIuanNcIiksbG9jYWxTdG9yYWdlTG9hZGVyPXJlcXVpcmUoXCIuL2V4dC9sb2NhbHN0b3JhZ2UuanNcIik7aWYodm9pZCAwPT09a28pdGhyb3dcIkNhbm5vdCBmaW5kIGtub2Nrb3V0LmpzIGxpYnJhcnkhXCI7aWYodm9pZCAwPT09JCl0aHJvd1wiQ2Fubm90IGZpbmQganF1ZXJ5IGxpYnJhcnkhXCI7dmFyIGluaXRGcm9tTG9jYWxTdG9yYWdlLHN0YXJ0PWZ1bmN0aW9uKGUsaSx0LG8sbil7dGVtcGxhdGVMb2FkZXIuZml4UGFnZUV2ZW50cygpO3ZhciBhPVtmdW5jdGlvbihpKXtlJiZlLnN0cmluZ3MmJihpLnQ9ZnVuY3Rpb24odCxvKXt2YXIgbj1lLnN0cmluZ3NbdF07cmV0dXJuIHZvaWQgMD09PW4mJihjb25zb2xlLndhcm4oXCJNaXNzaW5nIHRyYW5zbGF0aW9uIHN0cmluZyBmb3JcIix0LFwiOiB1c2luZyBkZWZhdWx0IHN0cmluZ1wiKSxuPXQpLGkudHQobixvKX0pfSxhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlcihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSxjb2xvclBsdWdpbix1dGlsUGx1Z2luLGlubGluZXJQbHVnaW5dO2lmKHZvaWQgMCE9PW4pZm9yKHZhciBsPTA7bDxuLmxlbmd0aDtsKyspYS5wdXNoKG5bbF0pO2EucHVzaChmdW5jdGlvbihpKXt2YXIgdD17bWVzc2FnZXM6e3Vua25vd25FcnJvcjppLnQoXCJVbmtub3duIGVycm9yXCIpLHVwbG9hZGVkQnl0ZXM6aS50KFwiVXBsb2FkZWQgYnl0ZXMgZXhjZWVkIGZpbGUgc2l6ZVwiKSxtYXhOdW1iZXJPZkZpbGVzOmkudChcIk1heGltdW0gbnVtYmVyIG9mIGZpbGVzIGV4Y2VlZGVkXCIpLGFjY2VwdEZpbGVUeXBlczppLnQoXCJGaWxlIHR5cGUgbm90IGFsbG93ZWRcIiksbWF4RmlsZVNpemU6aS50KFwiRmlsZSBpcyB0b28gbGFyZ2VcIiksbWluRmlsZVNpemU6aS50KFwiRmlsZSBpcyB0b28gc21hbGxcIikscG9zdF9tYXhfc2l6ZTppLnQoXCJUaGUgdXBsb2FkZWQgZmlsZSBleGNlZWRzIHRoZSBwb3N0X21heF9zaXplIGRpcmVjdGl2ZSBpbiBwaHAuaW5pXCIpLG1heF9maWxlX3NpemU6aS50KFwiRmlsZSBpcyB0b28gYmlnXCIpLG1pbl9maWxlX3NpemU6aS50KFwiRmlsZSBpcyB0b28gc21hbGxcIiksYWNjZXB0X2ZpbGVfdHlwZXM6aS50KFwiRmlsZXR5cGUgbm90IGFsbG93ZWRcIiksbWF4X251bWJlcl9vZl9maWxlczppLnQoXCJNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZFwiKSxtYXhfd2lkdGg6aS50KFwiSW1hZ2UgZXhjZWVkcyBtYXhpbXVtIHdpZHRoXCIpLG1pbl93aWR0aDppLnQoXCJJbWFnZSByZXF1aXJlcyBhIG1pbmltdW0gd2lkdGhcIiksbWF4X2hlaWdodDppLnQoXCJJbWFnZSBleGNlZWRzIG1heGltdW0gaGVpZ2h0XCIpLG1pbl9oZWlnaHQ6aS50KFwiSW1hZ2UgcmVxdWlyZXMgYSBtaW5pbXVtIGhlaWdodFwiKSxhYm9ydDppLnQoXCJGaWxlIHVwbG9hZCBhYm9ydGVkXCIpLGltYWdlX3Jlc2l6ZTppLnQoXCJGYWlsZWQgdG8gcmVzaXplIGltYWdlXCIpLGdlbmVyaWM6aS50KFwiVW5leHBlY3RlZCB1cGxvYWQgZXJyb3JcIil9fTtlJiZlLmZpbGV1cGxvYWRDb25maWcmJih0PSQuZXh0ZW5kKCEwLHQsZS5maWxldXBsb2FkQ29uZmlnKSksa28uYmluZGluZ0hhbmRsZXJzLmZpbGV1cGxvYWQuZXh0ZW5kT3B0aW9ucz10fSk7dmFyIHI9ZS5maWxldXBsb2FkQ29uZmlnP2UuZmlsZXVwbG9hZENvbmZpZy51cmw6XCIvdXBsb2FkL1wiO2FwcGx5QmluZGluZ09wdGlvbnMoZSxrbyksJChcIlxceDNjIS0tIGtvIHRlbXBsYXRlOiAnbWFpbicgLS1cXHgzZVxceDNjIS0tIC9rbyAtLVxceDNlXCIpLmFwcGVuZFRvKGdsb2JhbC5kb2N1bWVudC5ib2R5KSx2b2lkIDA9PT1pJiZ2b2lkIDAhPT10JiYoaT10LnRlbXBsYXRlKSx0ZW1wbGF0ZUxvYWRlci5sb2FkKHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIsaSx0LG8sYSxyKX0sYXBwbHlCaW5kaW5nT3B0aW9ucz0kLm5vb3AsY3VzdG9tRXh0PXJlcXVpcmUoXCIuL2V4dC9jdXN0b20tZXh0ZW5zaW9uc1wiKSxpbml0PWZ1bmN0aW9uKGUsaSl7cmV0dXJuIGNvbnNvbGUuaW5mbyhcIkNVU1RPTSBNT1NBSUNPIOKAkyBpbml0XCIpLGNvbnNvbGUubG9nKGUpLCEhKGUmJmUubWV0YWRhdGEmJmUuZGF0YSkmJihjdXN0b21FeHQuZXh0ZW5kVmlld01vZGVsKGUsaSksY3VzdG9tRXh0LmV4dGVuZEtub2Nrb3V0KGUpLHN0YXJ0KGUsdm9pZCAwLGUubWV0YWRhdGEsZS5kYXRhLGkpLCEwKX07bW9kdWxlLmV4cG9ydHM9e2lzQ29tcGF0aWJsZTp0ZW1wbGF0ZUxvYWRlci5pc0NvbXBhdGlibGUsaW5pdDppbml0LHN0YXJ0OnN0YXJ0fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltRndjQzVxY3lKZExDSnVZVzFsY3lJNld5SjFjbXdpTENKeVpYRjFhWEpsSWl3aVkyOXVjMjlzWlNJc0ltdHZJaXdpZDJsdVpHOTNJaXdpWjJ4dlltRnNJaXdpSkNJc0luUmxiWEJzWVhSbFRHOWhaR1Z5SWl3aWNHVnlabTl5YldGdVkyVkJkMkZ5WlVOaGJHeGxjaUlzSW5ScGJXVmtRMkZzYkNJc0ltRmtaRlZ1Wkc5VGRHRmphMFY0ZEdWdWMybHZiazFoYTJWeUlpd2lZMjlzYjNKUWJIVm5hVzRpTENKMWRHbHNVR3gxWjJsdUlpd2lhVzVzYVc1bGNsQnNkV2RwYmlJc0lteHZZMkZzVTNSdmNtRm5aVXh2WVdSbGNpSXNJbWx1YVhSR2NtOXRURzlqWVd4VGRHOXlZV2RsSWl3aWMzUmhjblFpTENKdmNIUnBiMjV6SWl3aWRHVnRjR3hoZEdWR2FXeGxJaXdpZEdWdGNHeGhkR1ZOWlhSaFpHRjBZU0lzSW1wemIzSnFjMjl1SWl3aVkzVnpkRzl0UlhoMFpXNXphVzl1Y3lJc0ltWnBlRkJoWjJWRmRtVnVkSE1pTENKbGVIUmxibk5wYjI1eklpd2lkbTBpTENKemRISnBibWR6SWl3aWRDSXNJbXRsZVNJc0ltOWlhbEJoY21GdElpd2ljbVZ6SWl3aWQyRnliaUlzSW5SMElpd2lheUlzSW14bGJtZDBhQ0lzSW5CMWMyZ2lMQ0ptYVd4bGRYQnNiMkZrUTI5dVptbG5JaXdpYldWemMyRm5aWE1pTENKMWJtdHViM2R1UlhKeWIzSWlMQ0oxY0d4dllXUmxaRUo1ZEdWeklpd2liV0Y0VG5WdFltVnlUMlpHYVd4bGN5SXNJbUZqWTJWd2RFWnBiR1ZVZVhCbGN5SXNJbTFoZUVacGJHVlRhWHBsSWl3aWJXbHVSbWxzWlZOcGVtVWlMQ0p3YjNOMFgyMWhlRjl6YVhwbElpd2liV0Y0WDJacGJHVmZjMmw2WlNJc0ltMXBibDltYVd4bFgzTnBlbVVpTENKaFkyTmxjSFJmWm1sc1pWOTBlWEJsY3lJc0ltMWhlRjl1ZFcxaVpYSmZiMlpmWm1sc1pYTWlMQ0p0WVhoZmQybGtkR2dpTENKdGFXNWZkMmxrZEdnaUxDSnRZWGhmYUdWcFoyaDBJaXdpYldsdVgyaGxhV2RvZENJc0ltRmliM0owSWl3aWFXMWhaMlZmY21WemFYcGxJaXdpWjJWdVpYSnBZeUlzSW1WNGRHVnVaQ0lzSW1KcGJtUnBibWRJWVc1a2JHVnljeUlzSW1WNGRHVnVaRTl3ZEdsdmJuTWlMQ0puWVd4c1pYSjVWWEpzSWl3aVlYQndiSGxDYVc1a2FXNW5UM0IwYVc5dWN5SXNJbUZ3Y0dWdVpGUnZJaXdpWkc5amRXMWxiblFpTENKaWIyUjVJaXdpZEdWdGNHeGhkR1VpTENKc2IyRmtJaXdpYm05dmNDSXNJbU4xYzNSdmJVVjRkQ0lzSW1sdWFYUWlMQ0p2Y0hSeklpd2lhVzVtYnlJc0lteHZaeUlzSW0xbGRHRmtZWFJoSWl3aVpHRjBZU0lzSW1WNGRHVnVaRlpwWlhkTmIyUmxiQ0lzSW1WNGRHVnVaRXR1YjJOcmIzVjBJaXdpYlc5a2RXeGxJaXdpWlhod2IzSjBjeUlzSW1selEyOXRjR0YwYVdKc1pTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNZVUZKUVN4SlFVRkpRU3hKUVVGVlF5eFJRVUZSTEU5QlEyeENReXhSUVVGVlJDeFJRVUZSTEhOQ1FVTnNRa1VzUjBGQmQwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRlhMRWRCUVhOQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlZ5eEhRVUZKTEV0QlEzQkhReXhGUVVGMVFpeHZRa0ZCV0VZc1QwRkJlVUpCTEU5QlFXVXNUMEZCYzBJc2IwSkJRVmhETEU5QlFYbENRU3hQUVVGbExFOUJRVWtzUzBGRk0wZEZMR1ZCUVdsQ1RpeFJRVUZSTEhkQ1FVVTNRa0VzVVVGQlVTeHZRa0ZEVWl4SlFVRkpUeXgxUWtGQmVVSlFMRkZCUVZFc2JVSkJRVzFDVVN4VlFVVndSRU1zTWtKQlFUWkNWQ3hSUVVGUkxEWkNRVU55UTFVc1dVRkJZMVlzVVVGQlVTeHJRa0ZEZEVKWExGZEJRV0ZZTEZGQlFWRXNhVUpCUTNKQ1dTeGpRVUZuUWxvc1VVRkJVU3h2UWtGRmVFSmhMRzFDUVVGeFFtSXNVVUZCVVN4NVFrRkZha01zVVVGQmFVSXNTVUZCVGtVc1IwRkJiVUlzUzBGQlRTeHRRMEZEY0VNc1VVRkJaMElzU1VGQlRFY3NSVUZCYTBJc1MwRkJUU3c0UWtGelJHNURMRWxCTUVWSlV5eHhRa0V4UlVGRExFMUJRVkVzVTBGQlUwTXNSVUZCVTBNc1JVRkJZME1zUlVGQmEwSkRMRVZCUVZWRExFZEJTWFJGWkN4bFFVRmxaU3huUWtGRlppeEpRVFpEU1VNc1JVRkJZU3hEUVdSaExGTkJRVk5ETEVkQlEycERVQ3hIUVVGWFFTeEZRVUZSVVN4VlFVTnlRa1FzUlVGQlIwVXNSVUZCU1N4VFFVRlRReXhGUVVGTFF5eEhRVU51UWl4SlFVRkpReXhGUVVGTldpeEZRVUZSVVN4UlFVRlJSU3hIUVVzeFFpeFpRVXByUWl4SlFVRlFSU3hKUVVOVU0wSXNVVUZCVVRSQ0xFdEJRVXNzYVVOQlFXbERTQ3hGUVVGSkxEQkNRVU5zUkVVc1JVRkJUVVlzUjBGRlJFZ3NSVUZCUjA4c1IwRkJSMFlzUlVGQlMwUXNUVUZOYlVKc1Fpd3lRa0ZCTWtKR0xIZENRVUY1UWtjc1dVRkJZVU1zVjBGQldVTXNaVUZEZUVnc1VVRkJaME1zU1VGQmNrSlJMRVZCUTFRc1NVRkJTeXhKUVVGSlZ5eEZRVUZKTEVWQlFVZEJMRVZCUVVsWUxFVkJRV2xDV1N4UFFVRlJSQ3hKUVVGTFZDeEZRVUZYVnl4TFFVRkxZaXhGUVVGcFFsY3NTVUZEY2taVUxFVkJRVmRYTEV0QmFFUjFRaXhUUVVGVFZpeEhRVU42UXl4SlFVRkpWeXhGUVVGdFFpeERRVU55UWtNc1UwRkJWU3hEUVVOU1F5eGhRVUZqWWl4RlFVRkhSU3hGUVVGRkxHbENRVU51UWxrc1kwRkJaV1FzUlVGQlIwVXNSVUZCUlN4dFEwRkRjRUpoTEdsQ1FVRnJRbVlzUlVGQlIwVXNSVUZCUlN4dlEwRkRka0pqTEdkQ1FVRnBRbWhDTEVWQlFVZEZMRVZCUVVVc2VVSkJRM1JDWlN4WlFVRmhha0lzUlVGQlIwVXNSVUZCUlN4eFFrRkRiRUpuUWl4WlFVRmhiRUlzUlVGQlIwVXNSVUZCUlN4eFFrRkRiRUpwUWl4alFVRmxia0lzUlVGQlIwVXNSVUZCUlN4dlJVRkRjRUpyUWl4alFVRmxjRUlzUlVGQlIwVXNSVUZCUlN4dFFrRkRjRUp0UWl4alFVRmxja0lzUlVGQlIwVXNSVUZCUlN4eFFrRkRjRUp2UWl4clFrRkJiVUowUWl4RlFVRkhSU3hGUVVGRkxIZENRVU40UW5GQ0xHOUNRVUZ4UW5aQ0xFVkJRVWRGTEVWQlFVVXNiME5CUXpGQ2MwSXNWVUZCVjNoQ0xFVkJRVWRGTEVWQlFVVXNLMEpCUTJoQ2RVSXNWVUZCVjNwQ0xFVkJRVWRGTEVWQlFVVXNhME5CUTJoQ2QwSXNWMEZCV1RGQ0xFVkJRVWRGTEVWQlFVVXNaME5CUTJwQ2VVSXNWMEZCV1ROQ0xFVkJRVWRGTEVWQlFVVXNiVU5CUTJwQ01FSXNUVUZCVHpWQ0xFVkJRVWRGTEVWQlFVVXNkVUpCUTFveVFpeGhRVUZqTjBJc1JVRkJSMFVzUlVGQlJTd3dRa0ZEYmtJMFFpeFJRVUZUT1VJc1JVRkJSMFVzUlVGQlJTdzJRa0ZKWkZRc1IwRkJWMEVzUlVGQlVXdENMRzFDUVVOeVFrRXNSVUZCYlVJM1FpeEZRVUZGYVVRc1VVRkJUeXhGUVVGTmNFSXNSVUZCYTBKc1FpeEZRVUZSYTBJc2JVSkJSVGxFYUVNc1IwRkJSM0ZFTEdkQ1FVRTBRaXhYUVVGRlF5eGpRVUZuUW5SQ0xFbEJkVUp1UkN4SlFVRkpkVUlzUlVGQllYcERMRVZCUVZGclFpeHBRa0ZCYlVKc1FpeEZRVUZSYTBJc2FVSkJRV2xDYmtNc1NVRkJUU3hYUVVNelJUSkVMRzlDUVVGdlFqRkRMRVZCUVZOa0xFbEJSemRDUnl4RlFVRkZMSGRFUVVFMFEzTkVMRk5CUVZOMlJDeFBRVUZQZDBRc1UwRkJVME1zVjBGSE5VTXNTVUZCYUVJMVF5eFJRVUV3UkN4SlFVRndRa01zU1VGREwwTkVMRVZCUVdWRExFVkJRV2xDTkVNc1ZVRkpiRU40UkN4bFFVRmxlVVFzUzBGQlMzaEVMSFZDUVVGM1FsVXNSVUZCWTBNc1JVRkJhMEpETEVWQlFWVkhMRVZCUVZsdFF5eEpRWFZFYUVkRExHOUNRVUZ6UW5KRUxFVkJRVVV5UkN4TFFWbDRRa01zVlVGQldXcEZMRkZCUVZFc01rSkJSWEJDYTBVc1MwRkJUeXhUUVVGVFF5eEZRVUZOTDBNc1IwRkxlRUlzVDBGS1FXNUNMRkZCUVZGdFJTeExRVUZMTEhsQ1FVTmlia1VzVVVGQlVXOUZMRWxCUVVsR0xFMUJRMGRCTEVkQlFWRkJMRVZCUVV0SExGVkJRVmxJTEVWQlFVdEpMRkZCU1RkRFRpeFZRVUZWVHl4blFrRkJaMEpNTEVWQlFVMHZReXhIUVVOb1F6WkRMRlZCUVZWUkxHVkJRV1ZPTEVkQlJYcENjRVFzVFVGQlRXOUVMRTlCUVUwc1JVRkJVMEVzUlVGQlMwY3NVMEZCVlVnc1JVRkJTMGtzUzBGQlRXNUVMRWxCUlhoRExFbEJTMVJ6UkN4UFFVRlBReXhSUVVGVkxFTkJRMlpETEdGQlFXTjBSU3hsUVVGbGMwVXNZVUZETjBKV0xFdEJRVTFCTEV0QlEwNXVSQ3hOUVVGUFFTSXNJbVpwYkdVaU9pSXZjSEpwZG1GMFpTOTBiWEF2Wm05dkxrZFBSUzl6Y21NdmFuTXZZWEJ3TG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIga289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIiksYWRkU2NyaXB0VGVtcGxhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvPWUuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtyZXR1cm4gby5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJ0ZXh0L2h0bWxcIiksby5zZXRBdHRyaWJ1dGUoXCJpZFwiLHQpLG8udGV4dD1uLGUuYm9keS5hcHBlbmRDaGlsZChvKSxvfTtrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZT17dHBsOic8IURPQ1RZUEUgaHRtbD5cXHJcXG48aHRtbD5cXHJcXG48aGVhZD5cXHJcXG48L2hlYWQ+XFxyXFxuPGJvZHk+PGRpdiBkYXRhLWJpbmQ9XCJibG9jazogY29udGVudFwiPjwvZGl2PjwvYm9keT5cXHJcXG48L2h0bWw+XFxyXFxuJyxpbml0OmZ1bmN0aW9uKGUsdCl7IWZ1bmN0aW9uKG4pe3RyeXt2YXIgbz1lLmNvbnRlbnREb2N1bWVudDtvLm9wZW4oKSxvLndyaXRlKGtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbCksby5jbG9zZSgpO3RyeXt2YXIgcj1vLmJvZHk7aWYocil7Zm9yKHZhciBpPWUuY29udGVudFdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIiksZD0wO2Q8aS5sZW5ndGg7ZCsrKVwidGV4dC9odG1sXCI9PWlbZF0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSYmaVtkXS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSYmYWRkU2NyaXB0VGVtcGxhdGUobyxpW2RdLmdldEF0dHJpYnV0ZShcImlkXCIpLGlbZF0uaW5uZXJIVE1MKTt2YXIgYT1vLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiSFRNTFwiKTtrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGUsZnVuY3Rpb24oKXtrby5jbGVhbk5vZGUoYVswXXx8cil9KSxrby5hcHBseUJpbmRpbmdzKHQoKSxhWzBdfHxyKX1lbHNlIGNvbnNvbGUubG9nKFwibm8gaWZyYW1lZG9jXCIsbil9Y2F0Y2goZSl7dGhyb3cgY29uc29sZS5sb2coXCJlcnJvciByZWFkaW5nIGlmcmFtZS5ib2R5XCIsZSxuKSxlfX1jYXRjaChlKXt0aHJvdyBjb25zb2xlLmxvZyhcImVycm9yIHJlYWRpbmcgaWZyYW1lIGNvbnRlbnREb2N1bWVudFwiLGUsbiksZX19KFwiZmlyc3QgY2FsbFwiKX19O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1KcGJtUXRhV1p5WVcxbExtcHpJbDBzSW01aGJXVnpJanBiSW10dklpd2lkMmx1Wkc5M0lpd2laMnh2WW1Gc0lpd2lZMjl1YzI5c1pTSXNJbkpsY1hWcGNtVWlMQ0poWkdSVFkzSnBjSFJVWlcxd2JHRjBaU0lzSW1Sdll5SXNJblJsYlhCc1lYUmxUbUZ0WlNJc0luUmxiWEJzWVhSbFRXRnlhM1Z3SWl3aWMyTnlhWEIwVkdGbklpd2lZM0psWVhSbFJXeGxiV1Z1ZENJc0luTmxkRUYwZEhKcFluVjBaU0lzSW5SbGVIUWlMQ0ppYjJSNUlpd2lZWEJ3Wlc1a1EyaHBiR1FpTENKaWFXNWthVzVuU0dGdVpHeGxjbk1pTENKaWFXNWtTV1p5WVcxbElpd2lkSEJzSWl3aWFXNXBkQ0lzSW1Wc1pXMWxiblFpTENKMllXeDFaVUZqWTJWemMyOXlJaXdpYkc5allXd2lMQ0pwWm5KaGJXVWlMQ0pqYjI1MFpXNTBSRzlqZFcxbGJuUWlMQ0p2Y0dWdUlpd2lkM0pwZEdVaUxDSmpiRzl6WlNJc0ltbG1jbUZ0WldSdll5SXNJblJsYlhCc1lYUmxjeUlzSW1OdmJuUmxiblJYYVc1a2IzY2lMQ0p3WVhKbGJuUWlMQ0prYjJOMWJXVnVkQ0lzSW1kbGRFVnNaVzFsYm5SelFubFVZV2RPWVcxbElpd2lhU0lzSW14bGJtZDBhQ0lzSW1kbGRFRjBkSEpwWW5WMFpTSXNJbWx1Ym1WeVNGUk5UQ0lzSW1oMGJXd2lMQ0oxZEdsc2N5SXNJbVJ2YlU1dlpHVkVhWE53YjNOaGJDSXNJbUZrWkVScGMzQnZjMlZEWVd4c1ltRmpheUlzSW1Oc1pXRnVUbTlrWlNJc0ltRndjR3g1UW1sdVpHbHVaM01pTENKc2IyY2lMQ0psSWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4aFFVVkJMRWxCUVVsQkxFZEJRWGRDTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCVnl4SFFVRnpRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRVmNzUjBGQlNTeExRVU53UjBNc1VVRkJWVU1zVVVGQlVTeHpRa0ZIYkVKRExHdENRVUZ2UWl4VFFVRlRReXhGUVVGTFF5eEZRVUZqUXl4SFFVTnNSQ3hKUVVGSlF5eEZRVUZaU0N4RlFVRkpTU3hqUVVGakxGVkJTMnhETEU5QlNrRkVMRVZCUVZWRkxHRkJRV0VzVDBGQlVTeGhRVU12UWtZc1JVRkJWVVVzWVVGQllTeExRVUZOU2l4SFFVTTNRa1VzUlVGQlZVY3NTMEZCVDBvc1JVRkRha0pHTEVWQlFVbFBMRXRCUVV0RExGbEJRVmxNTEVkQlEyUkJMRWRCUzFSVUxFZEJRVWRsTEdkQ1FVRm5Ra01zVjBGQllTeERRVVU1UWtNc1NVRkJTeXgxU0VGRFRFTXNTMEZCVFN4VFFVRlRReXhGUVVGVFF5eEpRVU4wUWl4VFFVRnZRa01zUjBGRGJFSXNTVUZEUlN4SlFVRkpReXhGUVVGVFNDeEZRVUZSU1N4blFrRkRja0pFTEVWQlFVOUZMRTlCUTFCR0xFVkJRVTlITEUxQlFVMTZRaXhIUVVGSFpTeG5Ra0ZCWjBKRExGZEJRVmRETEV0QlF6TkRTeXhGUVVGUFNTeFJRVVZRTEVsQlEwVXNTVUZCU1VNc1JVRkJXVXdzUlVGQlQxUXNTMEZEZGtJc1IwRkJTV01zUlVGQlZ5eERRVWRpTEVsQlJFRXNTVUZCU1VNc1JVRkJXVlFzUlVGQlVWVXNZMEZCWTBNc1QwRkJUME1zVTBGQlUwTXNjVUpCUVhGQ0xGVkJRMnhGUXl4RlFVRkpMRVZCUVVkQkxFVkJRVWxNTEVWQlFWVk5MRTlCUVZGRUxFbEJRMHNzWVVGQmNrTk1MRVZCUVZWTExFZEJRVWRGTEdGQlFXRXNVMEZCTUVKUUxFVkJRVlZMTEVkQlFVZEZMR0ZCUVdFc1QwRkRhRVk1UWl4clFrRkJhMEpwUWl4RlFVRlJUU3hGUVVGVlN5eEhRVUZIUlN4aFFVRmhMRTFCUVU5UUxFVkJRVlZMTEVkQlFVZEhMRmRCU1RWRkxFbEJRVWxETEVWQlFVOW1MRVZCUVU5VkxIRkNRVUZ4UWl4UlFVVjJRMmhETEVkQlFVZHpReXhOUVVGTlF5eG5Ra0ZCWjBKRExHMUNRVUZ0UW5KQ0xFVkJRVk1zVjBGRGJrUnVRaXhIUVVGSGVVTXNWVUZCVlVvc1JVRkJTeXhKUVVGTlZpeExRVWN4UWpOQ0xFZEJRVWN3UXl4alFVRmpkRUlzU1VGQmFVSnBRaXhGUVVGTExFbEJRVTFXTEZGQlJUZERlRUlzVVVGQlVYZERMRWxCUVVrc1pVRkJaMEowUWl4SFFVVTVRaXhOUVVGUGRVSXNSMEZGVUN4TlFVUkJla01zVVVGQlVYZERMRWxCUVVrc05FSkJRVFpDUXl4RlFVRkhka0lzUjBGRGRFTjFRaXhIUVVWU0xFMUJRVTlCTEVkQlJWQXNUVUZFUVhwRExGRkJRVkYzUXl4SlFVRkpMSFZEUVVGM1EwTXNSVUZCUjNaQ0xFZEJRMnBFZFVJc1IwRkpWalZDTEVOQlFWY2lMQ0ptYVd4bElqb2lMM0J5YVhaaGRHVXZkRzF3TDJadmJ5NUhUMFV2YzNKakwycHpMMkpwYm1ScGJtZHpMMkpwYm1RdGFXWnlZVzFsTG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIga289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIik7a28uYmluZGluZ0hhbmRsZXJzLndpdGhQcm9wZXJ0aWVzPXtpbml0OmZ1bmN0aW9uKGUsbixvLHQsbCl7dmFyIGE9bC5jcmVhdGVDaGlsZENvbnRleHQobC4kcmF3RGF0YSxudWxsLGZ1bmN0aW9uKGUpe2tvLnV0aWxzLmV4dGVuZChlLG4oKSl9KTtyZXR1cm4ga28uYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMoYSxlKSx7Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fX0sa28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5ncy53aXRoUHJvcGVydGllcz0hMCxrby5iaW5kaW5nSGFuZGxlcnMubG9nPXtpbml0OmZ1bmN0aW9uKGUsbixvLHQsbCl7Y29uc29sZS5sb2coXCJsb2dcIixuKCkpfX0sa28uYmluZGluZ0hhbmRsZXJzLmJsb2NrPXt0ZW1wbGF0ZUV4aXN0czpmdW5jdGlvbihlKXtyZXR1cm4hIWdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKX0sX2Nob29zZVRlbXBsYXRlOmZ1bmN0aW9uKGUsbixvLHQpe3ZhciBsPW4rXCItXCIrbztpZihrby5iaW5kaW5nSGFuZGxlcnMuYmxvY2sudGVtcGxhdGVFeGlzdHMobCkpcmV0dXJuIGw7aWYobnVsbCE9dClyZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLmJsb2NrLl9jaG9vc2VUZW1wbGF0ZShlLG4sdCk7dmFyIGE9ZT9cImFycmF5XCI6XCJvYmplY3QtXCIrbztpZihrby5iaW5kaW5nSGFuZGxlcnMuYmxvY2sudGVtcGxhdGVFeGlzdHMoYSkpcmV0dXJuIGE7dGhyb3dcImNhbm5vdCBmaW5kIHRlbXBsYXRlIGZvciBcIitsK1wiL1wiK2F9LF9kaXNwbGF5TW9kZTpmdW5jdGlvbihlLG4pe3ZhciBvPXZvaWQgMCE9PWUudHlwZT9rby51dGlscy51bndyYXBPYnNlcnZhYmxlKGUudHlwZSk6XCJub3RhYmxvY2stXCIrdHlwZW9mIGUsdD12b2lkIDAhPT1lLnNwbGljZSxsPW4udGVtcGxhdGVNb2RlP24udGVtcGxhdGVNb2RlOlwic2hvd1wiO3JldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuYmxvY2suX2Nob29zZVRlbXBsYXRlKHQsbyxsLG4udGVtcGxhdGVNb2RlRmFsbGJhY2spfSxfbWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3NvcjpmdW5jdGlvbihlLG4pe3JldHVybiBmdW5jdGlvbigpe3ZhciBvLHQsbD1lKCksYT1rby51dGlscy5wZWVrT2JzZXJ2YWJsZShsKTtpZighYXx8XCJvYmplY3RcIiE9dHlwZW9mIGEuZGF0YSYmXCJmdW5jdGlvblwiIT10eXBlb2YgYS5kYXRhKW89bDtlbHNlIGlmKG89YS5kYXRhLHZvaWQgMCE9PWEudGVtcGxhdGUpe3ZhciBpPWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYS50ZW1wbGF0ZSkscj1uLnRlbXBsYXRlTW9kZT9uLnRlbXBsYXRlTW9kZTpcInNob3dcIjt0PWtvLmJpbmRpbmdIYW5kbGVycy5ibG9jay5fY2hvb3NlVGVtcGxhdGUoITEsaSxyLG4udGVtcGxhdGVNb2RlRmFsbGJhY2spfXZhciBzPWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobyk7aWYoa28uaXNPYnNlcnZhYmxlKHMpJiZjb25zb2xlLmxvZyhcImRvdWJsZU9ic2VydmFibGVcIixzKSx2b2lkIDA9PT10KWlmKHZvaWQgMD09PW8pdD1cImVtcHR5XCI7ZWxzZSB0cnl7dD1rby5iaW5kaW5nSGFuZGxlcnMuYmxvY2suX2Rpc3BsYXlNb2RlKHMsbil9Y2F0Y2goZSl7dGhyb3cgY29uc29sZS5sb2coZSxzLG4uJGRhdGEsbi50ZW1wbGF0ZU1vZGUpLGV9cmV0dXJue25hbWU6dCxkYXRhOm8sdGVtcGxhdGVFbmdpbmU6a28ubmF0aXZlVGVtcGxhdGVFbmdpbmUuaW5zdGFuY2V9fX0saW5pdDpmdW5jdGlvbihlLG4sbyx0LGwpe3ZvaWQgMD09PW4oKSYmY29uc29sZS5sb2coXCJmb3VuZCBhIG51bGwgYmxvY2s6IGNoZWNrIGVuZGluZyBjb21tYXMgaW4gYXJyYXlzIGRlZnMgaW4gSUVcIik7dmFyIGE9a28uYmluZGluZ0hhbmRsZXJzLmJsb2NrLl9tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yKG4sbCk7cmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy50ZW1wbGF0ZS5pbml0KGUsYSl9LHVwZGF0ZTpmdW5jdGlvbihlLG4sbyx0LGwpe3ZhciBhPWtvLmJpbmRpbmdIYW5kbGVycy5ibG9jay5fbWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3NvcihuLGwpO3JldHVybiBrby5iaW5kaW5nSGFuZGxlcnMudGVtcGxhdGUudXBkYXRlKGUsYSxvLHQsbCl9fSxrby5leHByZXNzaW9uUmV3cml0aW5nLmJpbmRpbmdSZXdyaXRlVmFsaWRhdG9ycy5ibG9jaz0hMSxrby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzLmJsb2NrPSEwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1Kc2IyTnJjeTVxY3lKZExDSnVZVzFsY3lJNld5SnJieUlzSW5kcGJtUnZkeUlzSW1kc2IySmhiQ0lzSW1OdmJuTnZiR1VpTENKeVpYRjFhWEpsSWl3aVltbHVaR2x1WjBoaGJtUnNaWEp6SWl3aWFXNXBkQ0lzSW1Wc1pXMWxiblFpTENKMllXeDFaVUZqWTJWemMyOXlJaXdpWVd4c1FtbHVaR2x1WjNNaUxDSjJhV1YzVFc5a1pXd2lMQ0ppYVc1a2FXNW5RMjl1ZEdWNGRDSXNJbU5vYVd4a1FtbHVaR2x1WjBOdmJuUmxlSFFpTENKamNtVmhkR1ZEYUdsc1pFTnZiblJsZUhRaUxDSWtjbUYzUkdGMFlTSXNJbU52Ym5SbGVIUWlMQ0oxZEdsc2N5SXNJbVY0ZEdWdVpDSXNJbUZ3Y0d4NVFtbHVaR2x1WjNOVWIwUmxjMk5sYm1SaGJuUnpJaXdpWTI5dWRISnZiSE5FWlhOalpXNWtZVzUwUW1sdVpHbHVaM01pTENKMmFYSjBkV0ZzUld4bGJXVnVkSE1pTENKaGJHeHZkMlZrUW1sdVpHbHVaM01pTENKc2IyY2lMQ0owWlcxd2JHRjBaVVY0YVhOMGN5SXNJbWxrSWl3aVpHOWpkVzFsYm5RaUxDSm5aWFJGYkdWdFpXNTBRbmxKWkNJc0lsOWphRzl2YzJWVVpXMXdiR0YwWlNJc0ltbHpRWEp5WVhraUxDSndjbVZtYVhnaUxDSmhZM1JwYjI0aUxDSm1ZV3hzWW1GamF5SXNJbVpoYkd4Q1lXTnJTV1FpTENKZlpHbHpjR3hoZVUxdlpHVWlMQ0oxYm5keVlYQndaV1FpTENKMGVYQmxJaXdpZFc1M2NtRndUMkp6WlhKMllXSnNaU0lzSW5Od2JHbGpaU0lzSW5SbGJYQnNZWFJsVFc5a1pTSXNJblJsYlhCc1lYUmxUVzlrWlVaaGJHeGlZV05ySWl3aVgyMWhhMlZVWlcxd2JHRjBaVlpoYkhWbFFXTmpaWE56YjNJaUxDSnRiMlJsYkZaaGJIVmxJaXdpZEdWdGNHeGhkR1VpTENKMllXeDFaU0lzSW5WdWQzSmhjSEJsWkZaaGJIVmxJaXdpY0dWbGEwOWljMlZ5ZG1GaWJHVWlMQ0prWVhSaElpd2lkR1Z0Y0d4aGRHVlFZWEpoYlNJc0luVnVkM0poY0hCbFpFMXZaR1ZzVm1Gc2RXVWlMQ0pwYzA5aWMyVnlkbUZpYkdVaUxDSjFibVJsWm1sdVpXUWlMQ0psSWl3aWJtRnRaU0lzSW5SbGJYQnNZWFJsUlc1bmFXNWxJaXdpYm1GMGFYWmxWR1Z0Y0d4aGRHVkZibWRwYm1VaUxDSnBibk4wWVc1alpTSXNJbTVsZDFaaGJIVmxRV05qWlhOemIzSWlMQ0oxY0dSaGRHVWlMQ0psZUhCeVpYTnphVzl1VW1WM2NtbDBhVzVuSWl3aVltbHVaR2x1WjFKbGQzSnBkR1ZXWVd4cFpHRjBiM0p6SWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4aFFVZEJMRWxCUVVsQkxFZEJRWGRDTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCVnl4SFFVRnpRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRVmNzUjBGQlNTeExRVU53UjBNc1VVRkJWVU1zVVVGQlVTeHpRa0ZIZEVKS0xFZEJRVWRMTEdkQ1FVRm5ReXhsUVVGSkxFTkJRM0pEUXl4TFFVRk5MRk5CUVZORExFVkJRVk5ETEVWQlFXVkRMRVZCUVdGRExFVkJRVmRETEVkQlJUZEVMRWxCUVVsRExFVkJRWE5DUkN4RlFVRmxSU3h0UWtGRGRrTkdMRVZCUVdWSExGTkJRMllzUzBGRFFTeFRRVUZUUXl4SFFVTlFaaXhIUVVGSFowSXNUVUZCVFVNc1QwRkJUMFlzUlVGQlUxQXNUMEZOTjBJc1QwRklRVklzUjBGQlIydENMREpDUVVFeVFrNHNSVUZCY1VKTUxFZEJSelZETEVOQlEweFpMRFJDUVVFMFFpeExRVWxzUTI1Q0xFZEJRVWR2UWl4blFrRkJaMEpETEdkQ1FVRm5ReXhuUWtGQlNTeEZRVVYyUkhKQ0xFZEJRVWRMTEdkQ1FVRnhRaXhKUVVGSkxFTkJRekZDUXl4TFFVRk5MRk5CUVZORExFVkJRVk5ETEVWQlFXVkRMRVZCUVdGRExFVkJRVmRETEVkQlF6ZEVVaXhSUVVGUmJVSXNTVUZCU1N4TlFVRlBaQ3hQUVV0MlFsSXNSMEZCUjBzc1owSkJRWFZDTEUxQlFVa3NRMEZGTlVKclFpeGxRVUZuUWl4VFFVRlRReXhIUVVWMlFpeFJRVVJUZEVJc1QwRkJUM1ZDTEZOQlFWTkRMR1ZCUVdWR0xFbEJTekZEUnl4blFrRkJhVUlzVTBGQlUwTXNSVUZCVTBNc1JVRkJVVU1zUlVGQlVVTXNSMEZEYWtRc1NVRkJTVkFzUlVGQlMwc3NSVUZCVXl4SlFVRk5ReXhGUVVONFFpeEhRVUZKT1VJc1IwRkJSMHNzWjBKQlFYVkNMRTFCUVVWclFpeGxRVUZsUXl4SFFVRkxMRTlCUVU5QkxFVkJRek5FTEVkQlFVa3NUVUZCVDA4c1JVRkJPRU1zVDBGQlR5OUNMRWRCUVVkTExHZENRVUYxUWl4TlFVRkZjMElzWjBKQlFXZENReXhGUVVGVFF5eEZRVUZSUlN4SFFVVXpTQ3hKUVVGSlF5eEZRVUZoU2l4RlFVRlZMRkZCUVZVc1ZVRkJXVVVzUlVGRGFrUXNSMEZCU1RsQ0xFZEJRVWRMTEdkQ1FVRjFRaXhOUVVGRmEwSXNaVUZCWlZNc1IwRkJZU3hQUVVGUFFTeEZRVU01UkN4TFFVRk5MRFJDUVVFNFFsSXNSVUZCU3l4SlFVRk5VU3hIUVV0NFJFTXNZVUZCWXl4VFFVRlRReXhGUVVGWGRrSXNSMEZEYUVNc1NVRkJTV3RDTEU5QlFXdERMRWxCUVd4Q1N5eEZRVUZWUXl4TFFVRnpRbTVETEVkQlFVZG5RaXhOUVVGTmIwSXNhVUpCUVdsQ1JpeEZRVUZWUXl4TlFVRlJMRzlDUVVGeFFpeEZRVU5xU0ZBc1QwRkJjME1zU1VGQmNrSk5MRVZCUVZWSExFOUJRek5DUXl4RlFVRmxNMElzUlVGQlpUSkNMR0ZCUVdVelFpeEZRVUZsTWtJc1lVRkJaU3hQUVVNdlJTeFBRVUZQZEVNc1IwRkJSMHNzWjBKQlFYVkNMRTFCUVVWelFpeG5Ra0ZCWjBKRExFVkJRVk5ETEVWQlFWRlRMRVZCUVdNelFpeEZRVUZsTkVJc2RVSkJSMjVIUXl3eVFrRkJORUlzVTBGQlUyaERMRVZCUVdWSExFZEJRMnhFTEU5QlFVOHNWMEZEVEN4SlFVbEpPRUlzUlVGRFFVTXNSVUZNUVVNc1JVRkJVVzVETEVsQlExWnZReXhGUVVGcFFqVkRMRWRCUVVkblFpeE5RVUZOTmtJc1pVRkJaVVlzUjBGTk0wTXNTVUZCVFVNc1IwRkJhMFFzYVVKQlFYWkNRU3hGUVVGbFJTeE5RVUZyUkN4dFFrRkJka0pHTEVWQlFXVkZMRXRCUTNoR1RDeEZRVUZoUlN4UFFVZGlMRWRCUkVGR0xFVkJRV0ZITEVWQlFXVkZMRlZCUTFVc1NVRkJNMEpHTEVWQlFXVkdMRk5CUVhsQ0xFTkJRMnBFTEVsQlFVbExMRVZCUVdkQ0wwTXNSMEZCUjJkQ0xFMUJRVTF2UWl4cFFrRkJhVUpSTEVWQlFXVkdMRlZCUTNwRVNpeEZRVUZsTTBJc1JVRkJaVEpDTEdGQlFXVXpRaXhGUVVGbE1rSXNZVUZCWlN4UFFVTXZSVWtzUlVGQlZ6RkRMRWRCUVVkTExHZENRVUYxUWl4TlFVRkZjMElzYVVKQlFXZENMRVZCUVU5dlFpeEZRVUZsVkN4RlFVRmpNMElzUlVGQlpUUkNMSE5DUVVrNVJ5eEpRVUZKVXl4RlFVRnpRbWhFTEVkQlFVZG5RaXhOUVVGTmIwSXNhVUpCUVdsQ1N5eEhRVWR3UkN4SFFVWkpla01zUjBGQlIybEVMR0ZCUVdGRUxFbEJRWE5DTjBNc1VVRkJVVzFDTEVsQlFVa3NiVUpCUVc5Q01FSXNVVUZGYmtRc1NVRkJXazRzUlVGRlZDeFJRVUZ0UWxFc1NVRkJabFFzUlVGRFJrTXNSVUZCVnl4aFFVVllMRWxCUTBWQkxFVkJRVmN4UXl4SFFVRkhTeXhuUWtGQmRVSXNUVUZCUlRSQ0xHRkJRV0ZsTEVWQlFYRkNja01zUjBGRGVrVXNUVUZCVDNkRExFZEJSVkFzVFVGRVFXaEVMRkZCUVZGdFFpeEpRVUZKTmtJc1JVRkJSMGdzUlVGQmNVSnlReXhGUVVGelFpeE5RVUZIUVN4RlFVRmxNa0lzWTBGRGRFVmhMRVZCUzFvc1RVRkJUeXhEUVVOTVF5eExRVUZSVml4RlFVTlNTU3hMUVVGUlRDeEZRVU5TV1N4bFFVRnJRbkpFTEVkQlFVZHpSQ3h4UWtGQmNVSkRMRmxCUzJoRWFrUXNTMEZCVVN4VFFVRlRReXhGUVVGVFF5eEZRVUZsUXl4RlFVRmhReXhGUVVGWFF5eFJRVU5vUXl4SlFVRndRa2dzUzBGQmFVTk1MRkZCUVZGdFFpeEpRVUZKTEdkRlFVTjRSQ3hKUVVGSmEwTXNSVUZCYlVKNFJDeEhRVUZIU3l4blFrRkJkVUlzVFVGQlJXMURMREpDUVVFeVFtaERMRVZCUVdWSExFZEJRemRHTEU5QlFVOVlMRWRCUVVkTExHZENRVUV3UWl4VFFVRlJMRXRCUVVWRkxFVkJRVk5wUkN4SlFVVjZSRU1zVDBGQlZTeFRRVUZUYkVRc1JVRkJVME1zUlVGQlpVTXNSVUZCWVVNc1JVRkJWME1zUjBGRGFrVXNTVUZCU1RaRExFVkJRVzFDZUVRc1IwRkJSMHNzWjBKQlFYVkNMRTFCUVVWdFF5d3lRa0ZCTWtKb1F5eEZRVUZsUnl4SFFVTTNSaXhQUVVGUFdDeEhRVUZIU3l4blFrRkJNRUlzVTBGQlZTeFBRVUZGUlN4RlFVRlRhVVFzUlVGQmEwSXZReXhGUVVGaFF5eEZRVUZYUXl4TFFVZDJSMWdzUjBGQlJ6QkVMRzlDUVVGdlFrTXNlVUpCUVdkRExFOUJRVWtzUlVGRE0wUXpSQ3hIUVVGSGIwSXNaMEpCUVdkQ1F5eG5Ra0ZCZFVJc1QwRkJTU0lzSW1acGJHVWlPaUl2Y0hKcGRtRjBaUzkwYlhBdlptOXZMa2RQUlM5emNtTXZhbk12WW1sdVpHbHVaM012WW14dlkydHpMbXB6SW4wPSIsIlwidXNlIHN0cmljdFwiO21vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIuL3N0cmluZy10ZW1wbGF0ZS5qc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltTm9iMjl6WlMxMFpXMXdiR0YwWlM1cWN5SmRMQ0p1WVcxbGN5STZXeUp0YjJSMWJHVWlMQ0psZUhCdmNuUnpJaXdpY21WeGRXbHlaU0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzWVVGTFFVRXNUMEZCVDBNc1VVRkJWVU1zVVVGQlVTSXNJbVpwYkdVaU9pSXZjSEpwZG1GMFpTOTBiWEF2Wm05dkxrZFBSUzl6Y21NdmFuTXZZbWx1WkdsdVozTXZZMmh2YjNObExYUmxiWEJzWVhSbExtcHpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7cmVxdWlyZShcImV2b2wtY29sb3JwaWNrZXJcIik7dmFyICQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeTpudWxsLGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGwsa29qcXVpPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvanF1aTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rb2pxdWk6bnVsbCxDb2xvclBpY2tlcj1mdW5jdGlvbigpe2tvanF1aS5CaW5kaW5nSGFuZGxlci5jYWxsKHRoaXMsXCJjb2xvcnBpY2tlclwiKX07Q29sb3JQaWNrZXIucHJvdG90eXBlPWtvanF1aS51dGlscy5jcmVhdGVPYmplY3Qoa29qcXVpLkJpbmRpbmdIYW5kbGVyLnByb3RvdHlwZSksQ29sb3JQaWNrZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPUNvbG9yUGlja2VyLENvbG9yUGlja2VyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKG8sZSxpKXt2YXIgcj1lKCksbj1yLmNvbG9yLGw9a28uY29tcHV0ZWQoe3JlYWQ6bix3cml0ZTpuLGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDpvfSk7a28uYmluZGluZ0hhbmRsZXJzLnZhbHVlLmluaXQobyxmdW5jdGlvbigpe3JldHVybiBsfSxpKTt2YXIgdD1mdW5jdGlvbihvLGUpe3ZvaWQgMCE9PWUmJmwoZSl9OyQobykub24oXCJjaGFuZ2UuY29sb3JcIix0KSxrby5jb21wdXRlZCh7cmVhZDpmdW5jdGlvbigpe3ZhciBlPXtjb2xvcjprby51dGlscy51bndyYXBPYnNlcnZhYmxlKGwpLHNob3dPbjpcImJ1dHRvblwifTtmb3IodmFyIGkgaW4gcilcImNvbG9yXCIhPT1pJiZyLmhhc093blByb3BlcnR5KGkpJiYoZVtpXT1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKHJbaV0pKTskKG8pLmNvbG9ycGlja2VyKGUpfSxkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6b30pLGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2sobyxmdW5jdGlvbigpeyQobykub2ZmKFwiY2hhbmdlLmNvbG9yXCIsdCksJChvKS5jb2xvcnBpY2tlcihcImRlc3Ryb3lcIil9KX0sa29qcXVpLnV0aWxzLnJlZ2lzdGVyKENvbG9yUGlja2VyKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltTnZiRzl5Y0dsamEyVnlMbXB6SWwwc0ltNWhiV1Z6SWpwYkluSmxjWFZwY21VaUxDSWtJaXdpZDJsdVpHOTNJaXdpWjJ4dlltRnNJaXdpYTI4aUxDSnJiMnB4ZFdraUxDSkRiMnh2Y2xCcFkydGxjaUlzSWtKcGJtUnBibWRJWVc1a2JHVnlJaXdpWTJGc2JDSXNJblJvYVhNaUxDSndjbTkwYjNSNWNHVWlMQ0oxZEdsc2N5SXNJbU55WldGMFpVOWlhbVZqZENJc0ltTnZibk4wY25WamRHOXlJaXdpYVc1cGRDSXNJbVZzWlcxbGJuUWlMQ0oyWVd4MVpVRmpZMlZ6YzI5eUlpd2lZV3hzUW1sdVpHbHVaM01pTENKMllTSXNJblpoYkhWbElpd2lZMjlzYjNJaUxDSnVaWGRFVHlJc0ltTnZiWEIxZEdWa0lpd2ljbVZoWkNJc0luZHlhWFJsSWl3aVpHbHpjRzl6WlZkb1pXNU9iMlJsU1hOU1pXMXZkbVZrSWl3aVltbHVaR2x1WjBoaGJtUnNaWEp6SWl3aVkyaGhibWRsVUhKdmNHRm5ZWFJ2Y2lJc0ltVjJaVzUwSWl3aWIyNGlMQ0p2Y0hRaUxDSjFibmR5WVhCUFluTmxjblpoWW14bElpd2ljMmh2ZDA5dUlpd2ljSEp2Y0NJc0ltaGhjMDkzYmxCeWIzQmxjblI1SWl3aVkyOXNiM0p3YVdOclpYSWlMQ0prYjIxT2IyUmxSR2x6Y0c5ellXd2lMQ0poWkdSRWFYTndiM05sUTJGc2JHSmhZMnNpTENKdlptWWlMQ0p5WldkcGMzUmxjaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzWVVGSFFVRXNVVUZCVVN4dlFrRkZVaXhKUVVGSlF5eEZRVUYxUWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVdVc1QwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZsTEU5QlFVa3NTMEZETTBkRExFZEJRWGRDTEc5Q1FVRllSaXhQUVVGNVFrRXNUMEZCVnl4SFFVRnpRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRVmNzUjBGQlNTeExRVU53UjBVc1QwRkJORUlzYjBKQlFWaElMRTlCUVhsQ1FTeFBRVUZsTEU5QlFYTkNMRzlDUVVGWVF5eFBRVUY1UWtFc1QwRkJaU3hQUVVGSkxFdEJSMmhJUnl4WlFVRmpMRmRCUTJoQ1JDeFBRVUZQUlN4bFFVRmxReXhMUVVGTFF5eExRVUZOTEdkQ1FVVnVRMGdzV1VGQldVa3NWVUZCV1V3c1QwRkJUMDBzVFVGQlRVTXNZVUZCWVZBc1QwRkJUMFVzWlVGQlpVY3NWMEZEZUVWS0xGbEJRVmxKTEZWQlFWVkhMRmxCUVdOUUxGbEJSWEJEUVN4WlFVRlpTU3hWUVVGVlNTeExRVUZQTEZOQlFWTkRMRVZCUVZORExFVkJRV1ZETEVkQlF6VkVMRWxCUVVsRExFVkJRVXRHTEVsQlEweEhMRVZCUVZGRUxFVkJRVWRGTEUxQlNWaERMRVZCUVZGcVFpeEhRVUZIYTBJc1UwRkJVeXhEUVVOMFFrTXNTMEZCVFVvc1JVRkRUa3NzVFVGQlQwd3NSVUZEVUUwc2VVSkJRVEJDVml4SlFVMDFRbGdzUjBGQlIzTkNMR2RDUVVGblFsQXNUVUZCVFV3c1MwRkJTME1zUlVGS2JFSXNWMEZEVml4UFFVRlBUU3hIUVVkeFEwb3NSMEZGT1VNc1NVRkJTVlVzUlVGQmJVSXNVMEZCVTBNc1JVRkJUMUlzVVVGRGFFSXNTVUZCVmtFc1IwRkJkVUpETEVWQlFVMUVMRWxCUlRGRGJrSXNSVUZCUldNc1IwRkJVMk1zUjBGQlJ5eGxRVUZuUWtZc1IwRkZPVUoyUWl4SFFVRkhhMElzVTBGQlV5eERRVU5XUXl4TFFVRk5MRmRCUTBvc1NVRkJTVThzUlVGQlRTeERRVU5TVml4TlFVRlBhRUlzUjBGQlIwOHNUVUZCVFc5Q0xHbENRVUZwUWxZc1IwRkRha05YTEU5QlFWRXNWVUZGVml4SlFVRkxMRWxCUVVsRExFdEJRVkZtTEVWQlEwWXNWVUZCVkdVc1IwRkJiMEptTEVWQlFVZG5RaXhsUVVGbFJDeExRVUZQU0N4RlFVRkpSeXhIUVVGUk4wSXNSMEZCUjA4c1RVRkJUVzlDTEdsQ1FVRnBRbUlzUlVGQlIyVXNTMEZETlVab1F5eEZRVUZGWXl4SFFVRlRiMElzV1VGQldVd3NTVUZGZWtKTUxIbENRVUV3UWxZc1NVRkhOVUpZTEVkQlFVZFBMRTFCUVUxNVFpeG5Ra0ZCWjBKRExHMUNRVUZ0UW5SQ0xFVkJRVk1zVjBGRGJrUmtMRVZCUVVWakxFZEJRVk4xUWl4SlFVRkpMR1ZCUVdkQ1dDeEhRVU12UWpGQ0xFVkJRVVZqTEVkQlFWTnZRaXhaUVVGWkxHTkJTVE5DT1VJc1QwRkJUMDBzVFVGQlRUUkNMRk5CUVZOcVF5SXNJbVpwYkdVaU9pSXZjSEpwZG1GMFpTOTBiWEF2Wm05dkxrZFBSUzl6Y21NdmFuTXZZbWx1WkdsdVozTXZZMjlzYjNKd2FXTnJaWEl1YW5NaWZRPT0iLCJcInVzZSBzdHJpY3RcIjt2YXIga289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbDtrby5iaW5kaW5nSGFuZGxlcnMuY3NzVGV4dD17dXBkYXRlOmZ1bmN0aW9uKGUsbix0KXt2YXIgbz1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKG4oKSk7dHJ5e2UuaW5uZXJUZXh0PW99Y2F0Y2gobil7ZS5zdHlsZVNoZWV0fHwoZS5pbm5lckhUTUw9XCJhe31cIiksZS5zdHlsZVNoZWV0LmNzc1RleHQ9b319fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltTnpjM1JsZUhRdWFuTWlYU3dpYm1GdFpYTWlPbHNpYTI4aUxDSjNhVzVrYjNjaUxDSm5iRzlpWVd3aUxDSmlhVzVrYVc1blNHRnVaR3hsY25NaUxDSmpjM05VWlhoMElpd2lkWEJrWVhSbElpd2libTlrWlNJc0luWmhiSFZsUVdOalpYTnpiM0lpTENKaGJHeENhVzVrYVc1bmN5SXNJblJsZUhRaUxDSjFkR2xzY3lJc0luVnVkM0poY0U5aWMyVnlkbUZpYkdVaUxDSnBibTVsY2xSbGVIUWlMQ0psSWl3aWMzUjViR1ZUYUdWbGRDSXNJbWx1Ym1WeVNGUk5UQ0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzWVVGRlFTeEpRVUZKUVN4SFFVRjNRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRVmNzUjBGQmMwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRlhMRWRCUVVrc1MwRkhlRWRHTEVkQlFVZEhMR2RDUVVGblFrTXNVVUZCVlN4RFFVTXpRa01zVDBGQlZTeFRRVUZUUXl4RlFVRk5ReXhGUVVGbFF5eEhRVU4wUXl4SlFVRkpReXhGUVVGUFZDeEhRVUZIVlN4TlFVRk5ReXhwUWtGQmFVSktMRXRCUTNKRExFbEJRMFZFTEVWQlFVdE5MRlZCUVZsSUxFVkJRMnBDTEUxQlFVOUpMRWRCUTBaUUxFVkJRVXRSTEdGQlFWbFNMRVZCUVV0VExGVkJRVmtzVDBGRGRrTlVMRVZCUVV0UkxGZEJRVmRXTEZGQlFWVkxJaXdpWm1sc1pTSTZJaTl3Y21sMllYUmxMM1J0Y0M5bWIyOHVSMDlGTDNOeVl5OXFjeTlpYVc1a2FXNW5jeTlqYzNOMFpYaDBMbXB6SW4wPSIsIlwidXNlIHN0cmljdFwiO3ZhciBrbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5rbzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rbzpudWxsLCQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeTpudWxsLGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKTtrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlPXtmb2N1czpmdW5jdGlvbigpe30sYmx1cjpmdW5jdGlvbigpe30saW5pdDpmdW5jdGlvbihvKXtrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKG8sZnVuY3Rpb24oKXskKG8pLm9mZihcImZvY3VzaW5cIixrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmZvY3VzKSwkKG8pLm9mZihcImZvY3Vzb3V0XCIsa28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZS5ibHVyKX0pLCQobykub24oXCJmb2N1c2luXCIsa28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZS5mb2N1cyksJChvKS5vbihcImZvY3Vzb3V0XCIsa28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZS5ibHVyKX19LGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlPXtzY3JvbGw6ZnVuY3Rpb24oKXt9LGluaXQ6ZnVuY3Rpb24obyl7a28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhvLGZ1bmN0aW9uKCl7JChvKS5vZmYoXCJzY3JvbGxcIixrby5iaW5kaW5nSGFuZGxlcnMuc2Nyb2xsYWJsZS5zY3JvbGwpfSksJChvKS5vbihcInNjcm9sbFwiLGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlLnNjcm9sbCl9fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltVjJaVzUwWVdKc1pTNXFjeUpkTENKdVlXMWxjeUk2V3lKcmJ5SXNJbmRwYm1SdmR5SXNJbWRzYjJKaGJDSXNJaVFpTENKamIyNXpiMnhsSWl3aWNtVnhkV2x5WlNJc0ltSnBibVJwYm1kSVlXNWtiR1Z5Y3lJc0ltWnZZM1Z6WVdKc1pTSXNJbVp2WTNWeklpd2lZbXgxY2lJc0ltbHVhWFFpTENKbGJHVnRaVzUwSWl3aWRYUnBiSE1pTENKa2IyMU9iMlJsUkdsemNHOXpZV3dpTENKaFpHUkVhWE53YjNObFEyRnNiR0poWTJzaUxDSnZabVlpTENKdmJpSXNJbk5qY205c2JHRmliR1VpTENKelkzSnZiR3dpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEdGQlJVRXNTVUZCU1VFc1IwRkJkMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZYTEVkQlFYTkNMRzlDUVVGWVF5eFBRVUY1UWtFc1QwRkJWeXhIUVVGSkxFdEJRM0JIUXl4RlFVRjFRaXh2UWtGQldFWXNUMEZCZVVKQkxFOUJRV1VzVDBGQmMwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVVrc1MwRkRNMGRGTEZGQlFWVkRMRkZCUVZFc2MwSkJSM1JDVEN4SFFVRkhUU3huUWtGQlowSkRMRlZCUVZrc1EwRkROMEpETEUxQlFWTXNZVUZEVkVNc1MwRkJVU3hoUVVOU1F5eExRVUZSTEZOQlFWTkRMRWRCUTJaWUxFZEJRVWRaTEUxQlFVMURMR2RDUVVGblFrTXNiVUpCUVcxQ1NDeEZRVUZUTEZkQlEyNUVVaXhGUVVGRlVTeEhRVUZUU1N4SlFVRkpMRlZCUVZkbUxFZEJRVWROTEdkQ1FVRm5Ra01zVlVGQlZVTXNUMEZEZGtSTUxFVkJRVVZSTEVkQlFWTkpMRWxCUVVrc1YwRkJXV1lzUjBGQlIwMHNaMEpCUVdkQ1F5eFZRVUZWUlN4UlFVY3hSRTRzUlVGQlJWRXNSMEZCVTBzc1IwRkJSeXhWUVVGWGFFSXNSMEZCUjAwc1owSkJRV2RDUXl4VlFVRlZReXhQUVVOMFJFd3NSVUZCUlZFc1IwRkJVMHNzUjBGQlJ5eFhRVUZaYUVJc1IwRkJSMDBzWjBKQlFXZENReXhWUVVGVlJTeFJRVXN6UkZRc1IwRkJSMDBzWjBKQlFXZENWeXhYUVVGaExFTkJRemxDUXl4UFFVRlZMR0ZCUTFaU0xFdEJRVkVzVTBGQlUwTXNSMEZEWmxnc1IwRkJSMWtzVFVGQlRVTXNaMEpCUVdkQ1F5eHRRa0ZCYlVKSUxFVkJRVk1zVjBGRGJrUlNMRVZCUVVWUkxFZEJRVk5KTEVsQlFVa3NVMEZCVldZc1IwRkJSMDBzWjBKQlFXZENWeXhYUVVGWFF5eFZRVWQ2UkdZc1JVRkJSVkVzUjBGQlUwc3NSMEZCUnl4VFFVRlZhRUlzUjBGQlIwMHNaMEpCUVdkQ1Z5eFhRVUZYUXlJc0ltWnBiR1VpT2lJdmNISnBkbUYwWlM5MGJYQXZabTl2TGtkUFJTOXpjbU12YW5NdlltbHVaR2x1WjNNdlpYWmxiblJoWW14bExtcHpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyICQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeTpudWxsLGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGw7IWZ1bmN0aW9uKGUsbyl7ZS51dGlscy51bndyYXBPYnNlcnZhYmxlO3ZhciBuPWUudXRpbHMuZG9tRGF0YS5nZXQ7ZS51dGlscy5kb21EYXRhLnNldCxlLmJpbmRpbmdIYW5kbGVycy5leHRkcm9wcGFibGU9e2luaXQ6ZnVuY3Rpb24odCxkLGEsbCxpKXt2YXIgcyxwPW8odCkscj1lLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZCgpKXx8e30sdT17fTtvLmV4dGVuZCghMCx1LGUuYmluZGluZ0hhbmRsZXJzLmV4dGRyb3BwYWJsZSksci5kYXRhPyhyLm9wdGlvbnMmJnUub3B0aW9ucyYmKGUudXRpbHMuZXh0ZW5kKHUub3B0aW9ucyxyLm9wdGlvbnMpLGRlbGV0ZSByLm9wdGlvbnMpLGUudXRpbHMuZXh0ZW5kKHUscikpOnUuZGF0YT1yLHM9dS5vcHRpb25zLmRyb3AscC5kcm9wcGFibGUoZS51dGlscy5leHRlbmQodS5vcHRpb25zLHtkcm9wOmZ1bmN0aW9uKGUsbyl7dmFyIHQ9by5kcmFnZ2FibGVbMF0sZD1uKHQsXCJrb19zb3J0SXRlbVwiKXx8bih0LFwia29fZHJhZ0l0ZW1cIik7ZCYmKGQuY2xvbmUmJihkPWQuY2xvbmUoKSksdS5kcmFnZ2VkJiYoZD11LmRyYWdnZWQuY2FsbCh0aGlzLGQsZSxvKXx8ZCksdS5kYXRhJiZ1LmRhdGEoZCkpLHMmJnMuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pKSx2b2lkIDAhPT11LmlzRW5hYmxlZCYmZS5jb21wdXRlZCh7cmVhZDpmdW5jdGlvbigpe3AuZHJvcHBhYmxlKGUudXRpbHMudW53cmFwT2JzZXJ2YWJsZSh1LmlzRW5hYmxlZCk/XCJlbmFibGVcIjpcImRpc2FibGVcIil9LGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDp0fSl9LHVwZGF0ZTpmdW5jdGlvbihlLG8sbix0LGQpe30sdGFyZ2V0SW5kZXg6bnVsbCxhZnRlck1vdmU6bnVsbCxiZWZvcmVNb3ZlOm51bGwsb3B0aW9uczp7fX19KGtvLCQpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1WNGRHUnliM0J3WVdKc1pTNXFjeUpkTENKdVlXMWxjeUk2V3lJa0lpd2lkMmx1Wkc5M0lpd2laMnh2WW1Gc0lpd2lhMjhpTENKMWRHbHNjeUlzSW5WdWQzSmhjRTlpYzJWeWRtRmliR1VpTENKa1lYUmhSMlYwSWl3aVpHOXRSR0YwWVNJc0ltZGxkQ0lzSW5ObGRDSXNJbUpwYm1ScGJtZElZVzVrYkdWeWN5SXNJbVY0ZEdSeWIzQndZV0pzWlNJc0ltbHVhWFFpTENKbGJHVnRaVzUwSWl3aWRtRnNkV1ZCWTJObGMzTnZjaUlzSW1Gc2JFSnBibVJwYm1kelFXTmpaWE56YjNJaUxDSmtZWFJoSWl3aVkyOXVkR1Y0ZENJc0ltUnliM0JCWTNSMVlXd2lMQ0lrWld4bGJXVnVkQ0lzSW5aaGJIVmxJaXdpWkhKdmNIQmhZbXhsSWl3aVpYaDBaVzVrSWl3aWIzQjBhVzl1Y3lJc0ltUnliM0FpTENKbGRtVnVkQ0lzSW5WcElpd2laV3dpTENKa2NtRm5aMkZpYkdVaUxDSnBkR1Z0SWl3aVkyeHZibVVpTENKa2NtRm5aMlZrSWl3aVkyRnNiQ0lzSW5Sb2FYTWlMQ0poY0hCc2VTSXNJbUZ5WjNWdFpXNTBjeUlzSW5WdVpHVm1hVzVsWkNJc0ltbHpSVzVoWW14bFpDSXNJbU52YlhCMWRHVmtJaXdpY21WaFpDSXNJbVJwYzNCdmMyVlhhR1Z1VG05a1pVbHpVbVZ0YjNabFpDSXNJblZ3WkdGMFpTSXNJblJoY21kbGRFbHVaR1Y0SWl3aVlXWjBaWEpOYjNabElpd2lZbVZtYjNKbFRXOTJaU0lzSW1aaFkzUnZjbmtpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEdGQlJVRXNTVUZCU1VFc1JVRkJkVUlzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZsTEU5QlFYTkNMRzlDUVVGWVF5eFBRVUY1UWtFc1QwRkJaU3hQUVVGSkxFdEJRek5IUXl4SFFVRjNRaXh2UWtGQldFWXNUMEZCZVVKQkxFOUJRVmNzUjBGQmMwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRlhMRWRCUVVrc1RVRkxja2NzVTBGQlUwTXNSVUZCU1Vnc1IwRk5TRWNzUlVGQlIwTXNUVUZCVFVNc2FVSkJUSEJDTEVsQlRVVkRMRVZCUVZWSUxFVkJRVWRETEUxQlFVMUhMRkZCUVZGRExFbEJRMnBDVEN4RlFVRkhReXhOUVVGTlJ5eFJRVUZSUlN4SlFVYzNRazRzUlVGQlIwOHNaMEpCUVdkQ1F5eGhRVUZsTEVOQlEyaERReXhMUVVGTkxGTkJRVk5ETEVWQlFWTkRMRVZCUVdWRExFVkJRWEZDUXl4RlFVRk5ReXhIUVVOb1JTeEpRVWRGUXl4RlFVaEZReXhGUVVGWGJrSXNSVUZCUldFc1IwRkRaazhzUlVGQlVXcENMRVZCUVVkRExFMUJRVTFETEdsQ1FVRnBRbE1zVFVGQmIwSXNSMEZEZEVSUExFVkJRVmtzUjBGSFpISkNMRVZCUVVWelFpeFJRVUZQTEVWQlFVMUVMRVZCUVZkc1FpeEZRVUZIVHl4blFrRkJaMEpETEdOQlEzcERVeXhGUVVGTlNpeE5RVU5LU1N4RlFVRk5SeXhUUVVGWFJpeEZRVUZWUlN4VlFVTTNRbkJDTEVWQlFVZERMRTFCUVUxclFpeFBRVUZQUkN4RlFVRlZSU3hSUVVGVFNDeEZRVUZOUnl4blFrRkRiRU5JTEVWQlFVMUhMRk5CUldad1FpeEZRVUZIUXl4TlFVRk5hMElzVDBGQlQwUXNSVUZCVjBRc1NVRkZNMEpETEVWQlFWVk1MRXRCUVU5SkxFVkJSMjVDUml4RlFVRmhSeXhGUVVGVlJTeFJRVUZSUXl4TFFVVXZRa3dzUlVGQlUwVXNWVUZCVld4Q0xFVkJRVWRETEUxQlFVMXJRaXhQUVVGUFJDeEZRVUZWUlN4UlFVRlRMRU5CUTNCRVF5eExRVUZOTEZOQlFWTkRMRVZCUVU5RExFZEJSWEJDTEVsQlFVbERMRVZCUVV0RUxFVkJRVWRGTEZWQlFWVXNSMEZEY0VKRExFVkJRVTkyUWl4RlFVRlJjVUlzUlVGc1ExZ3NaMEpCYTBNeVFuSkNMRVZCUVZGeFFpeEZRVGxDY2tNc1pVRm5RMEZGTEVsQlJVVkJMRVZCUVV0RExGRkJRMUJFTEVWQlFVOUJMRVZCUVV0RExGTkJSMVpVTEVWQlFWVlZMRlZCUTFwR0xFVkJRVTlTTEVWQlFWVlZMRkZCUVZGRExFdEJRVXRETEV0QlFVMUtMRVZCUVUxS0xFVkJRVTlETEVsQlFVOUhMRWRCUjNSRVVpeEZRVUZWVEN4TlFVTmFTeXhGUVVGVlRDeExRVUZMWVN4SlFVdG1XQ3hIUVVOR1FTeEZRVUZYWjBJc1RVRkJUVVFzUzBGQlRVVXNiMEpCVDBSRExFbEJRWGhDWml4RlFVRlZaMElzVjBGRFdteERMRVZCUVVkdFF5eFRRVUZUTEVOQlExWkRMRXRCUVUwc1YwRkRTbkJDTEVWQlFWTkZMRlZCUVZWc1FpeEZRVUZIUXl4TlFVRk5ReXhwUWtGQmFVSm5RaXhGUVVGVlowSXNWMEZCWVN4VFFVRlhMRmxCUldwR1J5eDVRa0ZCTUVJelFpeExRVXRvUXpSQ0xFOUJRVkVzVTBGQlV6VkNMRVZCUVZORExFVkJRV1ZETEVWQlFYRkNReXhGUVVGTlF5eExRVWR3UlhsQ0xGbEJRV0VzUzBGRFlrTXNWVUZCVnl4TFFVTllReXhYUVVGWkxFdEJRMXB5UWl4UlFVRlRMRWxCT1VWWWMwSXNRMEZCVVRGRExFZEJRVWxJSWl3aVptbHNaU0k2SWk5d2NtbDJZWFJsTDNSdGNDOW1iMjh1UjA5RkwzTnlZeTlxY3k5aWFXNWthVzVuY3k5bGVIUmtjbTl3Y0dGaWJHVXVhbk1pZlE9PSIsIlwidXNlIHN0cmljdFwiO3ZhciBrbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5rbzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rbzpudWxsO2tvLmV4dGVuZGVycy5wYWdpbmc9ZnVuY3Rpb24oZSxuKXt2YXIgdD1rby5vYnNlcnZhYmxlKG58fDEwKSxvPWtvLm9ic2VydmFibGUoMSk7cmV0dXJuIGUucGFnZVNpemU9a28uY29tcHV0ZWQoe3JlYWQ6dCx3cml0ZTpmdW5jdGlvbihlKXt0KGU+MD9lOjEwKX19KSxlLmN1cnJlbnRQYWdlPWtvLmNvbXB1dGVkKHtyZWFkOm8sd3JpdGU6ZnVuY3Rpb24obil7bj5lLnBhZ2VDb3VudCgpP28oZS5wYWdlQ291bnQoKSk6byhuPD0wPzE6bil9fSksZS5wYWdlQ291bnQ9a28uY29tcHV0ZWQoZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5jZWlsKGUoKS5sZW5ndGgvZS5wYWdlU2l6ZSgpKXx8MX0pLGUuY3VycmVudFBhZ2VEYXRhPWtvLmNvbXB1dGVkKGZ1bmN0aW9uKCl7dmFyIG49dCgpLHI9bygpLHU9biooci0xKSxhPW4qcjtyZXR1cm4gZSgpLnNsaWNlKHUsYSl9KSxlLm1vdmVGaXJzdD1mdW5jdGlvbigpe2UuY3VycmVudFBhZ2UoMSl9LGUubW92ZVByZXZpb3VzPWZ1bmN0aW9uKCl7ZS5jdXJyZW50UGFnZShlLmN1cnJlbnRQYWdlKCktMSl9LGUubW92ZU5leHQ9ZnVuY3Rpb24oKXtlLmN1cnJlbnRQYWdlKGUuY3VycmVudFBhZ2UoKSsxKX0sZS5tb3ZlTGFzdD1mdW5jdGlvbigpe2UuY3VycmVudFBhZ2UoZS5wYWdlQ291bnQoKSl9LGV9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1WNGRHVnVaR1Z5TFhCaFoybHVZWFJwYjI0dWFuTWlYU3dpYm1GdFpYTWlPbHNpYTI4aUxDSjNhVzVrYjNjaUxDSm5iRzlpWVd3aUxDSmxlSFJsYm1SbGNuTWlMQ0p3WVdkcGJtY2lMQ0owWVhKblpYUWlMQ0p3WVdkbFUybDZaU0lzSWw5d1lXZGxVMmw2WlNJc0ltOWljMlZ5ZG1GaWJHVWlMQ0pmWTNWeWNtVnVkRkJoWjJVaUxDSmpiMjF3ZFhSbFpDSXNJbkpsWVdRaUxDSjNjbWwwWlNJc0ltNWxkMVpoYkhWbElpd2lZM1Z5Y21WdWRGQmhaMlVpTENKd1lXZGxRMjkxYm5RaUxDSk5ZWFJvSWl3aVkyVnBiQ0lzSW14bGJtZDBhQ0lzSW1OMWNuSmxiblJRWVdkbFJHRjBZU0lzSW5CaFoyVkpibVJsZUNJc0luTjBZWEowU1c1a1pYZ2lMQ0psYm1SSmJtUmxlQ0lzSW5Oc2FXTmxJaXdpYlc5MlpVWnBjbk4wSWl3aWJXOTJaVkJ5WlhacGIzVnpJaXdpYlc5MlpVNWxlSFFpTENKdGIzWmxUR0Z6ZENKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1lVRkZRU3hKUVVGSlFTeEhRVUYzUWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVZjc1IwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZYTEVkQlFVa3NTMEZGZUVkR0xFZEJRVWRITEZWQlFWVkRMRTlCUVZNc1UwRkJVME1zUlVGQlVVTXNSMEZEY2tNc1NVRkJTVU1zUlVGQldWQXNSMEZCUjFFc1YwRkJWMFlzUjBGQldTeEpRVVY0UTBjc1JVRkJaVlFzUjBGQlIxRXNWMEZCVnl4SFFXMUVMMElzVDBGc1JFRklMRVZCUVU5RExGTkJRVmRPTEVkQlFVZFZMRk5CUVZNc1EwRkROVUpETEV0QlFVMUtMRVZCUTA1TExFMUJRVThzVTBGQlUwTXNSMEZGV2s0c1JVRkVSVTBzUlVGQlZ5eEZRVU5JUVN4RlFVVkJMRTlCUzJoQ1VpeEZRVUZQVXl4WlFVRmpaQ3hIUVVGSFZTeFRRVUZUTEVOQlF5OUNReXhMUVVGTlJpeEZRVU5PUnl4TlFVRlBMRk5CUVZORExFZEJRMVpCTEVWQlFWZFNMRVZCUVU5VkxGbEJRM0JDVGl4RlFVRmhTaXhGUVVGUFZTeGhRVVZ3UWs0c1JVRkVVMGtzUjBGQldTeEZRVU5TTEVWQlJVRkJMRTFCUzI1Q1VpeEZRVUZQVlN4VlFVRlpaaXhIUVVGSFZTeFRRVUZUTEZkQlF6ZENMRTlCUVU5TkxFdEJRVXRETEV0QlFVdGFMRWxCUVZOaExFOUJRVk5pTEVWQlFVOURMR0ZCUVdVc1NVRkhNMFJFTEVWQlFVOWpMR2RDUVVGclFtNUNMRWRCUVVkVkxGTkJRVk1zVjBGRGJrTXNTVUZCU1Vvc1JVRkJWME1zU1VGRFltRXNSVUZCV1Znc1NVRkRXbGtzUlVGQllXWXNSMEZCV1dNc1JVRkJXU3hIUVVOeVEwVXNSVUZCVjJoQ0xFVkJRVmRqTEVWQlJYaENMRTlCUVU5bUxFbEJRVk5yUWl4TlFVRk5SaXhGUVVGWlF5eExRVWR3UTJwQ0xFVkJRVTl0UWl4VlFVRlpMRmRCUTJwQ2JrSXNSVUZCVDFNc1dVRkJXU3hKUVVWeVFsUXNSVUZCVDI5Q0xHRkJRV1VzVjBGRGNFSndRaXhGUVVGUFV5eFpRVUZaVkN4RlFVRlBVeXhqUVVGblFpeEpRVVUxUTFRc1JVRkJUM0ZDTEZOQlFWY3NWMEZEYUVKeVFpeEZRVUZQVXl4WlFVRlpWQ3hGUVVGUFV5eGpRVUZuUWl4SlFVVTFRMVFzUlVGQlQzTkNMRk5CUVZjc1YwRkRhRUowUWl4RlFVRlBVeXhaUVVGWlZDeEZRVUZQVlN4alFVZHlRbFlpTENKbWFXeGxJam9pTDNCeWFYWmhkR1V2ZEcxd0wyWnZieTVIVDBVdmMzSmpMMnB6TDJKcGJtUnBibWR6TDJWNGRHVnVaR1Z5TFhCaFoybHVZWFJwYjI0dWFuTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyICQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeTpudWxsLGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGwsc29ydGFibGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5LnVpLnNvcnRhYmxlOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeS51aS5zb3J0YWJsZTpudWxsLGRyYWdnYWJsZT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnkudWkuZHJhZ2dhYmxlOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeS51aS5kcmFnZ2FibGU6bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIik7aWYocmVxdWlyZShcImtub2Nrb3V0LXNvcnRhYmxlXCIpLHZvaWQgMD09PXNvcnRhYmxlKXRocm93XCJDYW5ub3QgZmluZCBqcXVlcnktdWkgc29ydGFibGUgd2lkZ2V0IGRlcGVuZGVuY3khXCI7aWYodm9pZCAwPT09ZHJhZ2dhYmxlKXRocm93XCJDYW5ub3QgZmluZCBqcXVlcnktdWkgc29ydGFibGUgd2lkZ2V0IGRlcGVuZGVuY3khXCI7dmFyIGlzRHJhZ2dpbmdIZWxwZXI9ZnVuY3Rpb24oZSxuKXtlKCk/bi50eXBlPT1lKCkrXCJzdG9wXCImJmUoITEpOlwiZHJhZ3N0YXJ0XCIhPW4udHlwZSYmXCJzb3J0c3RhcnRcIiE9bi50eXBlfHxlKG4udHlwZS5zdWJzdHJpbmcoMCw0KSl9LG1ha2VFeHRlbmRlZFZhbHVlQWNjZXNzb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49ZSgpO2tvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKG4pO2tvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobiksXCJ1bmRlZmluZWRcIj09bi5vcHRpb25zJiYobi5vcHRpb25zPXt9KTt2YXIgbz1uLm9wdGlvbnMuc3RhcnQ7bi5vcHRpb25zLnN0YXJ0PWZ1bmN0aW9uKGUscil7aWYodm9pZCAwIT09bi5kcmFnZ2luZyYma28uaXNXcml0YWJsZU9ic2VydmFibGUobi5kcmFnZ2luZykmJmlzRHJhZ2dpbmdIZWxwZXIobi5kcmFnZ2luZyxlKSx2b2lkIDAhPT1uLmRyb3BDb250YWluZXImJihuLnNjcm9sbEludGVydmFsPWdsb2JhbC5zZXRJbnRlcnZhbChmdW5jdGlvbigpe3ZhciBlPSQobi5kcm9wQ29udGFpbmVyKS5zY3JvbGxUb3AoKTskKG4uZHJvcENvbnRhaW5lcikuc2Nyb2xsVG9wKGUrbi5hZGRpbmcpfSwyMCkpLHZvaWQgMCE9PW8pcmV0dXJuIG8oZSxyKX07dmFyIHI9bi5vcHRpb25zLnN0b3A7bi5vcHRpb25zLnN0b3A9ZnVuY3Rpb24oZSxvKXtpZih2b2lkIDAhPT1uLmRyYWdnaW5nJiZrby5pc1dyaXRhYmxlT2JzZXJ2YWJsZShuLmRyYWdnaW5nKSYmaXNEcmFnZ2luZ0hlbHBlcihuLmRyYWdnaW5nLGUpLHZvaWQgMCE9PW4uZHJvcENvbnRhaW5lciYmZ2xvYmFsLmNsZWFySW50ZXJ2YWwobi5zY3JvbGxJbnRlcnZhbCksdm9pZCAwIT09cilyZXR1cm4gcihlLG8pfTt2YXIgaT1uLm9wdGlvbnMuZHJhZztyZXR1cm4gbi5vcHRpb25zLmRyYWc9ZnVuY3Rpb24oZSxvKXtpZih2b2lkIDAhPT1uLmRyb3BDb250YWluZXIpe3ZhciByPWUucGFnZVktJChuLmRyb3BDb250YWluZXIpLm9mZnNldCgpLnRvcCx0PXItJChuLmRyb3BDb250YWluZXIpLmhlaWdodCgpO24uYWRkaW5nPXI8LTIwPy0yMDpyPDA/LTEwOnI8MTA/LTU6dD4yMD8yMDp0PjA/MTA6dD4tMTA/NTowfWlmKHZvaWQgMCE9PWkpcmV0dXJuIGkoZSxvKX0sbn19O2tvLmJpbmRpbmdIYW5kbGVycy5leHRzb3J0YWJsZT17aW5pdDpmdW5jdGlvbihlLG4sbyxyLGkpe3JldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGUuaW5pdChlLG1ha2VFeHRlbmRlZFZhbHVlQWNjZXNzb3IobiksbyxyLGkpfSx1cGRhdGU6ZnVuY3Rpb24oZSxuLG8scixpKXtyZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlLnVwZGF0ZShlLG1ha2VFeHRlbmRlZFZhbHVlQWNjZXNzb3IobiksbyxyLGkpfX0sa28uYmluZGluZ0hhbmRsZXJzLmV4dGRyYWdnYWJsZT17aW5pdDpmdW5jdGlvbihlLG4sbyxyLGkpe3JldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLmluaXQoZSxtYWtlRXh0ZW5kZWRWYWx1ZUFjY2Vzc29yKG4pLG8scixpKX0sdXBkYXRlOmZ1bmN0aW9uKGUsbixvLHIsaSl7cmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy5kcmFnZ2FibGUudXBkYXRlKGUsbWFrZUV4dGVuZGVkVmFsdWVBY2Nlc3NvcihuKSxvLHIsaSl9fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltVjRkSE52Y25SaFlteGxjeTVxY3lKZExDSnVZVzFsY3lJNld5SWtJaXdpZDJsdVpHOTNJaXdpWjJ4dlltRnNJaXdpYTI4aUxDSnpiM0owWVdKc1pTSXNJbVJ5WVdkbllXSnNaU0lzSW1OdmJuTnZiR1VpTENKeVpYRjFhWEpsSWl3aWFYTkVjbUZuWjJsdVowaGxiSEJsY2lJc0luZHlhWFJoWW14bElpd2laU0lzSW5SNWNHVWlMQ0p6ZFdKemRISnBibWNpTENKdFlXdGxSWGgwWlc1a1pXUldZV3gxWlVGalkyVnpjMjl5SWl3aWRtRnNkV1ZCWTJObGMzTnZjaUlzSW0xdlpHVnNWbUZzZFdVaUxDSjFkR2xzY3lJc0luQmxaV3RQWW5ObGNuWmhZbXhsSWl3aWRXNTNjbUZ3VDJKelpYSjJZV0pzWlNJc0ltOXdkR2x2Ym5NaUxDSnZjbWxuVTNSaGNuUWlMQ0p6ZEdGeWRDSXNJblZwSWl3aVpISmhaMmRwYm1jaUxDSnBjMWR5YVhSaFlteGxUMkp6WlhKMllXSnNaU0lzSW1SeWIzQkRiMjUwWVdsdVpYSWlMQ0p6WTNKdmJHeEpiblJsY25aaGJDSXNJbk5sZEVsdWRHVnlkbUZzSWl3aVptOXZJaXdpYzJOeWIyeHNWRzl3SWl3aVlXUmthVzVuSWl3aWIzSnBaMU4wYjNBaUxDSnpkRzl3SWl3aVkyeGxZWEpKYm5SbGNuWmhiQ0lzSW05eWFXZEVjbUZuSWl3aVpISmhaeUlzSW5SdmNDSXNJbkJoWjJWWklpd2liMlptYzJWMElpd2lZbTkwZEc5dElpd2lhR1ZwWjJoMElpd2lZbWx1WkdsdVowaGhibVJzWlhKeklpd2laWGgwYzI5eWRHRmliR1VpTENKcGJtbDBJaXdpWld4bGJXVnVkQ0lzSW1Gc2JFSnBibVJwYm1kelFXTmpaWE56YjNJaUxDSmtZWFJoSWl3aVkyOXVkR1Y0ZENJc0luVndaR0YwWlNJc0ltVjRkR1J5WVdkbllXSnNaU0pkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzWVVGSFFTeEpRVUZKUVN4RlFVRjFRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRV1VzVDBGQmMwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVVrc1MwRkRNMGRETEVkQlFYZENMRzlDUVVGWVJpeFBRVUY1UWtFc1QwRkJWeXhIUVVGelFpeHZRa0ZCV0VNc1QwRkJlVUpCTEU5QlFWY3NSMEZCU1N4TFFVTndSMFVzVTBGQk9FSXNiMEpCUVZoSUxFOUJRWGxDUVN4UFFVRmxMRTlCUVUwc1IwRkJXU3hUUVVGelFpeHZRa0ZCV0VNc1QwRkJlVUpCTEU5QlFXVXNUMEZCVFN4SFFVRlpMRk5CUVVrc1MwRkRkRXBITEZWQlFTdENMRzlDUVVGWVNpeFBRVUY1UWtFc1QwRkJaU3hQUVVGTkxFZEJRV0VzVlVGQmMwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVUwc1IwRkJZU3hWUVVGSkxFdEJRM3BLU1N4UlFVRlZReXhSUVVGUkxITkNRVWQwUWl4SFFVWkJRU3hSUVVGUkxEQkNRVVZsTEVsQlFWcElMRk5CUVhsQ0xFdEJRVTBzYjBSQlF6RkRMRkZCUVhkQ0xFbEJRV0pETEZWQlFUQkNMRXRCUVUwc2IwUkJSVE5ETEVsQlFVbEhMR2xDUVVGdFFpeFRRVUZUUXl4RlFVRlZReXhIUVVOd1EwUXNTVUZEUlVNc1JVRkJSVU1zVFVGQlVVWXNTVUZCWVN4UlFVRlJRU3hIUVVGVExFZEJSVGxDTEdGQlFWWkRMRVZCUVVWRExFMUJRV2xETEdGQlFWWkVMRVZCUVVWRExFMUJRWEZDUml4RlFVRlRReXhGUVVGRlF5eExRVUZMUXl4VlFVRlZMRVZCUVVjc1MwRkpha1pETERCQ1FVRTBRaXhUUVVGVFF5eEhRVU4yUXl4UFFVRlBMRmRCUTB3c1NVRkJTVU1zUlVGQllVUXNTVUZEUlZnc1IwRkJSMkVzVFVGQlRVTXNaVUZCWlVZc1IwRkZNME5hTEVkQlFVZGhMRTFCUVUxRkxHbENRVUZwUWtnc1IwRkZRU3hoUVVGMFFrRXNSVUZCVjBrc1ZVRkRZa29zUlVGQlYwa3NVVUZCVlN4SlFVZDJRaXhKUVVGSlF5eEZRVUZaVEN4RlFVRlhTU3hSUVVGUlJTeE5RVU51UTA0c1JVRkJWMGtzVVVGQlVVVXNUVUZCVVN4VFFVRlRXQ3hGUVVGSFdTeEhRVkZ5UXl4UlFWQnJReXhKUVVGMlFsQXNSVUZCVjFFc1ZVRkJNa0p3UWl4SFFVRkhjVUlzY1VKQlFYRkNWQ3hGUVVGWFVTeFhRVUZYWml4cFFrRkJhVUpQTEVWQlFWZFJMRk5CUVZWaUxGRkJRemxHTEVsQlFUVkNTeXhGUVVGWFZTeG5Ra0ZEY0VKV0xFVkJRVmRYTEdWQlFXbENlRUlzVDBGQlQzbENMRmxCUVZrc1YwRkROME1zU1VGQlNVTXNSVUZCVFRWQ0xFVkJRVVZsTEVWQlFWZFZMR1ZCUVdWSkxGbEJRM1JETjBJc1JVRkJSV1VzUlVGQlYxVXNaVUZCWlVrc1ZVRkJWVVFzUlVGQlRXSXNSVUZCVjJVc1UwRkRkRVFzVlVGRmJVSXNTVUZCWWxZc1JVRkJNRUlzVDBGQlQwRXNSVUZCVlZZc1JVRkJSMWtzU1VGRk0wUXNTVUZCU1ZNc1JVRkJWMmhDTEVWQlFWZEpMRkZCUVZGaExFdEJRMnhEYWtJc1JVRkJWMGtzVVVGQlVXRXNTMEZCVHl4VFFVRlRkRUlzUlVGQlIxa3NSMEZMY0VNc1VVRkthME1zU1VGQmRrSlFMRVZCUVZkUkxGVkJRVEpDY0VJc1IwRkJSM0ZDTEhGQ1FVRnhRbFFzUlVGQlYxRXNWMEZCVjJZc2FVSkJRV2xDVHl4RlFVRlhVU3hUUVVGVllpeFJRVU01Uml4SlFVRTFRa3NzUlVGQlYxVXNaVUZEY0VKMlFpeFBRVUZQSzBJc1kwRkJZMnhDTEVWQlFWZFhMSEZDUVVWWUxFbEJRVnBMTEVWQlFYbENMRTlCUVU5QkxFVkJRVk55UWl4RlFVRkhXU3hKUVVWNlJDeEpRVUZKV1N4RlFVRlhia0lzUlVGQlYwa3NVVUZCVVdkQ0xFdEJLMEpzUXl4UFFUbENRWEJDTEVWQlFWZEpMRkZCUVZGblFpeExRVUZQTEZOQlFWTjZRaXhGUVVGSFdTeEhRVU53UXl4UlFVRjFReXhKUVVFMVFsQXNSVUZCVjFVc1kwRkJPRUlzUTBGRGJFUXNTVUZCU1Zjc1JVRkJUVEZDTEVWQlFVVXlRaXhOUVVGUmNrTXNSVUZCUldVc1JVRkJWMVVzWlVGQlpXRXNVMEZCVTBZc1NVRkRja1JITEVWQlFWTklMRVZCUVUxd1F5eEZRVUZGWlN4RlFVRlhWU3hsUVVGbFpTeFRRVWMzUTNwQ0xFVkJRVmRsTEU5QlJGUk5MRWRCUVU4c1NVRkRXU3hIUVVWYVFTeEZRVUZOTEVkQlEwMHNSMEZGV2tFc1JVRkJUU3hKUVVOTkxFVkJSVnBITEVWQlFWTXNSMEZEUlN4SFFVVllRU3hGUVVGVExFVkJRMFVzUjBGRldFRXNSMEZCVlN4SFFVTkRMRVZCUjBFc1JVRkhlRUlzVVVGQmRVSXNTVUZCV2t3c1JVRkJlVUlzVDBGQlQwRXNSVUZCVTNoQ0xFVkJRVWRaTEVsQlIyeEVVQ3hKUVVsWVdpeEhRVUZIYzBNc1owSkJRV2RDUXl4WlFVRmpMRU5CUXk5Q1F5eExRVUZOTEZOQlFWTkRMRVZCUVZNNVFpeEZRVUZsSzBJc1JVRkJjVUpETEVWQlFVMURMRWRCUTJoRkxFOUJRVTgxUXl4SFFVRkhjME1zWjBKQlFXZENja01zVTBGQlUzVkRMRXRCUVV0RExFVkJRVk12UWl3d1FrRkJNRUpETEVkQlFXZENLMElzUlVGQmNVSkRMRVZCUVUxRExFbEJSWGhJUXl4UFFVRlJMRk5CUVZOS0xFVkJRVk01UWl4RlFVRmxLMElzUlVGQmNVSkRMRVZCUVUxRExFZEJRMnhGTEU5QlFVODFReXhIUVVGSGMwTXNaMEpCUVdkQ2NrTXNVMEZCVXpSRExFOUJRVTlLTEVWQlFWTXZRaXd3UWtGQk1FSkRMRWRCUVdkQ0swSXNSVUZCY1VKRExFVkJRVTFETEV0QlNUVklOVU1zUjBGQlIzTkRMR2RDUVVGblFsRXNZVUZCWlN4RFFVTm9RMDRzUzBGQlRTeFRRVUZUUXl4RlFVRlRPVUlzUlVGQlpTdENMRVZCUVhGQ1F5eEZRVUZOUXl4SFFVTm9SU3hQUVVGUE5VTXNSMEZCUjNORExHZENRVUZuUW5CRExGVkJRVlZ6UXl4TFFVRkxReXhGUVVGVEwwSXNNRUpCUVRCQ1F5eEhRVUZuUWl0Q0xFVkJRWEZDUXl4RlFVRk5ReXhKUVVWNlNFTXNUMEZCVVN4VFFVRlRTaXhGUVVGVE9VSXNSVUZCWlN0Q0xFVkJRWEZDUXl4RlFVRk5ReXhIUVVOc1JTeFBRVUZQTlVNc1IwRkJSM05ETEdkQ1FVRm5RbkJETEZWQlFWVXlReXhQUVVGUFNpeEZRVUZUTDBJc01FSkJRVEJDUXl4SFFVRm5RaXRDTEVWQlFYRkNReXhGUVVGTlF5SXNJbVpwYkdVaU9pSXZjSEpwZG1GMFpTOTBiWEF2Wm05dkxrZFBSUzl6Y21NdmFuTXZZbWx1WkdsdVozTXZaWGgwYzI5eWRHRmliR1Z6TG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIgJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsa289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIik7a28uYmluZGluZ0hhbmRsZXJzLmZ1ZHJvcHBhYmxlPXtpbml0OmZ1bmN0aW9uKGUsaSl7dmFyIG89aSgpfHx7fSxsPXt9LHI9ZnVuY3Rpb24oZSxpLG8sbCxyLGEpe2VbaV0/Z2xvYmFsLmNsZWFyVGltZW91dChlW2ldKToodm9pZCAwIT09bCYmby5jbGFzc0xpc3QuYWRkKGwpLGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZShyKSYmIXIoKSYmcighMCkpO3ZhciBuPWZ1bmN0aW9uKCl7ZVtpXT1udWxsLHZvaWQgMCE9PWwmJm8uY2xhc3NMaXN0LnJlbW92ZShsKSxrby5pc1dyaXRlYWJsZU9ic2VydmFibGUocikmJnIoKSYmcighMSl9O1wiZHJhZ2xlYXZlXCI9PWEudHlwZT9uKCk6ZVtpXT1nbG9iYWwuc2V0VGltZW91dChuLDUwMCl9OyhvLmFjdGl2ZXx8by5hY3RpdmVDbGFzcykmJmtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGdsb2JhbCxcImRyYWdvdmVyXCIsci5iaW5kKHZvaWQgMCxsLFwiYWN0aXZlVGltZW91dFwiLGUsby5hY3RpdmVDbGFzcyxvLmFjdGl2ZSkpLG8uaG92ZXJDbGFzcyYma28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZSxcImRyYWdvdmVyIGRyYWdlbnRlciBkcmFnbGVhdmVcIixyLmJpbmQodm9pZCAwLGwsXCJob3ZlclRpbWVvdXRcIixlLG8uaG92ZXJDbGFzcyx2b2lkIDApKX19LGtvLmJpbmRpbmdIYW5kbGVycy5maWxldXBsb2FkPXtleHRlbmRPcHRpb25zOnt9LGluaXQ6ZnVuY3Rpb24oZSxpKXtrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGUsZnVuY3Rpb24oKXskKGUpLmZpbGV1cGxvYWQoXCJkZXN0cm95XCIpfSksIShcIldlYmtpdEFwcGVhcmFuY2VcImluIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpfHxcIndlYmtpdE5ic3BNb2RlXCJpbiBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlfHxcIlN0eWxlTWVkaWFcImluIGdsb2JhbD8kKGUpLmF0dHIoXCJ0aXRsZVwiLFwiXCIpOiQoZSkuYXR0cihcInRpdGxlXCIsXCIgXCIpfSx1cGRhdGU6ZnVuY3Rpb24oZSxpKXt2YXIgbz1pKCl8fHt9LGw9JChlKSxyPWwucGFyZW50cyhcIi51cGxvYWR6b25lXCIpLGE9by5kYXRhO28uZGF0YT12b2lkIDA7dmFyIG49by5jYW52YXNQcmV2aWV3O2tvLnV0aWxzLmV4dGVuZChvLHt1cmw6XCIvdXBsb2FkL1wiLGRhdGFUeXBlOlwianNvblwiLGRyb3Bab25lOnIuZmluZChcIi5tby11cGxvYWR6b25lXCIpWzBdLGF1dG9VcGxvYWQ6ITAsYWNjZXB0RmlsZVR5cGVzOi8oXFwufFxcLykoZ2lmfGpwZT9nfHBuZykkL2ksbWF4RmlsZVNpemU6MTA0ODU3NixkaXNhYmxlSW1hZ2VSZXNpemU6L0FuZHJvaWQoPyEuKkNocm9tZSl8T3BlcmEvLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpLHByZXZpZXdNYXhXaWR0aDoyMDAscHJldmlld01heEhlaWdodDoyMDAscHJldmlld0Nyb3A6ITEscmVwbGFjZUZpbGVJbnB1dDohMSxtZXNzYWdlczp7dW5rbm93bkVycm9yOlwiVW5rbm93biBlcnJvclwiLHVwbG9hZGVkQnl0ZXM6XCJVcGxvYWRlZCBieXRlcyBleGNlZWQgZmlsZSBzaXplXCIsbWF4TnVtYmVyT2ZGaWxlczpcIk1heGltdW0gbnVtYmVyIG9mIGZpbGVzIGV4Y2VlZGVkXCIsYWNjZXB0RmlsZVR5cGVzOlwiRmlsZSB0eXBlIG5vdCBhbGxvd2VkXCIsbWF4RmlsZVNpemU6XCJGaWxlIGlzIHRvbyBsYXJnZVwiLG1pbkZpbGVTaXplOlwiRmlsZSBpcyB0b28gc21hbGxcIixwb3N0X21heF9zaXplOlwiVGhlIHVwbG9hZGVkIGZpbGUgZXhjZWVkcyB0aGUgcG9zdF9tYXhfc2l6ZSBkaXJlY3RpdmUgaW4gcGhwLmluaVwiLG1heF9maWxlX3NpemU6XCJGaWxlIGlzIHRvbyBiaWdcIixtaW5fZmlsZV9zaXplOlwiRmlsZSBpcyB0b28gc21hbGxcIixhY2NlcHRfZmlsZV90eXBlczpcIkZpbGV0eXBlIG5vdCBhbGxvd2VkXCIsbWF4X251bWJlcl9vZl9maWxlczpcIk1heGltdW0gbnVtYmVyIG9mIGZpbGVzIGV4Y2VlZGVkXCIsbWF4X3dpZHRoOlwiSW1hZ2UgZXhjZWVkcyBtYXhpbXVtIHdpZHRoXCIsbWluX3dpZHRoOlwiSW1hZ2UgcmVxdWlyZXMgYSBtaW5pbXVtIHdpZHRoXCIsbWF4X2hlaWdodDpcIkltYWdlIGV4Y2VlZHMgbWF4aW11bSBoZWlnaHRcIixtaW5faGVpZ2h0OlwiSW1hZ2UgcmVxdWlyZXMgYSBtaW5pbXVtIGhlaWdodFwiLGFib3J0OlwiRmlsZSB1cGxvYWQgYWJvcnRlZFwiLGltYWdlX3Jlc2l6ZTpcIkZhaWxlZCB0byByZXNpemUgaW1hZ2VcIixnZW5lcmljOlwiVW5leHBlY3RlZCB1cGxvYWQgZXJyb3JcIn19KSxrby51dGlscy5leHRlbmQobyxrby5iaW5kaW5nSGFuZGxlcnMuZmlsZXVwbG9hZC5leHRlbmRPcHRpb25zKTt2YXIgcz0wLHQ9XCJcIixkPWZ1bmN0aW9uKCl7MD09LS1zJiYoYSYmYSh0KSx0PVwiXCIsbiYmKHIuZmluZChcImltZ1wiKS5zaG93KCksci5maW5kKFwiY2FudmFzXCIpLnJlbW92ZSgpKSxyLnJlbW92ZUNsYXNzKFwidXBsb2FkaW5nXCIpLHIuZmluZChcIi5wcm9ncmVzcy1iYXJcIikuY3NzKFwid2lkdGhcIiwwKSl9LHU9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIG8ubWVzc2FnZXMmJm51bGwhPT1vLm1lc3NhZ2VzKXt2YXIgaT1lLm1hdGNoKC9eKFteIF0rKSguKikkLyk7aWYoaSYmdm9pZCAwIT09by5tZXNzYWdlc1tpWzFdXSlyZXR1cm4gby5tZXNzYWdlc1tpWzFdXStpWzJdfXJldHVybiBlfTtvLnVwbG9hZFRvVGVtcGxhdGU/by51cmw9a28uYmluZGluZ0hhbmRsZXJzLmZpbGV1cGxvYWQuZXh0ZW5kT3B0aW9ucy51cmwudGVtcGxhdGU6by51cmw9a28uYmluZGluZ0hhbmRsZXJzLmZpbGV1cGxvYWQuZXh0ZW5kT3B0aW9ucy51cmwubWFpbGluZyxsLmZpbGV1cGxvYWQobyk7Zm9yKHZhciBwPVtcImZpbGV1cGxvYWRhZGRcIixcImZpbGV1cGxvYWRwcm9jZXNzYWx3YXlzXCIsXCJmaWxldXBsb2FkcHJvZ3Jlc3NhbGxcIixcImZpbGV1cGxvYWRkb25lXCIsXCJmaWxldXBsb2FkZmFpbFwiXSxmPWZ1bmN0aW9uKGUsaSl7aWYoXCJmaWxldXBsb2FkYWRkXCI9PWUudHlwZSYmcysrLFwiZmlsZXVwbG9hZGZhaWxcIj09ZS50eXBlJiYoY29uc29sZS5sb2coXCJmaWxldXBsb2FkZmFpbFwiLGUsaSksby5vbmVycm9yJiYoXCJcIj09PWkuZXJyb3JUaHJvd24mJlwiZXJyb3JcIj09aS50ZXh0U3RhdHVzP28ub25lcnJvcih1KFwiZ2VuZXJpY1wiKSk6by5vbmVycm9yKHUoXCJnZW5lcmljIChcIitpLmVycm9yVGhyb3duK1wiKVwiKSkpLGQoKSksXCJmaWxldXBsb2FkZG9uZVwiPT1lLnR5cGUpaWYodm9pZCAwIT09aS5yZXN1bHQuZmlsZXNbMF0udXJsKXtpZihvLm9uZmlsZSlmb3IodmFyIGw9MDtsPGkucmVzdWx0LmZpbGVzLmxlbmd0aDtsKyspaS5yZXN1bHQuZmlsZXNbbF09a28uYmluZGluZ0hhbmRsZXJzLmZpbGV1cGxvYWQucmVtb3RlRmlsZVByZXByb2Nlc3NvcihpLnJlc3VsdC5maWxlc1tsXSksby5vbmZpbGUoaS5yZXN1bHQuZmlsZXNbbF0pO2lmKFwiXCI9PT10JiYodD1pLnJlc3VsdC5maWxlc1swXS51cmwpLG4pe3ZhciBhPW5ldyBJbWFnZTthLm9ubG9hZD1kLGEub25lcnJvcj1kLGEuc3JjPWkucmVzdWx0LmZpbGVzWzBdLnVybH1lbHNlIGQoKX1lbHNlIHZvaWQgMCE9PWkucmVzdWx0LmZpbGVzWzBdLmVycm9yPyhjb25zb2xlLmxvZyhcInJlbW90ZSBlcnJvclwiLGUsaSksby5vbmVycm9yJiZvLm9uZXJyb3IodShpLnJlc3VsdC5maWxlc1swXS5lcnJvcikpLGQoKSk6KGNvbnNvbGUubG9nKFwidW5leHBlY3RlZCBlcnJvclwiLGUsaSksby5vbmVycm9yJiZvLm9uZXJyb3IodShcImdlbmVyaWMgKFVuZXhwZWN0ZWQgRXJyb3IgcmV0cmlldmluZyB1cGxvYWRlZCBmaWxlKVwiKSksZCgpKTtpZihcImZpbGV1cGxvYWRwcm9jZXNzYWx3YXlzXCI9PWUudHlwZSl7dmFyIHA9aS5pbmRleCxmPWkuZmlsZXNbcF07aWYoZi5wcmV2aWV3JiYwPT09cCYmMD09PXIuZmluZChcImNhbnZhc1wiKS5sZW5ndGgpe2lmKG4pe3ZhciBtPSQoZi5wcmV2aWV3KS5jc3MoXCJ3aWR0aFwiLFwiMTAwJVwiKTtyLmZpbmQoXCJpbWdcIikuaGlkZSgpLHIucHJlcGVuZChtKX1yLmFkZENsYXNzKFwidXBsb2FkaW5nXCIpLHIuZmluZChcIi5wcm9ncmVzcy1iYXJcIikuY3NzKFwid2lkdGhcIiwwKX1mLmVycm9yJiYoby5vbmVycm9yJiZvLm9uZXJyb3IodShmLmVycm9yKSksZCgpKX1pZihcImZpbGV1cGxvYWRwcm9ncmVzc2FsbFwiPT1lLnR5cGUpe3ZhciBnPXBhcnNlSW50KGkubG9hZGVkL2kudG90YWwqMTAwLDEwKTtyLmZpbmQoXCIucHJvZ3Jlc3MtYmFyXCIpLmNzcyhcIndpZHRoXCIsZytcIiVcIil9fSxtPXAubGVuZ3RoLTE7bT49MDttLS0pe3ZhciBnPXBbbV07bC5vbihnLGYpfSQuc3VwcG9ydC5maWxlSW5wdXR8fGwucHJvcChcImRpc2FibGVkXCIsITApLnBhcmVudCgpLmFkZENsYXNzKFwiZGlzYWJsZWRcIil9fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltWnBiR1YxY0d4dllXUXVhbk1pWFN3aWJtRnRaWE1pT2xzaUpDSXNJbmRwYm1SdmR5SXNJbWRzYjJKaGJDSXNJbXR2SWl3aVkyOXVjMjlzWlNJc0luSmxjWFZwY21VaUxDSmlhVzVrYVc1blNHRnVaR3hsY25NaUxDSnBibWwwSWl3aVpXeGxiV1Z1ZENJc0luWmhiSFZsUVdOalpYTnpiM0lpTENKdmNIUWlMQ0owYVcxbGIzVjBjMDlpYWlJc0ltOTJaWElpTENKMGFXMWxiM1YwY3lJc0ltUnliM0JhYjI1bFZHbHRaVzkxZENJc0ltTnNZWE56VG1GdFpTSXNJbTlpYzJWeWRtRmliR1VpTENKbGRtVnVkQ0lzSW1Oc1pXRnlWR2x0Wlc5MWRDSXNJbU5zWVhOelRHbHpkQ0lzSW1Ga1pDSXNJbWx6VjNKcGRHVmhZbXhsVDJKelpYSjJZV0pzWlNJc0luTjBiM0FpTENKeVpXMXZkbVVpTENKMGVYQmxJaXdpYzJWMFZHbHRaVzkxZENJc0ltRmpkR2wyWlNJc0ltRmpkR2wyWlVOc1lYTnpJaXdpZFhScGJITWlMQ0p5WldkcGMzUmxja1YyWlc1MFNHRnVaR3hsY2lJc0ltSnBibVFpTENKMWJtUmxabWx1WldRaUxDSm9iM1psY2tOc1lYTnpJaXdpWlhoMFpXNWtUM0IwYVc5dWN5SXNJbVJ2YlU1dlpHVkVhWE53YjNOaGJDSXNJbUZrWkVScGMzQnZjMlZEWVd4c1ltRmpheUlzSW1acGJHVjFjR3h2WVdRaUxDSmtiMk4xYldWdWRDSXNJbVJ2WTNWdFpXNTBSV3hsYldWdWRDSXNJbk4wZVd4bElpd2lZWFIwY2lJc0luVndaR0YwWlNJc0ltOXdkR2x2Ym5NaUxDSWtablVpTENJa2NHRnlaVzUwSWl3aWNHRnlaVzUwY3lJc0ltUmhkR0ZXWVd4MVpTSXNJbVJoZEdFaUxDSmpZVzUyWVhOUWNtVjJhV1YzSWl3aVpYaDBaVzVrSWl3aWRYSnNJaXdpWkdGMFlWUjVjR1VpTENKa2NtOXdXbTl1WlNJc0ltWnBibVFpTENKaGRYUnZWWEJzYjJGa0lpd2lZV05qWlhCMFJtbHNaVlI1Y0dWeklpd2liV0Y0Um1sc1pWTnBlbVVpTENKa2FYTmhZbXhsU1cxaFoyVlNaWE5wZW1VaUxDSjBaWE4wSWl3aWJtRjJhV2RoZEc5eUlpd2lkWE5sY2tGblpXNTBJaXdpY0hKbGRtbGxkMDFoZUZkcFpIUm9JaXdpY0hKbGRtbGxkMDFoZUVobGFXZG9kQ0lzSW5CeVpYWnBaWGREY205d0lpd2ljbVZ3YkdGalpVWnBiR1ZKYm5CMWRDSXNJbTFsYzNOaFoyVnpJaXdpZFc1cmJtOTNia1Z5Y205eUlpd2lkWEJzYjJGa1pXUkNlWFJsY3lJc0ltMWhlRTUxYldKbGNrOW1SbWxzWlhNaUxDSnRhVzVHYVd4bFUybDZaU0lzSW5CdmMzUmZiV0Y0WDNOcGVtVWlMQ0p0WVhoZlptbHNaVjl6YVhwbElpd2liV2x1WDJacGJHVmZjMmw2WlNJc0ltRmpZMlZ3ZEY5bWFXeGxYM1I1Y0dWeklpd2liV0Y0WDI1MWJXSmxjbDl2Wmw5bWFXeGxjeUlzSW0xaGVGOTNhV1IwYUNJc0ltMXBibDkzYVdSMGFDSXNJbTFoZUY5b1pXbG5hSFFpTENKdGFXNWZhR1ZwWjJoMElpd2lZV0p2Y25RaUxDSnBiV0ZuWlY5eVpYTnBlbVVpTENKblpXNWxjbWxqSWl3aWQyOXlhMmx1WnlJc0ltWnBjbk4wVjI5eWEyVmtJaXdpWTJ4bFlXNTFjQ0lzSW5Ob2IzY2lMQ0p5WlcxdmRtVkRiR0Z6Y3lJc0ltTnpjeUlzSW5SeVlXNXpiR0YwWldSTlpYTnpZV2RsSWl3aWRHVjRkQ0lzSW0xaGRHTm9JaXdpZFhCc2IyRmtWRzlVWlcxd2JHRjBaU0lzSW5SbGJYQnNZWFJsSWl3aWJXRnBiR2x1WnlJc0ltVjJaVzUwY3lJc0ltVjJaVzUwU0dGdVpHeGxjaUlzSW1VaUxDSnNiMmNpTENKdmJtVnljbTl5SWl3aVpYSnliM0pVYUhKdmQyNGlMQ0owWlhoMFUzUmhkSFZ6SWl3aWNtVnpkV3gwSWl3aVptbHNaWE1pTENKdmJtWnBiR1VpTENKcElpd2liR1Z1WjNSb0lpd2ljbVZ0YjNSbFJtbHNaVkJ5WlhCeWIyTmxjM052Y2lJc0ltbHRaeUlzSWtsdFlXZGxJaXdpYjI1c2IyRmtJaXdpYzNKaklpd2laWEp5YjNJaUxDSnBibVJsZUNJc0ltWnBiR1VpTENKd2NtVjJhV1YzSWl3aVpXd2lMQ0pvYVdSbElpd2ljSEpsY0dWdVpDSXNJbUZrWkVOc1lYTnpJaXdpY0hKdlozSmxjM01pTENKd1lYSnpaVWx1ZENJc0lteHZZV1JsWkNJc0luUnZkR0ZzSWl3aVpYWmxiblJPWVcxbElpd2liMjRpTENKemRYQndiM0owSWl3aVptbHNaVWx1Y0hWMElpd2ljSEp2Y0NJc0luQmhjbVZ1ZENKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1lVRlpRU3hKUVVGSlFTeEZRVUYxUWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVdVc1QwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZsTEU5QlFVa3NTMEZETTBkRExFZEJRWGRDTEc5Q1FVRllSaXhQUVVGNVFrRXNUMEZCVnl4SFFVRnpRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRVmNzUjBGQlNTeExRVU53UjBVc1VVRkJWVU1zVVVGQlVTeHpRa0ZGZEVKR0xFZEJRVWRITEdkQ1FVRTJRaXhaUVVGSkxFTkJRMnhEUXl4TFFVRk5MRk5CUVZORExFVkJRVk5ETEVkQlEzUkNMRWxCUVVsRExFVkJRVTFFTEV0QlFXMUNMRWRCUTNwQ1JTeEZRVUZqTEVkQlJXUkRMRVZCUVU4c1UwRkRWRU1zUlVGRFFVTXNSVUZEUVU0c1JVRkRRVThzUlVGRFFVTXNSVUZEUVVNc1IwRkZTMG9zUlVGQlUwTXNSMEZSV2xvc1QwRkJUMmRDTEdGQlFXRk1MRVZCUVZORExGVkJVRW9zU1VGQlpFTXNSMEZEVkZBc1JVRkJVVmNzVlVGQlZVTXNTVUZCU1V3c1IwRkZjRUphTEVkQlFVZHJRaXh6UWtGQmMwSk1MRXRCUVdkQ1FTeExRVU16UTBFc1IwRkJWeXhKUVUxbUxFbEJRVWxOTEVWQlFVOHNWMEZEVkZRc1JVRkJVME1zUjBGQmJVSXNWVUZEU0N4SlFVRmtReXhIUVVOVVVDeEZRVUZSVnl4VlFVRlZTU3hQUVVGUFVpeEhRVVYyUWxvc1IwRkJSMnRDTEhOQ1FVRnpRa3dzU1VGQlpVRXNTMEZETVVOQkxFZEJRVmNzU1VGSlJ5eGhRVUZrUXl4RlFVRk5UeXhMUVVGeFFrWXNTVUZITjBKVUxFVkJRVk5ETEVkQlFXMUNXaXhQUVVGUGRVSXNWMEZCVjBnc1JVRkJUU3hQUVVsd1JGb3NSVUZCU1dkQ0xGRkJRVlZvUWl4RlFVRkphVUlzWTBGRGNFSjRRaXhIUVVGSGVVSXNUVUZCVFVNc2NVSkJRMUF6UWl4UFFVTkJMRmRCUTBGVkxFVkJRVXRyUWl4VlFVTklReXhGUVVOQmNFSXNSVUZEUVN4blFrRkRRVWdzUlVGRFFVVXNSVUZCU1dsQ0xGbEJRMHBxUWl4RlFVRkpaMElzVTBGSlRtaENMRVZCUVVselFpeFpRVVZPTjBJc1IwRkJSM2xDTEUxQlFVMURMSEZDUVVOUWNrSXNSVUZEUVN3clFrRkRRVWtzUlVGQlMydENMRlZCUTBoRExFVkJRMEZ3UWl4RlFVTkJMR1ZCUTBGSUxFVkJRMEZGTEVWQlFVbHpRaXhuUWtGRFNrUXNUVUZQVmpWQ0xFZEJRVWRITEdkQ1FVRTBRaXhYUVVGSkxFTkJRMnBETWtJc1kwRkJaU3hIUVVWbU1VSXNTMEZCVFN4VFFVRlRReXhGUVVGVFF5eEhRVWwwUWs0c1IwRkJSM2xDTEUxQlFVMU5MR2RDUVVGblFrTXNiVUpCUVcxQ00wSXNSVUZCVXl4WFFVTnVSRklzUlVGQlJWRXNSMEZCVXpSQ0xGZEJRVmNzWlVGWGRFSXNjVUpCUVhOQ2JFTXNUMEZCVDIxRExGTkJRVk5ETEdkQ1FVRm5Ra01zVVVGRGNFUXNiVUpCUVc5Q2NrTXNUMEZCVDIxRExGTkJRVk5ETEdkQ1FVRm5Ra01zVDBGRGNFUXNaVUZCWjBKeVF5eFBRVWxtUml4RlFVRkZVU3hIUVVGVFowTXNTMEZCU3l4UlFVRlRMRWxCUkRWQ2VFTXNSVUZCUlZFc1IwRkJVMmRETEV0QlFVc3NVVUZCVXl4TlFVazNRa01zVDBGQlVTeFRRVUZUYWtNc1JVRkJVME1zUjBGRGVFSXNTVUZCU1dsRExFVkJRVlZxUXl4TFFVRnRRaXhIUVVVM1FtdERMRVZCUVUwelF5eEZRVUZGVVN4SFFVTlNiME1zUlVGQlZVUXNSVUZCU1VVc1VVRkJVU3hsUVVWMFFrTXNSVUZCV1Vvc1JVRkJVVXNzUzBGRGVFSk1MRVZCUVZGTExGVkJRVTlvUWl4RlFVVm1MRWxCUVVscFFpeEZRVUZuUWs0c1JVRkJVVTBzWTBGSE5VSTNReXhIUVVGSGVVSXNUVUZCVFhGQ0xFOUJRVTlRTEVWQlFWTXNRMEZEZGtKUkxFbEJRVXNzVjBGRFRFTXNVMEZCVlN4UFFVTldReXhUUVVGVlVpeEZRVUZSVXl4TFFVRkxMR3RDUVVGclFpeEhRVU42UTBNc1dVRkJXU3hGUVVOYVF5eG5Ra0ZCYVVJc01rSkJRMnBDUXl4WlFVRmhMRkZCU1dKRExHMUNRVUZ2UWl3MFFrRkJORUpETEV0QlF6bERlRVFzVDBGQlQzbEVMRlZCUVZWRExGZEJSVzVDUXl4blFrRkJhVUlzU1VGRGFrSkRMR2xDUVVGclFpeEpRVU5zUWtNc1lVRkJZU3hGUVVOaVF5eHJRa0ZCYTBJc1JVRkZiRUpETEZOQlFWVXNRMEZGVWtNc1lVRkJZeXhuUWtGRFpFTXNZMEZCWlN4clEwRkRaa01zYVVKQlFXdENMRzFEUVVOc1FtSXNaMEpCUVdsQ0xIZENRVU5xUWtNc1dVRkJZU3h2UWtGRFltRXNXVUZCWVN4dlFrRkZZa01zWTBGRFJTeHRSVUZEUmtNc1kwRkJaU3hyUWtGRFprTXNZMEZCWlN4dlFrRkRaa01zYTBKQlFXMUNMSFZDUVVOdVFrTXNiMEpCUVhGQ0xHMURRVU55UWtNc1ZVRkJWeXc0UWtGRFdFTXNWVUZCVnl4cFEwRkRXRU1zVjBGQldTd3JRa0ZEV2tNc1YwRkJXU3hyUTBGRFdrTXNUVUZCVHl4elFrRkRVRU1zWVVGQll5eDVRa0ZEWkVNc1VVRkJVeXcyUWtGTFlqbEZMRWRCUVVkNVFpeE5RVUZOY1VJc1QwRkJUMUFzUlVGQlUzWkRMRWRCUVVkSExHZENRVUUwUWl4WFFVRkZNa0lzWlVGRk1VUXNTVUZCU1dsRUxFVkJRVlVzUlVGRFZrTXNSVUZCWXl4SFFVVmtReXhGUVVGVkxGZEJRMDBzUzBGQldrWXNTVUZEUVhCRExFZEJRMFpCTEVWQlFWVnhReXhIUVVWYVFTeEZRVUZqTEVkQlExWnVReXhKUVVOR1NpeEZRVUZSVXl4TFFVRkxMRTlCUVU5blF5eFBRVU53UW5wRExFVkJRVkZUTEV0QlFVc3NWVUZCVlRsQ0xGVkJSWHBDY1VJc1JVRkJVVEJETEZsQlFWa3NZVUZEY0VJeFF5eEZRVUZSVXl4TFFVRkxMR2xDUVVGcFFtdERMRWxCUVVrc1VVRkJVeXhMUVVrelEwTXNSVUZCYjBJc1UwRkJVME1zUjBGREwwSXNSMEZCSzBJc2FVSkJRWEJDTDBNc1JVRkJVWFZDTEZWQlFUWkRMRTlCUVhKQ2RrSXNSVUZCVVhWQ0xGTkJRVzFDTEVOQlEzQkZMRWxCUVVsNVFpeEZRVUZSUkN4RlFVRkxReXhOUVVGTkxHbENRVU4yUWl4SFFVRkpRU3hSUVVOM1F5eEpRVUV2UW1oRUxFVkJRVkYxUWl4VFFVRlRlVUlzUlVGQlRTeEpRVU5vUXl4UFFVRlBhRVFzUlVGQlVYVkNMRk5CUVZONVFpeEZRVUZOTEVsQlFVMUJMRVZCUVUwc1IwRkphRVFzVDBGQlQwUXNSMEZKVEM5RExFVkJRVkZwUkN4cFFrRkRWbXBFTEVWQlFWRlJMRWxCUVUwdlF5eEhRVUZIUnl4blFrRkJORUlzVjBGQlJUSkNMR05CUVdOcFFpeEpRVUZKTUVNc1UwRkZha1ZzUkN4RlFVRlJVU3hKUVVGTkwwTXNSMEZCUjBjc1owSkJRVFJDTEZkQlFVVXlRaXhqUVVGamFVSXNTVUZCU1RKRExGRkJSMjVGYkVRc1JVRkJTVkFzVjBGQlYwMHNSMEU0Um1Zc1NVRTFSa0VzU1VGQlNXOUVMRVZCUVZNc1EwRkRXQ3huUWtGRFFTd3dRa0ZEUVN4M1FrRkRRU3hwUWtGRFFTeHJRa0ZGUlVNc1JVRkJaU3hUUVVGVFF5eEZRVUZIYWtRc1IwRnBRamRDTEVkQmFFSmpMR2xDUVVGV2FVUXNSVUZCUlhoRkxFMUJRMG93UkN4SlFVVlpMR3RDUVVGV1l5eEZRVUZGZUVVc1QwRkRTbkJDTEZGQlFWRTJSaXhKUVVGSkxHbENRVUZyUWtRc1JVRkJSMnBFTEVkQlF6ZENUQ3hGUVVGUmQwUXNWVUZEWlN4TFFVRnlRbTVFTEVWQlFVdHZSQ3hoUVVGNVF5eFRRVUZ1UW5CRUxFVkJRVXR4UkN4WFFVTnNRekZFTEVWQlFWRjNSQ3hSUVVGUlZpeEZRVUZyUWl4WlFVVnNRemxETEVWQlFWRjNSQ3hSUVVOT1ZpeEZRVUZyUWl4WlFVRmpla01zUlVGQlMyOUVMRmxCUVdNc1QwRkpla1JtTEV0QlJWa3NhMEpCUVZaWkxFVkJRVVY0UlN4TFFVTktMRkZCUVhkRExFbEJRVGRDZFVJc1JVRkJTM05FTEU5QlFVOURMRTFCUVUwc1IwRkJSM0JFTEVsQlFYRkNMRU5CUTI1RUxFZEJRVWxTTEVWQlFWRTJSQ3hQUVVOV0xFbEJRVXNzU1VGQlNVTXNSVUZCU1N4RlFVRkhRU3hGUVVGSmVrUXNSVUZCUzNORUxFOUJRVTlETEUxQlFVMUhMRTlCUVZGRUxFbEJRelZEZWtRc1JVRkJTM05FTEU5QlFVOURMRTFCUVUxRkxFZEJRVXR5Unl4SFFVRkhSeXhuUWtGRk1VSXNWMEZCUlc5SExIVkNRVUYxUWpORUxFVkJRVXR6UkN4UFFVRlBReXhOUVVGTlJTeEpRVU16UXpsRUxFVkJRVkUyUkN4UFFVRlBlRVFzUlVGQlMzTkVMRTlCUVU5RExFMUJRVTFGTEVsQlRYSkRMRWRCUm05Q0xFdEJRV2hDY2tJc1NVRkJiMEpCTEVWQlFXTndReXhGUVVGTGMwUXNUMEZCVDBNc1RVRkJUU3hIUVVGSGNFUXNTMEZGZGtSR0xFVkJRV1VzUTBGRGFrSXNTVUZCU1RKRUxFVkJRVTBzU1VGQlNVTXNUVUZEWkVRc1JVRkJTVVVzVDBGQlUzcENMRVZCUTJKMVFpeEZRVUZKVkN4UlFVRlZaQ3hGUVVOa2RVSXNSVUZCU1Vjc1NVRkJUUzlFTEVWQlFVdHpSQ3hQUVVGUFF5eE5RVUZOTEVkQlFVZHdSQ3hUUVVVdlFtdERMR05CUlRaRExFbEJRUzlDY2tNc1JVRkJTM05FTEU5QlFVOURMRTFCUVUwc1IwRkJSMU1zVDBGRGNrTXpSeXhSUVVGUk5rWXNTVUZCU1N4bFFVRm5Ra1FzUlVGQlIycEVMRWRCUXpOQ1RDeEZRVUZSZDBRc1UwRkRWbmhFTEVWQlFWRjNSQ3hSUVVGUlZpeEZRVUZyUW5wRExFVkJRVXR6UkN4UFFVRlBReXhOUVVGTkxFZEJRVWRUTEZGQlJYcEVNMElzVFVGRlFXaEdMRkZCUVZFMlJpeEpRVUZKTEcxQ1FVRnZRa1FzUlVGQlIycEVMRWRCUXk5Q1RDeEZRVUZSZDBRc1UwRkRWbmhFTEVWQlFWRjNSQ3hSUVVOT1ZpeEZRVU5GTEhkRVFVbE9TaXhMUVVkS0xFZEJRV01zTWtKQlFWWlpMRVZCUVVWNFJTeExRVUZ0UXl4RFFVTjJReXhKUVVGSmQwWXNSVUZCVVdwRkxFVkJRVXRwUlN4TlFVTm1ReXhGUVVGUGJFVXNSVUZCUzNWRUxFMUJRVTFWTEVkQlEzQkNMRWRCUVVsRExFVkJRVXRETEZOQlFYRkNMRWxCUVZaR0xFZEJSVzlDTEVsQlFXeERjRVVzUlVGQlVWTXNTMEZCU3l4VlFVRlZiMFFzVDBGQll5eERRVU4yUXl4SFFVRkpla1FzUlVGQlpTeERRVU5xUWl4SlFVRkpiVVVzUlVGQlMyNUlMRVZCUVVWcFNDeEZRVUZMUXl4VFFVRlRNMElzU1VGQlNTeFJRVUZUTEZGQlEzUkRNME1zUlVGQlVWTXNTMEZCU3l4UFFVRlBLMFFzVDBGRGNFSjRSU3hGUVVGUmVVVXNVVUZCVVVZc1IwRkZiRUoyUlN4RlFVRlJNRVVzVTBGQlV5eGhRVU5xUWpGRkxFVkJRVkZUTEV0QlFVc3NhVUpCUVdsQ2EwTXNTVUZCU1N4UlFVRlRMRWRCUnpORE1FSXNSVUZCUzBZc1VVRkhTSEpGTEVWQlFWRjNSQ3hUUVVOV2VFUXNSVUZCVVhkRUxGRkJRVkZXTEVWQlFXdENlVUlzUlVGQlMwWXNVVUZGZWtNelFpeExRVWRLTEVkQlFXTXNlVUpCUVZaWkxFVkJRVVY0UlN4TFFVRnBReXhEUVVOeVF5eEpRVUZKSzBZc1JVRkJWME1zVTBGQlZYcEZMRVZCUVVzd1JTeFBRVUZUTVVVc1JVRkJTekpGTEUxQlFWTXNTVUZCU3l4SlFVTXhSRGxGTEVWQlFWRlRMRXRCUVVzc2FVSkJRV2xDYTBNc1NVRkJTU3hSUVVGVFowTXNSVUZCVnl4UFFVZHFSR1lzUlVGQlNWWXNSVUZCVDFjc1QwRkJVeXhGUVVGSFJDeEhRVUZMTEVWQlFVZEJMRWxCUVVzc1EwRkRNME1zU1VGQlNXMUNMRVZCUVZrM1FpeEZRVUZQVlN4SFFVTjJRamRFTEVWQlFVbHBSaXhIUVVGSFJDeEZRVUZYTlVJc1IwRkZaaTlHTEVWQlFVVTJTQ3hSUVVGUlF5eFhRVU5pYmtZc1JVRkRSMjlHTEV0QlFVc3NXVUZCV1N4SFFVTnFRa01zVTBGRFFWWXNVMEZCVXlJc0ltWnBiR1VpT2lJdmNISnBkbUYwWlM5MGJYQXZabTl2TGtkUFJTOXpjbU12YW5NdlltbHVaR2x1WjNNdlptbHNaWFZ3Ykc5aFpDNXFjeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGJlZm9yZVN1YnNjcmlwdGlvblByb3AsYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wLGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGwsY29uc29sZT1yZXF1aXJlKFwiY29uc29sZS1icm93c2VyaWZ5XCIpO2lmKGtvLmJpbmRpbmdIYW5kbGVycy5pZlN1YnM9e2Nsb25lTm9kZXM6ZnVuY3Rpb24obyxlKXtmb3IodmFyIGk9MCxuPW8ubGVuZ3RoLHI9W107aTxuO2krKyl7dmFyIHM9b1tpXS5jbG9uZU5vZGUoITApO3IucHVzaChlP2tvLmNsZWFuTm9kZShzKTpzKX1yZXR1cm4gcn0saW5pdDpmdW5jdGlvbihvLGUsaSxuLHIpe3ZhciBzLHQsdT1lKCk7cmV0dXJuIHZvaWQgMD09PXUuZGF0YS5zdWJzQ291bnQmJmtvLmV4dGVuZGVycy5zdWJzY3JpcHRpb25zQ291bnQodS5kYXRhKSxrby5jb21wdXRlZChmdW5jdGlvbigpe3ZhciBpLG4sYj1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKGUoKS5kYXRhLnN1YnNDb3VudCkscD0hdDtuPS0odm9pZCAwIT09ZSgpLmd1dHRlcj9lKCkuZ3V0dGVyOjEpLGk9Yisocz9uOjApPj1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKHUudGhyZXNob2xkKSx2b2lkIDAhPT1lKCkubm90JiZlKCkubm90JiYoaT0haSksKHB8fGkhPT1zKSYmKHAmJmtvLmNvbXB1dGVkQ29udGV4dC5nZXREZXBlbmRlbmNpZXNDb3VudCgpJiYodD1rby5iaW5kaW5nSGFuZGxlcnMuaWZTdWJzLmNsb25lTm9kZXMoa28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMobyksITApKSxpPyhwfHxrby52aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuKG8sa28uYmluZGluZ0hhbmRsZXJzLmlmU3Vicy5jbG9uZU5vZGVzKHQpKSxrby5hcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyhyLG8pKTprby52aXJ0dWFsRWxlbWVudHMuZW1wdHlOb2RlKG8pLHM9aSl9LG51bGwse2Rpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDpvfSkse2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiEwfX19LGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3MuaWZTdWJzPSEwLFwiZnVuY3Rpb25cIj09dHlwZW9mIGtvLnN1YnNjcmlwdGlvbiYmdm9pZCAwIT09a28uaXNXcml0YWJsZU9ic2VydmFibGUpYmVmb3JlU3Vic2NyaXB0aW9uUHJvcD1cImJlZm9yZVN1YnNjcmlwdGlvbkFkZFwiLGFmdGVyU3Vic2NyaXB0aW9uUHJvcD1cImFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlXCI7ZWxzZSBpZihcIjMuMi4wXCI9PWtvLnZlcnNpb24pYmVmb3JlU3Vic2NyaXB0aW9uUHJvcD1cInZhXCIsYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wPVwibmJcIjtlbHNlIGlmKFwiMy4zLjBcIj09a28udmVyc2lvbiliZWZvcmVTdWJzY3JpcHRpb25Qcm9wPVwiamFcIixhZnRlclN1YnNjcmlwdGlvblByb3A9XCJ1YVwiO2Vsc2UgaWYoXCIzLjQuMFwiPT1rby52ZXJzaW9uKWJlZm9yZVN1YnNjcmlwdGlvblByb3A9XCJzYVwiLGFmdGVyU3Vic2NyaXB0aW9uUHJvcD1cIklhXCI7ZWxzZSBpZihcIjMuNC4xXCI9PWtvLnZlcnNpb24pYmVmb3JlU3Vic2NyaXB0aW9uUHJvcD1cInNhXCIsYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wPVwiSWFcIjtlbHNlIGlmKFwiMy40LjJcIj09a28udmVyc2lvbiliZWZvcmVTdWJzY3JpcHRpb25Qcm9wPVwidWFcIixhZnRlclN1YnNjcmlwdGlvblByb3A9XCJLYVwiO2Vsc2V7aWYoXCIzLjUuMC1iZXRhXCIhPWtvLnZlcnNpb24pdGhyb3dcIlVuc3VwcG9ydGVkIG1pbmltaXplZCBLbm9ja291dCB2ZXJzaW9uIFwiK2tvLnZlcnNpb24rXCIgKHN1cHBvcnRlZCBERUJVRyBvciBtaW5pbWl6ZWQgMy4yLjAgLi4uIDMuNS4wLWJldGEpXCI7YmVmb3JlU3Vic2NyaXB0aW9uUHJvcD1cIlBhXCIsYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wPVwiYWJcIn1rby5leHRlbmRlcnMuc3Vic2NyaXB0aW9uc0NvdW50PWZ1bmN0aW9uKG8sZSxpKXtpZih2b2lkIDA9PT1vLnN1YnNDb3VudCl7by5zdWJzQ291bnQ9a28ub2JzZXJ2YWJsZShvLmdldFN1YnNjcmlwdGlvbnNDb3VudCgpKS5leHRlbmQoe25vdGlmeTpcImFsd2F5c1wifSk7dmFyIG49b1tiZWZvcmVTdWJzY3JpcHRpb25Qcm9wXSxyPW9bYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wXTtvW2JlZm9yZVN1YnNjcmlwdGlvblByb3BdPWZ1bmN0aW9uKHIpe24mJm4uY2FsbChvLHIpO3ZhciBzPW8uZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkrMTt2b2lkIDAhPT1lJiZzIT1lJiZ2b2lkIDAhPT1pJiZzIT1pfHxvLnN1YnNDb3VudChzKX0sb1thZnRlclN1YnNjcmlwdGlvblByb3BdPWZ1bmN0aW9uKG4pe3ImJnIuY2FsbChvLG4pO3ZhciBzPW8uZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCk7dm9pZCAwIT09ZSYmcyE9ZSYmdm9pZCAwIT09aSYmcyE9aXx8by5zdWJzQ291bnQocyl9fWVsc2UgY29uc29sZS5sb2coXCJhbHJlYWR5IGFwcGxpZWQgc3Vic2NyaXB0aW9uQ291bnQgdG8gb2JzZXJ2YWJsZVwiKTtyZXR1cm4gbnVsbH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbWxtTFhOMVluTXVhbk1pWFN3aWJtRnRaWE1pT2xzaVltVm1iM0psVTNWaWMyTnlhWEIwYVc5dVVISnZjQ0lzSW1GbWRHVnlVM1ZpYzJOeWFYQjBhVzl1VUhKdmNDSXNJbXR2SWl3aWQybHVaRzkzSWl3aVoyeHZZbUZzSWl3aVkyOXVjMjlzWlNJc0luSmxjWFZwY21VaUxDSmlhVzVrYVc1blNHRnVaR3hsY25NaUxDSmpiRzl1WlU1dlpHVnpJaXdpYm05a1pYTkJjbkpoZVNJc0luTm9iM1ZzWkVOc1pXRnVUbTlrWlhNaUxDSnBJaXdpYWlJc0lteGxibWQwYUNJc0ltNWxkMDV2WkdWelFYSnlZWGtpTENKamJHOXVaV1JPYjJSbElpd2lZMnh2Ym1WT2IyUmxJaXdpY0hWemFDSXNJbU5zWldGdVRtOWtaU0lzSW1sdWFYUWlMQ0psYkdWdFpXNTBJaXdpZG1Gc2RXVkJZMk5sYzNOdmNpSXNJbUZzYkVKcGJtUnBibWR6SWl3aWRtbGxkMDF2WkdWc0lpd2lZbWx1WkdsdVowTnZiblJsZUhRaUxDSmthV1JFYVhOd2JHRjVUMjVNWVhOMFZYQmtZWFJsSWl3aWMyRjJaV1JPYjJSbGN5SXNJblpoYkhWbFFXTmpJaXdpWkdGMFlTSXNJbk4xWW5ORGIzVnVkQ0lzSW1WNGRHVnVaR1Z5Y3lJc0ltTnZiWEIxZEdWa0lpd2ljMmh2ZFd4a1JHbHpjR3hoZVNJc0ltZDFkSFJsY2lJc0ltUmhkR0ZXWVd4MVpTSXNJblYwYVd4eklpd2lkVzUzY21Gd1QySnpaWEoyWVdKc1pTSXNJbWx6Um1seWMzUlNaVzVrWlhJaUxDSjBhSEpsYzJodmJHUWlMQ0p1YjNRaUxDSmpiMjF3ZFhSbFpFTnZiblJsZUhRaUxDSm5aWFJFWlhCbGJtUmxibU5wWlhORGIzVnVkQ0lzSW5acGNuUjFZV3hGYkdWdFpXNTBjeUlzSW1Ob2FXeGtUbTlrWlhNaUxDSnpaWFJFYjIxT2IyUmxRMmhwYkdSeVpXNGlMQ0poY0hCc2VVSnBibVJwYm1kelZHOUVaWE5qWlc1a1lXNTBjeUlzSW1WdGNIUjVUbTlrWlNJc0ltUnBjM0J2YzJWWGFHVnVUbTlrWlVselVtVnRiM1psWkNJc0ltTnZiblJ5YjJ4elJHVnpZMlZ1WkdGdWRFSnBibVJwYm1keklpd2lZV3hzYjNkbFpFSnBibVJwYm1keklpd2ljM1ZpYzJOeWFYQjBhVzl1SWl3aWFYTlhjbWwwWVdKc1pVOWljMlZ5ZG1GaWJHVWlMQ0oyWlhKemFXOXVJaXdpZEdGeVoyVjBJaXdpYkRFaUxDSnNNaUlzSW05aWMyVnlkbUZpYkdVaUxDSm5aWFJUZFdKelkzSnBjSFJwYjI1elEyOTFiblFpTENKbGVIUmxibVFpTENKdWIzUnBabmtpTENKMWJtUmxjbXg1YVc1blFtVm1iM0psVTNWaWMyTnlhWEIwYVc5dVFXUmtSblZ1WTNScGIyNGlMQ0oxYm1SbGNteDVhVzVuUVdaMFpYSlRkV0p6WTNKcGNIUnBiMjVTWlcxdmRtVkdkVzVqZEdsdmJpSXNJbVYyWlc1MElpd2lZMkZzYkNJc0ltTWlMQ0pzYjJjaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxHRkJSVUVzU1VGblJVbEJMSFZDUVVOQlF5eHpRa0ZxUlVGRExFZEJRWGRDTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCVnl4SFFVRnpRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRVmNzUjBGQlNTeExRVU53UjBNc1VVRkJWVU1zVVVGQlVTeHpRa0ZwUlhSQ0xFZEJMMFJCU2l4SFFVRkhTeXhuUWtGQmQwSXNUMEZCU1N4RFFVVTNRa01zVjBGQldTeFRRVUZUUXl4RlFVRlpReXhIUVVNdlFpeEpRVUZMTEVsQlFVbERMRVZCUVVrc1JVRkJSME1zUlVGQlNVZ3NSVUZCVjBrc1QwRkJVVU1zUlVGQlowSXNSMEZCU1Vnc1JVRkJTVU1zUlVGQlIwUXNTVUZCU3l4RFFVTnlSU3hKUVVGSlNTeEZRVUZoVGl4RlFVRlhSU3hIUVVGSFN5eFhRVUZWTEVkQlEzcERSaXhGUVVGalJ5eExRVUZMVUN4RlFVRnRRbElzUjBGQlIyZENMRlZCUVZWSUxFZEJRV05CTEVkQlJXNUZMRTlCUVU5RUxFZEJSVlJMTEV0QlFWRXNVMEZCVTBNc1JVRkJVME1zUlVGQlpVTXNSVUZCWVVNc1JVRkJWME1zUjBGREwwUXNTVUZCU1VNc1JVRkRSa01zUlVGRFFVTXNSVUZCVjA0c1NVRnhRMklzV1VGd1EzVkRMRWxCUVRWQ1RTeEZRVUZUUXl4TFFVRkxReXhYUVVOMlFqTkNMRWRCUVVjMFFpeFZRVUU0UWl4dFFrRkJSVWdzUlVGQlUwTXNUVUZIT1VNeFFpeEhRVUZITmtJc1UwRkJVeXhYUVVOV0xFbEJSVVZETEVWQlFUWkNReXhGUVVZelFrTXNSVUZCV1doRExFZEJRVWRwUXl4TlFVRk5ReXhwUWtGQmFVSm1MRWxCUVdkQ1R5eExRVUZMUXl4WFFVTTNSRkVzUjBGQmFVSllMRVZCUjI1Q1R5eFRRVUUyUXl4SlFVRXpRbG9zU1VGQlowSlpMRTlCUVhsQ1dpeEpRVUZuUWxrc1QwRkJVeXhIUVVOd1JrUXNSVUZCWjBKRkxFZEJRV0ZVTEVWQlFYbENVU3hGUVVGVExFbEJRVTB2UWl4SFFVRkhhVU1zVFVGQlRVTXNhVUpCUVdsQ1ZDeEZRVUZUVnl4blFrRkRja1VzU1VGQmVFSnFRaXhKUVVGblFtdENMRXRCUVhWQ2JFSXNTVUZCWjBKclFpeE5RVU5vUlZBc1IwRkJhVUpCTEVsQlJVcExMRWRCUVd0Q1RDeEpRVUZyUWxBc1MwRkpOME5aTEVkQlFXbENia01zUjBGQlIzTkRMR2RDUVVGblFrTXNlVUpCUTNSRFppeEZRVUZoZUVJc1IwRkJSMHNzWjBKQlFYZENMRTlCUVVWRExGZEJRVmRPTEVkQlFVZDNReXhuUWtGQlowSkRMRmRCUVZkMlFpeEpRVUZWTEVsQlJ6TkdXU3hIUVVOSFN5eEhRVU5JYmtNc1IwRkJSM2RETEdkQ1FVRm5Ra1VzYlVKQlFXMUNlRUlzUlVGQlUyeENMRWRCUVVkTExHZENRVUYzUWl4UFFVRkZReXhYUVVGWGEwSXNTVUZGZWtaNFFpeEhRVUZITWtNc01rSkJRVEpDY2tJc1JVRkJaMEpLTEVsQlJUbERiRUlzUjBGQlIzZERMR2RDUVVGblFra3NWVUZCVlRGQ0xFZEJSeTlDU3l4RlFVRjVRazhzU1VGRk1VSXNTMEZCVFN4RFFVTlFaU3g1UWtGQk1FSXpRaXhKUVVWeVFpeERRVU5NTkVJc05FSkJRVGhDTEV0QlNYQkRPVU1zUjBGQlIzZERMR2RDUVVGblFrOHNaMEpCUVhkQ0xGRkJRVWtzUlVGVGFrSXNiVUpCUVc1Q0wwTXNSMEZCUjJkRUxHMUNRVUZwUlN4SlFVRTFRbWhFTEVkQlFVZHBSQ3h4UWtGRGNFUnVSQ3gxUWtGQmVVSXNkMEpCUTNwQ1F5eHpRa0ZCZDBJc0swSkJRMjVDTEVkQlFXdENMRk5CUVdSRExFZEJRVWRyUkN4UlFVTmFjRVFzZFVKQlFYbENMRXRCUTNwQ1F5eHpRa0ZCZDBJc1ZVRkRia0lzUjBGQmEwSXNVMEZCWkVNc1IwRkJSMnRFTEZGQlExcHdSQ3gxUWtGQmVVSXNTMEZEZWtKRExITkNRVUYzUWl4VlFVTnVRaXhIUVVGclFpeFRRVUZrUXl4SFFVRkhhMFFzVVVGRFduQkVMSFZDUVVGNVFpeExRVU42UWtNc2MwSkJRWGRDTEZWQlEyNUNMRWRCUVd0Q0xGTkJRV1JETEVkQlFVZHJSQ3hSUVVOYWNFUXNkVUpCUVhsQ0xFdEJRM3BDUXl4elFrRkJkMElzVlVGRGJrSXNSMEZCYTBJc1UwRkJaRU1zUjBGQlIydEVMRkZCUTFwd1JDeDFRa0ZCZVVJc1MwRkRla0pETEhOQ1FVRjNRaXhUUVVOdVFpeERRVUZCTEVkQlFXdENMR05CUVdSRExFZEJRVWRyUkN4UlFVbFVMRXRCUVUwc01FTkJRVFJEYkVRc1IwRkJSMnRFTEZGQlFWVXNkVVJCU0d4RmNFUXNkVUpCUVhsQ0xFdEJRM3BDUXl4elFrRkJkMElzUzBGTk1VSkRMRWRCUVVjMFFpeFZRVUU0UWl4dFFrRkJTU3hUUVVGVGRVSXNSVUZCVVVNc1JVRkJTVU1zUjBGRGVFUXNVVUZCWjBNc1NVRkJja0pHTEVWQlFVOTRRaXhWUVVFeVFpeERRVU16UTNkQ0xFVkJRVTk0UWl4VlFVRlpNMElzUjBGQlIzTkVMRmRCUVZkSUxFVkJRVTlKTEhsQ1FVRjVRa01zVDBGQlR5eERRVU4wUlVNc1QwRkJVU3hYUVVWV0xFbEJRVWxETEVWQlFUQkRVQ3hGUVVGUGNrUXNkMEpCUTJwRU5rUXNSVUZCTkVOU0xFVkJRVTl3UkN4MVFrRkRka1J2UkN4RlFVRlBja1FzZDBKQlFUQkNMRk5CUVZNNFJDeEhRVU53UTBZc1IwRkJlVU5CTEVWQlFYZERSeXhMUVVGTFZpeEZRVUZSVXl4SFFVTnNSeXhKUVVGSlJTeEZRVUZKV0N4RlFVRlBTU3gzUWtGQk1FSXNUMEZEZGtJc1NVRkJVRWdzUjBGQmMwSlZMRWRCUVV0V0xGRkJRVzlDTEVsQlFWQkRMRWRCUVhOQ1V5eEhRVUZMVkN4SFFVRkpSaXhGUVVGUGVFSXNWVUZCVlcxRExFbEJSWEpIV0N4RlFVRlBjRVFzZFVKQlFYbENMRk5CUVZNMlJDeEhRVU51UTBRc1IwRkJNa05CTEVWQlFUQkRSU3hMUVVGTFZpeEZRVUZSVXl4SFFVTjBSeXhKUVVGSlJTeEZRVUZKV0N4RlFVRlBTU3cyUWtGRFJ5eEpRVUZRU0N4SFFVRnpRbFVzUjBGQlMxWXNVVUZCYjBJc1NVRkJVRU1zUjBGQmMwSlRMRWRCUVV0VUxFZEJRVWxHTEVWQlFVOTRRaXhWUVVGVmJVTXNVMEZIY2tjelJDeFJRVUZSTkVRc1NVRkJTU3h0UkVGRlpDeFBRVUZQSWl3aVptbHNaU0k2SWk5d2NtbDJZWFJsTDNSdGNDOW1iMjh1UjA5RkwzTnlZeTlxY3k5aWFXNWthVzVuY3k5cFppMXpkV0p6TG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIgJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsc3Bpbm5lcj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnkudWkuc3Bpbm5lcjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5qUXVlcnkudWkuc3Bpbm5lcjpudWxsLGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKTtpZih2b2lkIDA9PT1zcGlubmVyKXRocm93XCJDYW5ub3QgZmluZCBqcXVlcnktdWkgc3Bpbm5lciB3aWRnZXQgZGVwZW5kZW5jeSFcIjskLndpZGdldChcInVpLnNwaW5uZXJcIixzcGlubmVyLHtfYWRqdXN0VmFsdWU6ZnVuY3Rpb24obil7dGhpcy5fc3VwZXIobik7dmFyIGU9dGhpcy5vcHRpb25zO3JldHVybiBuPXBhcnNlRmxvYXQobi50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbigpKSksbnVsbCE9PWUubWF4JiZuPmUubWF4P2UubWF4Om51bGwhPT1lLm1pbiYmbjxlLm1pbj9lLm1pbjpufX0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1weGRXVnllWFZwTFhOd2FXNXVaWEl1YW5NaVhTd2libUZ0WlhNaU9sc2lKQ0lzSW5kcGJtUnZkeUlzSW1kc2IySmhiQ0lzSW5Od2FXNXVaWElpTENKamIyNXpiMnhsSWl3aWNtVnhkV2x5WlNJc0luZHBaR2RsZENJc0lsOWhaR3AxYzNSV1lXeDFaU0lzSW5aaGJIVmxJaXdpZEdocGN5SXNJbDl6ZFhCbGNpSXNJbTl3ZEdsdmJuTWlMQ0p3WVhKelpVWnNiMkYwSWl3aWRHOUdhWGhsWkNJc0lsOXdjbVZqYVhOcGIyNGlMQ0p0WVhnaUxDSnRhVzRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEdGQlMwRXNTVUZCU1VFc1JVRkJkVUlzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZsTEU5QlFYTkNMRzlDUVVGWVF5eFBRVUY1UWtFc1QwRkJaU3hQUVVGSkxFdEJRek5IUXl4UlFVRTJRaXh2UWtGQldFWXNUMEZCZVVKQkxFOUJRV1VzVDBGQlRTeEhRVUZYTEZGQlFYTkNMRzlDUVVGWVF5eFBRVUY1UWtFc1QwRkJaU3hQUVVGTkxFZEJRVmNzVVVGQlNTeExRVU51U2tVc1VVRkJWVU1zVVVGQlVTeHpRa0ZGZEVJc1VVRkJjMElzU1VGQldFWXNVVUZCZDBJc1MwRkJUU3h0UkVGRmVrTklMRVZCUVVWTkxFOUJRVThzWVVGQlkwZ3NVVUZCVXl4RFFVTTVRa2tzWVVGQll5eFRRVUZUUXl4SFFVTllReXhMUVVGTFF5eFBRVUZQUml4SFFVRjBRaXhKUVVWSlJ5eEZRVUZWUml4TFFVRkxSU3hSUVUxdVFpeFBRVWhCU0N4RlFVRlJTU3hYUVVGWFNpeEZRVUZOU3l4UlFVRlJTaXhMUVVGTFN5eGxRVWRzUWl4UFFVRm9Ra2dzUlVGQlVVa3NTMEZCWjBKUUxFVkJRVkZITEVWQlFWRkpMRWxCUTI1RFNpeEZRVUZSU1N4SlFVVkhMRTlCUVdoQ1NpeEZRVUZSU3l4TFFVRm5RbElzUlVGQlVVY3NSVUZCVVVzc1NVRkRia05NTEVWQlFWRkxMRWxCUjFaU0lpd2labWxzWlNJNklpOXdjbWwyWVhSbEwzUnRjQzltYjI4dVIwOUZMM055WXk5cWN5OWlhVzVrYVc1bmN5OXFjWFZsY25sMWFTMXpjR2x1Ym1WeUxtcHpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyICQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeTpudWxsLGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKSx0YWJzPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmpRdWVyeS51aS50YWJzOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeS51aS50YWJzOm51bGw7aWYodm9pZCAwPT09dGFicyl0aHJvd1wiQ2Fubm90IGZpbmQganF1ZXJ5LXVpIHRhYnMgd2lkZ2V0IGRlcGVuZGVuY3khXCI7JC53aWRnZXQoXCJ1aS50YWJzXCIsdGFicyx7X2lzTG9jYWw6ZnVuY3Rpb24oZSl7cmV0dXJuXCJ0cnVlXCI9PWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1sb2NhbFwiKXx8dGhpcy5fc3VwZXJBcHBseShhcmd1bWVudHMpfX0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1weGRXVnllWFZwTFhSaFluTXVhbk1pWFN3aWJtRnRaWE1pT2xzaUpDSXNJbmRwYm1SdmR5SXNJbWRzYjJKaGJDSXNJbU52Ym5OdmJHVWlMQ0p5WlhGMWFYSmxJaXdpZEdGaWN5SXNJbmRwWkdkbGRDSXNJbDlwYzB4dlkyRnNJaXdpWVc1amFHOXlJaXdpWjJWMFFYUjBjbWxpZFhSbElpd2lkR2hwY3lJc0lsOXpkWEJsY2tGd2NHeDVJaXdpWVhKbmRXMWxiblJ6SWwwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4aFFVdEJMRWxCUVVsQkxFVkJRWFZDTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCWlN4UFFVRnpRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRV1VzVDBGQlNTeExRVU16UjBNc1VVRkJWVU1zVVVGQlVTeHpRa0ZEYkVKRExFdEJRVEJDTEc5Q1FVRllTaXhQUVVGNVFrRXNUMEZCWlN4UFFVRk5MRWRCUVZFc1MwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZsTEU5QlFVMHNSMEZCVVN4TFFVRkpMRXRCUlRsSkxGRkJRVzFDTEVsQlFWSkhMRXRCUVhGQ0xFdEJRVTBzWjBSQlJYUkRUQ3hGUVVGRlRTeFBRVUZQTEZWQlFWZEVMRXRCUVUwc1EwRkRlRUpGTEZOQlFWVXNVMEZCVlVNc1IwRkRiRUlzVFVGQmVVTXNVVUZCY2tOQkxFVkJRVTlETEdGQlFXRXNaVUZEV2tNc1MwRkJTME1zV1VGQllVTWlMQ0ptYVd4bElqb2lMM0J5YVhaaGRHVXZkRzF3TDJadmJ5NUhUMFV2YzNKakwycHpMMkpwYm1ScGJtZHpMMnB4ZFdWeWVYVnBMWFJoWW5NdWFuTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGw7a28uYmluZGluZ0hhbmRsZXJzLnByZWxvYWRlcj17aW5pdDpmdW5jdGlvbihlLG8pe3ZhciBkPW8oKTtpZih2b2lkIDA9PT1kLnByZWxvYWRlZCl7ZC5wcmVsb2FkZWQ9a28ub2JzZXJ2YWJsZShcIlwiKTt2YXIgbj1mdW5jdGlvbihlKXtpZihlIT1kLnByZWxvYWRlZCgpKWlmKFwiXCIhPT1lKXt2YXIgbz1uZXcgSW1hZ2U7by5vbmxvYWQ9ZnVuY3Rpb24oKXtkLnByZWxvYWRlZChlKX0sby5vbmVycm9yPWZ1bmN0aW9uKCl7ZC5wcmVsb2FkZWQoZSl9LG8uc3JjPWV9ZWxzZSBkLnByZWxvYWRlZChlKX07ZC5zdWJzY3JpYmUobiksbihkKCkpfX19O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5CeVpXeHZZV1JsY2k1cWN5SmRMQ0p1WVcxbGN5STZXeUpyYnlJc0luZHBibVJ2ZHlJc0ltZHNiMkpoYkNJc0ltSnBibVJwYm1kSVlXNWtiR1Z5Y3lJc0ltbHVhWFFpTENKbGJHVnRaVzUwSWl3aWRtRnNkV1ZCWTJObGMzTnZjaUlzSW5aaGJIVmxJaXdpY0hKbGJHOWhaR1ZrSWl3aWIySnpaWEoyWVdKc1pTSXNJbkJ5Wld4dllXUmxjaUlzSW01bGQxWmhiSFZsSWl3aWFXMW5JaXdpU1cxaFoyVWlMQ0p2Ym14dllXUWlMQ0p2Ym1WeWNtOXlJaXdpYzNKaklpd2ljM1ZpYzJOeWFXSmxJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3hoUVVkQkxFbEJRVWxCTEVkQlFYZENMRzlDUVVGWVF5eFBRVUY1UWtFc1QwRkJWeXhIUVVGelFpeHZRa0ZCV0VNc1QwRkJlVUpCTEU5QlFWY3NSMEZCU1N4TFFVZDRSMFlzUjBGQlIwY3NaMEpCUVRKQ0xGVkJRVWtzUTBGRGFFTkRMRXRCUVUwc1UwRkJVME1zUlVGQlUwTXNSMEZEZEVJc1NVRkJTVU1zUlVGQlVVUXNTVUZEV2l4UlFVRTRRaXhKUVVGdVFrTXNSVUZCVFVNc1ZVRkJNRUlzUTBGRGVrTkVMRVZCUVUxRExGVkJRVmxTTEVkQlFVZFRMRmRCUVZjc1NVRkZhRU1zU1VGQlNVTXNSVUZCV1N4VFFVRlRReXhIUVVOMlFpeEhRVUZKUVN4SFFVRlpTaXhGUVVGTlF5eFpRVU53UWl4SFFVRnBRaXhMUVVGaVJ5eEZRVUZwUWl4RFFVTnVRaXhKUVVGSlF5eEZRVUZOTEVsQlFVbERMRTFCUTJSRUxFVkJRVWxGTEU5QlFWTXNWMEZEV0ZBc1JVRkJUVU1zVlVGQlZVY3NTVUZGYkVKRExFVkJRVWxITEZGQlFWVXNWMEZEV2xJc1JVRkJUVU1zVlVGQlZVY3NTVUZGYkVKRExFVkJRVWxKTEVsQlFVMU1MRTlCUlZaS0xFVkJRVTFETEZWQlFWVkhMRWxCUzNSQ1NpeEZRVUZOVlN4VlFVRlZVQ3hIUVVOb1FrRXNSVUZCVlVnaUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwySnBibVJwYm1kekwzQnlaV3h2WVdSbGNpNXFjeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcHVzaFRlbXBsYXRlKGUsdCl7dmFyIG49Z2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7bi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJ0ZXh0L2h0bWxcIiksbi5zZXRBdHRyaWJ1dGUoXCJpZFwiLGUpLG4udGV4dD10LGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG4pfWZ1bmN0aW9uIHJlbW92ZVRlbXBsYXRlKGUpe3ZhciB0PWdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTt0JiZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCl9ZnVuY3Rpb24gaW5pdCgpe31mdW5jdGlvbiBnZXRUZW1wbGF0ZUNvbnRlbnQoZSl7dmFyIHQ9Z2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpO3JldHVybiB0P3QuaW5uZXJIVE1MOnZvaWQgMH1tb2R1bGUuZXhwb3J0cz17aW5pdDppbml0LGFkZFRlbXBsYXRlOnB1c2hUZW1wbGF0ZSxyZW1vdmVUZW1wbGF0ZTpyZW1vdmVUZW1wbGF0ZSxnZXRUZW1wbGF0ZUNvbnRlbnQ6Z2V0VGVtcGxhdGVDb250ZW50fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTmpjbWx3ZEMxMFpXMXdiR0YwWlM1cWN5SmRMQ0p1WVcxbGN5STZXeUp3ZFhOb1ZHVnRjR3hoZEdVaUxDSjBaVzF3YkdGMFpVNWhiV1VpTENKMFpXMXdiR0YwWlZSbGVIUWlMQ0p6WTNKcGNIUlVZV2NpTENKbmJHOWlZV3dpTENKa2IyTjFiV1Z1ZENJc0ltTnlaV0YwWlVWc1pXMWxiblFpTENKelpYUkJkSFJ5YVdKMWRHVWlMQ0owWlhoMElpd2lZbTlrZVNJc0ltRndjR1Z1WkVOb2FXeGtJaXdpY21WdGIzWmxWR1Z0Y0d4aGRHVWlMQ0psYkNJc0ltZGxkRVZzWlcxbGJuUkNlVWxrSWl3aWNHRnlaVzUwVG05a1pTSXNJbkpsYlc5MlpVTm9hV3hrSWl3aWFXNXBkQ0lzSW1kbGRGUmxiWEJzWVhSbFEyOXVkR1Z1ZENJc0ltbGtJaXdpYVc1dVpYSklWRTFNSWl3aWJXOWtkV3hsSWl3aVpYaHdiM0owY3lJc0ltRmtaRlJsYlhCc1lYUmxJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3hoUVVkQkxGTkJRVk5CTEdGQlFXRkRMRVZCUVdORExFZEJRMnhETEVsQlFVbERMRVZCUVZsRExFOUJRVTlETEZOQlFWTkRMR05CUVdNc1ZVRkRPVU5JTEVWQlFWVkpMR0ZCUVdFc1QwRkJVU3hoUVVNdlFrb3NSVUZCVlVrc1lVRkJZU3hMUVVGTlRpeEhRVU0zUWtVc1JVRkJWVXNzUzBGQlQwNHNSVUZEYWtKRkxFOUJRVTlETEZOQlFWTkpMRXRCUVV0RExGbEJRVmxRTEVkQlIyNURMRk5CUVZOUkxHVkJRV1ZXTEVkQlEzUkNMRWxCUVVsWExFVkJRVXRTTEU5QlFVOURMRk5CUVZOUkxHVkJRV1ZhTEVkQlEzQkRWeXhIUVVGSlFTeEZRVUZIUlN4WFFVRlhReXhaUVVGWlNDeEhRVWR3UXl4VFFVRlRTU3hSUVVWVUxGTkJRVk5ETEcxQ1FVRnRRa01zUjBGRE1VSXNTVUZCU1U0c1JVRkJTMUlzVDBGQlQwTXNVMEZCVTFFc1pVRkJaVXNzUjBGRGVFTXNUMEZCU1U0c1JVRkJWMEVzUlVGQlIwOHNaVUZEWWl4RlFVZFFReXhQUVVGUFF5eFJRVUZWTEVOQlEyWk1MRXRCUVUxQkxFdEJRMDVOTEZsQlFXRjBRaXhoUVVOaVZ5eGxRVUZuUWtFc1pVRkRhRUpOTEcxQ1FVRnZRa0VpTENKbWFXeGxJam9pTDNCeWFYWmhkR1V2ZEcxd0wyWnZieTVIVDBVdmMzSmpMMnB6TDJKcGJtUnBibWR6TDNOamNtbHdkQzEwWlcxd2JHRjBaUzVxY3lKOSIsIlwidXNlIHN0cmljdFwiO3ZhciB0aW1lb3V0LGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGwsJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsY29uc29sZT1yZXF1aXJlKFwiY29uc29sZS1icm93c2VyaWZ5XCIpLHRpbnltY2U9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cudGlueW1jZTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC50aW55bWNlOm51bGwscmVuZGVyPWZ1bmN0aW9uKCl7aWYodGltZW91dD12b2lkIDAsdm9pZCAwIT09dGlueW1jZS5hY3RpdmVFZGl0b3ImJm51bGwhPT10aW55bWNlLmFjdGl2ZUVkaXRvciYmdm9pZCAwIT09dGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUmJm51bGwhPT10aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZSYmdm9pZCAwIT09dGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwmJm51bGwhPT10aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbCl7KHZvaWQgMCE9PXRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLl92aXNpYmxlJiZ0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5fdmlzaWJsZSYmdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuX2ZpeGVkfHx2b2lkIDAhPT10aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5zdGF0ZSYmdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuc3RhdGUuZ2V0KFwidmlzaWJsZVwiKSYmdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuc3RhdGUuZ2V0KFwiZml4ZWRcIikpJiZ0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5maXhlZCghMSk7dmFyIGU9dm9pZCAwIT09dGlueW1jZS5hY3RpdmVFZGl0b3IuYm9keUVsZW1lbnQ/dGlueW1jZS5hY3RpdmVFZGl0b3IuYm9keUVsZW1lbnQ6dGlueW1jZS5hY3RpdmVFZGl0b3IuZG9tLnNldHRpbmdzLnJvb3RfZWxlbWVudDtudWxsIT09ZSYmdm9pZCAwIT09ZS5jbGFzc0xpc3QmJmUuY2xhc3NMaXN0LmNvbnRhaW5zKFwibWNlLWVkaXQtZm9jdXNcIikmJih0aW55bWNlLmFjdGl2ZUVkaXRvci5ub2RlQ2hhbmdlZCgpLHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLnZpc2libGUoITApLHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLmxheW91dFJlY3QoKS55PD00MCYmdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwubW92ZUJ5KDAsNDAtdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwubGF5b3V0UmVjdCgpLnkpKX19O2tvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU2Nyb2xsZml4PXtzY3JvbGw6ZnVuY3Rpb24oZSl7dGltZW91dCYmZ2xvYmFsLmNsZWFyVGltZW91dCh0aW1lb3V0KSx0aW1lb3V0PWdsb2JhbC5zZXRUaW1lb3V0KHJlbmRlciw1MCl9LGluaXQ6ZnVuY3Rpb24oZSl7a28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlLGZ1bmN0aW9uKCl7JChlKS5vZmYoXCJzY3JvbGxcIixrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1Njcm9sbGZpeC5zY3JvbGwpfSksJChlKS5vbihcInNjcm9sbFwiLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU2Nyb2xsZml4LnNjcm9sbCl9fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTmpjbTlzYkdacGVDNXFjeUpkTENKdVlXMWxjeUk2V3lKMGFXMWxiM1YwSWl3aWEyOGlMQ0ozYVc1a2IzY2lMQ0puYkc5aVlXd2lMQ0lrSWl3aVkyOXVjMjlzWlNJc0luSmxjWFZwY21VaUxDSjBhVzU1YldObElpd2ljbVZ1WkdWeUlpd2lkVzVrWldacGJtVmtJaXdpWVdOMGFYWmxSV1JwZEc5eUlpd2lkR2hsYldVaUxDSndZVzVsYkNJc0lsOTJhWE5wWW14bElpd2lYMlpwZUdWa0lpd2ljM1JoZEdVaUxDSm5aWFFpTENKbWFYaGxaQ0lzSW1Wc1pXMWxiblFpTENKaWIyUjVSV3hsYldWdWRDSXNJbVJ2YlNJc0luTmxkSFJwYm1keklpd2ljbTl2ZEY5bGJHVnRaVzUwSWl3aVkyeGhjM05NYVhOMElpd2lZMjl1ZEdGcGJuTWlMQ0p1YjJSbFEyaGhibWRsWkNJc0luWnBjMmxpYkdVaUxDSnNZWGx2ZFhSU1pXTjBJaXdpZVNJc0ltMXZkbVZDZVNJc0ltSnBibVJwYm1kSVlXNWtiR1Z5Y3lJc0luZDVjMmwzZVdkVFkzSnZiR3htYVhnaUxDSnpZM0p2Ykd3aUxDSmxkbVZ1ZENJc0ltTnNaV0Z5VkdsdFpXOTFkQ0lzSW5ObGRGUnBiV1Z2ZFhRaUxDSnBibWwwSWl3aWRYUnBiSE1pTENKa2IyMU9iMlJsUkdsemNHOXpZV3dpTENKaFpHUkVhWE53YjNObFEyRnNiR0poWTJzaUxDSnZabVlpTENKdmJpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNZVUZIUVN4SlFVdEpRU3hSUVV4QlF5eEhRVUYzUWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVZjc1IwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZYTEVkQlFVa3NTMEZEY0VkRExFVkJRWFZDTEc5Q1FVRllSaXhQUVVGNVFrRXNUMEZCWlN4UFFVRnpRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRV1VzVDBGQlNTeExRVU16UjBVc1VVRkJWVU1zVVVGQlVTeHpRa0ZEYkVKRExGRkJRVFpDTEc5Q1FVRllUQ3hQUVVGNVFrRXNUMEZCWjBJc1VVRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZuUWl4UlFVRkpMRXRCWTI1SVN5eFBRVUZUTEZkQlIxZ3NSMEZHUVZJc1lVRkJWVk1zVDBGSGQwSXNTVUZCZWtKR0xGRkJRVkZITEdOQlExVXNUMEZCZWtKSUxGRkJRVkZITEcxQ1FVTTRRaXhKUVVFdlFrZ3NVVUZCVVVjc1lVRkJZVU1zVDBGRFJ5eFBRVUV2UWtvc1VVRkJVVWNzWVVGQllVTXNXVUZEZFVJc1NVRkJja05LTEZGQlFWRkhMR0ZCUVdGRExFMUJRVTFETEU5QlEwY3NUMEZCY2tOTUxGRkJRVkZITEdGQlFXRkRMRTFCUVUxRExFMUJRek5DTEU5QlMzZEVMRWxCUVRsRFRDeFJRVUZSUnl4aFFVRmhReXhOUVVGTlF5eE5RVUZOUXl4VlFVTjJRMDRzVVVGQlVVY3NZVUZCWVVNc1RVRkJUVU1zVFVGQlRVTXNWVUZEYWtOT0xGRkJRVkZITEdGQlFXRkRMRTFCUVUxRExFMUJRVTFGTEdGQlEyZENMRWxCUVRORFVDeFJRVUZSUnl4aFFVRmhReXhOUVVGTlF5eE5RVUZOUnl4UFFVTjJRMUlzVVVGQlVVY3NZVUZCWVVNc1RVRkJUVU1zVFVGQlRVY3NUVUZCVFVNc1NVRkJTU3haUVVNelExUXNVVUZCVVVjc1lVRkJZVU1zVFVGQlRVTXNUVUZCVFVjc1RVRkJUVU1zU1VGQlNTeFhRVVUzUTFRc1VVRkJVVWNzWVVGQllVTXNUVUZCVFVNc1RVRkJUVXNzVDBGQlRTeEhRVWQ2UXl4SlFVRkpReXhQUVVNd1F5eEpRVUZ5UTFnc1VVRkJVVWNzWVVGQllWTXNXVUZEZUVKYUxGRkJRVkZITEdGQlFXRlRMRmxCUTNKQ1dpeFJRVUZSUnl4aFFVRmhWU3hKUVVGSlF5eFRRVUZUUXl4aFFVVXhRaXhQUVVGYVNpeFJRVU0yUWl4SlFVRjBRa0VzUlVGQlVVc3NWMEZEWmt3c1JVRkJVVXNzVlVGQlZVTXNVMEZCVXl4dlFrRkZNMEpxUWl4UlFVRlJSeXhoUVVGaFpTeGpRVU55UW14Q0xGRkJRVkZITEdGQlFXRkRMRTFCUVUxRExFMUJRVTFqTEZOQlFWRXNSMEZEY2tOdVFpeFJRVUZSUnl4aFFVRmhReXhOUVVGTlF5eE5RVUZOWlN4aFFVRmhReXhIUVVGTExFbEJRM0pFY2tJc1VVRkJVVWNzWVVGQllVTXNUVUZCVFVNc1RVRkJUV2xDTEU5QlF5OUNMRVZCUTBFc1IwRkJTM1JDTEZGQlFWRkhMR0ZCUVdGRExFMUJRVTFETEUxQlFVMWxMR0ZCUVdGRExFMUJUVGRFTTBJc1IwRkJSelpDTEdkQ1FVRm5Ra01zYVVKQlFXMUNMRU5CUTNCRFF5eFBRVUZSTEZOQlFWTkRMRWRCUTFocVF5eFRRVUZUUnl4UFFVRlBLMElzWVVGQllXeERMRk5CUTJwRFFTeFJRVUZWUnl4UFFVRlBaME1zVjBGQlZ6TkNMRTlCUVZFc1MwRkZkRU0wUWl4TFFVRk5MRk5CUVZOc1FpeEhRVU5pYWtJc1IwRkJSMjlETEUxQlFVMURMR2RDUVVGblFrTXNiVUpCUVcxQ2NrSXNSVUZCVXl4WFFVTnVSR1FzUlVGQlJXTXNSMEZCVTNOQ0xFbEJRVWtzVTBGQlZYWkRMRWRCUVVjMlFpeG5Ra0ZCWjBKRExHbENRVUZwUWtNc1ZVRkhMMFExUWl4RlFVRkZZeXhIUVVGVGRVSXNSMEZCUnl4VFFVRlZlRU1zUjBGQlJ6WkNMR2RDUVVGblFrTXNhVUpCUVdsQ1F5SXNJbVpwYkdVaU9pSXZjSEpwZG1GMFpTOTBiWEF2Wm05dkxrZFBSUzl6Y21NdmFuTXZZbWx1WkdsdVozTXZjMk55YjJ4c1ptbDRMbXB6SW4wPSIsIlwidXNlIHN0cmljdFwiO3ZhciAkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmpRdWVyeTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5qUXVlcnk6bnVsbCxrbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5rbzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rbzpudWxsLGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKSxfc2Nyb2xsSW50b1ZpZXc9ZnVuY3Rpb24obyxlLGwsbil7dmFyIGk9bC5zY3JvbGxUb3AoKSx0PWktbi0oZT8yMDotMjApO2lmKHZvaWQgMCE9PWxbMF0ubm9kZVR5cGUpe3ZhciByPXtzY3JvbGxUb3A6TWF0aC5yb3VuZCh0KStcInB4XCJ9LHM9TWF0aC5yb3VuZChNYXRoLmFicyh0LWkpKTtsLnN0b3AoKS5hbmltYXRlKHIscyl9ZWxzZSBsLnNjcm9sbFRvcCh0KX07a28uYmluZGluZ0hhbmRsZXJzLnNjcm9sbEludG9WaWV3PXt1cGRhdGU6ZnVuY3Rpb24obyxlLGwsbixpKXtpZihrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGUoKSkpdHJ5e2Zvcig7OD09PW8ubm9kZVR5cGU7KW89by5uZXh0U2libGluZztpZig4IT09by5ub2RlVHlwZSl7dmFyIHQscj0kKG8pLnNjcm9sbFBhcmVudCgpLHM9ITE7OT09clswXS5ub2RlVHlwZT8ocj0kKHJbMF0uZGVmYXVsdFZpZXcpLHQ9MCxzPSEwKTp0PXIub2Zmc2V0KCkudG9wO3ZhciBhPXIuaGVpZ2h0KCksZD1yLnNjcm9sbFRvcCgpLGM9dCthLGY9JChvKSx3PWYub2Zmc2V0KCkudG9wO3MmJih3LT1kKTt2YXIgcD1mLmhlaWdodCgpLHU9dytwO3c+dCYmdytwPGN8fChwPGE/KHc8dCYmX3Njcm9sbEludG9WaWV3KG8sITAscix0LXcpLHU+YyYmX3Njcm9sbEludG9WaWV3KG8sITEscixjLXUpKToodzx0JiZ1PGMmJl9zY3JvbGxJbnRvVmlldyhvLCExLHIsYy11KSx3PnQmJnU+YyYmX3Njcm9sbEludG9WaWV3KG8sITAscix0LXcpKSl9fWNhdGNoKG8pe2NvbnNvbGUubG9nKFwiVE9ETyBleGNlcHRpb24gc2Nyb2xsaW5nIGludG8gdmlld1wiLG8pfX19LGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3Muc2Nyb2xsSW50b1ZpZXc9ITA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk5qY205c2JHbHVkRzkyYVdWM0xtcHpJbDBzSW01aGJXVnpJanBiSWlRaUxDSjNhVzVrYjNjaUxDSm5iRzlpWVd3aUxDSnJieUlzSW1OdmJuTnZiR1VpTENKeVpYRjFhWEpsSWl3aVgzTmpjbTlzYkVsdWRHOVdhV1YzSWl3aUpHVnNaVzFsYm5RaUxDSmhiR2xuYmxSdmNDSXNJbk5qY205c2JGQmhjbVZ1ZENJc0ltMXZkbVZDZVNJc0ltTjFjbkpsYm5SVFkzSnZiR3hVYjNBaUxDSnpZM0p2Ykd4VWIzQWlMQ0p1WlhkVFkzSnZiR3hVYjNBaUxDSnViMlJsVkhsd1pTSXNJbUZqZEdsdmJpSXNJazFoZEdnaUxDSnliM1Z1WkNJc0luUnBiV1VpTENKaFluTWlMQ0p6ZEc5d0lpd2lZVzVwYldGMFpTSXNJbUpwYm1ScGJtZElZVzVrYkdWeWN5SXNJbk5qY205c2JFbHVkRzlXYVdWM0lpd2lkWEJrWVhSbElpd2laV3hsYldWdWRDSXNJblpoYkhWbFFXTmpaWE56YjNJaUxDSmhiR3hDYVc1a2FXNW5jMEZqWTJWemMyOXlJaXdpZG1sbGQwMXZaR1ZzSWl3aVltbHVaR2x1WjBOdmJuUmxlSFFpTENKMWRHbHNjeUlzSW5WdWQzSmhjRTlpYzJWeWRtRmliR1VpTENKdVpYaDBVMmxpYkdsdVp5SXNJbkJoY21WdWRGUnZjQ0lzSW5KbGJHRjBhWFpsVDJabWMyVjBJaXdpWkdWbVlYVnNkRlpwWlhjaUxDSnZabVp6WlhRaUxDSjBiM0FpTENKd1lYSmxiblJJWldsbmFIUWlMQ0pvWldsbmFIUWlMQ0p3WVhKbGJuUlRZM0p2Ykd3aUxDSndZWEpsYm5SQ2IzUjBiMjBpTENKbGJGUnZjQ0lzSW1Wc1NHVnBaMmgwSWl3aVpXeENiM1IwYjIwaUxDSmxJaXdpYkc5bklpd2lkbWx5ZEhWaGJFVnNaVzFsYm5Seklpd2lZV3hzYjNkbFpFSnBibVJwYm1keklsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeGhRVVZCTEVsQlFVbEJMRVZCUVhWQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlpTeFBRVUZ6UWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVdVc1QwRkJTU3hMUVVNelIwTXNSMEZCZDBJc2IwSkJRVmhHTEU5QlFYbENRU3hQUVVGWExFZEJRWE5DTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCVnl4SFFVRkpMRXRCUTNCSFJTeFJRVUZWUXl4UlFVRlJMSE5DUVVWc1FrTXNaMEpCUVd0Q0xGTkJRVk5ETEVWQlFWVkRMRVZCUVZWRExFVkJRV05ETEVkQlF5OUVMRWxCUVVsRExFVkJRVzFDUml4RlFVRmhSeXhaUVVOb1EwTXNSVUZCWlVZc1JVRkJiVUpFTEVkQlFWVkdMRVZCUVZjc1NVRkJUU3hKUVVkcVJTeFJRVVJyUkN4SlFVRTNRa01zUlVGQllTeEhRVUZIU3l4VFFVTjRRaXhEUVVOWUxFbEJRVWxETEVWQlFWTXNRMEZEV0Vnc1ZVRkJhMEpKTEV0QlFVdERMRTFCUVUxS0xFZEJRV2RDTEUxQlJUTkRTeXhGUVVGUFJpeExRVUZMUXl4TlFVRk5SQ3hMUVVGTFJ5eEpRVUZKVGl4RlFVRmxSaXhKUVVNNVEwWXNSVUZCWVZjc1QwRkJUME1zVVVGQlVVNHNSVUZCVVVjc1VVRkZjRU5VTEVWQlFXRkhMRlZCUVZWRExFbEJUVE5DVml4SFFVRkhiVUlzWjBKQlFXZENReXhsUVVGcFFpeERRVU5zUTBNc1QwRkJVU3hUUVVGVFF5eEZRVUZUUXl4RlFVRmxReXhGUVVGeFFrTXNSVUZCVjBNc1IwRkZka1VzUjBGRVpURkNMRWRCUVVjeVFpeE5RVUZOUXl4cFFrRkJhVUpNTEV0QlJYcERMRWxCUlVVc1MwRkJORUlzU1VGQmNrSkVMRVZCUVZGWUxGVkJSV0pYTEVWQlFWVkJMRVZCUVZGUExGbEJSWEJDTEVkQlFYbENMRWxCUVhKQ1VDeEZRVUZSV0N4VFFVRm5RaXhEUVVNeFFpeEpRVVZKYlVJc1JVRkdRWGhDTEVWQlFXVlVMRVZCUVVWNVFpeEhRVUZUYUVJc1pVRkhNVUo1UWl4SFFVRnBRaXhGUVVOWExFZEJRVFZDZWtJc1JVRkJZU3hIUVVGSFN5eFZRVVZzUWt3c1JVRkJaVlFzUlVGQlJWTXNSVUZCWVN4SFFVRkhNRUlzWVVGRGFrTkdMRVZCUVZrc1JVRkRXa01zUjBGQmFVSXNSMEZGYWtKRUxFVkJRVmw0UWl4RlFVRmhNa0lzVTBGQlUwTXNTVUZIY0VNc1NVRkJTVU1zUlVGQlpUZENMRVZCUVdFNFFpeFRRVU0xUWtNc1JVRkJaUzlDTEVWQlFXRkhMRmxCUXpWQ05rSXNSVUZCWlZJc1JVRkJXVXNzUlVGSE0wSXZRaXhGUVVGWFVDeEZRVUZGZVVJc1IwRkRZbWxDTEVWQlFWRnVReXhGUVVGVE5rSXNVMEZCVTBNc1NVRkZNVUpJTEVsQlFXZENVU3hIUVVGblFrWXNSMEZEY0VNc1NVRkJTVWNzUlVGQlYzQkRMRVZCUVZOblF5eFRRVU53UWtzc1JVRkJWMFlzUlVGQlVVTXNSVUZEYmtKRUxFVkJRVkZVTEVkQlFXRlRMRVZCUVZGRExFVkJRVmRHTEVsQlJXcERSU3hGUVVGWFRDeEhRVVZvUWtrc1JVRkJVVlFzUjBGQlZ6TkNMR2RDUVVGblFtMUNMRWRCUVZNc1JVRkJUV2hDTEVWQlFXTjNRaXhGUVVGWlV5eEhRVVUxUlVVc1JVRkJWMGdzUjBGQlkyNURMR2RDUVVGblFtMUNMRWRCUVZNc1JVRkJUMmhDTEVWQlFXTm5ReXhGUVVGbFJ5eExRVXQwUmtZc1JVRkJVVlFzUjBGQllWY3NSVUZCVjBnc1IwRkJZMjVETEdkQ1FVRm5RbTFDTEVkQlFWTXNSVUZCVDJoQ0xFVkJRV05uUXl4RlFVRmxSeXhIUVVVelIwWXNSVUZCVVZRc1IwRkJZVmNzUlVGQlYwZ3NSMEZCWTI1RExHZENRVUZuUW0xQ0xFZEJRVk1zUlVGQlRXaENMRVZCUVdOM1FpeEZRVUZaVXl4TlFVc3ZSeXhOUVVGUFJ5eEhRVU5RZWtNc1VVRkJVVEJETEVsQlFVa3NjVU5CUVhORFJDeE5RVWw0UkRGRExFZEJRVWMwUXl4blFrRkJaMEpETEdkQ1FVRm5ReXhuUWtGQlNTSXNJbVpwYkdVaU9pSXZjSEpwZG1GMFpTOTBiWEF2Wm05dkxrZFBSUzl6Y21NdmFuTXZZbWx1WkdsdVozTXZjMk55YjJ4c2FXNTBiM1pwWlhjdWFuTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGwsb3JpZ1RlbXBsYXRlU3lzdGVtPXJlcXVpcmUoXCIuL3NjcmlwdC10ZW1wbGF0ZS5qc1wiKSx0ZW1wbGF0ZXM9e307ZnVuY3Rpb24gY3JlYXRlU3RyaW5nVGVtcGxhdGVFbmdpbmUoZSl7dmFyIHQ9ZS5tYWtlVGVtcGxhdGVTb3VyY2U7cmV0dXJuIGUubWFrZVRlbXBsYXRlU291cmNlPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT10ZW1wbGF0ZXNbZV0/bmV3IGtvLnRlbXBsYXRlU291cmNlcy5zdHJpbmdUZW1wbGF0ZShlLHRlbXBsYXRlc1tlXSk6dChlKX0sZX1mdW5jdGlvbiBwdXNoVGVtcGxhdGUoZSx0KXt0ZW1wbGF0ZXNbZV09dH1mdW5jdGlvbiByZW1vdmVUZW1wbGF0ZShlKXt2b2lkIDAhPT10ZW1wbGF0ZXNbZV0/dGVtcGxhdGVzW2VdPXZvaWQgMDpvcmlnVGVtcGxhdGVTeXN0ZW0ucmVtb3ZlVGVtcGxhdGUoZSl9ZnVuY3Rpb24gaW5pdCgpe2tvLnNldFRlbXBsYXRlRW5naW5lKGNyZWF0ZVN0cmluZ1RlbXBsYXRlRW5naW5lKG5ldyBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSkpfWZ1bmN0aW9uIGdldFRlbXBsYXRlQ29udGVudChlKXtyZXR1cm4gdm9pZCAwIT09dGVtcGxhdGVzW2VdP3RlbXBsYXRlc1tlXTpvcmlnVGVtcGxhdGVTeXN0ZW0uZ2V0VGVtcGxhdGVDb250ZW50KGUpfWtvLnRlbXBsYXRlU291cmNlcy5zdHJpbmdUZW1wbGF0ZT1mdW5jdGlvbihlLHQpe3RoaXMudGVtcGxhdGVOYW1lPWUsdGhpcy50ZW1wbGF0ZT10LHRoaXMuX2RhdGE9e319LGtvLnV0aWxzLmV4dGVuZChrby50ZW1wbGF0ZVNvdXJjZXMuc3RyaW5nVGVtcGxhdGUucHJvdG90eXBlLHtkYXRhOmZ1bmN0aW9uKGUsdCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2RhdGFbZV07dGhpcy5fZGF0YVtlXT10fSx0ZXh0OmZ1bmN0aW9uKGUpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnRlbXBsYXRlO3RoaXMudGVtcGxhdGU9ZX19KSxtb2R1bGUuZXhwb3J0cz17aW5pdDppbml0LGFkZFRlbXBsYXRlOnB1c2hUZW1wbGF0ZSxyZW1vdmVUZW1wbGF0ZTpyZW1vdmVUZW1wbGF0ZSxnZXRUZW1wbGF0ZUNvbnRlbnQ6Z2V0VGVtcGxhdGVDb250ZW50fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTjBjbWx1WnkxMFpXMXdiR0YwWlM1cWN5SmRMQ0p1WVcxbGN5STZXeUpyYnlJc0luZHBibVJ2ZHlJc0ltZHNiMkpoYkNJc0ltOXlhV2RVWlcxd2JHRjBaVk41YzNSbGJTSXNJbkpsY1hWcGNtVWlMQ0owWlcxd2JHRjBaWE1pTENKamNtVmhkR1ZUZEhKcGJtZFVaVzF3YkdGMFpVVnVaMmx1WlNJc0luUmxiWEJzWVhSbFJXNW5hVzVsSWl3aWIzSnBaeUlzSW0xaGEyVlVaVzF3YkdGMFpWTnZkWEpqWlNJc0luUmxiWEJzWVhSbFRtRnRaU0lzSW5SbGJYQnNZWFJsVTI5MWNtTmxjeUlzSW5OMGNtbHVaMVJsYlhCc1lYUmxJaXdpY0hWemFGUmxiWEJzWVhSbElpd2lkR1Z0Y0d4aGRHVlVaWGgwSWl3aWNtVnRiM1psVkdWdGNHeGhkR1VpTENKMWJtUmxabWx1WldRaUxDSnBibWwwSWl3aWMyVjBWR1Z0Y0d4aGRHVkZibWRwYm1VaUxDSnVZWFJwZG1WVVpXMXdiR0YwWlVWdVoybHVaU0lzSW1kbGRGUmxiWEJzWVhSbFEyOXVkR1Z1ZENJc0ltbGtJaXdpZEdWdGNHeGhkR1VpTENKMGFHbHpJaXdpWDJSaGRHRWlMQ0oxZEdsc2N5SXNJbVY0ZEdWdVpDSXNJbkJ5YjNSdmRIbHdaU0lzSW1SaGRHRWlMQ0pyWlhraUxDSjJZV3gxWlNJc0ltRnlaM1Z0Wlc1MGN5SXNJbXhsYm1kMGFDSXNJblJsZUhRaUxDSnRiMlIxYkdVaUxDSmxlSEJ2Y25Seklpd2lZV1JrVkdWdGNHeGhkR1VpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEdGQlJVRXNTVUZCU1VFc1IwRkJkMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZYTEVkQlFYTkNMRzlDUVVGWVF5eFBRVUY1UWtFc1QwRkJWeXhIUVVGSkxFdEJRM0JIUXl4dFFrRkJjVUpETEZGQlFWRXNkMEpCUlRkQ1F5eFZRVUZaTEVkQk5rSm9RaXhUUVVGVFF5d3lRa0ZCTWtKRExFZEJRMnhETEVsQlFVbERMRVZCUVU5RUxFVkJRV1ZGTEcxQ1FWRXhRaXhQUVZCQlJpeEZRVUZsUlN4dFFrRkJjVUlzVTBGQlUwTXNSMEZETTBNc1dVRkJkVU1zU1VGQk5VSk1MRlZCUVZWTExFZEJRMW9zU1VGQlNWWXNSMEZCUjFjc1owSkJRV2RDUXl4bFFVRmxSaXhGUVVGalRDeFZRVUZWU3l4SlFVVTVSRVlzUlVGQlMwVXNTVUZIVkVnc1JVRkhWQ3hUUVVGVFRTeGhRVUZoU0N4RlFVRmpTU3hIUVVOc1ExUXNWVUZCVlVzc1IwRkJaMEpKTEVWQlJ6VkNMRk5CUVZORExHVkJRV1ZNTEZGQlEybENMRWxCUVRWQ1RDeFZRVUZWU3l4SFFVTnVRa3dzVlVGQlZVc3NVVUZCWjBKTkxFVkJSVEZDWWl4dFFrRkJiVUpaTEdWQlFXVk1MRWRCU1hSRExGTkJRVk5QTEU5QlExQnFRaXhIUVVGSGEwSXNhMEpCUVd0Q1dpd3lRa0ZCTWtJc1NVRkJTVTRzUjBGQlIyMUNMSFZDUVVkNlJDeFRRVUZUUXl4dFFrRkJiVUpETEVkQlF6RkNMRmxCUVRaQ0xFbEJRV3hDYUVJc1ZVRkJWV2RDTEVkQlExcG9RaXhWUVVGVlowSXNSMEZGVm14Q0xHMUNRVUZ0UW1sQ0xHMUNRVUZ0UWtNc1IwRXhSR3BFY2tJc1IwRkJSMWNzWjBKQlFXZENReXhsUVVGcFFpeFRRVUZUUml4RlFVRmpXU3hIUVVONlJFTXNTMEZCUzJJc1lVRkJaVUVzUlVGRGNFSmhMRXRCUVV0RUxGTkJRVmRCTEVWQlEyaENReXhMUVVGTFF5eE5RVUZSTEVsQlIyWjRRaXhIUVVGSGVVSXNUVUZCVFVNc1QwRkJUekZDTEVkQlFVZFhMR2RDUVVGblFrTXNaVUZCWldVc1ZVRkJWeXhEUVVNelJFTXNTMEZCVFN4VFFVRlRReXhGUVVGTFF5eEhRVVZzUWl4SFFVRjVRaXhKUVVGeVFrTXNWVUZCVlVNc1QwRkRXaXhQUVVGUFZDeExRVUZMUXl4TlFVRk5TeXhIUVVkd1FrNHNTMEZCUzBNc1RVRkJUVXNzUjBGQlQwTXNSMEZGY0VKSExFdEJRVTBzVTBGQlUwZ3NSMEZGWWl4SFFVRjVRaXhKUVVGeVFrTXNWVUZCVlVNc1QwRkRXaXhQUVVGUFZDeExRVUZMUkN4VFFVVmtReXhMUVVGTFJDeFRRVUZYVVN4TFFUQkRjRUpKTEU5QlFVOURMRkZCUVZVc1EwRkRabXhDTEV0QlFVMUJMRXRCUTA1dFFpeFpRVUZoZGtJc1lVRkRZa1VzWlVGQlowSkJMR1ZCUTJoQ1N5eHRRa0ZCYjBKQklpd2labWxzWlNJNklpOXdjbWwyWVhSbEwzUnRjQzltYjI4dVIwOUZMM055WXk5cWN5OWlhVzVrYVc1bmN5OXpkSEpwYm1jdGRHVnRjR3hoZEdVdWFuTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGtvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvOm51bGwsJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsa29qcXVpPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmtvanF1aTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rb2pxdWk6bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIiksZXh0ZW5kVmFsdWVBY2Nlc3Nvcj1mdW5jdGlvbihvLG4pe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBrby51dGlscy5leHRlbmQobixvKCkpLG59fSxvcHRpb25zPXtzaG93OntkZWxheTo1MDB9LHRyYWNrOiEwLGl0ZW1zOidbdGl0bGVdW3RpdGxlIT1cIlwiXVt0aXRsZSE9XCIgXCJdJ307a28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXBzPXtpbml0OmZ1bmN0aW9uKG8sbixpLGUsdCl7aWYodm9pZCAwIT09JC5mbi50b29sdGlwJiZ2b2lkIDAhPT1rby5iaW5kaW5nSGFuZGxlcnMudG9vbHRpcClyZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXAuaW5pdChvLGV4dGVuZFZhbHVlQWNjZXNzb3IobixvcHRpb25zKSxpLGUsdCl9LHVwZGF0ZTpmdW5jdGlvbihvLG4saSxlLHQpe2lmKHZvaWQgMCE9PSQuZm4udG9vbHRpcCYmdm9pZCAwIT09a28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXApcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy50b29sdGlwLnVwZGF0ZShvLGV4dGVuZFZhbHVlQWNjZXNzb3IobixvcHRpb25zKSxpLGUsdCl9fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluUnZiMngwYVhCekxtcHpJbDBzSW01aGJXVnpJanBiSW10dklpd2lkMmx1Wkc5M0lpd2laMnh2WW1Gc0lpd2lKQ0lzSW10dmFuRjFhU0lzSW1OdmJuTnZiR1VpTENKeVpYRjFhWEpsSWl3aVpYaDBaVzVrVm1Gc2RXVkJZMk5sYzNOdmNpSXNJblpoYkhWbFFXTmpaWE56YjNJaUxDSnZZbW9pTENKMWRHbHNjeUlzSW1WNGRHVnVaQ0lzSW05d2RHbHZibk1pTENKemFHOTNJaXdpWkdWc1lYa2lMQ0owY21GamF5SXNJbWwwWlcxeklpd2lZbWx1WkdsdVowaGhibVJzWlhKeklpd2lkRzl2YkhScGNITWlMQ0pwYm1sMElpd2laV3hsYldWdWRDSXNJbUZzYkVKcGJtUnBibWR6UVdOalpYTnpiM0lpTENKa1lYUmhJaXdpWTI5dWRHVjRkQ0lzSW1adUlpd2lkRzl2YkhScGNDSXNJblZ3WkdGMFpTSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNZVUZGUVN4SlFVRkpRU3hIUVVGM1FpeHZRa0ZCV0VNc1QwRkJlVUpCTEU5QlFWY3NSMEZCYzBJc2IwSkJRVmhETEU5QlFYbENRU3hQUVVGWExFZEJRVWtzUzBGRGNFZERMRVZCUVhWQ0xHOUNRVUZZUml4UFFVRjVRa0VzVDBGQlpTeFBRVUZ6UWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVdVc1QwRkJTU3hMUVVNelIwVXNUMEZCTkVJc2IwSkJRVmhJTEU5QlFYbENRU3hQUVVGbExFOUJRWE5DTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCWlN4UFFVRkpMRXRCUTJoSVJ5eFJRVUZWUXl4UlFVRlJMSE5DUVVWc1FrTXNiMEpCUVhOQ0xGTkJRVk5ETEVWQlFXVkRMRWRCUTJoRUxFOUJRVThzVjBGRlRDeFBRVVJCVkN4SFFVRkhWU3hOUVVGTlF5eFBRVUZQUml4RlFVRkxSQ3hMUVVOa1F5eEpRVWxRUnl4UlFVRlZMRU5CUTFwRExFdEJRVTBzUTBGRFNrTXNUVUZCVHl4TFFVVlVReXhQUVVGUExFVkJRMUJETEUxQlFVOHNhME5CUjFSb1FpeEhRVUZIYVVJc1owSkJRV2RDUXl4VFFVRlhMRU5CUXpWQ1F5eExRVUZOTEZOQlFWTkRMRVZCUVZOYUxFVkJRV1ZoTEVWQlFYRkNReXhGUVVGTlF5eEhRVU5vUlN4UlFVRTBRaXhKUVVGcVFuQkNMRVZCUVVWeFFpeEhRVUZIUXl4alFVRnBSU3hKUVVFdlFucENMRWRCUVVkcFFpeG5Ra0ZCWjBKUkxGRkJSMjVGTEU5QlFVOTZRaXhIUVVGSGFVSXNaMEpCUVdkQ1VTeFJRVUZSVGl4TFFVRkxReXhGUVVGVFlpeHZRa0ZCYjBKRExFVkJRV1ZKTEZOQlFWVlRMRVZCUVhGQ1F5eEZRVUZOUXl4SlFVYzFTRWNzVDBGQlVTeFRRVUZUVGl4RlFVRlRXaXhGUVVGbFlTeEZRVUZ4UWtNc1JVRkJUVU1zUjBGRGJFVXNVVUZCTkVJc1NVRkJha0p3UWl4RlFVRkZjVUlzUjBGQlIwTXNZMEZCYVVVc1NVRkJMMEo2UWl4SFFVRkhhVUlzWjBKQlFXZENVU3hSUVVOdVJTeFBRVUZQZWtJc1IwRkJSMmxDTEdkQ1FVRm5RbEVzVVVGQlVVTXNUMEZCVDA0c1JVRkJVMklzYjBKQlFXOUNReXhGUVVGbFNTeFRRVUZWVXl4RlFVRnhRa01zUlVGQlRVTWlMQ0ptYVd4bElqb2lMM0J5YVhaaGRHVXZkRzF3TDJadmJ5NUhUMFV2YzNKakwycHpMMkpwYm1ScGJtZHpMM1J2YjJ4MGFYQnpMbXB6SW4wPSIsIlwidXNlIHN0cmljdFwiO3ZhciBrbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5rbzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rbzpudWxsLGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKTtrby5iaW5kaW5nSGFuZGxlcnMudmFsaWRhdGVkVmFsdWU9e2luaXQ6ZnVuY3Rpb24oZSxuLGkpe3ZhciBvPW47aWYodm9pZCAwIT09ZS5wYXR0ZXJuKXt2YXIgdD1uZXcgUmVnRXhwKFwiXig/OlwiK2UucGF0dGVybitcIikkXCIpLGE9a28uY29tcHV0ZWQoe3JlYWQ6ZnVuY3Rpb24oKXt2YXIgaT1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKG4oKSk7cmV0dXJuIG51bGw9PT1pfHxcIlwiPT09aXx8dC50ZXN0KGkpP2UuY2xhc3NMaXN0LnJlbW92ZShcImludmFsaWRcIik6ZS5jbGFzc0xpc3QuYWRkKFwiaW52YWxpZFwiKSxpfSx3cml0ZTprby5pc1dyaXRlYWJsZU9ic2VydmFibGUobigpKSYmZnVuY3Rpb24oaSl7a28uc2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlKGUsaSk7dmFyIG89a28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZSk7bigpKG8pfSxkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6ZX0pO289ZnVuY3Rpb24oKXtyZXR1cm4gYX19a28uYmluZGluZ0hhbmRsZXJzLnZhbHVlLmluaXQoZSxvLGkpfX0sa28uZXhwcmVzc2lvblJld3JpdGluZy5fdHdvV2F5QmluZGluZ3MudmFsaWRhdGVkVmFsdWU9ITA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJblpoYkdsa1lYUmxaQzEyWVd4MVpTNXFjeUpkTENKdVlXMWxjeUk2V3lKcmJ5SXNJbmRwYm1SdmR5SXNJbWRzYjJKaGJDSXNJbU52Ym5OdmJHVWlMQ0p5WlhGMWFYSmxJaXdpWW1sdVpHbHVaMGhoYm1Sc1pYSnpJaXdpYVc1cGRDSXNJbVZzWlcxbGJuUWlMQ0oyWVd4MVpVRmpZMlZ6YzI5eUlpd2lZV3hzUW1sdVpHbHVaM01pTENKdVpYZFdZV3gxWlVGalkyVnpjMjl5SWl3aWNHRjBkR1Z5YmlJc0luSmxJaXdpVW1WblJYaHdJaXdpWTI5dGNIVjBaV1FpTENKeVpXRmtJaXdpY21Weklpd2lkWFJwYkhNaUxDSjFibmR5WVhCUFluTmxjblpoWW14bElpd2lkR1Z6ZENJc0ltTnNZWE56VEdsemRDSXNJbkpsYlc5MlpTSXNJbUZrWkNJc0luZHlhWFJsSWl3aWFYTlhjbWwwWldGaWJHVlBZbk5sY25aaFlteGxJaXdpZG1Gc2RXVWlMQ0p6Wld4bFkzUkZlSFJsYm5OcGIyNXpJaXdpZDNKcGRHVldZV3gxWlNJc0luVndaRlpoYkhWbElpd2ljbVZoWkZaaGJIVmxJaXdpWkdsemNHOXpaVmRvWlc1T2IyUmxTWE5TWlcxdmRtVmtJaXdpWlhod2NtVnpjMmx2YmxKbGQzSnBkR2x1WnlJc0lsOTBkMjlYWVhsQ2FXNWthVzVuY3lKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1lVRkZRU3hKUVVGSlFTeEhRVUYzUWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVZjc1IwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZYTEVkQlFVa3NTMEZEY0VkRExGRkJRVlZETEZGQlFWRXNjMEpCUjNSQ1NpeEhRVUZIU3l4blFrRkJaME1zWlVGQlNTeERRVU4wUTBNc1MwRkJUU3hUUVVGVFF5eEZRVUZUUXl4RlFVRmxReXhIUVVOMFF5eEpRVUZKUXl4RlFVRnRRa1lzUlVGRGRrSXNVVUZCSzBJc1NVRkJjRUpFTEVWQlFWRkpMRkZCUVhsQ0xFTkJRek5ETEVsQlFVbERMRVZCUVVzc1NVRkJTVU1zVDBGQlR5eFBRVUZUVGl4RlFVRlJTU3hSUVVGVkxFMUJRek5EUnl4RlFVRlhaQ3hIUVVGSFl5eFRRVUZUTEVOQlF6RkNReXhMUVVGTkxGZEJRMHdzU1VGQlNVTXNSVUZCVFdoQ0xFZEJRVWRwUWl4TlFVRk5ReXhwUWtGQmFVSldMRXRCVTNCRExFOUJVRzlDTEU5QlFWSlJMRWRCUVhkQ0xFdEJRVkpCTEVkQlFXTktMRVZCUVVkUExFdEJRVXRJTEVkQlIycEVWQ3hGUVVGUllTeFZRVUZWUXl4UFFVRlBMRmRCUlhwQ1pDeEZRVUZSWVN4VlFVRlZSU3hKUVVGSkxGZEJSV2hDVGl4SFFVVlNUeXhOUVVGUGRrSXNSMEZCUjNkQ0xITkNRVUZ6UW1oQ0xFMUJRVzlDTEZOQlFWTnBRaXhIUVVVMVJIcENMRWRCUVVjd1FpeHBRa0ZCYVVKRExGZEJRVmR3UWl4RlFVRlRhMElzUjBGRGVFTXNTVUZCU1Vjc1JVRkJWelZDTEVkQlFVY3dRaXhwUWtGQmFVSkhMRlZCUVZWMFFpeEhRVU0zUTBNc1IwRkJRVUVzUTBGQlowSnZRaXhKUVVWcVFrVXNlVUpCUVRCQ2RrSXNTVUZGTTBKSExFVkJRVzFDTEZkQlEyeENMRTlCUVU5SkxFZEJSMVJrTEVkQlFVZExMR2RDUVVGMVFpeE5RVUZGUXl4TFFVRkxReXhGUVVGVFJ5eEZRVUZyUWtRc1MwRkhPVVJVTEVkQlFVY3JRaXh2UWtGQmIwSkRMR2RDUVVGblF5eG5Ra0ZCU1NJc0ltWnBiR1VpT2lJdmNISnBkbUYwWlM5MGJYQXZabTl2TGtkUFJTOXpjbU12YW5NdlltbHVaR2x1WjNNdmRtRnNhV1JoZEdWa0xYWmhiSFZsTG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIga289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIik7a28uYmluZGluZ0hhbmRsZXJzLnVuaXF1ZUlkPXtjdXJyZW50SW5kZXg6MCxpbml0OmZ1bmN0aW9uKGUsbil7dmFyIHQ9a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShuKCkpfHx7fTtpZihcIlwiPT09dC5pZCgpKXt2YXIgaSxsLHI7cj1cImtvX1wiKyh2b2lkIDAhPT10LnR5cGU/a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0LnR5cGUpOlwiYmxvY2tcIik7ZG97aT1yK1wiX1wiKyArK2tvLmJpbmRpbmdIYW5kbGVycy51bmlxdWVJZC5jdXJyZW50SW5kZXgsbD1nbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaSl9d2hpbGUobCk7dC5pZChpKX19fSxrby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzLnVuaXF1ZUlkPSEwLGtvLmJpbmRpbmdIYW5kbGVycy52aXJ0dWFsQXR0cj17dXBkYXRlOmZ1bmN0aW9uKGUsbil7OCE9PWUubm9kZVR5cGUmJmtvLmJpbmRpbmdIYW5kbGVycy5hdHRyLnVwZGF0ZShlLG4pfX0sa28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5ncy52aXJ0dWFsQXR0cj0hMCxrby5iaW5kaW5nSGFuZGxlcnMudmlydHVhbEF0dHJTdHlsZT17dXBkYXRlOmZ1bmN0aW9uKGUsbix0LGksbCl7aWYoOCE9PWUubm9kZVR5cGUpe3ZhciByPVtcInN0eWxlXCJdOyh2b2lkIDA9PT1sLnRlbXBsYXRlTW9kZXx8XCJ3eXNpd3lnXCIhPWwudGVtcGxhdGVNb2RlKSYmci5wdXNoKFwicmVwbGFjZWRzdHlsZVwiKTtmb3IodmFyIG89a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShuKCkpLGQ9MDtkPHIubGVuZ3RoO2QrKyl7dmFyIGE9cltkXTshMT09PW98fG51bGw9PW8/ZS5yZW1vdmVBdHRyaWJ1dGUoYSk6ZS5zZXRBdHRyaWJ1dGUoYSxvLnRvU3RyaW5nKCkpfX19fSxrby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzLnZpcnR1YWxBdHRyU3R5bGU9ITAsa28uYmluZGluZ0hhbmRsZXJzLnZpcnR1YWxTdHlsZT17dXBkYXRlOmZ1bmN0aW9uKGUsbil7OCE9PWUubm9kZVR5cGUmJmtvLmJpbmRpbmdIYW5kbGVycy5zdHlsZS51cGRhdGUoZSxuKX19LGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3MudmlydHVhbFN0eWxlPSEwLGtvLmJpbmRpbmdIYW5kbGVycy52aXJ0dWFsSHRtbD17aW5pdDprby5iaW5kaW5nSGFuZGxlcnMuaHRtbC5pbml0LHVwZGF0ZTpmdW5jdGlvbihlLG4pe2lmKDg9PT1lLm5vZGVUeXBlKXt2YXIgdD1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKG4oKSk7aWYoa28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZShlKSxudWxsIT10KXtcInN0cmluZ1wiIT10eXBlb2YgdCYmKHQ9dC50b1N0cmluZygpKTt2YXIgaT1rby51dGlscy5wYXJzZUh0bWxGcmFnbWVudCh0KTtpZihpKWZvcih2YXIgbD1lLm5leHRTaWJsaW5nLHI9MCxvPWkubGVuZ3RoO3I8bztyKyspbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpW3JdLGwpfX1lbHNlIGtvLmJpbmRpbmdIYW5kbGVycy5odG1sLnVwZGF0ZShlLG4pO3JldHVybntjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczohMH19fSxrby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzLnZpcnR1YWxIdG1sPSEwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5acGNuUjFZV3h6TG1weklsMHNJbTVoYldWeklqcGJJbXR2SWl3aWQybHVaRzkzSWl3aVoyeHZZbUZzSWl3aVkyOXVjMjlzWlNJc0luSmxjWFZwY21VaUxDSmlhVzVrYVc1blNHRnVaR3hsY25NaUxDSmpkWEp5Wlc1MFNXNWtaWGdpTENKcGJtbDBJaXdpWld4bGJXVnVkQ0lzSW5aaGJIVmxRV05qWlhOemIzSWlMQ0prWVhSaElpd2lkWFJwYkhNaUxDSjFibmR5WVhCUFluTmxjblpoWW14bElpd2lhV1FpTENKbGJDSXNJbkJ5WldacGVDSXNJblI1Y0dVaUxDSmtiMk4xYldWdWRDSXNJbWRsZEVWc1pXMWxiblJDZVVsa0lpd2lkbWx5ZEhWaGJFVnNaVzFsYm5Seklpd2lZV3hzYjNkbFpFSnBibVJwYm1keklpd2lkWEJrWVhSbElpd2libTlrWlZSNWNHVWlMQ0poYkd4Q2FXNWthVzVuYzBGalkyVnpjMjl5SWl3aWRtbGxkMDF2WkdWc0lpd2lZbWx1WkdsdVowTnZiblJsZUhRaUxDSmhkSFJ5Y3lJc0luUmxiWEJzWVhSbFRXOWtaU0lzSW5CMWMyZ2lMQ0poZEhSeVZtRnNkV1VpTENKcElpd2liR1Z1WjNSb0lpd2lZWFIwY2s1aGJXVWlMQ0p5WlcxdmRtVkJkSFJ5YVdKMWRHVWlMQ0p6WlhSQmRIUnlhV0oxZEdVaUxDSjBiMU4wY21sdVp5SXNJbWgwYld3aUxDSmxiWEIwZVU1dlpHVWlMQ0p3WVhKelpXUk9iMlJsY3lJc0luQmhjbk5sU0hSdGJFWnlZV2R0Wlc1MElpd2laVzVrUTI5dGJXVnVkRTV2WkdVaUxDSnVaWGgwVTJsaWJHbHVaeUlzSW1vaUxDSndZWEpsYm5ST2IyUmxJaXdpYVc1elpYSjBRbVZtYjNKbElpd2lZMjl1ZEhKdmJITkVaWE5qWlc1a1lXNTBRbWx1WkdsdVozTWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUjBFc1NVRkJTVUVzUjBGQmQwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRlhMRWRCUVhOQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlZ5eEhRVUZKTEV0QlEzQkhReXhSUVVGVlF5eFJRVUZSTEhOQ1FVVjBRa29zUjBGQlIwc3NaMEpCUVRCQ0xGTkJRVWtzUTBGREwwSkRMR0ZCUVdNc1JVRkRaRU1zUzBGQlVTeFRRVUZUUXl4RlFVRlRReXhIUVVONFFpeEpRVUZKUXl4RlFVRlBWaXhIUVVGSFZ5eE5RVUZOUXl4cFFrRkJhVUpJTEUxQlFXOUNMRWRCUTNwRUxFZEJRV3RDTEV0QlFXUkRMRVZCUVV0SExFdEJRV0VzUTBGRGNFSXNTVUZCU1VFc1JVRkJTVU1zUlVGQlNVTXNSVUZGV2tFc1JVRkJVeXhaUVVFNFFpeEpRVUZrVEN4RlFVRkxUU3hMUVVGMVFtaENMRWRCUVVkWExFMUJRVTFETEdsQ1FVRnBRa1lzUlVGQlMwMHNUVUZCVVN4VFFVVTFSaXhIUVVORlNDeEZRVUZMUlN4RlFVRlRMRTlCUVZObUxFZEJRVWRMTEdkQ1FVRXdRaXhUUVVGRlF5eGhRVU4wUkZFc1JVRkJTMW9zVDBGQlQyVXNVMEZCVTBNc1pVRkJaVXdzVTBGUk4wSkRMRWRCUTFSS0xFVkJRVXRITEVkQlFVZEJMRTFCU1dSaUxFZEJRVWR0UWl4blFrRkJaMEpETEdkQ1FVRXdRaXhWUVVGSkxFVkJSV3BFY0VJc1IwRkJSMHNzWjBKQlFUWkNMRmxCUVVrc1EwRkRiRU5uUWl4UFFVRlJMRk5CUVZOaUxFVkJRVk5ETEVkQlEwTXNTVUZCY2tKRUxFVkJRVkZqTEZWQlExWjBRaXhIUVVGSFN5eG5Ra0ZCYzBJc1MwRkJSV2RDTEU5QlFVOWlMRVZCUVZORExFdEJTV3BFVkN4SFFVRkhiVUlzWjBKQlFXZENReXhuUWtGQk5rSXNZVUZCU1N4RlFVVndSSEJDTEVkQlFVZExMR2RDUVVGclF5eHBRa0ZCU1N4RFFVTjJRMmRDTEU5QlFWRXNVMEZCVTJJc1JVRkJVME1zUlVGQlpXTXNSVUZCY1VKRExFVkJRVmRETEVkQlEzWkZMRWRCUVhsQ0xFbEJRWEpDYWtJc1JVRkJVV01zVTBGQlowSXNRMEZGTVVJc1NVRkRTVWtzUlVGQlVTeERRVUZETEdWQlJHbEVMRWxCUVM5Q1JDeEZRVUZsUlN4alFVRTRSQ3hYUVVFdlFrWXNSVUZCWlVVc1pVRkZkRVZFTEVWQlFVMUZMRXRCUVVzc2FVSkJSV3BETEVsQlJFRXNTVUZCU1VNc1JVRkJXVGRDTEVkQlFVZFhMRTFCUVUxRExHbENRVUZwUWtnc1MwRkRha054UWl4RlFVRkpMRVZCUVVkQkxFVkJRVWxLTEVWQlFVMUxMRTlCUVZGRUxFbEJRVXNzUTBGRGNrTXNTVUZCU1VVc1JVRkJWMDRzUlVGQlRVa3NTVUZEVXl4SlFVRmtSQ3hIUVVGRUxFMUJRVEJDUVN4RlFVVjJRM0pDTEVWQlFWRjVRaXhuUWtGQlowSkVMRWRCUlhoQ2VFSXNSVUZCVVRCQ0xHRkJRV0ZHTEVWQlFWVklMRVZCUVZWTkxHZENRVXR1Ukc1RExFZEJRVWR0UWl4blFrRkJaMEpETEdkQ1FVRnJReXhyUWtGQlNTeEZRVVY2UkhCQ0xFZEJRVWRMTEdkQ1FVRTRRaXhoUVVGSkxFTkJRMjVEWjBJc1QwRkJVU3hUUVVGVFlpeEZRVUZUUXl4SFFVTkRMRWxCUVhKQ1JDeEZRVUZSWXl4VlFVTldkRUlzUjBGQlIwc3NaMEpCUVhWQ0xFMUJRVVZuUWl4UFFVRlBZaXhGUVVGVFF5eExRVWxzUkZRc1IwRkJSMjFDTEdkQ1FVRm5Ra01zWjBKQlFUaENMR05CUVVrc1JVRkhja1J3UWl4SFFVRkhTeXhuUWtGQk5rSXNXVUZCU1N4RFFVTnNRMFVzUzBGQlRWQXNSMEZCUjBzc1owSkJRWE5DTEV0QlFVVkZMRXRCUTJwRFl5eFBRVUZSTEZOQlFWTmlMRVZCUVZORExFZEJRM2hDTEVkQlFYbENMRWxCUVhKQ1JDeEZRVUZSWXl4VFFVRm5RaXhEUVVNeFFpeEpRVUZKWXl4RlFVRlBjRU1zUjBGQlIxY3NUVUZCVFVNc2FVSkJRV2xDU0N4TFFVZHlReXhIUVVSQlZDeEhRVUZIYlVJc1owSkJRV2RDYTBJc1ZVRkJWVGRDTEVkQlEzcENMRTFCUVVNMFFpeEZRVUYzUXl4RFFVTjJRaXhwUWtGQlZFRXNTVUZEVkVFc1JVRkJUMEVzUlVGQlMwUXNXVUZIWkN4SlFVRkpSeXhGUVVGamRFTXNSMEZCUjFjc1RVRkJUVFJDTEd0Q1FVRnJRa2dzUjBGRE4wTXNSMEZCU1VVc1JVRkZSaXhKUVVSQkxFbEJRVWxGTEVWQlFXbENhRU1zUlVGQlVXbERMRmxCUTNCQ1dDeEZRVUZKTEVWQlFVZFpMRVZCUVVsS0xFVkJRVmxRTEU5QlFWRkVMRVZCUVVsWkxFVkJRVWRhTEVsQlF6ZERWU3hGUVVGbFJ5eFhRVUZYUXl4aFFVRmhUaXhGUVVGWlVpeEhRVUZKVlN4VFFVazNSSGhETEVkQlFVZExMR2RDUVVGelFpeExRVUZGWjBJc1QwRkJUMklzUlVGQlUwTXNSMEZKTjBNc1RVRkJUeXhEUVVOTWIwTXNORUpCUVRSQ0xFdEJTV3hETjBNc1IwRkJSMjFDTEdkQ1FVRm5Ra01zWjBKQlFUWkNMR0ZCUVVraUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwySnBibVJwYm1kekwzWnBjblIxWVd4ekxtcHpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIHRpbnltY2U9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cudGlueW1jZTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC50aW55bWNlOm51bGwsJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsa289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIik7cmVxdWlyZShcIi4vZXZlbnRhYmxlLmpzXCIpLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnT3JIdG1sPXtpbml0OmZ1bmN0aW9uKGUsaSxuLHQsbyl7cmV0dXJuIHZvaWQgMD09PW8udGVtcGxhdGVNb2RlfHxcInd5c2l3eWdcIiE9by50ZW1wbGF0ZU1vZGU/a28uYmluZGluZ0hhbmRsZXJzLnZpcnR1YWxIdG1sLmluaXQoKTprby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5pbml0KGUsaSxuLHQsbyl9LHVwZGF0ZTpmdW5jdGlvbihlLGksbix0LG8pe2lmKHZvaWQgMD09PW8udGVtcGxhdGVNb2RlfHxcInd5c2l3eWdcIiE9by50ZW1wbGF0ZU1vZGUpcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy52aXJ0dWFsSHRtbC51cGRhdGUoZSxpLG4sdCxvKX19LGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3Mud3lzaXd5Z09ySHRtbD0hMCxrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0hyZWY9e2luaXQ6ZnVuY3Rpb24oZSxpLG4sdCxvKXtpZig4IT09ZS5ub2RlVHlwZSl7aSgpO2lmKHZvaWQgMD09PW8udGVtcGxhdGVNb2RlfHxcInd5c2l3eWdcIiE9by50ZW1wbGF0ZU1vZGUpZS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIixcIl9uZXdcIik7ZWxzZSB2b2lkIDAhPT1uKCkud3lzaXd5Z09ySHRtbD9lLnNldEF0dHJpYnV0ZShcImhyZWZcIixcImphdmFzY3JpcHQ6dm9pZCgwKVwiKTooZS5yZW1vdmVBdHRyaWJ1dGUoXCJocmVmXCIpLGUuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRocmVmXCIsXCIjXCIpKX19LHVwZGF0ZTpmdW5jdGlvbihlLGksbix0LG8pe2lmKDghPT1lLm5vZGVUeXBlKXt2YXIgbD12b2lkIDA9PT1vLnRlbXBsYXRlTW9kZXx8XCJ3eXNpd3lnXCIhPW8udGVtcGxhdGVNb2RlLHM9a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpKCkpO2wmJighMT09PXN8fG51bGw9PXM/ZS5yZW1vdmVBdHRyaWJ1dGUoXCJocmVmXCIpOmUuc2V0QXR0cmlidXRlKFwiaHJlZlwiLHMudG9TdHJpbmcoKSkpfX19LGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3Mud3lzaXd5Z0hyZWY9ITAsa28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmM9e2NvbnZlcnRlZFVybDpmdW5jdGlvbihlLGksbix0KXt2YXIgbz0tMT09ZS5pbmRleE9mKFwiP1wiKT9cIj9cIjpcIiZcIjtyZXR1cm4gZStvK1wibWV0aG9kPVwiK2krXCImd2lkdGg9XCIrbisobnVsbCE9PXQ/XCImaGVpZ2h0PVwiK3Q6XCJcIil9LHBsYWNlaG9sZGVyVXJsOmZ1bmN0aW9uKGUsaSxuKXt9LHVwZGF0ZTpmdW5jdGlvbihlLGksbix0LG8pe3ZhciBsPWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoaSgpKSxzPWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobC5zcmMpLHI9a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShsLnBsYWNlaG9sZGVyKSxhPWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobC53aWR0aCksZD1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKGwuaGVpZ2h0KTtpZighMT09PXN8fG51bGw9PXN8fFwiXCI9PT1zKVwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cj9lLnNldEF0dHJpYnV0ZShcInNyY1wiLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLnBsYWNlaG9sZGVyVXJsKHIud2lkdGgsci5oZWlnaHQsci50ZXh0KSk6ZS5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7ZWxzZXt2YXIgZz1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKGwubWV0aG9kKTtnfHwoZz1hPjAmJmQ+MD9cImNvdmVyXCI6XCJyZXNpemVcIik7dmFyIHU9a28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMuY29udmVydGVkVXJsKHMudG9TdHJpbmcoKSxnLGEsZCk7ZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIix1KX1udWxsIT1hP2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIixhKTplLnJlbW92ZUF0dHJpYnV0ZShcIndpZHRoXCIpLG51bGwhPWQ/ZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIixkKTplLnJlbW92ZUF0dHJpYnV0ZShcImhlaWdodFwiKX19LGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnSWQ9e2luaXQ6ZnVuY3Rpb24oZSxpLG4sdCxvKXt2b2lkIDA9PT1vLnRlbXBsYXRlTW9kZXx8XCJ3eXNpd3lnXCIhPW8udGVtcGxhdGVNb2RlfHxlLnNldEF0dHJpYnV0ZShcImlkXCIsa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpKCkpKX0sdXBkYXRlOmZ1bmN0aW9uKGUsaSxuLHQsbyl7dm9pZCAwPT09by50ZW1wbGF0ZU1vZGV8fFwid3lzaXd5Z1wiIT1vLnRlbXBsYXRlTW9kZXx8ZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoaSgpKSl9fSxrby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzLnd5c2l3eWdJZD0hMCxrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0NsaWNrPXtpbml0OmZ1bmN0aW9uKGUsaSxuLHQsbyl7dm9pZCAwPT09by50ZW1wbGF0ZU1vZGV8fFwid3lzaXd5Z1wiIT1vLnRlbXBsYXRlTW9kZXx8a28uYmluZGluZ0hhbmRsZXJzLmNsaWNrLmluaXQoZSxpLG4sdCxvKX19LGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3Mud3lzaXd5Z0NsaWNrPSEwLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnQ3NzPXt1cGRhdGU6ZnVuY3Rpb24oZSxpLG4sdCxvKXt2b2lkIDA9PT1vLnRlbXBsYXRlTW9kZXx8XCJ3eXNpd3lnXCIhPW8udGVtcGxhdGVNb2RlfHxrby5iaW5kaW5nSGFuZGxlcnMuY3NzLnVwZGF0ZShlLGksbix0LG8pfX0sa28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5ncy53eXNpd3lnQ3NzPSEwLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnSW1nPXttYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yOmZ1bmN0aW9uKGUsaSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dm9pZCAwIT09aS50ZW1wbGF0ZU1vZGUmJlwid3lzaXd5Z1wiPT1pLnRlbXBsYXRlTW9kZSx0PWUoKSxvPWtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKHQpO3JldHVybiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHQpLHtuYW1lOm4/by5fZWRpdFRlbXBsYXRlOm8uX3RlbXBsYXRlLHRlbXBsYXRlRW5naW5lOmtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLmluc3RhbmNlfX19LGluaXQ6ZnVuY3Rpb24oZSxpLG4sdCxvKXtyZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLmluaXQoZSxrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0ltZy5tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yKGksbykpfSx1cGRhdGU6ZnVuY3Rpb24oZSxpLG4sdCxvKXtyZXR1cm4gbz1vLmV4dGVuZChpKCkpLGtvLmJpbmRpbmdIYW5kbGVycy50ZW1wbGF0ZS51cGRhdGUoZSxrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0ltZy5tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yKGksbyksbix0LG8pfX0sa28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5ncy53eXNpd3lnSW1nPSEwO3ZhciBfY2F0Y2hpbmdGaXJlPWZ1bmN0aW9uKGUsaSl7dHJ5e3JldHVybiB0aGlzLm9yaWdpbmFsRmlyZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2goaSl7Y29uc29sZS53YXJuKFwiQ291Z2h0IHRpbnltY2UgZXhjZXB0aW9uIHdoaWxlIGZpcmluZyBlZGl0b3IgZXZlbnRcIixlLGkpfX07a28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWc9e2RlYnVnOiExLGdldENvbnRlbnRPcHRpb25zOntmb3JtYXQ6XCJyYXdcIn0sdXNlVGFyZ2V0OiExLGN1cnJlbnRJbmRleDowLHN0YW5kYXJkT3B0aW9uczp7fSxpbml0aWFsaXppbmdDbGFzczpcInd5c2l3eWctbG9hZGluZ1wiLHJlbW92ZVNlbGVjdGlvbk9uQmx1cjohMCxlbXB0eUNsYXNzOnZvaWQgMCxmdWxsT3B0aW9uczp7dG9vbGJhcjE6XCJib2xkIGl0YWxpYyBmb3JlY29sb3IgYmFja2NvbG9yIGhyIHN0eWxlc2VsZWN0IHJlbW92ZWZvcm1hdCB8IGxpbmsgdW5saW5rIHwgcGFzdGV0ZXh0IGNvZGVcIixwbHVnaW5zOltcImxpbmsgaHIgcGFzdGUgbGlzdHMgdGV4dGNvbG9yIGNvZGVcIl19LGluaXQ6ZnVuY3Rpb24oZSxpLG4sdCxvKXtrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmluaXQoZSk7dmFyIGwscz1rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5kZWJ1ZyYmXCJmdW5jdGlvblwiPT10eXBlb2YgY29uc29sZS5kZWJ1Zztrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy51c2VUYXJnZXQ/bD1cIkB0YXJnZXRfXCIrICsra28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuY3VycmVudEluZGV4OihsPWUuZ2V0QXR0cmlidXRlKFwiaWRcIikpfHwobD1cInd5c2l3eWdfXCIrICsra28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuY3VycmVudEluZGV4LGUuc2V0QXR0cmlidXRlKFwiaWRcIixsKSksa28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuaW5pdGlhbGl6aW5nQ2xhc3MmJmUuY2xhc3NMaXN0LmFkZChrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5pbml0aWFsaXppbmdDbGFzcyksa28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlLGZ1bmN0aW9uKCl7cyYmY29uc29sZS5kZWJ1ZyhcIkVkaXRvciBmb3Igc2VsZWN0b3JcIixsLFwiaXMgYmVpbmcgcmVtb3ZlZC4uLlwiKSx0aW55bWNlLnJlbW92ZShcIiNcIitlLmdldEF0dHJpYnV0ZShcImlkXCIpKSxzJiZjb25zb2xlLmRlYnVnKFwiRWRpdG9yIGZvciBzZWxlY3RvclwiLGwsXCJoYXMgYmVlbiByZW1vdmVkLlwiKX0pO3ZhciByPWkoKTtpZigha28uaXNPYnNlcnZhYmxlKHIpKXRocm93XCJXeXNpd3lnIGJpbmRpbmcgY2FsbGVkIHdpdGggbm9uIG9ic2VydmFibGVcIjtpZig4PT09ZS5ub2RlVHlwZSl0aHJvd1wiV3lzaXd5ZyBiaW5kaW5nIGNhbGxlZCBvbiB2aXJ0dWFsIG5vZGUsIGlnbm9yaW5nLi4uLlwiK2UuaW5uZXJIVE1MO3ZhciBhLGQ9XCJESVZcIj09ZS50YWdOYW1lfHxcIlREXCI9PWUudGFnTmFtZSxnPSExLHU9ITEsdz17aW5saW5lOiEwLGhpZGRlbl9pbnB1dDohMSxwbHVnaW5zOltcInBhc3RlXCJdLHRvb2xiYXIxOlwiYm9sZCBpdGFsaWNcIix0b29sYmFyMjpcIlwiLHByZXZpZXdfc3R5bGVzOiExLHBhc3RlX2FzX3RleHQ6ITAsbGFuZ3VhZ2U6XCJlblwiLHNjaGVtYTpcImh0bWw1XCIsZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHM6XCJzdHJvbmcvYixlbS9pLCpbKl1cIixtZW51YmFyOiExLHNraW46XCJncmF5LWZsYXRcIixmb3JjZWRfcm9vdF9ibG9jazpkP1wicFwiOlwiXCIsaW5pdF9pbnN0YW5jZV9jYWxsYmFjazpmdW5jdGlvbihpKXtpZihzJiZjb25zb2xlLmRlYnVnKFwiRWRpdG9yIGZvciBzZWxlY3RvclwiLGwsXCJpcyBub3cgaW5pdGlhbGl6ZWQuXCIpLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLmluaXRpYWxpemluZ0NsYXNzJiZlLmNsYXNzTGlzdC5yZW1vdmUoa28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuaW5pdGlhbGl6aW5nQ2xhc3MpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUuZGVidWcpe3ZhciBuPWUuY3VycmVudFN0eWxlP2UuY3VycmVudFN0eWxlLmRpc3BsYXk6Z2xvYmFsLmdldENvbXB1dGVkU3R5bGUoZSxudWxsKS5kaXNwbGF5O1wiaW5saW5lXCI9PW4mJmNvbnNvbGUuZGVidWcoXCJJbml0aWFsaXppbmcgYW4gZWRpdG9yIG9uIGFuIGlubGluZSBlbGVtZW50OiBwbGVhc2Ugbm90ZSB0aGF0IHdoaWxlIGl0IG1heSB3b3JrLCB0aGlzIGlzIHVuc3VwcG9ydGVkIGJlY2F1c2Ugb2YgYSBtdWx0aXR1ZGUgb2YgYnJvd3NlciBpc3N1ZXNcIixlLnRhZ05hbWUsbixsKX19LHNldHVwOmZ1bmN0aW9uKGkpe3MmJmNvbnNvbGUuZGVidWcoXCJFZGl0b3IgZm9yIHNlbGVjdG9yXCIsbCxcImlzIG5vdyBpbiB0aGUgc2V0dXAgcGhhc2UuXCIpO3ZhciBuPWZ1bmN0aW9uKCl7MD09KGUudGV4dENvbnRlbnR8fGUuaW5uZXJUZXh0fHxcIlwiKS50cmltKCkubGVuZ3RoP2UuY2xhc3NMaXN0LmFkZChrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5lbXB0eUNsYXNzKTplLmNsYXNzTGlzdC5yZW1vdmUoa28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuZW1wdHlDbGFzcyl9O2kub24oXCJjaGFuZ2UgcmVkbyB1bmRvXCIsZnVuY3Rpb24oKXtpZighZyl0cnl7dT0hMCxyKGkuZ2V0Q29udGVudChrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5nZXRDb250ZW50T3B0aW9ucykpfWNhdGNoKGUpe2NvbnNvbGUud2FybihcIlVuZXhwZWN0ZWQgZXJyb3Igc2V0dGluZyBjb250ZW50IHZhbHVlIGZvclwiLGwsZSl9ZmluYWxseXt1PSExfWtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLmVtcHR5Q2xhc3MmJm4oKX0pLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLmVtcHR5Q2xhc3MmJmkub24oXCJrZXl1cFwiLGZ1bmN0aW9uKCl7bigpfSksaS5vbihcImZvY3VzXCIsZnVuY3Rpb24oKXtpLm5vZGVDaGFuZ2VkKCksaS5nZXRFbGVtZW50KCkuY2xpY2soKX0pLGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnJlbW92ZVNlbGVjdGlvbk9uQmx1ciYmaS5vbihcImJsdXJcIixmdW5jdGlvbihlKXtnbG9iYWwuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCl9KSxpLm9uKFwiQmVmb3JlU2V0Q29udGVudFwiLGZ1bmN0aW9uKGUpe2UuaW5pdGlhbCYmKGUuZm9ybWF0PVwicmF3XCIpfSksdm9pZCAwPT09aS5vcmlnaW5hbEZpcmUmJihpLm9yaWdpbmFsRmlyZT1pLmZpcmUsaS5maXJlPV9jYXRjaGluZ0ZpcmUpLGE9aX19O3JldHVybiBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy51c2VUYXJnZXQ/dy50YXJnZXQ9ZTp3LnNlbGVjdG9yPVwiI1wiK2wsa28udXRpbHMuZXh0ZW5kKHcsa28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuc3RhbmRhcmRPcHRpb25zKSxkJiZrby51dGlscy5leHRlbmQodyxrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5mdWxsT3B0aW9ucyksZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtzJiZjb25zb2xlLmRlYnVnKFwiRWRpdG9yIGZvciBzZWxlY3RvclwiLGwsXCJpcyBiZWluZyBpbml6aWFsaXplZCAuLi5cIik7dmFyIGU9dGlueW1jZS5pbml0KHcpO3MmJmNvbnNvbGUuZGVidWcoXCJFZGl0b3IgZm9yIHNlbGVjdG9yXCIsbCxcImluaXQgaGFzIGp1c3QgYmVlbiBjYWxsZWQgcmV0dXJuaW5nXCIsZSksZS50aGVuKGZ1bmN0aW9uKCl7cyYmY29uc29sZS5kZWJ1ZyhcIkVkaXRvciBmb3Igc2VsZWN0b3JcIixsLFwiaW5pdCBwcm9taXNlIGhhcyByZXNvbHZlZC5cIil9LGZ1bmN0aW9uKGUpe2NvbnNvbGUubG9nKFwiRWRpdG9yIGZvciBzZWxlY3RvclwiLGwsXCJpbml0IHByb21pc2UgaGFzIGZhaWxlZC5cIixlKX0pfSksa28uY29tcHV0ZWQoZnVuY3Rpb24oKXt2YXIgbj1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKGkoKSk7aWYoIXUpe3RyeXtnPSEwLHZvaWQgMCE9PWE/YS5zZXRDb250ZW50KG4se2Zvcm1hdDpcInJhd1wifSk6a28udXRpbHMuc2V0SHRtbChlLG4pfWNhdGNoKGUpe2NvbnNvbGUud2FybihcIkV4Y2VwdGlvbiBzZXR0aW5nIGNvbnRlbnQgdG8gZWRpdGFibGUgZWxlbWVudFwiLHR5cGVvZiBhLGUpfWc9ITF9fSxudWxsLHtkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6ZX0pLHtjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczohMH19fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZDVjMmwzZVdkekxtcHpJbDBzSW01aGJXVnpJanBiSW5ScGJubHRZMlVpTENKM2FXNWtiM2NpTENKbmJHOWlZV3dpTENJa0lpd2lhMjhpTENKamIyNXpiMnhsSWl3aWNtVnhkV2x5WlNJc0ltSnBibVJwYm1kSVlXNWtiR1Z5Y3lJc0luZDVjMmwzZVdkUGNraDBiV3dpTENKcGJtbDBJaXdpWld4bGJXVnVkQ0lzSW5aaGJIVmxRV05qWlhOemIzSWlMQ0poYkd4Q2FXNWthVzVuYzBGalkyVnpjMjl5SWl3aWRtbGxkMDF2WkdWc0lpd2lZbWx1WkdsdVowTnZiblJsZUhRaUxDSjBaVzF3YkdGMFpVMXZaR1VpTENKM2VYTnBkM2xuSWl3aWRYQmtZWFJsSWl3aWRtbHlkSFZoYkVWc1pXMWxiblJ6SWl3aVlXeHNiM2RsWkVKcGJtUnBibWR6SWl3aWQzbHphWGQ1WjBoeVpXWWlMQ0p1YjJSbFZIbHdaU0lzSW5ObGRFRjBkSEpwWW5WMFpTSXNJbkpsYlc5MlpVRjBkSEpwWW5WMFpTSXNJbWx6VG05MFYzbHphWGQ1WjAxdlpHVWlMQ0poZEhSeVZtRnNkV1VpTENKMWRHbHNjeUlzSW5WdWQzSmhjRTlpYzJWeWRtRmliR1VpTENKMGIxTjBjbWx1WnlJc0luZDVjMmwzZVdkVGNtTWlMQ0pqYjI1MlpYSjBaV1JWY213aUxDSnpjbU1pTENKdFpYUm9iMlFpTENKM2FXUjBhQ0lzSW1obGFXZG9kQ0lzSW5GMVpYSjVVR0Z5WVcxVFpYQmhjbUYwYjNJaUxDSnBibVJsZUU5bUlpd2ljR3hoWTJWb2IyeGtaWEpWY213aUxDSndiSGRwWkhSb0lpd2ljR3hvWldsbmFIUWlMQ0p3YkhSbGVIUWlMQ0oyWVd4MVpTSXNJbkJzWVdObGFHOXNaR1Z5Vm1Gc2RXVWlMQ0p3YkdGalpXaHZiR1JsY2lJc0luUmxlSFFpTENKM2VYTnBkM2xuU1dRaUxDSjNlWE5wZDNsblEyeHBZMnNpTENKamJHbGpheUlzSW5kNWMybDNlV2REYzNNaUxDSmpjM01pTENKM2VYTnBkM2xuU1cxbklpd2liV0ZyWlZSbGJYQnNZWFJsVm1Gc2RXVkJZMk5sYzNOdmNpSXNJbWx6VjNsemFYZDVaMDF2WkdVaUxDSnRiMlJsYkZaaGJIVmxJaXdpZFc1M2NtRndjR1ZrVm1Gc2RXVWlMQ0p3WldWclQySnpaWEoyWVdKc1pTSXNJbTVoYldVaUxDSjBaVzF3YkdGMFpVVnVaMmx1WlNJc0ltNWhkR2wyWlZSbGJYQnNZWFJsUlc1bmFXNWxJaXdpYVc1emRHRnVZMlVpTENKaGJHeENhVzVrYVc1bmN5SXNJbDlqWVhSamFHbHVaMFpwY21VaUxDSmxkbVZ1ZENJc0ltRnlaM01pTENKMGFHbHpJaXdpYjNKcFoybHVZV3hHYVhKbElpd2lZWEJ3YkhraUxDSmhjbWQxYldWdWRITWlMQ0psSWl3aWQyRnliaUlzSW1SbFluVm5JaXdpWjJWMFEyOXVkR1Z1ZEU5d2RHbHZibk1pTENKbWIzSnRZWFFpTENKMWMyVlVZWEpuWlhRaUxDSmpkWEp5Wlc1MFNXNWtaWGdpTENKemRHRnVaR0Z5WkU5d2RHbHZibk1pTENKcGJtbDBhV0ZzYVhwcGJtZERiR0Z6Y3lJc0luSmxiVzkyWlZObGJHVmpkR2x2Yms5dVFteDFjaUlzSW1WdGNIUjVRMnhoYzNNaUxDSjFibVJsWm1sdVpXUWlMQ0ptZFd4c1QzQjBhVzl1Y3lJc0luUnZiMnhpWVhJeElpd2ljR3gxWjJsdWN5SXNJbVp2WTNWellXSnNaU0lzSW5ObGJHVmpkRzl5U1dRaUxDSmtiMFJsWW5Wbklpd2laMlYwUVhSMGNtbGlkWFJsSWl3aVkyeGhjM05NYVhOMElpd2lZV1JrSWl3aVpHOXRUbTlrWlVScGMzQnZjMkZzSWl3aVlXUmtSR2x6Y0c5elpVTmhiR3hpWVdOcklpd2ljbVZ0YjNabElpd2lhWE5QWW5ObGNuWmhZbXhsSWl3aWFXNXVaWEpJVkUxTUlpd2lkR2hwYzBWa2FYUnZjaUlzSW1aMWJHeEZaR2wwYjNJaUxDSjBZV2RPWVcxbElpd2lhWE5UZFdKelkzSnBZbVZ5UTJoaGJtZGxJaXdpYVhORlpHbDBiM0pEYUdGdVoyVWlMQ0p2Y0hScGIyNXpJaXdpYVc1c2FXNWxJaXdpYUdsa1pHVnVYMmx1Y0hWMElpd2lkRzl2YkdKaGNqSWlMQ0p3Y21WMmFXVjNYM04wZVd4bGN5SXNJbkJoYzNSbFgyRnpYM1JsZUhRaUxDSnNZVzVuZFdGblpTSXNJbk5qYUdWdFlTSXNJbVY0ZEdWdVpHVmtYM1poYkdsa1gyVnNaVzFsYm5Seklpd2liV1Z1ZFdKaGNpSXNJbk5yYVc0aUxDSm1iM0pqWldSZmNtOXZkRjlpYkc5amF5SXNJbWx1YVhSZmFXNXpkR0Z1WTJWZlkyRnNiR0poWTJzaUxDSmxaR2wwYjNJaUxDSmxiR1Z0Wlc1MFUzUjViR1VpTENKamRYSnlaVzUwVTNSNWJHVWlMQ0prYVhOd2JHRjVJaXdpWjJWMFEyOXRjSFYwWldSVGRIbHNaU0lzSW5ObGRIVndJaXdpWlcxd2RIbERiR0Z6YzBoaGJtUnNaWElpTENKMFpYaDBRMjl1ZEdWdWRDSXNJbWx1Ym1WeVZHVjRkQ0lzSW5SeWFXMGlMQ0pzWlc1bmRHZ2lMQ0p2YmlJc0ltZGxkRU52Ym5SbGJuUWlMQ0p1YjJSbFEyaGhibWRsWkNJc0ltZGxkRVZzWlcxbGJuUWlMQ0puWlhSVFpXeGxZM1JwYjI0aUxDSnlaVzF2ZG1WQmJHeFNZVzVuWlhNaUxDSnBibWwwYVdGc0lpd2labWx5WlNJc0luUmhjbWRsZENJc0luTmxiR1ZqZEc5eUlpd2laWGgwWlc1a0lpd2ljMlYwVkdsdFpXOTFkQ0lzSW5KbGN5SXNJblJvWlc0aUxDSm1ZV2xzZFhKbElpd2liRzluSWl3aVkyOXRjSFYwWldRaUxDSmpiMjUwWlc1MElpd2ljMlYwUTI5dWRHVnVkQ0lzSW5ObGRFaDBiV3dpTENKa2FYTndiM05sVjJobGJrNXZaR1ZKYzFKbGJXOTJaV1FpTENKamIyNTBjbTlzYzBSbGMyTmxibVJoYm5SQ2FXNWthVzVuY3lKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1lVRkhRU3hKUVVGSlFTeFJRVUUyUWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVdkQ0xGRkJRWE5DTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCWjBJc1VVRkJTU3hMUVVOdVNFTXNSVUZCZFVJc2IwSkJRVmhHTEU5QlFYbENRU3hQUVVGbExFOUJRWE5DTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCWlN4UFFVRkpMRXRCUXpOSFJTeEhRVUYzUWl4dlFrRkJXRWdzVDBGQmVVSkJMRTlCUVZjc1IwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZYTEVkQlFVa3NTMEZEY0VkSExGRkJRVlZETEZGQlFWRXNjMEpCUTNSQ1FTeFJRVUZSTEd0Q1FVVlNSaXhIUVVGSFJ5eG5Ra0ZCWjBKRExHTkJRV2RDTEVOQlEycERReXhMUVVGTkxGTkJRVk5ETEVWQlFWTkRMRVZCUVdWRExFVkJRWEZDUXl4RlFVRlhReXhIUVVkeVJTeFpRVVk0UkN4SlFVRXZRa0VzUlVGQlpVTXNZMEZCT0VRc1YwRkJMMEpFTEVWQlFXVkRMR0ZCUjI1R1dDeEhRVUZIUnl4blFrRkJOa0lzV1VGQlJVVXNUMEZGYkVOTUxFZEJRVWRITEdkQ1FVRm5RbE1zVVVGQlVWQXNTMEZCUzBNc1JVRkJVME1zUlVGQlpVTXNSVUZCY1VKRExFVkJRVmRETEVsQlJXNUhSeXhQUVVGUkxGTkJRVk5RTEVWQlFWTkRMRVZCUVdWRExFVkJRWEZDUXl4RlFVRlhReXhIUVVWMlJTeFJRVVE0UkN4SlFVRXZRa0VzUlVGQlpVTXNZMEZCT0VRc1YwRkJMMEpFTEVWQlFXVkRMR0ZCUlRGR0xFOUJRVTlZTEVkQlFVZEhMR2RDUVVFMlFpeFpRVUZGVlN4UFFVRlBVQ3hGUVVGVFF5eEZRVUZsUXl4RlFVRnhRa01zUlVGQlYwTXNTMEZMT1VkV0xFZEJRVWRqTEdkQ1FVRm5Ra01zWjBKQlFTdENMR1ZCUVVrc1JVRkZkRVJtTEVkQlFVZEhMR2RDUVVGblFtRXNXVUZCWXl4RFFVTXZRbGdzUzBGQlRTeFRRVUZUUXl4RlFVRlRReXhGUVVGbFF5eEZRVUZ4UWtNc1JVRkJWME1zUjBGRGNrVXNSMEZCZVVJc1NVRkJja0pLTEVWQlFWRlhMRk5CUVdkQ0xFTkJRMnhDVml4SlFVbFNMRkZCUmpoRUxFbEJRUzlDUnl4RlFVRmxReXhqUVVFNFJDeFhRVUV2UWtRc1JVRkJaVU1zWVVGSE1VWk1MRVZCUVZGWkxHRkJRV0VzVTBGQlZTeHJRa0ZUVlN4SlFVUjJRbFlzU1VGRFMwb3NZMEZEY2tKRkxFVkJRVkZaTEdGQlFXRXNUMEZCVVN4MVFrRkZOMEphTEVWQlFWRmhMR2RDUVVGblFpeFJRVU40UW1Jc1JVRkJVVmtzWVVGQllTeGxRVUZuUWl4UlFVczNRMHdzVDBGQlVTeFRRVUZUVUN4RlFVRlRReXhGUVVGbFF5eEZRVUZ4UWtNc1JVRkJWME1zUjBGRGRrVXNSMEZCZVVJc1NVRkJja0pLTEVWQlFWRlhMRk5CUVdkQ0xFTkJRekZDTEVsQlFVbEhMRTlCUVRCRUxFbEJRUzlDVml4RlFVRmxReXhqUVVFNFJDeFhRVUV2UWtRc1JVRkJaVU1zWVVGRmVFWlZMRVZCUVZseVFpeEhRVUZIYzBJc1RVRkJUVU1zYVVKQlFXbENhRUlzUzBGRGRFTmhMRXRCUTJsQ0xFbEJRV1JETEVkQlFVUXNUVUZCTUVKQkxFVkJRelZDWml4RlFVRlJZU3huUWtGQlowSXNVVUZGZUVKaUxFVkJRVkZaTEdGQlFXRXNUMEZCVVVjc1JVRkJWVWNzWjBKQlMycEVlRUlzUjBGQlIyTXNaMEpCUVdkQ1F5eG5Ra0ZCTmtJc1lVRkJTU3hGUVVWd1JHWXNSMEZCUjBjc1owSkJRV2RDYzBJc1YwRkJZU3hEUVVNNVFrTXNZVUZCWXl4VFFVRlRReXhGUVVGTFF5eEZRVUZSUXl4RlFVRlBReXhIUVVONlF5eEpRVUZKUXl4SFFVRXlReXhIUVVGeVFrb3NSVUZCU1Vzc1VVRkJVU3hMUVVGaExFbEJRVTBzU1VGRmVrUXNUMEZFVlV3c1JVRkJUVWtzUlVGQmMwSXNWVUZCV1Vnc1JVRkJVeXhWUVVGWlF5eEhRVUZ2UWl4UFFVRllReXhGUVVGclFpeFhRVUZoUVN4RlFVRlRMRXRCUnpGSVJ5eGxRVUZuUWl4VFFVRlRReXhGUVVGVFF5eEZRVUZWUXl4TFFVMDFRM1pDTEU5QlFWRXNVMEZCVTFBc1JVRkJVME1zUlVGQlpVTXNSVUZCY1VKRExFVkJRVmRETEVkQlEzWkZMRWxCUVVreVFpeEZRVUZSY2tNc1IwRkJSM05DTEUxQlFVMURMR2xDUVVGcFFtaENMRXRCUTJ4RFl5eEZRVUZaY2tJc1IwRkJSM05DTEUxQlFVMURMR2xDUVVGcFFtTXNSVUZCVFZZc1MwRkROVU5YTEVWQlFXMUNkRU1zUjBGQlIzTkNMRTFCUVUxRExHbENRVUZwUW1Nc1JVRkJUVVVzWVVGRGJrUldMRVZCUVZFM1FpeEhRVUZIYzBJc1RVRkJUVU1zYVVKQlFXbENZeXhGUVVGTlVpeFBRVU40UTBNc1JVRkJVemxDTEVkQlFVZHpRaXhOUVVGTlF5eHBRa0ZCYVVKakxFVkJRVTFRTEZGQlF6ZERMRWxCUVcxQ0xFbEJRV1JVTEVkQlFVUXNUVUZCTUVKQkxFZEJRVzFGTEV0QlFXUkJMRVZCUTJ4RUxHbENRVUZ3UW1sQ0xFZEJRWEZFTEU5QlFYSkNRU3hGUVVFeVFtaERMRVZCUVZGWkxHRkJRV0VzVFVGQlQyeENMRWRCUVVkSExHZENRVUZuUW5OQ0xGZEJRVmRSTEdWQlFXVkxMRVZCUVdsQ1ZDeE5RVUZQVXl4RlFVRnBRbElzVDBGQlVWRXNSVUZCYVVKRkxFOUJRelZOYkVNc1JVRkJVV0VzWjBKQlFXZENMRmRCUTNoQ0xFTkJRMHdzU1VGQlNWTXNSVUZCVXpWQ0xFZEJRVWR6UWl4TlFVRk5ReXhwUWtGQmFVSmpMRVZCUVUxVUxGRkJRM2hEUVN4SlFVRlJRU3hGUVVGVFF5eEZRVUZSTEVkQlFVdERMRVZCUVZNc1JVRkJTU3hSUVVGVkxGVkJRekZFTEVsQlFVbElMRVZCUVUwelFpeEhRVUZIUnl4blFrRkJaMEp6UWl4WFFVRlhReXhoUVVGaFRDeEZRVUZWUnl4WFFVRlpTU3hGUVVGUlF5eEZRVUZQUXl4SFFVTXhSbmhDTEVWQlFWRlpMR0ZCUVdFc1RVRkJUMU1zUjBGRk1VSXNUVUZCVDBVc1JVRkJlVU4yUWl4RlFVRlJXU3hoUVVGaExGRkJRVk5YTEVkQlF6ZEZka0lzUlVGQlVXRXNaMEpCUVdkQ0xGTkJRM3BDTEUxQlFVOVhMRVZCUVRKRGVFSXNSVUZCVVZrc1lVRkJZU3hUUVVGVldTeEhRVU5vUm5oQ0xFVkJRVkZoTEdkQ1FVRm5RaXhaUVVscVEyNUNMRWRCUVVkSExHZENRVUZuUW5ORExGVkJRVmtzUTBGRE4wSndReXhMUVVGTkxGTkJRVk5ETEVWQlFWTkRMRVZCUVdWRExFVkJRWEZDUXl4RlFVRlhReXhSUVVOUUxFbEJRUzlDUVN4RlFVRmxReXhqUVVFNFJDeFhRVUV2UWtRc1JVRkJaVU1zWTBGRk1VWk1MRVZCUVZGWkxHRkJRV0VzUzBGQlRXeENMRWRCUVVkelFpeE5RVUZOUXl4cFFrRkJhVUpvUWl4UFFVVjZSRTBzVDBGQlVTeFRRVUZUVUN4RlFVRlRReXhGUVVGbFF5eEZRVUZ4UWtNc1JVRkJWME1zVVVGRFZDeEpRVUV2UWtFc1JVRkJaVU1zWTBGQk9FUXNWMEZCTDBKRUxFVkJRV1ZETEdOQlJURkdUQ3hGUVVGUldTeGhRVUZoTEV0QlFVMXNRaXhIUVVGSGMwSXNUVUZCVFVNc2FVSkJRV2xDYUVJc1VVRkhNMFJRTEVkQlFVZGpMR2RDUVVGblFrTXNaMEpCUVRKQ0xGZEJRVWtzUlVGSGJFUm1MRWRCUVVkSExHZENRVUZuUW5WRExHRkJRV1VzUTBGRGFFTnlReXhMUVVGTkxGTkJRVk5ETEVWQlFWTkRMRVZCUVdWRExFVkJRWEZDUXl4RlFVRlhReXhSUVVOUUxFbEJRUzlDUVN4RlFVRmxReXhqUVVFNFJDeFhRVUV2UWtRc1JVRkJaVU1zWTBGRk1VWllMRWRCUVVkSExHZENRVUZuUW5kRExFMUJRVTEwUXl4TFFVRkxReXhGUVVGVFF5eEZRVUZsUXl4RlFVRnhRa01zUlVGQlYwTXNTMEZITlVaV0xFZEJRVWRqTEdkQ1FVRm5Ra01zWjBKQlFUaENMR05CUVVrc1JVRkhja1JtTEVkQlFVZEhMR2RDUVVGblFubERMRmRCUVdFc1EwRkRPVUl2UWl4UFFVRlJMRk5CUVZOUUxFVkJRVk5ETEVWQlFXVkRMRVZCUVhGQ1F5eEZRVUZYUXl4UlFVTlVMRWxCUVM5Q1FTeEZRVUZsUXl4alFVRTRSQ3hYUVVFdlFrUXNSVUZCWlVNc1kwRkZNVVpZTEVkQlFVZEhMR2RDUVVGblFqQkRMRWxCUVVsb1F5eFBRVUZQVUN4RlFVRlRReXhGUVVGbFF5eEZRVUZ4UWtNc1JVRkJWME1zUzBGSE5VWldMRWRCUVVkakxHZENRVUZuUWtNc1owSkJRVFJDTEZsQlFVa3NSVUZGYmtSbUxFZEJRVWRITEdkQ1FVRm5RakpETEZkQlFXRXNRMEZET1VKRExEQkNRVUV5UWl4VFFVRlRlRU1zUlVGQlpVY3NSMEZEYWtRc1QwRkJUeXhYUVVOTUxFbEJRVWx6UXl4UFFVRjFSQ3hKUVVFdlFuUkRMRVZCUVdWRExHTkJRVGhFTEZkQlFTOUNSQ3hGUVVGbFF5eGhRVVZ5Um5ORExFVkJRV0V4UXl4SlFVTm1Na01zUlVGQmFVSnNSQ3hIUVVGSGMwSXNUVUZCVFRaQ0xHVkJRV1ZHTEVkQlN6TkRMRTlCUmtGcVJDeEhRVUZIYzBJc1RVRkJUVU1zYVVKQlFXbENNRUlzUjBGRmJrSXNRMEZEVEVjc1MwRkJVVW9zUlVGQlowSkZMRVZCUVRoQ0xHTkJRVWxCTEVWQlFUQkNMRlZCUTNCR1J5eGxRVUZyUW5KRUxFZEJRVWR6UkN4eFFrRkJjVUpETEZsQlNXaEViRVFzUzBGQlVTeFRRVUZUUXl4RlFVRlRReXhGUVVGbGFVUXNSVUZCWVM5RExFVkJRVmRETEVkQlF5OUVMRTlCUVU5V0xFZEJRVWRITEdkQ1FVRXdRaXhUUVVGUkxFdEJRVVZITEVWQlFWTk9MRWRCUVVkSExHZENRVUUwUWl4WFFVRkZORU1zTUVKQlFUQkNlRU1zUlVGQlpVY3NTMEZGYmtsSExFOUJRVlVzVTBGQlUxQXNSVUZCVTBNc1JVRkJaV2xFTEVWQlFXRXZReXhGUVVGWFF5eEhRVVZxUlN4UFFVUkJRU3hGUVVGcFFrRXNSVUZCZFVJc1QwRkJSVWdzUzBGRGJrTlFMRWRCUVVkSExHZENRVUV3UWl4VFFVRlZMRTlCUVVWSExFVkJRVk5PTEVkQlFVZEhMR2RDUVVFMFFpeFhRVUZGTkVNc01FSkJRVEJDZUVNc1JVRkJaVWNzUjBGQmFVSTRReXhGUVVGaEwwTXNSVUZCVjBNc1MwRkhhRXhXTEVkQlFVZGpMR2RDUVVGblFrTXNaMEpCUVRSQ0xGbEJRVWtzUlVGSGJrUXNTVUZCU1RCRExHTkJRV2RDTEZOQlFWTkRMRVZCUVU5RExFZEJRMnhETEVsQlEwVXNUMEZCVDBNc1MwRkJTME1zWVVGQllVTXNUVUZCVFVZc1MwRkJUVWNzVjBGRGNrTXNUVUZCVDBNc1IwRkRVQzlFTEZGQlFWRm5SU3hMUVVGTExIRkVRVUZ6UkZBc1JVRkJUMDBzUzBGUk9VVm9SU3hIUVVGSFJ5eG5Ra0ZCWjBKVExGRkJRVlVzUTBGRE0wSnpSQ3hQUVVGUExFVkJSMUJETEd0Q1FVRnRRaXhEUVVGRlF5eFBRVUZSTEU5QlF6ZENReXhYUVVGWExFVkJRMWhETEdGQlFXTXNSVUZEWkVNc1owSkJRV2xDTEVkQlJXcENReXhyUWtGQmJVSXNhMEpCUTI1Q1F5eDFRa0ZCZFVJc1JVRkhka0pETEdkQ1FVRlpReXhGUVVOYVF5eFpRVUZoTEVOQlExaERMRk5CUVZVc05rWkJSMVpETEZGQlFWTXNRMEZCUXl4MVEwRlBXbnBGTEV0QlFVMHNVMEZCVTBNc1JVRkJVME1zUlVGQlpVTXNSVUZCY1VKRExFVkJRVmRETEVkQlJYSkZWaXhIUVVGSFJ5eG5Ra0ZCWjBJMFJTeFZRVUZWTVVVc1MwRkJTME1zUjBGSGJFTXNTVUZGU1RCRkxFVkJSa0ZETEVWQlFWVnFSaXhIUVVGSFJ5eG5Ra0ZCWjBKVExGRkJRVkZ6UkN4UFFVRnBReXh0UWtGQmFrSnFSU3hSUVVGUmFVVXNUVUZITjBSc1JTeEhRVUZIUnl4blFrRkJaMEpUTEZGQlFWRjVSQ3hWUVVNM1FsY3NSVUZCWVN4alFVRm5RbWhHTEVkQlFVZEhMR2RDUVVGNVFpeFJRVUZGYlVVc1kwRkZNMFJWTEVWQlFXRXhSU3hGUVVGUk5FVXNZVUZCWVN4VFFVVm9RMFlzUlVGQllTeGpRVUZuUW1oR0xFZEJRVWRITEdkQ1FVRjVRaXhSUVVGRmJVVXNZVUZETTBSb1JTeEZRVUZSV1N4aFFVRmhMRXRCUVUwNFJDeEpRVWt6UW1oR0xFZEJRVWRITEdkQ1FVRm5RbE1zVVVGQlVUUkVMRzFDUVVNM1FteEZMRVZCUVZFMlJTeFZRVUZWUXl4SlFVRkpjRVlzUjBGQlIwY3NaMEpCUVdkQ1V5eFJRVUZSTkVRc2JVSkJSMjVFZUVVc1IwRkJSM05DTEUxQlFVMHJSQ3huUWtGQlowSkRMRzFDUVVGdFFtaEdMRVZCUVZNc1YwRkRMME15UlN4SFFVRlRhRVlzVVVGQlVXbEZMRTFCUVUwc2MwSkJRWFZDWXl4RlFVRlpMSFZDUVVNNVJIQkdMRkZCUVZFeVJpeFBRVUZQTEVsQlFVMXFSaXhGUVVGUk5FVXNZVUZCWVN4UFFVTjBRMFFzUjBGQlUyaEdMRkZCUVZGcFJTeE5RVUZOTEhOQ1FVRjFRbU1zUlVGQldTeDFRa0ZIYUVVc1NVRkJTVE5ETEVWQlFWRTVRaXhKUVVWYUxFbEJRVXRRTEVkQlFVZDNSaXhoUVVGaGJrUXNSMEZCVVN4TFFVRk5MRFpEUVVOdVF5eEhRVUY1UWl4SlFVRnlRaTlDTEVWQlFWRlhMRk5CUVdkQ0xFdEJRVTBzZFVSQlFYbEVXQ3hGUVVGUmJVWXNWVUZGYmtjc1NVRkZTVU1zUlVGR1FVTXNSVUZCWjBNc1QwRkJia0p5Uml4RlFVRlJjMFlzVTBGQmRVTXNUVUZCYmtKMFJpeEZRVUZSYzBZc1VVRkRha1JETEVkQlFYRkNMRVZCUlhKQ1F5eEhRVUZwUWl4RlFVVnFRa01zUlVGQlZTeERRVU5hUXl4UlFVRlJMRVZCUlZKRExHTkJRV01zUlVGRFpHNUNMRkZCUVZNc1EwRkJReXhUUVVOV1JDeFRRVUZWTEdOQlExWnhRaXhUUVVGVkxFZEJSVlpETEdkQ1FVRm5RaXhGUVVOb1FrTXNaVUZCWlN4RlFVTm1ReXhUUVVGVkxFdEJRMVpETEU5QlFWRXNVVUZEVWtNc2QwSkJRWGxDTEhGQ1FVTjZRa01zVTBGQlV5eEZRVU5VUXl4TFFVRk5MRmxCU1U1RExHdENRVUZ0UW1Zc1JVRkJZU3hKUVVGTkxFZEJRM1JEWjBJc2RVSkJRWGxDTEZOQlFWTkRMRWRCVTJoRExFZEJVa2t6UWl4SFFVRlRhRVlzVVVGQlVXbEZMRTFCUVUwc2MwSkJRWFZDWXl4RlFVRlpMSFZDUVVNeFJHaEdMRWRCUVVkSExHZENRVUZuUWxNc1VVRkJVVFJFTEcxQ1FVTTNRbXhGTEVWQlFWRTJSU3hWUVVGVlNTeFBRVUZQZGtZc1IwRkJSMGNzWjBKQlFXZENVeXhSUVVGUk5FUXNiVUpCVFRGQ0xHMUNRVUZxUW5aRkxGRkJRVkZwUlN4TlFVRnhRaXhEUVVOMFF5eEpRVUZKTWtNc1JVRkJaWFpITEVWQlFWRjNSeXhoUVVGbGVFY3NSVUZCVVhkSExHRkJRV0ZETEZGQlFWVnFTQ3hQUVVGUGEwZ3NhVUpCUVdsQ01VY3NSVUZCVXl4TlFVRk5lVWNzVVVGRE5VWXNWVUZCYUVKR0xFZEJRMFkxUnl4UlFVRlJhVVVzVFVGQlRTeG5Ta0ZCYVVvMVJDeEZRVUZSYzBZc1VVRkJVMmxDTEVWQlFXTTNRaXhMUVV0d1RXbERMRTFCUVU4c1UwRkJVMHdzUjBGRFZqTkNMRWRCUVZOb1JpeFJRVUZSYVVVc1RVRkJUU3h6UWtGQmRVSmpMRVZCUVZrc09FSkJSVGxFTEVsQlFVbHJReXhGUVVGdlFpeFhRVVZKTEVsQlJGQTFSeXhGUVVGUk5rY3NZVUZCWlRkSExFVkJRVkU0Unl4WFFVRmhMRWxCUVVsRExFOUJRMjVFUXl4UFFVTmthRWdzUlVGQlVUWkZMRlZCUVZWRExFbEJRVWx3Uml4SFFVRkhSeXhuUWtGQlowSlRMRkZCUVZFNFJDeFpRVVZxUkhCRkxFVkJRVkUyUlN4VlFVRlZTU3hQUVVGUGRrWXNSMEZCUjBjc1owSkJRV2RDVXl4UlFVRlJPRVFzWVVGTmVFUnJReXhGUVVGUFZ5eEhRVUZITEcxQ1FVRnZRaXhYUVVNMVFpeEpRVUZMTVVJc1JVRkRTQ3hKUVVORlF5eEhRVUZwUWl4RlFWTnFRbnBFTEVWQlFVMTFSU3hGUVVGUFdTeFhRVUZYZUVnc1IwRkJSMGNzWjBKQlFXZENVeXhSUVVGUmRVUXNiMEpCUTI1RUxFMUJRVTlJTEVkQlExQXZSQ3hSUVVGUlowVXNTMEZCU3l3MlEwRkJPRU5sTEVWQlFWbG9RaXhIUVVOMlJTeFJRVU5CT0VJc1IwRkJhVUlzUlVGSGFrSTVSaXhIUVVGSFJ5eG5Ra0ZCWjBKVExGRkJRVkU0UkN4WlFVRlpkME1zVFVGSGVrTnNTQ3hIUVVGSFJ5eG5Ra0ZCWjBKVExGRkJRVkU0UkN4WlFVTTNRbXRETEVWQlFVOVhMRWRCUVVjc1VVRkJVeXhYUVVOcVFrd3NUVUZOU2s0c1JVRkJUMWNzUjBGQlJ5eFJRVUZUTEZkQlJXcENXQ3hGUVVGUFlTeGpRVU5RWWl4RlFVRlBZeXhoUVVGaEwwVXNWVUZMYkVJelF5eEhRVUZIUnl4blFrRkJaMEpUTEZGQlFWRTJSQ3gxUWtGRE4wSnRReXhGUVVGUFZ5eEhRVUZITEU5QlFWRXNVMEZCVXpkRUxFZEJRM3BDTlVRc1QwRkJUelpJTEdWQlFXVkRMRzlDUVVzeFFtaENMRVZCUVU5WExFZEJRVWNzYlVKQlFXOUNMRk5CUVZNMVJDeEhRVU5xUTBFc1JVRkJTMnRGTEZWQlFWTnNSU3hGUVVGTFV5eFBRVUZUTEdOQlpVRXNTVUZCZGtKM1F5eEZRVUZQTDBNc1pVRkRhRUlyUXl4RlFVRlBMME1zWVVGQlpTdERMRVZCUVU5clFpeExRVU0zUW14Q0xFVkJRVTlyUWl4TFFVRlBja1VzWlVGSGFFSnBReXhGUVVGaGEwSXNTVUZ0UkdwQ0xFOUJOME5KTlVjc1IwRkJSMGNzWjBKQlFXZENVeXhSUVVGUmVVUXNWVUZETjBJd1FpeEZRVUZSWjBNc1QwRkJVM3BJTEVWQlJXcENlVVlzUlVGQlVXbERMRk5CUVZjc1NVRkJUV2hFTEVWQlJ6TkNhRVlzUjBGQlIzTkNMRTFCUVUweVJ5eFBRVUZQYkVNc1JVRkJVeTlHTEVkQlFVZEhMR2RDUVVGblFsTXNVVUZCVVRKRUxHbENRVU5vUkc5Q0xFZEJRVmt6Uml4SFFVRkhjMElzVFVGQlRUSkhMRTlCUVU5c1F5eEZRVUZUTDBZc1IwRkJSMGNzWjBKQlFXZENVeXhSUVVGUlowVXNZVUZMY0VVNVJTeFBRVUZQYjBrc1YwRkJWeXhYUVVOYWFrUXNSMEZCVTJoR0xGRkJRVkZwUlN4TlFVRk5MSE5DUVVGMVFtTXNSVUZCV1N3MFFrRkRPVVFzU1VGQlNXMUVMRVZCUVUxMlNTeFJRVUZSVXl4TFFVRkxNRVlzUjBGRGJrSmtMRWRCUVZOb1JpeFJRVUZSYVVVc1RVRkJUU3h6UWtGQmRVSmpMRVZCUVZrc2MwTkJRWFZEYlVRc1IwRkRja2RCTEVWQlFVbERMRXRCUVVzc1YwRkRTRzVFTEVkQlFWTm9SaXhSUVVGUmFVVXNUVUZCVFN4elFrRkJkVUpqTEVWQlFWa3NLMEpCUXpkRUxGTkJRVk54UkN4SFFVTldjRWtzVVVGQlVYRkpMRWxCUVVrc2MwSkJRWFZDZEVRc1JVRkJXU3d5UWtGQk5FSnhSQ3hQUVVrdlJYSkpMRWRCUVVkMVNTeFRRVUZUTEZkQlExWXNTVUZCU1VNc1JVRkJWWGhKTEVkQlFVZHpRaXhOUVVGTlF5eHBRa0ZCYVVKb1FpeExRVU40UXl4SlFVRkxkVVlzUlVGQlowSXNRMEZEYmtJc1NVRkRSVVFzUjBGQmNVSXNUMEZIU3l4SlFVRm1TQ3hGUVVOVVFTeEZRVUZYSzBNc1YwRkJWMFFzUlVGQlV5eERRVUZGY0VVc1QwRkJVU3hSUVVWNlEzQkZMRWRCUVVkelFpeE5RVUZOYjBnc1VVRkJVWEJKTEVWQlFWTnJTU3hIUVVVMVFpeE5RVUZQZUVVc1IwRkRVQzlFTEZGQlFWRm5SU3hMUVVGTExIVkVRVUYzUkhsQ0xFVkJRVmt4UWl4SFFVVnVSalpDTEVkQlFYRkNMRWxCUlhSQ0xFdEJRVTBzUTBGRFVEaERMSGxDUVVFd1FuSkpMRWxCU1hKQ0xFTkJRMHh6U1N3MFFrRkJORUlpTENKbWFXeGxJam9pTDNCeWFYWmhkR1V2ZEcxd0wyWnZieTVIVDBVdmMzSmpMMnB6TDJKcGJtUnBibWR6TDNkNWMybDNlV2R6TG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIgY29uc29sZT1yZXF1aXJlKFwiY29uc29sZS1icm93c2VyaWZ5XCIpLGNoZWNrTW9kZWw9ZnVuY3Rpb24oZSxvLHQsbixsKXt2YXIgaSxmLHIsYT0wO2lmKHZvaWQgMD09PWwmJihsPSExKSx2b2lkIDAhPT1vJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLnNwbGljZSlmb3IoaT17fSxmPTA7ZjxvLmxlbmd0aDtmKyspaVtvW2ZdLnR5cGVdPW9bZl07ZWxzZSBpPW87Zm9yKHZhciBwIGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eShwKSlpZihyPXZvaWQgMCE9PW4/bitcIi5cIitwOnAsdC5oYXNPd25Qcm9wZXJ0eShwKSlpZih0eXBlb2YgdFtwXSE9dHlwZW9mIGVbcF0pbnVsbCE9PXRbcF0mJm51bGwhPT1lW3BdJiYoXCJzdHJpbmdcIj09dHlwZW9mIHRbcF0/U3RyaW5nKGVbcF0pIT1lW3BdJiYoY29uc29sZS5sb2coXCJUT0RPIERpZmZlcmVudCB0eXBlIDEgXCIscix0eXBlb2YgdFtwXSx0eXBlb2YgZVtwXSx0W3BdLGVbcF0pLGE9TWF0aC5tYXgoYSwyKSk6XCJudW1iZXJcIj09dHlwZW9mIHRbcF0/TnVtYmVyKGVbcF0pIT1lW3BdJiYoY29uc29sZS5sb2coXCJUT0RPIERpZmZlcmVudCB0eXBlIDIgXCIscix0eXBlb2YgdFtwXSx0eXBlb2YgZVtwXSx0W3BdLGVbcF0pLGE9TWF0aC5tYXgoYSwyKSk6KGNvbnNvbGUubG9nKFwiVE9ETyBEaWZmZXJlbnQgdHlwZSAzIFwiLHIsdHlwZW9mIHRbcF0sdHlwZW9mIGVbcF0sdFtwXSxlW3BdKSxhPU1hdGgubWF4KGEsMikpKTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlW3BdKWlmKG51bGwhPT1lW3BdKWlmKHZvaWQgMCE9PWVbcF0uc3BsaWNlKXtpZihlW3BdLmxlbmd0aD4wKWlmKHRbcF0ubGVuZ3RoPjApe3ZhciBjPTA7Zm9yKGY9MDtmPHRbcF0ubGVuZ3RoO2YrKylpZihcInN0cmluZ1wiPT10eXBlb2YgdFtwXVtmXS50eXBlKXtmb3IoO2M8ZVtwXS5sZW5ndGgmJmVbcF1bY10udHlwZSE9PXRbcF1bZl0udHlwZTspY29uc29sZS5sb2coXCJpZ25vcmluZyBcIixyLGVbcF1bY10udHlwZSxcIiBibG9jayB0eXBlIGluIHJlZmVyZW5jZSBub3QgZm91bmQgaW4gbW9kZWxcIiksYysrO2lmKGM+PWVbcF0ubGVuZ3RoKXtjb25zb2xlLmxvZyhcIldBUk4gY2Fubm90IGZpbmQgXCIscix0W3BdW2ZdLnR5cGUsXCIgYmxvY2sgaW4gcmVmZXJlbmNlXCIpLGE9TWF0aC5tYXgoYSwyKTticmVha31hPU1hdGgubWF4KGEsY2hlY2tNb2RlbChlW3BdW2NdLHZvaWQgMCx0W3BdW2ZdLHIrXCJbXCIrZitcIi5cIit0W3BdW2ZdLnR5cGUrXCJdXCIpKX19ZWxzZSBmb3IoZj0wO2Y8ZVtwXS5sZW5ndGg7ZisrKVwic3RyaW5nXCIhPXR5cGVvZiBlW3BdW2ZdLnR5cGU/KGNvbnNvbGUubG9nKFwiVE9ETyBmb3VuZCBhbiBvYmplY3Qgd2l0aCBubyB0eXBlXCIscixlW3BdW2ZdKSxhPU1hdGgubWF4KGEsMikpOmkuaGFzT3duUHJvcGVydHkoZVtwXVtmXS50eXBlKT9hPU1hdGgubWF4KGEsY2hlY2tNb2RlbChpW2VbcF1bZl0udHlwZV0saSxlW3BdW2ZdLHIrXCJbXCIrZitcIi5cIitlW3BdW2ZdLnR5cGUrXCJdXCIpKTooY29uc29sZS53YXJuKFwiVE9ETyB0aGUgbW9kZWwgdXNlcyBhIGJsb2NrIHR5cGUgbm90IGRlZmluZWQgYnkgdGhlIHRlbXBsYXRlLiBSRU1PVklORyBJVCEhXCIscixlW3BdW2ZdKSxlW3BdLnNwbGljZShmLDEpLGYtLSxhPU1hdGgubWF4KGEsMikpfWVsc2UgbnVsbD09PXRbcF0/bD8oY29uc29sZS5sb2coXCJXQVJOIE51bGwgb2JqZWN0IGluIG1vZGVsIFwiLHIsXCJpbnN0ZWFkIG9mXCIsZVtwXSxcImRlbGV0aW5nIGl0XCIpLGE9TWF0aC5tYXgoYSwyKSxkZWxldGUgZVtwXSk6KGNvbnNvbGUubG9nKFwiSU5GTyBOdWxsIG9iamVjdCBpbiBtb2RlbCBcIixyLFwiaW5zdGVhZCBvZlwiLGVbcF0sXCJjbG9uaW5nIGl0IGZyb20gdGhlIHJlZmVyZW5jZVwiKSxhPU1hdGgubWF4KGEsMSksdFtwXT1lW3BdKTphPU1hdGgubWF4KGEsY2hlY2tNb2RlbChlW3BdLGksdFtwXSxyLGwpKTtlbHNlIG51bGwhPT10W3BdJiYoY29uc29sZS5sb2coXCJUT0RPIE51bGwgaW4gcmVmZXJlbmNlIGJ1dCBub3QgbnVsbCBpbiBtb2RlbFwiLHIsdFtwXSksYT1NYXRoLm1heChhLDIpKTtlbHNlXCJzdHJpbmdcIiE9dHlwZW9mIGVbcF0mJlwiYm9vbGVhblwiIT10eXBlb2YgZVtwXSYmXCJudW1iZXJcIiE9dHlwZW9mIGVbcF0mJihjb25zb2xlLmxvZyhcIlRPRE8gdW5zdXBwb3J0ZWQgdHlwZVwiLHIsdHlwZW9mIGVbcF0pLGE9TWF0aC5tYXgoYSwyKSk7ZWxzZSBsPyhjb25zb2xlLndhcm4oXCJXQVJOIFByb3BlcnR5IFwiLHIsXCJmb3VuZCBpbiBtb2RlbCBpcyBub3QgZGVmaW5lZCBieSB0ZW1wbGF0ZTogcmVtb3ZpbmcgaXQhXCIpLGE9TWF0aC5tYXgoYSwyKSxkZWxldGUgZVtwXSk6KGNvbnNvbGUubG9nKFwiSU5GTyBQcm9wZXJ0eSBcIixyLFwibWlzc2luZyBpbiBtb2RlbCwgY2xvbmluZyBmcm9tIHJlZmVyZW5jZSFcIiksYT1NYXRoLm1heChhLDEpLHRbcF09ZVtwXSk7cmV0dXJuIGx8fChhPU1hdGgubWF4KGEsY2hlY2tNb2RlbCh0LG8sZSx2b2lkIDAhPT1uP24rXCIhUlwiOlwiIVJcIiwhMCkpKSxhfTttb2R1bGUuZXhwb3J0cz1jaGVja01vZGVsO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1Ob1pXTnJiVzlrWld3dWFuTWlYU3dpYm1GdFpYTWlPbHNpWTI5dWMyOXNaU0lzSW5KbGNYVnBjbVVpTENKamFHVmphMDF2WkdWc0lpd2ljbVZtWlhKbGJtTmxJaXdpWW14dlkydEVaV1p6SWl3aWJXOWtaV3dpTENKdmNtbG5VSEpsWm1sNElpd2ljbVYyWlhKelpTSXNJbUpzYjJOclJHVm1jMDlpYWlJc0lta2lMQ0p3Y21WbWFYZ2lMQ0oyWVd4cFpDSXNJbk53YkdsalpTSXNJbXhsYm1kMGFDSXNJblI1Y0dVaUxDSndjbTl3SWl3aWFHRnpUM2R1VUhKdmNHVnlkSGtpTENKVGRISnBibWNpTENKc2IyY2lMQ0pOWVhSb0lpd2liV0Y0SWl3aVRuVnRZbVZ5SWl3aWFpSXNJblZ1WkdWbWFXNWxaQ0lzSW5kaGNtNGlMQ0p0YjJSMWJHVWlMQ0psZUhCdmNuUnpJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3hoUVVOQkxFbEJRVWxCTEZGQlFWVkRMRkZCUVZFc2MwSkJSMnhDUXl4WFFVRmhMRk5CUVZORExFVkJRVmRETEVWQlFWZERMRVZCUVU5RExFVkJRVmxETEVkQlEycEZMRWxCUVVsRExFVkJRV05ETEVWQlFVZERMRVZCUTJwQ1F5eEZRVUZSTEVWQlJWb3NVVUZFYzBJc1NVRkJXRW9zU1VGQmQwSkJMRWRCUVZVc1VVRkRjRUlzU1VGQlpFZ3NSMEZCZDBRc2JVSkJRWEJDUVN4RlFVRlZVU3hQUVVWMlJDeEpRVVJCU2l4RlFVRmxMRWRCUTFaRExFVkJRVWtzUlVGQlIwRXNSVUZCU1V3c1JVRkJWVk1zVDBGQlVVb3NTVUZCUzBRc1JVRkJZVW9zUlVGQlZVc3NSMEZCUjBzc1RVRkJVVllzUlVGQlZVc3NVVUZGYmtaRUxFVkJRV1ZLTEVWQlJXcENMRWxCUVVzc1NVRkJTVmNzUzBGQlVWb3NSVUZEWml4SFFVRkpRU3hGUVVGVllTeGxRVUZsUkN4SFFVVXpRaXhIUVVSQlRDeFBRVUVyUWl4SlFVRm1TaXhGUVVFMlFrRXNSVUZCWVN4SlFVRk5VeXhGUVVGUFFTeEZRVU5zUlZZc1JVRkJUVmNzWlVGQlpVUXNSMEZWYmtJc1ZVRkJWMVlzUlVGQlRWVXNWMEZCWjBKYUxFVkJRVlZaTEVkQlJUVkNMRTlCUVdoQ1ZpeEZRVUZOVlN4SlFVRnpReXhQUVVGd1Fsb3NSVUZCVlZrc1MwRkRWaXhwUWtGQlpsWXNSVUZCVFZVc1IwRkRXRVVzVDBGQlQyUXNSVUZCVlZrc1MwRkJWVm9zUlVGQlZWa3NTMEZEZGtObUxGRkJRVkZyUWl4SlFVRkpMSGxDUVVFd1FsSXNVMEZCWlV3c1JVRkJUVlVzVlVGQlkxb3NSVUZCVlZrc1IwRkJUMVlzUlVGQlRWVXNSMEZCVDFvc1JVRkJWVmtzU1VGRGFraEtMRVZCUVZGUkxFdEJRVXRETEVsQlFVbFVMRVZCUVU4c1NVRkZTeXhwUWtGQlprNHNSVUZCVFZVc1IwRkRiRUpOTEU5QlFVOXNRaXhGUVVGVldTeExRVUZWV2l4RlFVRlZXU3hMUVVOMlEyWXNVVUZCVVd0Q0xFbEJRVWtzZVVKQlFUQkNVaXhUUVVGbFRDeEZRVUZOVlN4VlFVRmpXaXhGUVVGVldTeEhRVUZQVml4RlFVRk5WU3hIUVVGUFdpeEZRVUZWV1N4SlFVTnFTRW9zUlVGQlVWRXNTMEZCUzBNc1NVRkJTVlFzUlVGQlR5eExRVWN4UWxnc1VVRkJVV3RDTEVsQlFVa3NlVUpCUVRCQ1VpeFRRVUZsVEN4RlFVRk5WU3hWUVVGaldpeEZRVUZWV1N4SFFVRlBWaXhGUVVGTlZTeEhRVUZQV2l4RlFVRlZXU3hKUVVOcVNFb3NSVUZCVVZFc1MwRkJTME1zU1VGQlNWUXNSVUZCVHl4VlFVZDJRaXhIUVVFNFFpeHBRa0ZCYmtKU0xFVkJRVlZaTEVkQlF6RkNMRWRCUVhkQ0xFOUJRWEJDV2l4RlFVRlZXU3hIUVVOYUxGRkJRWE5ETEVsQlFUTkNXaXhGUVVGVldTeEhRVUZOU0N4UlFVTjZRaXhIUVVGSlZDeEZRVUZWV1N4SFFVRk5SaXhQUVVGVExFVkJRek5DTEVkQlFVbFNMRVZCUVUxVkxFZEJRVTFHTEU5QlFWTXNSVUZCUnl4RFFVVXhRaXhKUVVGSlV5eEZRVUZKTEVWQlExSXNTVUZCUzJJc1JVRkJTU3hGUVVGSFFTeEZRVUZKU2l4RlFVRk5WU3hIUVVGTlJpeFBRVUZSU2l4SlFVTnNReXhIUVVGclF5eHBRa0ZCZGtKS0xFVkJRVTFWTEVkQlFVMU9MRWRCUVVkTExFdEJRV3RDTEVOQlF6RkRMRXRCUVU5UkxFVkJRVWx1UWl4RlFVRlZXU3hIUVVGTlJpeFJRVUZWVml4RlFVRlZXU3hIUVVGTlR5eEhRVUZIVWl4UFFVRlRWQ3hGUVVGTlZTeEhRVUZOVGl4SFFVRkhTeXhOUVVNNVJXUXNVVUZCVVd0Q0xFbEJRVWtzV1VGQllWSXNSVUZCVVZBc1JVRkJWVmtzUjBGQlRVOHNSMEZCUjFJc1MwRkJUU3dyUTBGRE1VUlJMRWxCUlVZc1IwRkJTVUVzUjBGQlMyNUNMRVZCUVZWWkxFZEJRVTFHTEU5QlFWRXNRMEZETDBKaUxGRkJRVkZyUWl4SlFVRkpMRzlDUVVGeFFsSXNSVUZCVVV3c1JVRkJUVlVzUjBGQlRVNHNSMEZCUjBzc1MwRkJUU3gxUWtGRE9VUklMRVZCUVZGUkxFdEJRVXRETEVsQlFVbFVMRVZCUVU4c1IwRkRlRUlzVFVGSFJrRXNSVUZCVVZFc1MwRkJTME1zU1VGQlNWUXNSVUZCVDFRc1YwRkJWME1zUlVGQlZWa3NSMEZCVFU4c1VVRkJTVU1zUlVGQlYyeENMRVZCUVUxVkxFZEJRVTFPTEVkQlFVbERMRVZCUVZNc1NVRkJUVVFzUlVGQlNTeEpRVUZOU2l4RlFVRk5WU3hIUVVGTlRpeEhRVUZIU3l4TFFVRlBMRmxCUzNKSkxFbEJRVXRNTEVWQlFVa3NSVUZCUjBFc1JVRkJTVTRzUlVGQlZWa3NSMEZCVFVZc1QwRkJVVW9zU1VGRFF5eHBRa0ZCTlVKT0xFVkJRVlZaTEVkQlFVMU9MRWRCUVVkTExFMUJRelZDWkN4UlFVRlJhMElzU1VGQlNTeHZRMEZCY1VOU0xFVkJRVkZRTEVWQlFWVlpMRWRCUVUxT0xFbEJRM3BGUlN4RlFVRlJVU3hMUVVGTFF5eEpRVUZKVkN4RlFVRlBMRWxCUTJSSUxFVkJRV0ZSTEdWQlFXVmlMRVZCUVZWWkxFZEJRVTFPTEVkQlFVZExMRTFCVFhwRVNDeEZRVUZSVVN4TFFVRkxReXhKUVVGSlZDeEZRVUZQVkN4WFFVRlhUU3hGUVVGaFRDeEZRVUZWV1N4SFFVRk5UaXhIUVVGSFN5eE5RVUZQVGl4RlFVRmpUQ3hGUVVGVldTeEhRVUZOVGl4SFFVRkpReXhGUVVGVExFbEJRVTFFTEVWQlFVa3NTVUZCVFU0c1JVRkJWVmtzUjBGQlRVNHNSMEZCUjBzc1MwRkJUeXhQUVV3dlNtUXNVVUZCVVhkQ0xFdEJRVXNzT0VWQlFTdEZaQ3hGUVVGUlVDeEZRVUZWV1N4SFFVRk5UaXhKUVVOd1NFNHNSVUZCVlZrc1IwRkJUVWdzVDBGQlQwZ3NSVUZCUnl4SFFVTXhRa0VzU1VGRFFVVXNSVUZCVVZFc1MwRkJTME1zU1VGQlNWUXNSVUZCVHl4VFFWRmFMRTlCUVdoQ1RpeEZRVUZOVlN4SFFVTktVaXhIUVVOR1VDeFJRVUZSYTBJc1NVRkJTU3cyUWtGQk9FSlNMRVZCUVZFc1lVRkJZMUFzUlVGQlZWa3NSMEZCVHl4bFFVTnFSa29zUlVGQlVWRXNTMEZCUzBNc1NVRkJTVlFzUlVGQlR5eFZRVU5xUWxJc1JVRkJWVmtzUzBGRmFrSm1MRkZCUVZGclFpeEpRVUZKTERaQ1FVRTRRbElzUlVGQlVTeGhRVUZqVUN4RlFVRlZXU3hIUVVGUExHbERRVU5xUmtvc1JVRkJVVkVzUzBGQlMwTXNTVUZCU1ZRc1JVRkJUeXhIUVVONFFrNHNSVUZCVFZVc1IwRkJVVm9zUlVGQlZWa3NTVUZITVVKS0xFVkJRVkZSTEV0QlFVdERMRWxCUVVsVUxFVkJRVTlVTEZkQlFWZERMRVZCUVZWWkxFZEJRVTlRTEVWQlFXTklMRVZCUVUxVkxFZEJRVTlNTEVWQlFWRklMRk5CUjJ4RkxFOUJRV2hDUml4RlFVRk5WU3hMUVVObVppeFJRVUZSYTBJc1NVRkJTU3dyUTBGQlowUlNMRVZCUVZGTUxFVkJRVTFWTEVsQlF6RkZTaXhGUVVGUlVTeExRVUZMUXl4SlFVRkpWQ3hGUVVGUExGRkJSVlVzYVVKQlFYQkNVaXhGUVVGVldTeEpRVUZwUkN4clFrRkJjRUphTEVWQlFWVlpMRWxCUVd0RUxHbENRVUZ3UWxvc1JVRkJWVmtzUzBGRGVrZG1MRkZCUVZGclFpeEpRVUZKTEhkQ1FVRjVRbElzVTBGQlpWQXNSVUZCVlZrc1NVRkRPVVJLTEVWQlFWRlJMRXRCUVV0RExFbEJRVWxVTEVWQlFVOHNVMEYyUm5CQ1NpeEhRVU5HVUN4UlFVRlJkMElzUzBGQlN5eHBRa0ZCYTBKa0xFVkJRVkVzTWtSQlEzWkRReXhGUVVGUlVTeExRVUZMUXl4SlFVRkpWQ3hGUVVGUExGVkJRMnBDVWl4RlFVRlZXU3hMUVVWcVFtWXNVVUZCVVd0Q0xFbEJRVWtzYVVKQlFXdENVaXhGUVVGUkxEWkRRVU4wUTBNc1JVRkJVVkVzUzBGQlMwTXNTVUZCU1ZRc1JVRkJUeXhIUVVONFFrNHNSVUZCVFZVc1IwRkJVVm9zUlVGQlZWa3NTVUZ4Um1oRExFOUJSRXRTTEVsQlFWTkpMRVZCUVZGUkxFdEJRVXRETEVsQlFVbFVMRVZCUVU5VUxGZEJRVmRITEVWQlFVOUVMRVZCUVZkRUxFOUJRV2xETEVsQlFXWkhMRVZCUVRaQ1FTeEZRVUZoTEV0QlFVOHNUVUZCVFN4TFFVTnlTVXNzUjBGSFZHTXNUMEZCVDBNc1VVRkJWWGhDSWl3aVptbHNaU0k2SWk5d2NtbDJZWFJsTDNSdGNDOW1iMjh1UjA5RkwzTnlZeTlxY3k5amIyNTJaWEowWlhJdlkyaGxZMnR0YjJSbGJDNXFjeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGNvbnZlcnRlclV0aWxzPXJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLGNzc1BhcnNlPXJlcXVpcmUoXCJtZW5zY2gvbGliL3BhcnNlci5qc1wiKSxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIiksZG9tdXRpbHM9cmVxdWlyZShcIi4vZG9tdXRpbHMuanNcIiksX2RlY2xhcmF0aW9uVmFsdWVMb29rdXA9ZnVuY3Rpb24oZSx0LHIpe2Zvcih2YXIgbD1lLmxlbmd0aC0xO2w+PTA7bC0tKWlmKFwicHJvcGVydHlcIj09ZVtsXS50eXBlJiZlW2xdLm5hbWU9PXQpcmV0dXJuIF9kZWNsYXJhdGlvblZhbHVlVXJsUHJlZml4ZXIoZVtsXS52YWx1ZSxyKTtyZXR1cm4gbnVsbH0sX3Byb3BUb0NhbWVsQ2FzZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC8tKFthLXpdKS9nLGZ1bmN0aW9uKGUsdCxyLGwpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9KX0sX2RlY2xhcmF0aW9uVmFsdWVVcmxQcmVmaXhlcj1mdW5jdGlvbihlLHQpe3JldHVybiBlLm1hdGNoKC91cmxcXCguKlxcKS8pP2UucmVwbGFjZSgvKHVybFxcKCkoW15cXCldKikoXFwpKS9nLGZ1bmN0aW9uKGUscixsLGkpe3ZhciBuPWwudHJpbSgpLG89bC50cmltKCkuY2hhckF0KDApO1wiJ1wiPT1vfHwnXCInPT1vP249bi5zdWJzdHIoMSxuLmxlbmd0aC0yKTpvPVwiXCI7dmFyIGE9dChuKTtyZXR1cm4gbnVsbCE9PWE/citvK2ErbytpOmV9KTplfSxlbGFib3JhdGVEZWNsYXJhdGlvbnM9ZnVuY3Rpb24oZSx0LHIsbCxpLG4sbyl7dmFyIGE9XCJvYmplY3RcIj09dHlwZW9mIG4mJm51bGwhPT1uP246e30sdT1udWxsLHM9MDt2b2lkIDA9PT10JiYodD1jc3NQYXJzZShcIiN7XFxuXCIrZStcIn1cIix7Y29tbWVudHM6ITAscG9zaXRpb246ITB9KS5zdHlsZXNoZWV0LnJ1bGVzWzBdLmRlY2xhcmF0aW9ucyxzPTEpO2Zvcih2YXIgdj10Lmxlbmd0aC0xO3Y+PTA7di0tKWlmKFwicHJvcGVydHlcIj09dFt2XS50eXBlKWlmKCEwPT09byYmXCJkaXNwbGF5XCI9PXRbdl0ubmFtZSYmXCJub25lXCI9PXRbdl0udmFsdWUpbnVsbD09PXUmJih1PWUpLHU9Y29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUodSx0W3ZdLnBvc2l0aW9uLnN0YXJ0LHRbdl0ucG9zaXRpb24uZW5kLHMsMCwwLFwiXCIpO2Vsc2V7dmFyIGQ9dFt2XS5uYW1lLm1hdGNoKC9eLWtvLShiaW5kLXxhdHRyLSk/KFthLXowLTktXSo/KSgtaWZ8LWlmbm90KT8kLyk7aWYobnVsbCE9PWQpe251bGw9PT11JiZ2b2lkIDAhPT1lJiYodT1lKTt2YXIgYyxmLHAsbT1cImF0dHItXCI9PWRbMV0seT1cImJpbmQtXCI9PWRbMV0saD1kWzJdLGI9XCItaWZcIj09ZFszXXx8XCItaWZub3RcIj09ZFszXTtpZihiKXtpZihjPXRbdl0ubmFtZS5zdWJzdHIoMCx0W3ZdLm5hbWUubGVuZ3RoLWRbM10ubGVuZ3RoKSxudWxsPT09X2RlY2xhcmF0aW9uVmFsdWVMb29rdXAodCxjLHIpKXRocm93XCJVbmFibGUgdG8gZmluZCBkZWNsYXJhdGlvbiBcIitjK1wiIGZvciBcIit0W3ZdLm5hbWV9ZWxzZXtpZigobXx8eSkmJnZvaWQgMD09PWkmJnZvaWQgMCE9PWUpdGhyb3dcIkF0dHJpYnV0ZXMgYW5kIGJpbmQgZGVjbGFyYXRpb25zIGFyZSBvbmx5IGFsbG93ZWQgaW4gaW5saW5lIHN0eWxlcyFcIjt2YXIgUyxnPSEwO2lmKG0/KHA9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGksaCksZz0hMSxTPVwidmlydHVhbEF0dHJcIik6eT8oUz1udWxsLFwidGV4dFwiPT1oP3ZvaWQgMCE9PWk/cD1kb211dGlscy5nZXRJbm5lclRleHQoaSk6Zz0hMTpcImh0bWxcIj09aCYmdm9pZCAwIT09aT9wPWRvbXV0aWxzLmdldElubmVySHRtbChpKTpnPSExKTooKGc9dm9pZCAwIT09ZSkmJihwPV9kZWNsYXJhdGlvblZhbHVlTG9va3VwKHQsaCxyKSksUz1cInZpcnR1YWxTdHlsZVwiKSxnJiZudWxsPT09cCl0aHJvdyBjb25zb2xlLmVycm9yKFwiQ2Fubm90IGZpbmQgZGVmYXVsdCB2YWx1ZSBmb3JcIix0W3ZdLm5hbWUsdCksXCJDYW5ub3QgZmluZCBkZWZhdWx0IHZhbHVlIGZvciBcIit0W3ZdLm5hbWUrXCI6IFwiK3Rbdl0udmFsdWUrXCIgaW4gXCIraStcIiAoXCIrdHlwZW9mIGUrXCIvXCIraCtcIilcIjt2YXIgdz1wLFU9eXx8bT8tMSE9aC5pbmRleE9mKFwiLVwiKT9cIidcIitoK1wiJ1wiOmg6X3Byb3BUb0NhbWVsQ2FzZShoKTt0cnl7Zj1jb252ZXJ0ZXJVdGlscy5leHByZXNzaW9uQmluZGluZyh0W3ZdLnZhbHVlLGwsdyl9Y2F0Y2goZSl7dGhyb3cgY29uc29sZS5lcnJvcihcIk1vZGVsIGVuc3VyZSBwYXRoIGZhaWxlZFwiLGUuc3RhY2ssXCJuYW1lXCIsdFt2XS5uYW1lLFwidmFsdWVcIix0W3ZdLnZhbHVlLFwiZGVmYXVsdFwiLHAsXCJlbGVtZW50XCIsaSksZX1udWxsIT09UyYmdm9pZCAwPT09YVtTXSYmKGFbU109e30pLFwidmlydHVhbEF0dHJcIj09UyYmXCJocmVmXCI9PVUmJihTPW51bGwsVT1cInd5c2l3eWdIcmVmXCIsbnVsbCE9aSYmZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGksXCJocmVmXCIpKTt2YXIgeD1fZGVjbGFyYXRpb25WYWx1ZUxvb2t1cCh0LHRbdl0ubmFtZStcIi1pZlwiLHIpLF89ITE7aWYobnVsbD09PXgpeD1fZGVjbGFyYXRpb25WYWx1ZUxvb2t1cCh0LHRbdl0ubmFtZStcIi1pZm5vdFwiLHIpLF89ITA7ZWxzZSBpZihudWxsIT09X2RlY2xhcmF0aW9uVmFsdWVMb29rdXAodCx0W3ZdLm5hbWUrXCItaWZub3RcIixyKSl0aHJvd1wiVW5leHBlY3RlZCBlcnJvcjogY2Fubm90IHVzZSBib3RoIC1pZiBhbmQgLWlmbm90IHByb3BlcnR5IGNvbmRpdGlvbnNcIjtpZihudWxsIT09eCl0cnl7Zj0oXz9cIiFcIjpcIlwiKStcIihcIitjb252ZXJ0ZXJVdGlscy5jb25kaXRpb25CaW5kaW5nKHgsbCkrXCIpID8gXCIrZitcIiA6IG51bGxcIn1jYXRjaChlKXt0aHJvdyBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGRlYWwgd2l0aCAta28gc3R5bGUgYmluZGluZyBjb25kaXRpb25cIix4LHRbdl0ubmFtZSksZX1udWxsIT09Uz9hW1NdW1VdPWY6YVtVXT1mfWlmKG51bGwhPT11KXRyeXtpZihudWxsIT1pKXU9Y29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUodSx0W3ZdLnBvc2l0aW9uLnN0YXJ0LHRbdl0ucG9zaXRpb24uZW5kLHMsMCwwLFwiXCIpO2Vsc2V7dmFyIEE9XCJcIjtifHwoQT1oK1wiOiBcXHgzYyEtLSBrbyB0ZXh0OiBcIitmK1wiIC0tXFx4M2VcIitwK1wiXFx4M2MhLS0gL2tvIC0tXFx4M2VcIiksdT1jb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZSh1LHRbdl0ucG9zaXRpb24uc3RhcnQsdFt2XS5wb3NpdGlvbi5lbmQscywwLDAsQSl9fWNhdGNoKGUpe3Rocm93IGNvbnNvbGUud2FybihcIlJlbW92ZSBzdHlsZSBmYWlsZWRcIixlLFwibmFtZVwiLHRbdl0pLGV9fWVsc2V7dmFyIGs9X2RlY2xhcmF0aW9uVmFsdWVVcmxQcmVmaXhlcih0W3ZdLnZhbHVlLHIpO2lmKGshPXRbdl0udmFsdWUmJihudWxsPT09dSYmdm9pZCAwIT09ZSYmKHU9ZSksbnVsbCE9PXUpKXRyeXt1PWNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKHUsdFt2XS5wb3NpdGlvbi5zdGFydCx0W3ZdLnBvc2l0aW9uLmVuZCxzLDAsMCx0W3ZdLm5hbWUrXCI6IFwiK2spfWNhdGNoKGUpe3Rocm93IGNvbnNvbGUubG9nKFwiUmVtb3ZlIHN0eWxlIGZhaWxlZCByZXBsYWNpbmcgdXJsXCIsZSxcIm5hbWVcIix0W3ZdKSxlfXZhciBDPV9wcm9wVG9DYW1lbENhc2UodFt2XS5uYW1lKSxWPVwidmlydHVhbEF0dHJTdHlsZVwiLFA9dm9pZCAwIT09YS52aXJ0dWFsU3R5bGU/YS52aXJ0dWFsU3R5bGVbQ106dm9pZCAwLGo9XCIgXCI7dm9pZCAwPT09YVtWXSYmKGFbVl09XCInJ1wiLGo9XCJcIiksdm9pZCAwIT09UD8oYVtWXT1cIidcIit0W3ZdLm5hbWUrXCI6ICcrKFwiK1ArXCIpKyc7XCIraitcIicrXCIrYVtWXSxkZWxldGUgYS52aXJ0dWFsU3R5bGVbQ10pOmFbVl09XCInXCIrdFt2XS5uYW1lK1wiOiBcIitjb252ZXJ0ZXJVdGlscy5hZGRTbGFzaGVzKGspK1wiO1wiK2orXCInK1wiK2FbVl19fWlmKG51bGwhPWkpe2Zvcih2YXIgeiBpbiBhLnZpcnR1YWxTdHlsZSlpZihhLnZpcnR1YWxTdHlsZS5oYXNPd25Qcm9wZXJ0eSh6KSl0aHJvdyBjb25zb2xlLmxvZyhcIlVuZXhwZWN0ZWQgdmlydHVhbFN0eWxlIGJpbmRpbmcgYWZ0ZXIgY29udmVyc2lvbiB0byB2aXJ0dWFsQXR0ci5zdHlsZVwiLHosYS52aXJ0dWFsU3R5bGVbel0sZSksXCJVbmV4cGVjdGVkIHZpcnR1YWxTdHlsZSBiaW5kaW5nIGFmdGVyIGNvbnZlcnNpb24gdG8gdmlydHVhbEF0dHIuc3R5bGUgZm9yIFwiK3o7ZGVsZXRlIGEudmlydHVhbFN0eWxlO3ZhciBMPWRvbXV0aWxzLmdldEF0dHJpYnV0ZShpLFwiZGF0YS1iaW5kXCIpLHE9KG51bGwhPT1MP0wrXCIsIFwiOlwiXCIpK19iaW5kaW5nU2VyaWFsaXplcihhKTtkb211dGlscy5zZXRBdHRyaWJ1dGUoaSxcImRhdGEtYmluZFwiLHEpfWlmKHZvaWQgMD09PWUpe3ZhciBPPSExO2Zvcih2YXIgVCBpbiBhLnZpcnR1YWxTdHlsZSlpZihhLnZpcnR1YWxTdHlsZS5oYXNPd25Qcm9wZXJ0eShUKSl7Tz0hMDticmVha31pZihPKXtpZih2b2lkIDAhPT1hLnZpcnR1YWxBdHRyU3R5bGUpe3ZhciBCPWEudmlydHVhbEF0dHJTdHlsZTtkZWxldGUgYS52aXJ0dWFsQXR0clN0eWxlLGEudmlydHVhbEF0dHJTdHlsZT1CfX1lbHNlIGRlbGV0ZSBhLnZpcnR1YWxTdHlsZTtyZXR1cm4gX2JpbmRpbmdTZXJpYWxpemVyKGEpfXJldHVybiB1fSxfYmluZGluZ1NlcmlhbGl6ZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciByIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShyKSYmKFwib2JqZWN0XCI9PXR5cGVvZiBlW3JdP3QucHVzaChyK1wiOiB7IFwiK19iaW5kaW5nU2VyaWFsaXplcihlW3JdKStcIiB9XCIpOnQucHVzaChyK1wiOiBcIitlW3JdKSk7cmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4oXCIsIFwiKX07bW9kdWxlLmV4cG9ydHM9ZWxhYm9yYXRlRGVjbGFyYXRpb25zO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1SbFkyeGhjbUYwYVc5dWN5NXFjeUpkTENKdVlXMWxjeUk2V3lKamIyNTJaWEowWlhKVmRHbHNjeUlzSW5KbGNYVnBjbVVpTENKamMzTlFZWEp6WlNJc0ltTnZibk52YkdVaUxDSmtiMjExZEdsc2N5SXNJbDlrWldOc1lYSmhkR2x2YmxaaGJIVmxURzl2YTNWd0lpd2laR1ZqYkdGeVlYUnBiMjV6SWl3aWNISnZjR1Z5ZEhsdVlXMWxJaXdpZEdWdGNHeGhkR1ZWY214RGIyNTJaWEowWlhJaUxDSnBJaXdpYkdWdVozUm9JaXdpZEhsd1pTSXNJbTVoYldVaUxDSmZaR1ZqYkdGeVlYUnBiMjVXWVd4MVpWVnliRkJ5WldacGVHVnlJaXdpZG1Gc2RXVWlMQ0pmY0hKdmNGUnZRMkZ0Wld4RFlYTmxJaXdpY0hKdmNFNWhiV1VpTENKeVpYQnNZV05sSWl3aWJXRjBZMmdpTENKamIyNTBaVzUwY3lJc0ltOW1abk5sZENJc0luTWlMQ0owYjFWd2NHVnlRMkZ6WlNJc0ltMWhkR05vWldRaUxDSndjbVZtYVhnaUxDSjFjbXdpTENKd2IzTjBabWw0SWl3aWRISnBiVzFsWkNJc0luUnlhVzBpTENKaGNHbGpaU0lzSW1Ob1lYSkJkQ0lzSW5OMVluTjBjaUlzSW01bGQxVnliQ0lzSW1Wc1lXSnZjbUYwWlVSbFkyeGhjbUYwYVc5dWN5SXNJbk4wZVd4bElpd2lZbWx1WkdsdVoxQnliM1pwWkdWeUlpd2laV3hsYldWdWRDSXNJbUpoYzJsalFtbHVaR2x1WjNNaUxDSnlaVzF2ZG1WRWFYTndiR0Y1VG05dVpTSXNJbTVsZDBKcGJtUnBibWR6SWl3aWJtVjNVM1I1YkdVaUxDSnphMmx3VEdsdVpYTWlMQ0pqYjIxdFpXNTBjeUlzSW5CdmMybDBhVzl1SWl3aWMzUjViR1Z6YUdWbGRDSXNJbkoxYkdWeklpd2ljbVZ0YjNabFUzUjViR1VpTENKemRHRnlkQ0lzSW1WdVpDSXNJbVJsWTJ3aUxDSmpiMjVrUkdWamJDSXNJbUpwYm1SV1lXeDFaU0lzSW5CeWIzQkVaV1poZFd4MFZtRnNkV1VpTENKcGMwRjBkSElpTENKcGMwSnBibVFpTENKcGMwbG1JaXdpWW1sdVpGUjVjR1VpTENKdVpXVmtSR1ZtWVhWc2RGWmhiSFZsSWl3aVoyVjBRWFIwY21saWRYUmxJaXdpWjJWMFNXNXVaWEpVWlhoMElpd2laMlYwU1c1dVpYSklkRzFzSWl3aVpYSnliM0lpTENKaWFXNWtSR1ZtWVhWc2RGWmhiSFZsSWl3aVltbHVaRTVoYldVaUxDSnBibVJsZUU5bUlpd2laWGh3Y21WemMybHZia0pwYm1ScGJtY2lMQ0psSWl3aWMzUmhZMnNpTENKeVpXMXZkbVZCZEhSeWFXSjFkR1VpTENKa1pXTnNZWEpoZEdsdmJrTnZibVJwZEdsdmJpSXNJbTV2ZENJc0ltTnZibVJwZEdsdmJrSnBibVJwYm1jaUxDSnlaWEJzWVdObFpGZHBkR2dpTENKM1lYSnVJaXdpY21Wd2JHRmpaV1JXWVd4MVpTSXNJbXh2WnlJc0ltSnBibVJPWVcxbE1pSXNJbUpwYm1RaUxDSmlhVzVrVm1Gc01pSXNJblZ1WkdWbWFXNWxaQ0lzSW1ScGMzUWlMQ0poWkdSVGJHRnphR1Z6SWl3aWNISnZjQ0lzSW1oaGMwOTNibEJ5YjNCbGNuUjVJaXdpWTNWeWNtVnVkRUpwYm1ScGJtZHpJaXdpWkdGMFlVSnBibVFpTENKZlltbHVaR2x1WjFObGNtbGhiR2w2WlhJaUxDSnpaWFJCZEhSeWFXSjFkR1VpTENKb1lYTldhWEowZFdGc1UzUjViR1VpTENKd2NtOXdNU0lzSW5aeklpd2lkbUZzSWl3aWNtVnpJaXdpY0hWemFDSXNJbkpsZG1WeWMyVWlMQ0pxYjJsdUlpd2liVzlrZFd4bElpd2laWGh3YjNKMGN5SmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNZVUZOUVN4SlFVRkpRU3hsUVVGcFFrTXNVVUZCVVN4alFVTjZRa01zVTBGQlYwUXNVVUZCVVN4M1FrRkRia0pGTEZGQlFWVkdMRkZCUVZFc2MwSkJRMnhDUnl4VFFVRlhTQ3hSUVVGUkxHbENRVVZ1UWtrc2QwSkJRVEJDTEZOQlFWTkRMRVZCUVdORExFVkJRV05ETEVkQlEycEZMRWxCUVVzc1NVRkJTVU1zUlVGQlNVZ3NSVUZCWVVrc1QwRkJVeXhGUVVGSFJDeEhRVUZMTEVWQlFVZEJMRWxCUXpWRExFZEJRVFJDTEZsQlFYaENTQ3hGUVVGaFJ5eEhRVUZIUlN4TlFVRnpRa3dzUlVGQllVY3NSMEZCUjBjc1RVRkJVVXdzUlVGRGFFVXNUMEZCVDAwc05rSkJRVFpDVUN4RlFVRmhSeXhIUVVGSFN5eE5RVUZQVGl4SFFVY3ZSQ3hQUVVGUExFMUJSMHhQTEdsQ1FVRnRRaXhUUVVGVFF5eEhRVU01UWl4UFFVRlBRU3hGUVVGVFF5eFJRVUZSTEZsQlFXRXNVMEZCVTBNc1JVRkJUME1zUlVGQlZVTXNSVUZCVVVNc1IwRkRja1VzVDBGQlQwWXNSVUZCVTBjc2FVSkJTV2hDVkN3MlFrRkJLMElzVTBGQlUwTXNSVUZCVDA0c1IwRkRha1FzVDBGQlNVMHNSVUZCVFVrc1RVRkJUU3hoUVVORFNpeEZRVUZOUnl4UlFVRlJMSFZDUVVGM1FpeFRRVUZUVFN4RlFVRlRReXhGUVVGUlF5eEZRVUZMUXl4SFFVTnNSaXhKUVVGSlF5eEZRVUZWUml4RlFVRkpSeXhQUVVOa1F5eEZRVUZSU2l4RlFVRkpSeXhQUVVGUFJTeFBRVUZQTEVkQlEycENMRXRCUVZSRUxFZEJRVEJDTEV0QlFWUkJMRVZCUTI1Q1JpeEZRVUZWUVN4RlFVRlJTU3hQUVVGUExFVkJRVWRLTEVWQlFWRnFRaXhQUVVGVExFZEJSVGREYlVJc1JVRkJVU3hIUVVWV0xFbEJRVWxITEVWQlFWTjRRaXhGUVVGeFFtMUNMRWRCUTJ4RExFOUJRV1VzVDBGQldFc3NSVUZEUzFJc1JVRkJVMHNzUlVGQlVVY3NSVUZCVTBnc1JVRkJVVWdzUlVGRmJFTklMRWxCUzBwVUxFZEJTVkJ0UWl4elFrRkJkMElzVTBGQlUwTXNSVUZCVHpWQ0xFVkJRV05GTEVWQlFYTkNNa0lzUlVGQmFVSkRMRVZCUVZORExFVkJRV1ZETEVkQlEzWklMRWxCUVVsRExFVkJRWE5ETEdsQ1FVRnFRa1lzUjBGQkswTXNUMEZCYkVKQkxFVkJRWGxDUVN4RlFVRm5RaXhIUVVNelJrY3NSVUZCVnl4TFFVTllReXhGUVVGWkxFOUJRMWNzU1VGQmFFSnVReXhKUVV0VVFTeEZRVXBwUWtvc1UwRkJVeXhQUVVGVFowTXNSVUZCVVN4SlFVRkxMRU5CUXpsRFVTeFZRVUZWTEVWQlExWkRMRlZCUVZVc1NVRkZZME1zVjBGQlYwTXNUVUZCVFN4SFFVRkhka01zWVVGRE9VTnRReXhGUVVGWkxFZEJSV1FzU1VGQlN5eEpRVUZKYUVNc1JVRkJTVWdzUlVGQllVa3NUMEZCVXl4RlFVRkhSQ3hIUVVGTExFVkJRVWRCTEVsQlF6VkRMRWRCUVRSQ0xGbEJRWGhDU0N4RlFVRmhSeXhIUVVGSFJTeExRVU5zUWl4SlFVRXdRaXhKUVVGMFFqSkNMRWRCUVhORUxGZEJRWGhDYUVNc1JVRkJZVWNzUjBGQlIwY3NUVUZCT0VNc1VVRkJla0pPTEVWQlFXRkhMRWRCUVVkTExFMUJRM0JGTEU5QlFXSXdRaXhKUVVGdFFrRXNSVUZCVjA0c1IwRkRiRU5OTEVWQlFWZDRReXhsUVVGbE9FTXNXVUZCV1U0c1JVRkJWV3hETEVWQlFXRkhMRWRCUVVkclF5eFRRVUZUU1N4TlFVRlBla01zUlVGQllVY3NSMEZCUjJ0RExGTkJRVk5MTEVsQlFVdFFMRVZCUVZjc1JVRkJSeXhGUVVGSExGRkJRekZJTEVOQlEwd3NTVUZCU1ZFc1JVRkJUek5ETEVWQlFXRkhMRWRCUVVkSExFdEJRVXROTEUxQlFVMHNhMFJCUTNSRExFZEJRV0VzVDBGQlZDdENMRVZCUVdVc1EwRkZRU3hQUVVGaVZDeFJRVUZ4UXl4SlFVRlVUaXhKUVVGelFrMHNSVUZCVjA0c1IwRkZha1VzU1VGTFNXZENMRVZCUTBGRExFVkJRMEZETEVWQlVFRkRMRVZCUVc5Q0xGTkJRVmhLTEVWQlFVc3NSMEZEWkVzc1JVRkJiMElzVTBGQldFd3NSVUZCU3l4SFFVTmtha01zUlVGQlYybERMRVZCUVVzc1IwRkZhRUpOTEVWQlFXdENMRTlCUVZoT0xFVkJRVXNzU1VGQk1FSXNWVUZCV0VFc1JVRkJTeXhIUVV0d1F5eEhRVUZKVFN4RlFVRk5MRU5CUjFJc1IwRkdRVXdzUlVGQlZ6VkRMRVZCUVdGSExFZEJRVWRITEV0QlFVdHRRaXhQUVVGUExFVkJRVWQ2UWl4RlFVRmhSeXhIUVVGSFJ5eExRVUZMUml4UFFVRlRkVU1zUlVGQlN5eEhRVUZIZGtNc1VVRkZha1FzVDBGRVJrd3NkMEpCUVhkQ1F5eEZRVUZqTkVNc1JVRkJWVEZETEVkQlEzaERMRXRCUVUwc09FSkJRV2RETUVNc1JVRkJWeXhSUVVGVk5VTXNSVUZCWVVjc1IwRkJSMGNzVTBGRE0wY3NRMEZGVEN4SlFVRkxlVU1zUjBGQlZVTXNVMEZCT0VJc1NVRkJXR3hDTEZGQlFUQkRMRWxCUVZSR0xFVkJRWFZDTEV0QlFVMHNjMFZCUldoSExFbEJRMGx6UWl4RlFVUkJReXhIUVVGdFFpeEZRVFpDZGtJc1IwRXpRa2xLTEVkQlEwWkVMRVZCUVcxQ2FFUXNVMEZCVTNORUxHRkJRV0YwUWl4RlFVRlRjRUlzUjBGRGJFUjVReXhIUVVGdFFpeEZRVU51UWtRc1JVRkJWeXhsUVVORVJpeEhRVXRXUlN4RlFVRlhMRXRCUTBzc1VVRkJXbmhETEU5QlEzRkNMRWxCUVZwdlFpeEZRVU5VWjBJc1JVRkJiVUpvUkN4VFFVRlRkVVFzWVVGQllYWkNMRWRCUlhwRGNVSXNSMEZCYlVJc1JVRkZRU3hSUVVGYWVrTXNVVUZEWXl4SlFVRmFiMElzUlVGRFZHZENMRVZCUVcxQ2FFUXNVMEZCVTNkRUxHRkJRV0Y0UWl4SFFVc3pRM0ZDTEVkQlFXMUNMRXRCYkVKeVFrRXNUMEZCYjBNc1NVRkJWblpDTEV0QlEwcHJRaXhGUVVGdFFpOURMSGRDUVVGM1FrTXNSVUZCWTFVc1JVRkJWVklzU1VGRGVrWm5SQ3hGUVVGWExHZENRVzlDVkVNc1IwRkJlVU1zVDBGQmNrSk1MRVZCUlhSQ0xFMUJSRUZxUkN4UlFVRlJNRVFzVFVGQlRTeG5RMEZCYVVOMlJDeEZRVUZoUnl4SFFVRkhSeXhMUVVGTlRpeEhRVU12UkN4cFEwRkJiVU5CTEVWQlFXRkhMRWRCUVVkSExFdEJRVThzUzBGQlQwNHNSVUZCWVVjc1IwRkJSMHNzVFVGQlVTeFBRVUZUYzBJc1JVRkJWU3haUVVGalJpeEZRVUZSTEVsQlFVMXNRaXhGUVVGWExFbEJSVE5LTEVsQlFVazRReXhGUVVGdFFsWXNSVUZGYmtKWExFVkJRVmxVTEVkQlFWZEVMRWRCUVdsRkxFZEJRVEZDY2tNc1JVRkJVMmRFTEZGQlFWRXNTMEZCWVN4SlFVRkxhRVFzUlVGQlV5eEpRVUZQUVN4RlFVRnFSa1FzYVVKQlFXbENReXhIUVVWeVJDeEpRVU5GYlVNc1JVRkJXVzVFTEdWQlFXVnBSU3hyUWtGQmEwSXpSQ3hGUVVGaFJ5eEhRVUZIU3l4TlFVRlBjVUlzUlVGQmFVSXlRaXhIUVVOeVJpeE5RVUZQU1N4SFFVVlFMRTFCUkVFdlJDeFJRVUZSTUVRc1RVRkJUU3d5UWtGQk5FSkxMRVZCUVVWRExFMUJRVThzVDBGQlVUZEVMRVZCUVdGSExFZEJRVWRITEV0QlFVMHNVVUZCVTA0c1JVRkJZVWNzUjBGQlIwc3NUVUZCVHl4VlFVRlhjME1zUlVGQmEwSXNWVUZCVjJoQ0xFZEJRMjVLT0VJc1JVRkhVeXhQUVVGaVZpeFJRVUZ4UkN4SlFVRjZRbXBDTEVWQlFWbHBRaXhMUVVFd1FtcENMRVZCUVZscFFpeEhRVUZaTEVsQlNUbEZMR1ZCUVZwQkxFZEJRWGxETEZGQlFWcFBMRWxCUXk5Q1VDeEZRVUZYTEV0QlExaFBMRVZCUVZjc1kwRkZVQ3hOUVVGUE0wSXNSMEZEVkdoRExGTkJRVk5uUlN4blFrRkJaMEpvUXl4RlFVRlRMRk5CVFhSRExFbEJRVWxwUXl4RlFVRjFRbWhGTEhkQ1FVRjNRa01zUlVGQlkwRXNSVUZCWVVjc1IwRkJSMGNzUzBGQlR5eE5RVUZQU2l4SFFVTXpSamhFTEVkQlFVMHNSVUZEVml4SFFVRTJRaXhQUVVGNlFrUXNSVUZEUmtFc1JVRkJkVUpvUlN4M1FrRkJkMEpETEVWQlFXTkJMRVZCUVdGSExFZEJRVWRITEV0QlFVOHNVMEZCVlVvc1IwRkRPVVk0UkN4SFFVRk5MRTlCUlU0c1IwRkJjVWNzVDBGQmFrZHFSU3gzUWtGQmQwSkRMRVZCUVdOQkxFVkJRV0ZITEVkQlFVZEhMRXRCUVU4c1UwRkJWVW9zUjBGRGVrVXNTMEZCVFN4MVJVRkhWaXhIUVVFMlFpeFBRVUY2UWpaRUxFVkJRMFlzU1VGRlJXeENMRWRCUVdGdFFpeEZRVUZOTEVsQlFVMHNTVUZCVFN4SlFVUmlkRVVzWlVGQlpYVkZMR2xDUVVGcFFrWXNSVUZCYzBKc1F5eEhRVU55UWl4UFFVRlRaMElzUlVGQldTeFZRVU40UlN4TlFVRlBaU3hIUVVWUUxFMUJSRUV2UkN4UlFVRlJNRVFzVFVGQlRTeHJSRUZCYlVSUkxFVkJRWE5DTDBRc1JVRkJZVWNzUjBGQlIwY3NUVUZEYWtkelJDeEZRVWxQTEU5QlFXSldMRVZCUVcxQ2FrSXNSVUZCV1dsQ0xFZEJRVlZQTEVkQlFWbGFMRVZCUTNCRVdpeEZRVUZaZDBJc1IwRkJXVm9zUlVGSkwwSXNSMEZCYVVJc1QwRkJZbGdzUlVGRlJpeEpRVVZGTEVkQlFVa3NUVUZCVDBvc1JVRkRWRWtzUlVGQlYzaERMR1ZCUVdVNFF5eFpRVUZaVGl4RlFVRlZiRU1zUlVGQllVY3NSMEZCUjJ0RExGTkJRVk5KTEUxQlFVOTZReXhGUVVGaFJ5eEhRVUZIYTBNc1UwRkJVMHNzU1VGQlMxQXNSVUZCVnl4RlFVRkhMRVZCUVVjc1VVRkRNVWdzUTBGRlRDeEpRVUZKSzBJc1JVRkJaU3hIUVVWa2FrSXNTVUZCVFdsQ0xFVkJRV1Y0UkN4RlFVRlhMSE5DUVVGeFFtMURMRVZCUVZrc1ZVRkJVME1zUlVGQmJVSXNjMEpCUTJ4SFdpeEZRVUZYZUVNc1pVRkJaVGhETEZsQlFWbE9MRVZCUVZWc1F5eEZRVUZoUnl4SFFVRkhhME1zVTBGQlUwa3NUVUZCVDNwRExFVkJRV0ZITEVkQlFVZHJReXhUUVVGVFN5eEpRVUZMVUN4RlFVRlhMRVZCUVVjc1JVRkJSeXRDTEVsQlJXcEpMRTFCUVU5T0xFZEJSVkFzVFVGRVFTOUVMRkZCUVZGelJTeExRVUZMTEhOQ1FVRjFRbEFzUlVGQlJ5eFBRVUZSTlVRc1JVRkJZVWNzU1VGRGRFUjVSQ3hQUVV0TUxFTkJSVXdzU1VGQlNWRXNSVUZCWjBJM1JDdzJRa0ZCTmtKUUxFVkJRV0ZITEVkQlFVZExMRTFCUVU5T0xFZEJRM2hGTEVkQlFVbHJSU3hIUVVGcFFuQkZMRVZCUVdGSExFZEJRVWRMTEZGQlEyeENMRTlCUVdJd1FpeFJRVUZ6UXl4SlFVRldUaXhKUVVGMVFrMHNSVUZCVjA0c1IwRkRha1FzVDBGQllrMHNSMEZEUml4SlFVTkZRU3hGUVVGWGVFTXNaVUZCWlRoRExGbEJRVmxPTEVWQlFWVnNReXhGUVVGaFJ5eEhRVUZIYTBNc1UwRkJVMGtzVFVGQlQzcERMRVZCUVdGSExFZEJRVWRyUXl4VFFVRlRTeXhKUVVGTFVDeEZRVUZYTEVWQlFVY3NSVUZCUjI1RExFVkJRV0ZITEVkQlFVZEhMRXRCUVU4c1MwRkJUemhFTEVkQlF6ZEtMRTFCUVU5U0xFZEJSVkFzVFVGRVFTOUVMRkZCUVZGM1JTeEpRVUZKTEc5RFFVRnhRMVFzUlVGQlJ5eFBRVUZSTlVRc1JVRkJZVWNzU1VGRGJrVjVSQ3hGUVUxYUxFbEJRVWxWTEVWQlFWazNSQ3hwUWtGQmFVSlVMRVZCUVdGSExFZEJRVWRITEUxQlF6ZERhVVVzUlVGQlR5eHRRa0ZEVUVNc1QwRkJhMFFzU1VGQmFFTjJReXhGUVVFd1FpeGhRVUZ2UWtFc1JVRkJNRUlzWVVGQlJYRkRMRkZCUVdGSExFVkJSWHBIUXl4RlFVRlBMRk5CUTNGQ0xFbEJRWEpDZWtNc1JVRkJXWE5ETEV0QlEzSkNkRU1zUlVGQldYTkRMRWRCUVZFc1MwRkRjRUpITEVWQlFVOHNVMEZIWlN4SlFVRmlSaXhIUVVOVWRrTXNSVUZCV1hORExFZEJRVkVzU1VGQlRYWkZMRVZCUVdGSExFZEJRVWRITEV0QlFVOHNVVUZCVld0RkxFVkJRVmNzVDBGQlUwVXNSVUZCVHl4TFFVRlBla01zUlVGQldYTkRMRlZCUTJ4SGRFTXNSVUZCTUVJc1lVRkJSWEZETEVsQlJXNURja01zUlVGQldYTkRMRWRCUVZFc1NVRkJUWFpGTEVWQlFXRkhMRWRCUVVkSExFdEJRVThzUzBGQlQxb3NaVUZCWldsR0xGZEJRVmRRTEVkQlFXbENMRWxCUVUxTkxFVkJRVThzUzBGQlQzcERMRVZCUVZselF5eEpRVTgzU1N4SFFVRkpMRTFCUVU5NlF5eEZRVUUwUXl4RFFVTnlSQ3hKUVVGTExFbEJRVWs0UXl4TFFVRlJNME1zUlVGQk1FSXNZVUZEZWtNc1IwRkJTVUVzUlVGQk1FSXNZVUZCUlRSRExHVkJRV1ZFTEVkQlJUZERMRTFCUkVFdlJTeFJRVUZSZDBVc1NVRkJTU3gzUlVGQmVVVlBMRVZCUVUwelF5eEZRVUV3UWl4aFFVRkZNa01zUjBGQlQyaEVMRWRCUTNoSUxEWkZRVUVyUldkRUxGTkJSV3hHTTBNc1JVRkJNRUlzWVVGRmFrTXNTVUZCU1RaRExFVkJRV3RDYUVZc1UwRkJVM05FTEdGQlFXRjBRaXhGUVVGVExHRkJRMnBFYVVRc1IwRkJaME1zVDBGQmNFSkVMRVZCUVRKQ1FTeEZRVUZyUWl4TFFVRlBMRWxCUVUxRkxHMUNRVUZ0UWk5RExFZEJRemRHYmtNc1UwRkJVMjFHTEdGQlFXRnVSQ3hGUVVGVExGbEJRV0ZwUkN4SFFVazVReXhSUVVGdlFpeEpRVUZVYmtRc1JVRkJjMElzUTBGRkwwSXNTVUZCU1hORUxFZEJRV3RDTEVWQlEzUkNMRWxCUVVzc1NVRkJTVU1zUzBGQlUyeEVMRVZCUVRCQ0xHRkJRekZETEVkQlFVbEJMRVZCUVRCQ0xHRkJRVVUwUXl4bFFVRmxUU3hIUVVGUkxFTkJRM0pFUkN4SFFVRnJRaXhGUVVOc1FpeE5RVVZLTEVkQlFVdEJMRWRCUjBnc1VVRkJLME1zU1VGQmNFTnFSQ3hGUVVFNFFpeHBRa0ZCYlVJc1EwRkRNVVFzU1VGQlNXMUVMRVZCUVV0dVJDeEZRVUU0UWl4M1FrRkRhRU5CTEVWQlFUaENMR2xDUVVOeVEwRXNSVUZCT0VJc2FVSkJRVWx0UkN4bFFVNVVia1FzUlVGQk1FSXNZVUZWZGtRc1QwRkJUeXRETEcxQ1FVRnRRaTlETEVkQlJ6VkNMRTlCUVU5RExFZEJSMHc0UXl4dFFrRkJjVUlzVTBGQlUwc3NSMEZEYUVNc1NVRkJTVU1zUlVGQlRTeEhRVU5XTEVsQlFVc3NTVUZCU1ZZc1MwRkJVVk1zUlVGRFdFRXNSVUZCU1ZJc1pVRkJaVVFzUzBGRFJ5eHBRa0ZCWWxNc1JVRkJTVlFzUjBGQmJVSlZMRVZCUVVsRExFdEJRVXRZTEVWQlFVOHNUMEZCWTBrc2JVSkJRVzFDU3l4RlFVRkpWQ3hKUVVGVExFMUJRek5HVlN4RlFVRkpReXhMUVVGTFdDeEZRVUZQTEV0QlFVOVRMRVZCUVVsVUxFdEJSWEJETEU5QlFVOVZMRVZCUVVsRkxGVkJRVlZETEV0QlFVc3NUMEZITlVKRExFOUJRVTlETEZGQlFWVm9SU0lzSW1acGJHVWlPaUl2Y0hKcGRtRjBaUzkwYlhBdlptOXZMa2RQUlM5emNtTXZhbk12WTI5dWRtVnlkR1Z5TDJSbFkyeGhjbUYwYVc5dWN5NXFjeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyICQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeTpudWxsO2Z1bmN0aW9uIF9leHRlbmQoZSx0KXtpZih0KWZvcih2YXIgbiBpbiB0KXQuaGFzT3duUHJvcGVydHkobikmJihlW25dPXRbbl0pO3JldHVybiBlfXZhciBvYmpFeHRlbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiAkLmV4dGVuZD8kLmV4dGVuZCghMCxlLHQpOl9leHRlbmQoZSxKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQpKSl9LGdldEF0dHJpYnV0ZT1mdW5jdGlvbihlLHQpe3ZhciBuPSQoZSkuYXR0cih0KTtyZXR1cm4gdm9pZCAwPT09biYmKG49bnVsbCksbn0sc2V0QXR0cmlidXRlPWZ1bmN0aW9uKGUsdCxuKXskKGUpLmF0dHIodCxuKX0scmVtb3ZlQXR0cmlidXRlPWZ1bmN0aW9uKGUsdCl7JChlKS5yZW1vdmVBdHRyKHQpfSxnZXRJbm5lclRleHQ9ZnVuY3Rpb24oZSl7cmV0dXJuICQoZSkudGV4dCgpfSxnZXRJbm5lckh0bWw9ZnVuY3Rpb24oZSl7cmV0dXJuICQoZSkuaHRtbCgpfSxnZXRMb3dlclRhZ05hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJcIj09PWUudGFnTmFtZSYmXCJzdHJpbmdcIj09dHlwZW9mIGUubmFtZT9lLm5hbWUudG9Mb3dlckNhc2UoKTpcIlwiIT09ZS50YWdOYW1lP2UudGFnTmFtZS50b0xvd2VyQ2FzZSgpOiQoZSkucHJvcChcInRhZ05hbWVcIikudG9Mb3dlckNhc2UoKX0sc2V0Q29udGVudD1mdW5jdGlvbihlLHQpeyQoZSkuaHRtbCh0KX0scmVwbGFjZUh0bWw9ZnVuY3Rpb24oZSx0KXskKGUpLnJlcGxhY2VXaXRoKHQpfSxyZW1vdmVFbGVtZW50cz1mdW5jdGlvbihlLHQpe3QmJnZvaWQgMCE9PWUuZGV0YWNoJiZlLmRldGFjaCgpLGUucmVtb3ZlKCl9O21vZHVsZS5leHBvcnRzPXtnZXRBdHRyaWJ1dGU6Z2V0QXR0cmlidXRlLHNldEF0dHJpYnV0ZTpzZXRBdHRyaWJ1dGUscmVtb3ZlQXR0cmlidXRlOnJlbW92ZUF0dHJpYnV0ZSxnZXRJbm5lclRleHQ6Z2V0SW5uZXJUZXh0LGdldElubmVySHRtbDpnZXRJbm5lckh0bWwsZ2V0TG93ZXJUYWdOYW1lOmdldExvd2VyVGFnTmFtZSxzZXRDb250ZW50OnNldENvbnRlbnQscmVwbGFjZUh0bWw6cmVwbGFjZUh0bWwscmVtb3ZlRWxlbWVudHM6cmVtb3ZlRWxlbWVudHMsb2JqRXh0ZW5kOm9iakV4dGVuZH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbVJ2YlhWMGFXeHpMbXB6SWwwc0ltNWhiV1Z6SWpwYklpUWlMQ0ozYVc1a2IzY2lMQ0puYkc5aVlXd2lMQ0pmWlhoMFpXNWtJaXdpZEdGeVoyVjBJaXdpYzI5MWNtTmxJaXdpY0hKdmNDSXNJbWhoYzA5M2JsQnliM0JsY25SNUlpd2liMkpxUlhoMFpXNWtJaXdpYjJKcUlpd2laWGgwWlc1a1pYSWlMQ0psZUhSbGJtUWlMQ0pLVTA5T0lpd2ljR0Z5YzJVaUxDSnpkSEpwYm1kcFpua2lMQ0puWlhSQmRIUnlhV0oxZEdVaUxDSmxiR1Z0Wlc1MElpd2lZWFIwY21saWRYUmxJaXdpY21Weklpd2lZWFIwY2lJc0luTmxkRUYwZEhKcFluVjBaU0lzSW5aaGJIVmxJaXdpY21WdGIzWmxRWFIwY21saWRYUmxJaXdpY21WdGIzWmxRWFIwY2lJc0ltZGxkRWx1Ym1WeVZHVjRkQ0lzSW5SbGVIUWlMQ0puWlhSSmJtNWxja2gwYld3aUxDSm9kRzFzSWl3aVoyVjBURzkzWlhKVVlXZE9ZVzFsSWl3aWRHRm5UbUZ0WlNJc0ltNWhiV1VpTENKMGIweHZkMlZ5UTJGelpTSXNJbk5sZEVOdmJuUmxiblFpTENKamIyNTBaVzUwSWl3aWNtVndiR0ZqWlVoMGJXd2lMQ0p5WlhCc1lXTmxWMmwwYUNJc0luSmxiVzkyWlVWc1pXMWxiblJ6SWl3aUpHVnNaVzFsYm5Seklpd2lkSEo1UkdWMFlXTm9JaXdpWkdWMFlXTm9JaXdpY21WdGIzWmxJaXdpYlc5a2RXeGxJaXdpWlhod2IzSjBjeUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzWVVGTlFTeEpRVUZKUVN4RlFVRjFRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRV1VzVDBGQmMwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVVrc1MwRkZMMGNzVTBGQlUwTXNVVUZCVVVNc1JVRkJVVU1zUjBGRGRrSXNSMEZCU1VFc1JVRkRSaXhKUVVGTExFbEJRVWxETEV0QlFWRkVMRVZCUTFoQkxFVkJRVTlGTEdWQlFXVkVMRXRCUTNoQ1JpeEZRVUZQUlN4SFFVRlJSQ3hGUVVGUFF5eEpRVWsxUWl4UFFVRlBSaXhGUVVkVUxFbEJRVWxKTEZWQlFWa3NVMEZCVTBNc1JVRkJTME1zUjBGRE5VSXNUVUZCZFVJc2JVSkJRVnBXTEVWQlFVVlhMRTlCUTBwWUxFVkJRVVZYTEZGQlFVOHNSVUZCVFVZc1JVRkJTME1zUjBGRmNFSlFMRkZCUVZGTkxFVkJRVXRITEV0QlFVdERMRTFCUVUxRUxFdEJRVXRGTEZWQlFWVktMRTFCU1RsRFN5eGhRVUZsTEZOQlFWTkRMRVZCUVZORExFZEJRMjVETEVsQlFVbERMRVZCUVUxc1FpeEZRVUZGWjBJc1IwRkJVMGNzUzBGQlMwWXNSMEZGTVVJc1dVRkVhMElzU1VGQlVFTXNTVUZCYjBKQkxFVkJRVTBzVFVGRE9VSkJMRWRCU1V4RkxHRkJRV1VzVTBGQlUwb3NSVUZCVTBNc1JVRkJWMGtzUjBGRE9VTnlRaXhGUVVGRlowSXNSMEZCVTBjc1MwRkJTMFlzUlVGQlYwa3NTVUZKZWtKRExHZENRVUZyUWl4VFFVRlRUaXhGUVVGVFF5eEhRVU4wUTJwQ0xFVkJRVVZuUWl4SFFVRlRUeXhYUVVGWFRpeEpRVWx3UWs4c1lVRkJaU3hUUVVGVFVpeEhRVU14UWl4UFFVRlBhRUlzUlVGQlJXZENMRWRCUVZOVExGRkJTMmhDUXl4aFFVRmxMRk5CUVZOV0xFZEJRekZDTEU5QlFVOW9RaXhGUVVGRlowSXNSMEZCVTFjc1VVRkphRUpETEdkQ1FVRnJRaXhUUVVGVFdpeEhRVWszUWl4TlFVRjNRaXhMUVVGd1FrRXNSVUZCVVdFc1UwRkJlVU1zYVVKQlFXaENZaXhGUVVGUll5eExRVUY1UW1Rc1JVRkJVV01zUzBGQlMwTXNZMEZETTBRc1MwRkJjRUptTEVWQlFWRmhMRkZCUVhWQ1lpeEZRVUZSWVN4UlFVRlJSU3hqUVVNMVF5OUNMRVZCUVVWblFpeEhRVUZUVml4TFFVRkxMRmRCUVZkNVFpeGxRVWxvUTBNc1YwRkJZU3hUUVVGVGFFSXNSVUZCVTJsQ0xFZEJRMnBEYWtNc1JVRkJSV2RDTEVkQlFWTlhMRXRCUVV0TkxFbEJTV1JETEZsQlFXTXNVMEZCVTJ4Q0xFVkJRVk5YTEVkQlEyeERNMElzUlVGQlJXZENMRWRCUVZOdFFpeFpRVUZaVWl4SlFVbHlRbE1zWlVGQmFVSXNVMEZCVTBNc1JVRkJWME1zUjBGRGJrTkJMRkZCUVhsRExFbEJRWEpDUkN4RlFVRlZSU3hSUVVGM1FrWXNSVUZCVlVVc1UwRkZjRVZHTEVWQlFWVkhMRlZCUjFwRExFOUJRVTlETEZGQlFWVXNRMEZEWmpOQ0xHRkJRV05CTEdGQlEyUkxMR0ZCUVdOQkxHRkJRMlJGTEdkQ1FVRnBRa0VzWjBKQlEycENSU3hoUVVGalFTeGhRVU5rUlN4aFFVRmpRU3hoUVVOa1JTeG5Ra0ZCYVVKQkxHZENRVU5xUWtrc1YwRkJXVUVzVjBGRFdrVXNXVUZCWVVFc1dVRkRZa1VzWlVGQlowSkJMR1ZCUTJoQ05VSXNWVUZCVjBFaUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwyTnZiblpsY25SbGNpOWtiMjExZEdsc2N5NXFjeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKSxlbGFib3JhdGVEZWNsYXJhdGlvbnM9cmVxdWlyZShcIi4vZGVjbGFyYXRpb25zLmpzXCIpLHV0aWxzPXJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLG1vZGVsRGVmPXJlcXVpcmUoXCIuL21vZGVsLmpzXCIpLF9nZXRPcHRpb25zT2JqZWN0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLnNwbGl0KFwifFwiKSxvPXt9LGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIGw9dFtpXS5zcGxpdChcIj1cIik7b1tsWzBdLnRyaW0oKV09bC5sZW5ndGg+MT9sWzFdLnRyaW0oKTpsWzBdLnRyaW0oKX1yZXR1cm4gb30sX2ZpbHRlclByb3BzPWZ1bmN0aW9uKGUsdCxvKXt2YXIgaT1bXTtmb3IodmFyIGwgaW4gZSlpZighbC5tYXRjaCgvXmN1c3RvbVN0eWxlJC8pJiYhbC5tYXRjaCgvXl8vKSYmZS5oYXNPd25Qcm9wZXJ0eShsKSl7dmFyIGE9bnVsbCE9PWVbbF0mJnZvaWQgMCE9PWVbbF0uX2NhdGVnb3J5JiZcInN0eWxlXCI9PWVbbF0uX2NhdGVnb3J5O2lmKFwiaWRcIj09bHx8XCJ0eXBlXCI9PWx8fGwubWF0Y2goL0Jsb2NrcyQvKSk7ZWxzZSBpZihcInN0eWxlclwiPT10KShhfHxvPjApJiZpLnB1c2gobCk7ZWxzZSBpZihcImVkaXRcIj09dCl7bnVsbCE9PWVbbF0mJnZvaWQgMCE9PWVbbF0uX2NhdGVnb3J5JiZcImNvbnRlbnRcIj09ZVtsXS5fY2F0ZWdvcnkmJih2b2lkIDA9PT1lW2xdLl9jb250ZXh0fHxcImJsb2NrXCIhPWVbbF0uX2NvbnRleHQpJiZpLnB1c2gobCl9ZWxzZSB2b2lkIDA9PT10JiZpLnB1c2gobCl9cmV0dXJuIGl9LF9wcm9wSW5wdXQ9ZnVuY3Rpb24oZSx0LG8saSxsKXt2YXIgYSxuPVwiXCI7aWYobnVsbCE9PWUmJnZvaWQgMCE9PWUuX3dpZGdldCYmKGE9ZS5fd2lkZ2V0KSx2b2lkIDA9PT1hKXRocm93XCJVbmtub3duIGRhdGEgdHlwZSBmb3IgXCIrdDt2YXIgcz1cImZvY3VzYWJsZTogdHJ1ZVwiO2lmKFwiZWRpdFwiPT1pJiYocys9XCIsIGV2ZW50OiB7IGZvY3VzOiBmdW5jdGlvbih1aSwgZXZlbnQpIHsgJCgkZWxlbWVudCkuY2xpY2soKTsgfSB9IFwiKSxuKz0nPGxhYmVsIGNsYXNzPVwiZGF0YS0nK2ErJ1wiJysoXCJib29sZWFuXCI9PWE/XCIgZGF0YS1iaW5kPVxcXCJldmVudDogeyBtb3VzZWRvd246IGZ1bmN0aW9uKHVpLCBldnQpIHsgaWYgKGV2dC5idXR0b24gPT0gMCkgeyB2YXIgaW5wdXQgPSAkKCRlbGVtZW50KS5maW5kKCdpbnB1dCcpOyB2YXIgY2ggPSBpbnB1dC5wcm9wKCdjaGVja2VkJyk7IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGlucHV0LmNsaWNrKCk7IGlucHV0LnByb3AoJ2NoZWNrZWQnLCAhY2gpOyBpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTsgfSwgMCk7IH0gfSB9LCBjbGljazogZnVuY3Rpb24odWksIGV2dCkgeyBldnQucHJldmVudERlZmF1bHQoKTsgfSwgY2xpY2tCdWJibGU6IGZhbHNlXFxcIlwiOlwiXCIpK1wiPlwiLHZvaWQgMCE9PWwmJnZvaWQgMCE9PWxbYV0pe3ZhciBkPWxbYV0scj17fTtpZih2b2lkIDAhPT1kLnBhcmFtZXRlcnMpZm9yKHZhciBjIGluIGQucGFyYW1ldGVycylkLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoYykmJnZvaWQgMCE9PWVbXCJfXCIrY10mJihyW2NdPWVbXCJfXCIrY10pO24rPWQuaHRtbChvLHMscil9ZWxzZSBpZihcImJvb2xlYW5cIj09YSluKz0nPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwibm90aGluZ1wiIGRhdGEtYmluZD1cImNoZWNrZWQ6ICcrbytcIiwgXCIrcysnXCIgLz4nLG4rPSc8c3BhbiBjbGFzcz1cImNoZWNrYm94LXJlcGxhY2VyXCIgPjwvc3Bhbj4nO2Vsc2UgaWYoXCJjb2xvclwiPT1hKW4rPSc8aW5wdXQgc2l6ZT1cIjdcIiB0eXBlPVwidGV4dFwiIGRhdGEtYmluZD1cImNvbG9ycGlja2VyOiB7IGNvbG9yOiAnK28rXCIsIHN0cmluZ3M6ICRyb290LnQoJ1RoZW1lIENvbG9ycyxTdGFuZGFyZCBDb2xvcnMsV2ViIENvbG9ycyxUaGVtZSBDb2xvcnMsQmFjayB0byBQYWxldHRlLEhpc3RvcnksTm8gaGlzdG9yeSB5ZXQuJykgfSwgLCBcIitzKydcIiAvPic7ZWxzZSBpZihcInNlbGVjdFwiPT1hKXtpZih2b2lkIDAhPT1lLl9vcHRpb25zKXt2YXIgcD1fZ2V0T3B0aW9uc09iamVjdChlLl9vcHRpb25zKTtmb3IodmFyIHYgaW4gbis9JzxzZWxlY3QgZGF0YS1iaW5kPVwidmFsdWU6ICcrbytcIiwgXCIrcysnXCI+JyxwKXAuaGFzT3duUHJvcGVydHkodikmJihuKz0nPG9wdGlvbiB2YWx1ZT1cIicrditcIlxcXCIgZGF0YS1iaW5kPVxcXCJ0ZXh0OiAkcm9vdC51dCgndGVtcGxhdGUnLCAnXCIrdXRpbHMuYWRkU2xhc2hlcyhwW3ZdKStcIicpXFxcIj5cIitwW3ZdK1wiPC9vcHRpb24+XCIpO24rPVwiPC9zZWxlY3Q+XCJ9fWVsc2UgaWYoXCJmb250XCI9PWEpbis9JzxzZWxlY3QgdHlwZT1cInRleHRcIiBkYXRhLWJpbmQ9XCJ2YWx1ZTogJytvK1wiLCBcIitzKydcIj4nLG4rPSc8b3B0Z3JvdXAgbGFiZWw9XCJTYW5zLVNlcmlmIEZvbnRzXCI+JyxuKz0nPG9wdGlvbiB2YWx1ZT1cIkFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmXCI+QXJpYWw8L29wdGlvbj4nLG4rPVwiPG9wdGlvbiB2YWx1ZT1cXFwiJ0NvbWljIFNhbnMgTVMnLGN1cnNpdmUsc2Fucy1zZXJpZlxcXCI+Q29taWMgU2FucyBNUzwvb3B0aW9uPlwiLG4rPSc8b3B0aW9uIHZhbHVlPVwiSW1wYWN0LENoYXJjb2FsLHNhbnMtc2VyaWZcIj5JbXBhY3Q8L29wdGlvbj4nLG4rPVwiPG9wdGlvbiB2YWx1ZT1cXFwiJ1RyZWJ1Y2hldCBNUycsSGVsdmV0aWNhLHNhbnMtc2VyaWZcXFwiPlRyZWJ1Y2hldCBNUzwvb3B0aW9uPlwiLG4rPSc8b3B0aW9uIHZhbHVlPVwiVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZlwiPlZlcmRhbmE8L29wdGlvbj4nLG4rPVwiPC9vcHRncm91cD5cIixuKz0nPG9wdGdyb3VwIGxhYmVsPVwiU2VyaWYgRm9udHNcIj4nLG4rPSc8b3B0aW9uIHZhbHVlPVwiR2VvcmdpYSxzZXJpZlwiPkdlb3JnaWE8L29wdGlvbj4nLG4rPVwiPG9wdGlvbiB2YWx1ZT1cXFwiJ1RpbWVzIE5ldyBSb21hbicsVGltZXMsc2VyaWZcXFwiPlRpbWVzIE5ldyBSb21hbjwvb3B0aW9uPlwiLG4rPVwiPC9vcHRncm91cD5cIixuKz0nPG9wdGdyb3VwIGxhYmVsPVwiTW9ub3NwYWNlIEZvbnRzXCI+JyxuKz1cIjxvcHRpb24gdmFsdWU9XFxcIidDb3VyaWVyIE5ldycsQ291cmllcixtb25vc3BhY2VcXFwiPkNvdXJpZXIgTmV3PC9vcHRpb24+XCIsbis9XCI8L29wdGdyb3VwPlwiLG4rPVwiPC9zZWxlY3Q+XCI7ZWxzZSBpZihcInVybFwiPT1hKW4rPSc8ZGl2IGNsYXNzPVwidWktdGV4dGJ1dHRvblwiPicsbis9JzxpbnB1dCBjbGFzcz1cInVpLXRleHRidXR0b24taW5wdXRcIiBzaXplPVwiN1wiIHR5cGU9XCJ1cmxcIiBwYXR0ZXJuPVwiKG1haWx0bzouK0AuK3xodHRwcz86Ly8uK1xcXFwuLit8XFxcXFsuKlxcXFxdLiopXCIgdmFsdWU9XCJub3RoaW5nXCIgZGF0YS1iaW5kPVwiY3NzOiB7IHdpdGhCdXR0b246IHR5cGVvZiAkcm9vdC5saW5rRGlhbG9nICE9PSBcXCd1bmRlZmluZWRcXCcgfSwgdmFsaWRhdGVkVmFsdWU6ICcrbytcIiwgXCIrcysnXCIgLz4nLG4rPVwiPGEgY2xhc3M9XFxcInVpLXRleHRidXR0b24tYnV0dG9uXFxcIiBkYXRhLWJpbmQ9XFxcInZpc2libGU6IHR5cGVvZiAkcm9vdC5saW5rRGlhbG9nICE9PSAndW5kZWZpbmVkJywgY2xpY2s6IHR5cGVvZiAkcm9vdC5saW5rRGlhbG9nICE9PSAndW5kZWZpbmVkJyA/ICRyb290LmxpbmtEaWFsb2cuYmluZCgkZWxlbWVudC5wcmV2aW91c1NpYmxpbmcpIDogZmFsc2UsIGJ1dHRvbjogeyBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtZWxsaXBzaXMtaCcgfSwgbGFiZWw6ICdPcHppb25pJywgdGV4dDogZmFsc2UgfVxcXCI+T3B6aW9uaTwvYT5cIixuKz1cIjwvZGl2PlwiO2Vsc2UgaWYoXCJpbnRlZ2VyXCI9PWEpe3ZhciB1PTAsYj0xZTM7bnVsbCE9PWUmJnZvaWQgMCE9PWUuX21heCYmKGI9ZS5fbWF4KSxudWxsIT09ZSYmdm9pZCAwIT09ZS5fbWluJiYodT1lLl9taW4pO3ZhciBmPWItdT49MTAwPzEwOjE7bis9JzxpbnB1dCBjbGFzcz1cIm51bWJlci1zcGlubmVyXCIgc2l6ZT1cIjdcIiBzdGVwPVwiJytmKydcIiB0eXBlPVwibnVtYmVyXCIgdmFsdWU9XCItMVwiIGRhdGEtYmluZD1cInNwaW5uZXI6IHsgbWluOiAnK3UrXCIsIG1heDogXCIrYitcIiwgcGFnZTogXCIrNSpmK1wiLCB2YWx1ZTogXCIrbytcIiB9LCB2YWx1ZVVwZGF0ZTogWydjaGFuZ2UnLCAnc3BpbiddLCBcIitzKydcIiAvPid9ZWxzZSBuKz0nPGlucHV0IHNpemU9XCI3XCIgdHlwZT1cInRleHRcIiB2YWx1ZT1cIm5vdGhpbmdcIiBkYXRhLWJpbmQ9XCJ2YWx1ZTogJytvK1wiLCBcIitzKydcIiAvPic7cmV0dXJuIG4rPVwiPC9sYWJlbD5cIn0sX2dldEdsb2JhbFN0eWxlUHJvcD1mdW5jdGlvbihlLHQsbyxpKXt2YXIgbDtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQmJnZvaWQgMD09PXQuX3dpZGdldHx8dm9pZCAwIT09byYmdm9pZCAwIT09aSYmaS5sZW5ndGg+MCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJnZvaWQgMCE9PWVbaV0mJihsPWVbaV0pLGx9LF9wcm9wRWRpdG9yPWZ1bmN0aW9uKGUsdCxvLGksbCxhLG4scyxkLHIsYyxwLHYsdSxiKXtpZih2b2lkIDA9PT1kJiYoZD0wKSx2b2lkIDAhPT1uJiZcIm9iamVjdFwiPT10eXBlb2YgaSYmbnVsbCE9PWkmJnZvaWQgMD09PWkuX3VzZWNvdW50KXJldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUuZGVidWcmJmNvbnNvbGUuZGVidWcoXCJJZ25vcmluZ1wiLGEsXCJwcm9wZXJ0eSBiZWNhdXNlIGl0IGlzIG5vdCB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZVwiLFwicHJvcDpcIixuLFwidHlwZTpcIixzLFwibGV2ZWw6XCIsZCxlLl90ZW1wbGF0ZU5hbWUpLFwiXCI7dmFyIGYsaD12b2lkIDAhPT1wP24rXCIuX2RlZmF1bHRDb21wdXRlZFwiOm4sbT1cIlwiLGc9aCxfPTEseT0xO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBpJiZudWxsIT09aSYmdm9pZCAwPT09aS5fd2lkZ2V0fHx2b2lkIDA9PT1wJiYoXys9MSksdm9pZCAwPT09cCYmdm9pZCAwIT09ciYmKHkrPXIpLHZvaWQgMCE9PW4mJnYmJihtKz1cIlxceDNjIS0tIGtvIGlmU3ViczogeyBkYXRhOiBcIitnK1wiLCB0aHJlc2hvbGQ6IFwiK3krXCIsIGd1dHRlcjogXCIrXytcIiB9IC0tXFx4M2VcIiksdm9pZCAwPT09bnx8bnVsbCE9PWkmJnZvaWQgMCE9PWkuX25hbWV8fGNvbnNvbGUubG9nKFwiTWlzc2luZyBsYWJlbCBmb3IgcHJvcGVydHkgXCIsbiksdm9pZCAwPT09biYmbnVsbCE9PWkmJnZvaWQgMD09PWkuX25hbWUmJlwidGhlbWVcIiE9PWkudHlwZSYmY29uc29sZS5sb2coXCJNaXNzaW5nIGxhYmVsIGZvciBvYmplY3QgXCIsaS50eXBlKSxcIm9iamVjdFwiPT10eXBlb2YgaSYmbnVsbCE9PWkmJnZvaWQgMD09PWkuX3dpZGdldCl7dmFyIGs9X2ZpbHRlclByb3BzKGkscyxkKSx4PVwic3R5bGVyXCI9PXMmJm51bGwhPT1pJiZ2b2lkIDAhPT1pLmN1c3RvbVN0eWxlJiZ2b2lkIDAhPT1wLFM9XCJcIix3PVwiXCI7dm9pZCAwIT09biYmXCJlZGl0XCI9PXMmJihTPVwiLCBjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0SXRlbShcIituK1wiLCAkZGF0YSk7IHJldHVybiBmYWxzZSB9LCBjbGlja0J1YmJsZTogZmFsc2UsIGNzczogeyBzZWxlY3RlZGl0ZW06ICRyb290LmlzU2VsZWN0ZWRJdGVtKFwiK24rXCIpIH0sIHNjcm9sbEludG9WaWV3OiAkcm9vdC5pc1NlbGVjdGVkSXRlbShcIituK1wiKSwgXCIsdys9XCIgc2VsZWN0YWJsZVwiKSx4JiYodys9XCIgc3VwcG9ydHNDdXN0b21TdHlsZXNcIiksbSs9JzxkaXYgY2xhc3M9XCJvYmpFZGl0IGxldmVsJytkK3crJ1wiIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7fScrUysnXCI+Jzt2YXIgJCxqLEQsQj1udWxsIT09aSYmdm9pZCAwIT09aS5fbmFtZT9pLl9uYW1lOnZvaWQgMCE9PW4/XCJbXCIrbitcIl1cIjpcIlwiO2lmKHgpe3ZhciBFPVwiU3RpbGVcIjtudWxsIT1sJiZ2b2lkIDAhPT1sLl9uYW1lP0U9bC5fbmFtZTpjb25zb2xlLmxvZyhcIk1pc3NpbmcgbGFiZWwgZm9yIHRoZW1lIHNlY3Rpb24gXCIsbixudWxsIT09aT9pLnR5cGU6XCItXCIpLEI9XCI8c3BhbiBjbGFzcz1cXFwiYmxvY2tTZWxlY3Rpb25NZXRob2RcXFwiIGRhdGEtYmluZD1cXFwidGV4dDogY3VzdG9tU3R5bGUoKSA/ICRyb290LnV0KCd0ZW1wbGF0ZScsICdcIit1dGlscy5hZGRTbGFzaGVzKEIpK1wiJykgOiAkcm9vdC51dCgndGVtcGxhdGUnLCAnXCIrdXRpbHMuYWRkU2xhc2hlcyhFKStcIicpXFxcIj5CbG9jazwvc3Bhbj5cIn1lbHNlIEI9XCI8c3BhbiBkYXRhLWJpbmQ9XFxcInRleHQ6ICRyb290LnV0KCd0ZW1wbGF0ZScsICdcIit1dGlscy5hZGRTbGFzaGVzKEIpK1wiJylcXFwiPlwiK0IrXCI8L3NwYW4+XCI7aWYobSs9XCI8c3BhblwiKyhmPW51bGwhPT1pJiZ2b2lkIDAhPT1pLl9oZWxwPycgdGl0bGU9XCInK3V0aWxzLmFkZFNsYXNoZXMoaS5faGVscCkrXCJcXFwiIGRhdGEtYmluZD1cXFwiYXR0cjogeyB0aXRsZTogJHJvb3QudXQoJ3RlbXBsYXRlJywgJ1wiK3V0aWxzLmFkZFNsYXNoZXMoaS5faGVscCkrXCInKSB9XFxcIlwiOlwiXCIpKycgY2xhc3M9XCJvYmpMYWJlbCBsZXZlbCcrZCsnXCI+JytCK1wiPC9zcGFuPlwiLFwiZWRpdFwiPT1zJiZ2b2lkIDAhPT1pLl9ibG9ja0Rlc2NyaXB0aW9uJiYobSs9XCI8ZGl2IGNsYXNzPVxcXCJibG9ja0Rlc2NyaXB0aW9uXFxcIiBkYXRhLWJpbmQ9XFxcImh0bWw6ICRyb290LnV0KCd0ZW1wbGF0ZScsICdcIit1dGlscy5hZGRTbGFzaGVzKGkuX2Jsb2NrRGVzY3JpcHRpb24pK1wiJylcXFwiPlwiK2kuX2Jsb2NrRGVzY3JpcHRpb24rXCI8L2Rpdj5cIikseCYmKG0rPSc8bGFiZWwgY2xhc3M9XCJkYXRhLWJvb2xlYW4gYmxvY2tDaGVja1wiIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7IH1cIj4nLG0rPSc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJub3RoaW5nXCIgZGF0YS1iaW5kPVwiZm9jdXNhYmxlOiB0cnVlLCBjaGVja2VkOiBjdXN0b21TdHlsZVwiIC8+JyxtKz0nPHNwYW4gdGl0bGU9XCJTd2l0Y2ggYmV0d2VlbiBnbG9iYWwgYW5kIGJsb2NrIGxldmVsIHN0eWxlcyBlZGl0aW5nXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdTd2l0Y2ggYmV0d2VlbiBnbG9iYWwgYW5kIGJsb2NrIGxldmVsIHN0eWxlcyBlZGl0aW5nXFwnKSB9XCIgY2xhc3M9XCJjaGVja2JveC1yZXBsYWNlciBjaGVja2JveC1yZXBsYWNlci1vbm9mZlwiPjwvc3Bhbj4nLG0rPVwiPC9sYWJlbD5cIixtKz1cIlxceDNjIS0tIGtvIHRlbXBsYXRlOiB7IG5hbWU6ICdjdXN0b21zdHlsZScsIGlmOiBjdXN0b21TdHlsZSB9IC0tXFx4M2VcXHgzYyEtLSAva28gLS1cXHgzZVwiKSx2b2lkIDAhPT1uKWlmKG0rPVwiXFx4M2MhLS0ga28gd2l0aDogXCIrbitcIiAtLVxceDNlXCIsMT09ZCYmdm9pZCAwIT09bilpZih2b2lkIDAhPT1pLl9wcmV2aWV3QmluZGluZ3MmJnZvaWQgMCE9PWUpdm9pZCAwIT09dSYmKG0rPSdcXHgzYyEtLSBrbyB3aXRoOiAkcm9vdC5jb250ZW50KCkgLS1cXHgzZTxkaXYgY2xhc3M9XCJvYmpQcmV2aWV3XCIgZGF0YS1iaW5kPVwiJyt1KydcIj48L2Rpdj5cXHgzYyEtLSAva28gLS1cXHgzZScpLHZvaWQgMCE9PWImJihtKz0nXFx4M2MhLS0ga28gd2l0aDogJHBhcmVudCAtLVxceDNlPGRpdiBjbGFzcz1cIm9ialByZXZpZXdcIiBkYXRhLWJpbmQ9XCInK2IrJ1wiPjwvZGl2PlxceDNjIS0tIC9rbyAtLVxceDNlJyksbSs9JzxkaXYgY2xhc3M9XCJvYmpQcmV2aWV3XCI+PGRpdiBjbGFzcz1cIm9ialByZXZpZXdJbm5lclwiIGRhdGEtYmluZD1cIicrZWxhYm9yYXRlRGVjbGFyYXRpb25zKHZvaWQgMCxpLl9wcmV2aWV3QmluZGluZ3MsbyxlLmJpbmQodGhpcyxhK1wiLlwiKSkrJ1wiPjwvZGl2PjwvZGl2Pic7MD09PWQmJnZvaWQgMCE9PWkuX3ByZXZpZXdCaW5kaW5ncyYmKCQ9ZWxhYm9yYXRlRGVjbGFyYXRpb25zKHZvaWQgMCxpLl9wcmV2aWV3QmluZGluZ3MsbyxlLmJpbmQodGhpcyxhLmxlbmd0aD4wP2ErXCIuXCI6XCJcIikpKTt2YXIgQyxJPW0ubGVuZ3RoO2ZvcihqPTA7ajxrLmxlbmd0aDtqKyspRD1hLmxlbmd0aD4wP2ErXCIuXCIra1tqXTprW2pdLFwib2JqZWN0XCI9PXR5cGVvZiBpW2tbal1dJiZudWxsIT09aVtrW2pdXSYmdm9pZCAwPT09aVtrW2pdXS5fd2lkZ2V0fHwoQz12b2lkIDAsMD09PWQmJlwidGhlbWVcIj09a1tqXT9tKz1fcHJvcEVkaXRvcihlLHQsbyxpW2tbal1dLHZvaWQgMCxELGtbal0scywwLHIsdm9pZCAwLHZvaWQgMCx2LHUpOihDPV9nZXRHbG9iYWxTdHlsZVByb3AoYyxpW2tbal1dLGtbal0sRCksbSs9X3Byb3BFZGl0b3IoZSx0LG8saVtrW2pdXSx2b2lkIDAsRCxrW2pdLHMsZCsxLHIsYyxDLHYsdSwkKSkpO2ZvcihqPTA7ajxrLmxlbmd0aDtqKyspRD1hLmxlbmd0aD4wP2ErXCIuXCIra1tqXTprW2pdLFwib2JqZWN0XCI9PXR5cGVvZiBpW2tbal1dJiZudWxsIT09aVtrW2pdXSYmdm9pZCAwPT09aVtrW2pdXS5fd2lkZ2V0JiYoQz12b2lkIDAsMD09PWQmJlwidGhlbWVcIj09a1tqXT9tKz1fcHJvcEVkaXRvcihlLHQsbyxpW2tbal1dLHZvaWQgMCxELGtbal0scywwLHIsdm9pZCAwLHZvaWQgMCx2LHUpOihDPV9nZXRHbG9iYWxTdHlsZVByb3AoYyxpW2tbal1dLGtbal0sRCksbSs9X3Byb3BFZGl0b3IoZSx0LG8saVtrW2pdXSx2b2lkIDAsRCxrW2pdLHMsZCsxLHIsYyxDLHYsdSwkKSkpO2lmKDA9PT1tLmxlbmd0aC1JKXtpZihcIm9iamVjdFwiPT10eXBlb2YgaSYmbnVsbCE9PWkmJlwidGVtcGxhdGVcIj09aS5fY29udGV4dClyZXR1cm5cIlwiO20rPSc8ZGl2IGNsYXNzPVwib2JqRW1wdHlcIiBkYXRhLWJpbmQ9XCJodG1sOiAkcm9vdC50KFxcJ1NlbGVjdGVkIGVsZW1lbnQgaGFzIG5vIGVkaXRhYmxlIHByb3BlcnRpZXNcXCcpXCI+U2VsZWN0ZWQgZWxlbWVudCBoYXMgbm8gZWRpdGFibGUgcHJvcGVydGllczwvZGl2Pid9dm9pZCAwIT09biYmKG0rPVwiXFx4M2MhLS0gL2tvIC0tXFx4M2VcIiksbSs9XCI8L2Rpdj5cIn1lbHNle3ZhciBQPSEwO2lmKHZvaWQgMD09PWMmJihQPSExKSxudWxsPT09aXx8XCJvYmplY3RcIiE9dHlwZW9mIGl8fHZvaWQgMCE9PWkuX3dpZGdldCl7dmFyIE09W107dm9pZCAwIT09cCYmTS5wdXNoKFwiY3NzOiB7IG5vdG51bGw6IFwiK24rXCIoKSAhPT0gbnVsbCB9XCIpLChmPW51bGwhPT1pJiZ2b2lkIDAhPT1pLl9oZWxwPycgdGl0bGU9XCInK3V0aWxzLmFkZFNsYXNoZXMoaS5faGVscCkrXCJcXFwiIGRhdGEtYmluZD1cXFwiYXR0cjogeyB0aXRsZTogJHJvb3QudXQoJ3RlbXBsYXRlJywgJ1wiK3V0aWxzLmFkZFNsYXNoZXMoaS5faGVscCkrXCInKSB9XFxcIlwiOlwiXCIpLmxlbmd0aD4wJiZNLnB1c2goXCJ0b29sdGlwczoge31cIiksbSs9JzxkaXYgY2xhc3M9XCJwcm9wRWRpdG9yICcrKFA/XCJjaGVja2JveGVzXCI6XCJcIikrJ1wiJysoTS5sZW5ndGg+MD8nZGF0YS1iaW5kPVwiJyt1dGlscy5hZGRTbGFzaGVzKE0uam9pbigpKSsnXCInOlwiXCIpK1wiPlwiO3ZhciBUPW51bGwhPT1pJiZ2b2lkIDAhPT1pLl9uYW1lP2kuX25hbWU6dm9pZCAwIT09bj9cIltcIituK1wiXVwiOlwiXCI7bSs9XCI8c3BhblwiK2YrJyBjbGFzcz1cInByb3BMYWJlbFwiPicrKFQ9XCI8c3BhbiBkYXRhLWJpbmQ9XFxcInRleHQ6ICRyb290LnV0KCd0ZW1wbGF0ZScsICdcIit1dGlscy5hZGRTbGFzaGVzKFQpK1wiJylcXFwiPlwiK1QrXCI8L3NwYW4+XCIpK1wiPC9zcGFuPlwiLG0rPSc8ZGl2IGNsYXNzPVwicHJvcElucHV0ICcrKHZvaWQgMCE9PWM/XCJsb2NhbFwiOlwiXCIpKydcIiBkYXRhLWJpbmQ9XCJjc3M6IHsgZGVmYXVsdDogJytuKycoKSA9PT0gbnVsbCB9XCI+JyxtKz1fcHJvcElucHV0KGksbixoLHMsdCksbSs9XCI8L2Rpdj5cIix2b2lkIDAhPT1wJiYobSs9JzxkaXYgY2xhc3M9XCJwcm9wSW5wdXQgZ2xvYmFsXCIgZGF0YS1iaW5kPVwiY3NzOiB7IG92ZXJyaWRkZW46ICcrbisnKCkgIT09IG51bGwgfVwiPicsbSs9X3Byb3BJbnB1dChpLG4scCxzLHQpLG0rPVwiPC9kaXY+XCIsUCYmKG0rPSc8ZGl2IGNsYXNzPVwicHJvcENoZWNrXCI+PGxhYmVsIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7fVwiPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBkYXRhLWJpbmQ9XCJmb2N1c2FibGU6IHRydWUsIGNsaWNrOiBmdW5jdGlvbihldnQsIG9iaikgeyAkcm9vdC5sb2NhbEdsb2JhbFN3aXRjaCgnK24rXCIsIFwiK3ArXCIpOyByZXR1cm4gdHJ1ZTsgfSwgY2hlY2tlZDogXCIrbisnKCkgIT09IG51bGxcIj4nLG0rPSc8c3BhbiBjbGFzcz1cImNoZWNrYm94LXJlcGxhY2VyXCIgZGF0YS1iaW5kPVwiY3NzOiB7IGNoZWNrZWQ6ICcrbitcIigpICE9PSBudWxsIH0sIGF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1RoaXMgc3R5bGUgaXMgc3BlY2lmaWMgZm9yIHRoaXMgYmxvY2s6IGNsaWNrIGhlcmUgdG8gcmVtb3ZlIHRoZSBjdXN0b20gc3R5bGUgYW5kIHJldmVydCB0byB0aGUgdGhlbWUgdmFsdWUnKSB9XFxcIj48L3NwYW4+XCIsbSs9XCI8L2xhYmVsPjwvZGl2PlwiKSksbSs9XCI8L2Rpdj5cIn1lbHNlIG0rPW51bGw9PT1pfHxcIm9iamVjdFwiIT10eXBlb2YgaT8nPGRpdiBjbGFzcz1cInByb3BFZGl0b3IgdW5rbm93blwiPltBfCcrbitcInxcIit0eXBlb2YgaStcIl08L2Rpdj5cIjonPGRpdiBjbGFzcz1cInByb3BFZGl0b3IgdW5rbm93blwiPltCfCcrbitcInxcIit0eXBlb2YgaStcIl08L2Rpdj5cIn1yZXR1cm4gdm9pZCAwIT09biYmdiYmKG0rPVwiXFx4M2MhLS0gL2tvIC0tXFx4M2VcIixtKz1cIlxceDNjIS0tIGtvIGlmU3ViczogeyBub3Q6IHRydWUsIGRhdGE6IFwiK2crXCIsIHRocmVzaG9sZDogXCIreStcIiwgZ3V0dGVyOiAwIH0gLS1cXHgzZVwiLG0rPSc8c3BhbiBjbGFzcz1cImxhYmVsIG5vdHVzZWRcIj4oJytuK1wiKTwvc3Bhbj5cIixtKz1cIlxceDNjIS0tIC9rbyAtLVxceDNlXCIpLG19LGNyZWF0ZUJsb2NrRWRpdG9yPWZ1bmN0aW9uKGUsdCxvLGksbCxhLG4scyxkLHIsYyxwKXt2b2lkIDA9PT1jJiYoYz0hMCk7dmFyIHYsdT1tb2RlbERlZi5nZXREZWYoZSxhKSxiPW1vZGVsRGVmLmdldERlZihlLGwpO3ZvaWQgMCE9PWIuX3ByZXZpZXdCaW5kaW5ncyYmXCJ0aGFlbWVcIiE9YSYmXCJzdHlsZXJcIj09biYmKHY9ZWxhYm9yYXRlRGVjbGFyYXRpb25zKHZvaWQgMCxiLl9wcmV2aWV3QmluZGluZ3MsaSxtb2RlbERlZi5nZXRCaW5kVmFsdWUuYmluZCh2b2lkIDAsZSxvLGwsbCxcIlwiKSkpO3ZhciBmLGg9dm9pZCAwIT09ciYmcj9lW2FdLl9nbG9iYWxTdHlsZXM6dm9pZCAwLG09dm9pZCAwIT09ciYmcj9lW2FdLl9nbG9iYWxTdHlsZTp2b2lkIDA7dm9pZCAwIT09bSYmKGY9bW9kZWxEZWYuZ2V0RGVmKGUsXCJ0aGVtZVwiKVttLnJlcGxhY2UoL14oXFwkdGhlbWV8X3RoZW1lXylcXC4vLFwiXCIpXSk7dmFyIGc9bW9kZWxEZWYuZ2V0QmluZFZhbHVlLmJpbmQodm9pZCAwLGUsbyxsLGEpO2cuX3RlbXBsYXRlTmFtZT1hO3ZhciBfPSc8ZGl2IGNsYXNzPVwiZWRpdG9yXCI+JztfKz0nPGRpdiBjbGFzcz1cImJsb2NrVHlwZScrKHZvaWQgMCE9PWg/XCIgd2l0aGRlZmF1bHRzXCI6XCJcIikrJ1wiPicrdS50eXBlK1wiPC9kaXY+XCI7dmFyIHk9X3Byb3BFZGl0b3IoZyx0LGksdSxmLFwiXCIsdm9pZCAwLG4scCxkLGgsbSxjLHYpO3kubGVuZ3RoPjAmJihfKz15KSxzKF8rPVwiPC9kaXY+XCIsYSxuKX0sY3JlYXRlQmxvY2tFZGl0b3JzPWZ1bmN0aW9uKGUsdCxvLGksbCxhLG4scyl7Y3JlYXRlQmxvY2tFZGl0b3IoZSx0LG8saSxsLGEsXCJlZGl0XCIsbixzKSxjcmVhdGVCbG9ja0VkaXRvcihlLHQsbyxpLGwsYSxcInN0eWxlclwiLG4scywhMCl9LGdlbmVyYXRlRWRpdG9ycz1mdW5jdGlvbihlLHQsbyxpLGwpe3ZhciBhLG49ZS5fZGVmcyxzPWUudGVtcGxhdGVOYW1lLGQ9ZS5fYmxvY2tzLHI9W107Zm9yKGE9MDthPGQubGVuZ3RoO2ErKyl2b2lkIDAhPT1kW2FdLmNvbnRhaW5lciYmci5wdXNoKG1vZGVsRGVmLmdlbmVyYXRlTW9kZWwobixkW2FdLmJsb2NrKSksY3JlYXRlQmxvY2tFZGl0b3JzKG4sdCx2b2lkIDAsbyxkW2FdLnJvb3QsZFthXS5ibG9jayxpLGwpO3JldHVybiB2b2lkIDAhPT1uLnRoZW1lJiZjcmVhdGVCbG9ja0VkaXRvcihuLHQsdm9pZCAwLG8scyxcInRoZW1lXCIsXCJzdHlsZXJcIixpLHZvaWQgMCwhMSwhMSwtMSkscn07bW9kdWxlLmV4cG9ydHM9Z2VuZXJhdGVFZGl0b3JzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1Wa2FYUnZjaTVxY3lKZExDSnVZVzFsY3lJNld5SmpiMjV6YjJ4bElpd2ljbVZ4ZFdseVpTSXNJbVZzWVdKdmNtRjBaVVJsWTJ4aGNtRjBhVzl1Y3lJc0luVjBhV3h6SWl3aWJXOWtaV3hFWldZaUxDSmZaMlYwVDNCMGFXOXVjMDlpYW1WamRDSXNJbTl3ZEdsdmJuTWlMQ0p2Y0hScGIyNXpRMjkxY0d4bGN5SXNJbk53YkdsMElpd2liM0IwY3lJc0lta2lMQ0pzWlc1bmRHZ2lMQ0p2Y0hRaUxDSjBjbWx0SWl3aVgyWnBiSFJsY2xCeWIzQnpJaXdpYlc5a1pXd2lMQ0psWkdsMFZIbHdaU0lzSW14bGRtVnNJaXdpY21Weklpd2ljSEp2Y0NJc0ltMWhkR05vSWl3aWFHRnpUM2R1VUhKdmNHVnlkSGtpTENKcGMxTjBlV3hsVUhKdmNDSXNJbDlqWVhSbFoyOXllU0lzSW5CMWMyZ2lMQ0pmWTI5dWRHVjRkQ0lzSWw5d2NtOXdTVzV3ZFhRaUxDSndjbTl3UVdOalpYTnpiM0lpTENKM2FXUm5aWFJ6SWl3aWQybGtaMlYwSWl3aWFIUnRiQ0lzSWw5M2FXUm5aWFFpTENKdmJtWnZZM1Z6WW1sdVpHbHVaeUlzSW5jaUxDSndZWEpoYldWMFpYSnpJaXdpY0NJc0lsOXZjSFJwYjI1eklpd2lZV1JrVTJ4aGMyaGxjeUlzSW0xcGJpSXNJbTFoZUNJc0lsOXRZWGdpTENKZmJXbHVJaXdpYzNSbGNDSXNJbDluWlhSSGJHOWlZV3hUZEhsc1pWQnliM0FpTENKbmJHOWlZV3hUZEhsc1pYTWlMQ0p3WVhSb0lpd2laMnh2WW1Gc1UzUjViR1ZRY205d0lpd2lYM0J5YjNCRlpHbDBiM0lpTENKM2FYUm9RbWx1WkdsdVoxQnliM1pwWkdWeUlpd2lkR1Z0Y0d4aGRHVlZjbXhEYjI1MlpYSjBaWElpTENKMGFHVnRaVTF2WkdWc0lpd2lZbUZ6WlZSb2NtVnphRzlzWkNJc0luUnlZV05yVlhOaFoyVWlMQ0p5YjI5MFVISmxkbWxsZDBKcGJtUnBibWNpTENKd2NtVjJhV1YzUW1GamEyZHliM1Z1WkNJc0lsOTFjMlZqYjNWdWRDSXNJbVJsWW5Wbklpd2lYM1JsYlhCc1lYUmxUbUZ0WlNJc0luUnBkR3hsSWl3aWFXWlRkV0p6VUhKdmNDSXNJbWxtVTNWaWMwZDFkSFJsY2lJc0ltbG1VM1ZpYzFSb2NtVnphRzlzWkNJc0lsOXVZVzFsSWl3aWJHOW5JaXdpZEhsd1pTSXNJbkJ5YjNCeklpd2lhR0Z6UTNWemRHOXRVM1I1YkdVaUxDSmpkWE4wYjIxVGRIbHNaU0lzSW5ObGJHVmpkR1ZrU1hSbGJVSnBibVJwYm1jaUxDSmhaR1JwZEdsdmJtRnNRMnhoYzNObGN5SXNJbkJ5WlhacFpYZENSeUlzSW01bGQxQmhkR2dpTENKdGIyUmxiRTVoYldVaUxDSjBhR1Z0WlZObFkzUnBiMjVPWVcxbElpd2lYMmhsYkhBaUxDSmZZbXh2WTJ0RVpYTmpjbWx3ZEdsdmJpSXNJbDl3Y21WMmFXVjNRbWx1WkdsdVozTWlMQ0oxYm1SbFptbHVaV1FpTENKaWFXNWtJaXdpZEdocGN5SXNJbTVsZDBkc2IySmhiRk4wZVd4bFVISnZjQ0lzSW1KbFptOXlaU0lzSW01bGQxUm9aVzFsVFc5a1pXd2lMQ0pqYUdWamEySnZlR1Z6SWl3aVltbHVaR2x1WjNNaUxDSnFiMmx1SWl3aWJXOWtaV3hPWVcxbE1pSXNJbU55WldGMFpVSnNiMk5yUldScGRHOXlJaXdpWkdWbWN5SXNJblJvWlcxbFZYQmtZWFJsY2lJc0luSnZiM1JOYjJSbGJFNWhiV1VpTENKMFpXMXdiR0YwWlU1aGJXVWlMQ0owWlcxd2JHRjBaVU55WldGMGIzSWlMQ0owY21GamEwZHNiMkpoYkZOMGVXeGxjeUlzSW1aeWIyMU1aWFpsYkNJc0luSnZiM1JRY21WMmFXVjNRbWx1WkdsdVozTWlMQ0puWlhSRVpXWWlMQ0p5YjI5MFRXOWtaV3dpTENKblpYUkNhVzVrVm1Gc2RXVWlMQ0pmWjJ4dlltRnNVM1I1YkdWeklpd2lYMmRzYjJKaGJGTjBlV3hsSWl3aWNtVndiR0ZqWlNJc0ltVmthWFJ2Y2tOdmJuUmxiblFpTENKamNtVmhkR1ZDYkc5amEwVmthWFJ2Y25NaUxDSm5aVzVsY21GMFpVVmthWFJ2Y25NaUxDSjBaVzF3YkdGMFpVUmxaaUlzSW1sa2VDSXNJbDlrWldaeklpd2lZbXh2WTJ0eklpd2lYMkpzYjJOcmN5SXNJbUpzYjJOclJHVm1jeUlzSW1OdmJuUmhhVzVsY2lJc0ltZGxibVZ5WVhSbFRXOWtaV3dpTENKaWJHOWpheUlzSW5KdmIzUWlMQ0p0YjJSMWJHVWlMQ0psZUhCdmNuUnpJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3hoUVVWQkxFbEJRVWxCTEZGQlFWVkRMRkZCUVZFc2MwSkJRMnhDUXl4elFrRkJkMEpFTEZGQlFWRXNjVUpCUTJoRFJTeE5RVUZSUml4UlFVRlJMR05CUTJoQ1J5eFRRVUZYU0N4UlFVRlJMR05CUlc1Q1NTeHJRa0ZCYjBJc1UwRkJVME1zUjBGSEwwSXNTVUZHUVN4SlFVRkpReXhGUVVGcFFrUXNSVUZCVVVVc1RVRkJUU3hMUVVNdlFrTXNSVUZCVHl4SFFVTkdReXhGUVVGSkxFVkJRVWRCTEVWQlFVbElMRVZCUVdWSkxFOUJRVkZFTEVsQlFVc3NRMEZET1VNc1NVRkJTVVVzUlVGQlRVd3NSVUZCWlVjc1IwRkJSMFlzVFVGQlRTeExRVU5zUTBNc1JVRkJTMGNzUlVGQlNTeEhRVUZIUXl4UlFVRlZSQ3hGUVVGSlJDeFBRVUZUTEVWQlFVbERMRVZCUVVrc1IwRkJSME1zVDBGQlUwUXNSVUZCU1N4SFFVRkhReXhQUVVWb1JTeFBRVUZQU2l4SFFVOU1TeXhoUVVGbExGTkJRVk5ETEVWQlFVOURMRVZCUVZWRExFZEJRek5ETEVsQlFVbERMRVZCUVUwc1IwRkRWaXhKUVVGTExFbEJRVWxETEV0QlFWRktMRVZCUTJZc1NVRkJTMGtzUlVGQlMwTXNUVUZCVFN4dFFrRkJjVUpFTEVWQlFVdERMRTFCUVUwc1QwRkJVMHdzUlVGQlRVMHNaVUZCWlVZc1IwRkJUeXhEUVVOdVJpeEpRVUZKUnl4RlFVRTRRaXhQUVVGb1FsQXNSVUZCVFVrc1UwRkJhMFFzU1VGQmVrSktMRVZCUVUxSkxFZEJRVTFKTEZkQlFYRkVMRk5CUVhwQ1VpeEZRVUZOU1N4SFFVRk5TU3hWUVVOeVJ5eEhRVUZaTEUxQlFWSktMRWRCUVhkQ0xGRkJRVkpCTEVkQlFXdENRU3hGUVVGTFF5eE5RVUZOTEdsQ1FVRnZRaXhIUVVGblFpeFZRVUZhU2l4SFFVTnVSVTBzUjBGQlpVd3NSVUZCVVN4SlFVRkhReXhGUVVGSlRTeExRVUZMVEN4UlFVTnNReXhIUVVGblFpeFJRVUZhU0N4RlFVRnZRaXhEUVVWUExFOUJRV2hDUkN4RlFVRk5TU3hUUVVGclJDeEpRVUY2UWtvc1JVRkJUVWtzUjBGQlRVa3NWMEZCY1VRc1YwRkJla0pTTEVWQlFVMUpMRWRCUVUxSkxHbENRVU55UlN4SlFVRjRRbElzUlVGQlRVa3NSMEZCVFUwc1ZVRkJiVVFzVTBGQmVFSldMRVZCUVUxSkxFZEJRVTFOTEZkQlF6RkRVQ3hGUVVGSlRTeExRVUZMVEN4aFFVTkJMRWxCUVZwSUxFZEJRMmhDUlN4RlFVRkpUU3hMUVVGTFRDeEhRVWRtTEU5QlFVOUVMRWRCUjB4UkxGZEJRV0VzVTBGQlUxZ3NSVUZCVDBrc1JVRkJUVkVzUlVGQlkxZ3NSVUZCVlZrc1IwRkROMFFzU1VGRFNVTXNSVUZFUVVNc1JVRkJUeXhIUVVsWUxFZEJSbU1zVDBGQlZtWXNVVUZCTUVNc1NVRkJha0pCTEVWQlFVMW5RaXhWUVVGM1FrWXNSVUZCVTJRc1JVRkJUV2RDTEdOQlJYSkVMRWxCUVZaR0xFVkJRMVFzUzBGQlRTeDVRa0ZCTWtKV0xFVkJTVzVETEVsQlFVbGhMRVZCUVdsQ0xHdENRVTl5UWl4SFFVNW5RaXhSUVVGYWFFSXNTVUZEUm1kQ0xFZEJRV3RDTEhGRlFVZHdRa1lzUjBGQlVTeHpRa0ZCZDBKRUxFVkJRVk1zUzBGQmFVSXNWMEZCVmtFc1JVRkJjMElzZDFWQlFXZFdMRWxCUVUwc1UwRkZjbGtzU1VGQldrUXNVVUZCYzBRc1NVRkJjRUpCTEVWQlFWRkRMRWRCUVhsQ0xFTkJRelZGTEVsQlFVbEpMRVZCUVVsTUxFVkJRVkZETEVkQlExcExMRVZCUVdFc1IwRkRha0lzVVVGQk5FSXNTVUZCYWtKRUxFVkJRVVZETEZkQlExZ3NTVUZCU3l4SlFVRkpReXhMUVVGTFJpeEZRVUZGUXl4WFFVTldSQ3hGUVVGRlF5eFhRVUZYWWl4bFFVRmxZeXhUUVVFNFFpeEpRVUZxUW5CQ0xFVkJRVTBzU1VGQlNXOUNMRXRCUTNKRVJDeEZRVUZYUXl4SFFVRkxjRUlzUlVGQlRTeEpRVUZKYjBJc1NVRkRhRU5NTEVkQlFWRkhMRVZCUVVWSUxFdEJRVXRJTEVWQlFXTkxMRVZCUVdkQ1JTeFJRVU40UXl4SFFVRmpMRmRCUVZaTUxFVkJRMVJETEVkQlFWRXNPRVJCUVdkRlNDeEZRVUZsTEV0QlFVOUxMRVZCUVdsQ0xFOUJReTlIUml4SFFVRlJMR2RFUVVOSUxFZEJRV01zVTBGQlZrUXNSVUZEVkVNc1IwRkJVU3huUlVGQmEwVklMRVZCUVdVc01raEJRVzlKU3l4RlFVRnBRaXhaUVVONlR5eEhRVUZqTEZWQlFWWklMRWRCUTFRc1VVRkJOa0lzU1VGQmJFSmtMRVZCUVUxeFFpeFRRVUY1UWl4RFFVTjRReXhKUVVGSk0wSXNSVUZCVDBvc2EwSkJRV3RDVlN4RlFVRk5jVUlzVlVGSGJrTXNTVUZCU3l4SlFVRkplRUlzUzBGRVZHdENMRWRCUVZFc05rSkJRU3RDU0N4RlFVRmxMRXRCUVU5TExFVkJRV2xDTEV0QlF6bEVka0lzUlVGRFZrRXNSVUZCUzFrc1pVRkJaVlFzUzBGRGRFSnJRaXhIUVVGUkxHdENRVUZ2UW14Q0xFVkJRVTBzT0VOQlFXbEVWQ3hOUVVGTmEwTXNWMEZCVnpWQ0xFVkJRVXRITEVsQlFWRXNVVUZCVlVnc1JVRkJTMGNzUjBGQlR5eGhRVVV6U1d0Q0xFZEJRVkVzYTBKQlJVd3NSMEZCWXl4UlFVRldSQ3hGUVVOVVF5eEhRVUZSTEhsRFFVRXlRMGdzUlVGQlpTeExRVUZQU3l4RlFVRnBRaXhMUVVNeFJrWXNSMEZCVVN4elEwRkRVa0VzUjBGQlVTdzBSRUZEVWtFc1IwRkJVU3c0UlVGRFVrRXNSMEZCVVN3MlJFRkRVa0VzUjBGQlVTdzRSVUZEVWtFc1IwRkJVU3cyUkVGRFVrRXNSMEZCVVN4alFVTlNRU3hIUVVGUkxHbERRVU5TUVN4SFFVRlJMR2xFUVVOU1FTeEhRVUZSTERKRlFVTlNRU3hIUVVGUkxHTkJRMUpCTEVkQlFWRXNjVU5CUTFKQkxFZEJRVkVzZVVWQlExSkJMRWRCUVZFc1kwRkRVa0VzUjBGQlVTeHBRa0ZEU0N4SFFVRmpMRTlCUVZaRUxFVkJRMVJETEVkQlFWRXNPRUpCUlZKQkxFZEJRVkVzTUU1QlFUUk9TQ3hGUVVGbExFdEJRVTlMTEVWQlFXbENMRTlCUXpOUlJpeEhRVUZSTEd0VVFVTlNRU3hIUVVGUkxHTkJRMGdzUjBGQll5eFhRVUZXUkN4RlFVRnhRaXhEUVVjNVFpeEpRVUZKVXl4RlFVRk5MRVZCUTA1RExFVkJRVTBzU1VGRFNTeFBRVUZXZUVJc1VVRkJkME1zU1VGQlprRXNSVUZCVFhsQ0xFOUJRWE5DUkN4RlFVRk5lRUlzUlVGQlRYbENMRTFCUTNaRUxFOUJRVlo2UWl4UlFVRjNReXhKUVVGbVFTeEZRVUZOTUVJc1QwRkJjMEpJTEVWQlFVMTJRaXhGUVVGTk1FSXNUVUZEY2tVc1NVRkJTVU1zUlVGQlVVZ3NSVUZCVFVRc1IwRkJVU3hKUVVGTkxFZEJRVXNzUlVGRmNrTlNMRWRCUVZFc1owUkJRV3RFV1N4RlFVRlBMSGxFUVVFeVJFb3NSVUZCVFN4VlFVRlpReXhGUVVGTkxGZEJSR3hKTEVWQlFWQkhMRVZCUXpaS0xGbEJRV05tTEVWQlFXVXNkME5CUVcxRVN5eEZRVUZwUWl4WlFVVjZVVVlzUjBGQlVTeHBSVUZCYlVWSUxFVkJRV1VzUzBGQlQwc3NSVUZCYVVJc1QwRkxjRWdzVDBGR1FVWXNSMEZCVVN4WlFVdE9ZU3h2UWtGQmMwSXNVMEZCVTBNc1JVRkJZemRDTEVWQlFVOUpMRVZCUVUwd1FpeEhRVU0xUkN4SlFVRkpReXhGUVUxS0xFMUJUSEZDTEdsQ1FVRldMMElzUjBGQlowTXNUMEZCVmtFc1VVRkJNa01zU1VGQmJFSkJMRVZCUVUxblFpeGpRVU14UXl4SlFVRlVXaXhSUVVGM1F5eEpRVUZVTUVJc1IwRkJkMEpCTEVWQlFVdHNReXhQUVVGVExFZEJRVFJDTEdsQ1FVRm9RbWxETEZGQlFYbEVMRWxCUVhSQ1FTeEZRVUZoUXl4TFFVTXhTVU1zUlVGQmEwSkdMRVZCUVdGRExFbEJSelZDUXl4SFFVZE1ReXhaUVVGakxGTkJRVk5ETEVWQlFYRkNjRUlzUlVGQlUzRkNMRVZCUVhOQ2JFTXNSVUZCVDIxRExFVkJRVmxNTEVWQlFVMHhRaXhGUVVGTlNDeEZRVUZWUXl4RlFVRlBhME1zUlVGQlpWQXNSVUZCWTBVc1JVRkJhVUpOTEVWQlFWbERMRVZCUVc5Q1F5eEhRVWN6VFN4UlFVWnZRaXhKUVVGVWNrTXNTVUZCYzBKQkxFVkJRVkVzVVVGRmNrSXNTVUZCVkVVc1IwRkJkME1zYVVKQlFWUktMRWRCUVN0Q0xFOUJRVlpCTEZGQlFUWkRMRWxCUVhCQ1FTeEZRVUZOZDBNc1ZVRkZOVVlzVFVGRU5FSXNiVUpCUVdwQ2RrUXNVVUZCVVhkRUxFOUJRWEZDZUVRc1VVRkJVWGRFTEUxQlFVMHNWMEZCV1Znc1JVRkJUU3hyUkVGQmJVUXNVVUZCVXpGQ0xFVkJRVTBzVVVGQlUwZ3NSVUZCVlN4VFFVRlZReXhGUVVGUEswSXNSVUZCYjBKVExHVkJRek5NTEVkQlIxUXNTVUZIU1VNc1JVRklRUzlDTEU5QlFYbERMRWxCUVc1Q2JVSXNSVUZCYVVNelFpeEZRVUZQTEc5Q1FVRnpRa0VzUlVGRmNFWlhMRVZCUVU4c1IwRkZVRFpDTEVWQlFXRm9ReXhGUVVOaWFVTXNSVUZCWlN4RlFVVm1ReXhGUVVGclFpeEZRVzFEZEVJc1IwRXhRbTlDTEdsQ1FVRlVPVU1zUjBGQkswSXNUMEZCVmtFc1VVRkJNRU1zU1VGQmFrSkJMRVZCUVUxblFpeGpRVWN2UWl4SlFVRnVRbVVzU1VGRFZHTXNSMEZCWjBJc1VVRlJWU3hKUVVGdVFtUXNVVUZCTWtRc1NVRkJiRUpMTEVsQlFTdENWU3hIUVVGdFFsWXNVVUZGYmtZc1NVRkJVbWhETEVkQlFYbENhVU1zU1VGRGJFTjBRaXhIUVVGUkxEaENRVUUyUWpaQ0xFVkJRV0VzWjBKQlFXdENSU3hGUVVGclFpeGhRVUZsUkN4RlFVRmxMR3RDUVVkdVJ5eEpRVUZTZWtNc1IwRkJhME1zVDBGQlZrb3NVVUZCZDBNc1NVRkJaa0VzUlVGQlRTdERMRTlCUldoRk9VUXNVVUZCVVN0RUxFbEJRVWtzT0VKQlFTdENOVU1zVVVGRk1VSXNTVUZCVWtFc1IwRkJhVU1zVDBGQlZrb3NVVUZCZDBNc1NVRkJaa0VzUlVGQlRTdERMRTlCUVhWRExGVkJRV1l2UXl4RlFVRk5hVVFzVFVGRE4wWm9SU3hSUVVGUkswUXNTVUZCU1N3MFFrRkJOa0pvUkN4RlFVRk5hVVFzVFVGSE4wSXNhVUpCUVZScVJDeEhRVUVyUWl4UFFVRldRU3hSUVVFd1F5eEpRVUZxUWtFc1JVRkJUV2RDTEZGQlFYZENMRU5CUTNKR0xFbEJRVWxyUXl4RlFVRlJia1FzWVVGQllVTXNSVUZCVDBNc1JVRkJWVU1zUjBGRmRFTnBSQ3hGUVVFMlFpeFZRVUZhYkVRc1IwRkJhME1zVDBGQlZrUXNVVUZCSzBNc1NVRkJkRUpCTEVWQlFVMXZSQ3hyUWtGQk1FUXNTVUZCY0VKeVFpeEZRVU01UjNOQ0xFVkJRWE5DTEVkQlEzUkNReXhGUVVGdlFpeFJRVU5LTEVsQlFWUnNSQ3hIUVVGdlF5eFJRVUZhU0N4SlFVTnFRMjlFTEVWQlFYTkNMR3RFUVVGdlJHcEVMRVZCUVU4c01rWkJRVFpHUVN4RlFVRlBMRFpEUVVFclEwRXNSVUZCVHl4TlFVTXpUMnRFTEVkQlFYRkNMR1ZCUlc1Q1NDeEpRVU5HUnl4SFFVRnhRaXg1UWtGRmRrSjJReXhIUVVGUkxEUkNRVUU0UW1Jc1JVRkJVVzlFTEVWQlFXOUNMRFJDUVVFNFFrUXNSVUZCYzBJc1MwRkRkRWdzU1VFMFEwbEZMRVZCVDBFMVJDeEZRVUZITmtRc1JVRnVSRWhETEVWQlFYVkNMRTlCUVZaNlJDeFJRVUYzUXl4SlFVRm1RU3hGUVVGTkswTXNUVUZCZFVJdlF5eEZRVUZOSzBNc1YwRkJlVUlzU1VGQlZETkRMRVZCUVhWQ0xFbEJRVTFCTEVWQlFVOHNTVUZCVFN4SFFVTjJTU3hIUVVGSkswTXNSVUZCWjBJc1EwRkRiRUlzU1VGQlNVOHNSVUZCYlVJc1VVRkRia0lzVFVGQlQzWkNMRkZCUVdsR0xFbEJRWEpDUVN4RlFVRlhXU3hOUVVOb1JsY3NSVUZCYlVKMlFpeEZRVUZYV1N4TlFVVTVRamxFTEZGQlFWRXJSQ3hKUVVGSkxHMURRVUZ2UXpWRExFVkJRV2RDTEU5QlFWWktMRVZCUVdsQ1FTeEZRVUZOYVVRc1MwRkJUeXhMUVVkMFJsRXNSVUZCV1N4blIwRkJhMGR5UlN4TlFVRk5hME1zVjBGQlYyMURMRWRCUVdFc09FSkJRVzlEY2tVc1RVRkJUV3RETEZkQlFWZHZReXhIUVVGdlFpeDVRa0ZGY2s1RUxFVkJRVmtzYVVSQlFYRkVja1VzVFVGQlRXdERMRmRCUVZkdFF5eEhRVUZoTEZGQlFWVkJMRVZCUVZrc1ZVRnJRblpJTEVkQlprRXhReXhIUVVGUkxGTkJSRkkwUWl4RlFVRnJRaXhQUVVGV00wTXNVVUZCZVVNc1NVRkJhRUpCTEVWQlFVMHlSQ3hOUVVGM1FpeFhRVUZoZGtVc1RVRkJUV3RETEZkQlFWZDBRaXhGUVVGTk1rUXNUMEZCVXl4MVJFRkJNRVIyUlN4TlFVRk5hME1zVjBGQlYzUkNMRVZCUVUweVJDeFBRVUZUTEZOQlFWY3NTVUZEZGt3c2VVSkJRVEpDZWtRc1JVRkJVU3hMUVVGUGRVUXNSVUZCV1N4VlFVVm9SU3hSUVVGYWVFUXNVVUZCZVVRc1NVRkJOVUpFTEVWQlFVMDBSQ3h2UWtGRGNrTTNReXhIUVVGUkxESkZRVUUyUlROQ0xFMUJRVTFyUXl4WFFVRlhkRUlzUlVGQlRUUkVMRzFDUVVGeFFpeFJRVUZWTlVRc1JVRkJUVFJFTEd0Q1FVRnZRaXhWUVVsdVMxUXNTVUZEUm5CRExFZEJRVkVzYjBWQlExSkJMRWRCUVZFc09FWkJRMUpCTEVkQlFWRXNPRTVCUTFKQkxFZEJRVkVzVjBGRFVrRXNSMEZCVVN3clJrRkhVeXhKUVVGU1dDeEZRVWxVTEVkQlNFRlhMRWRCUVZFc2IwSkJRVzFDV0N4RlFVRlBMRlZCUjNKQ0xFZEJRVlJHTEZGQlFUWkNMRWxCUVZKRkxFVkJRM1pDTEZGQlFYRkRMRWxCUVRGQ1NpeEZRVUZOTmtRc2RVSkJRV2xGTEVsQlFYWkNOVUlzVDBGRGVFSXNTVUZCZEVKTExFbEJRVzFEZGtJc1IwRkJVU3cyUlVGQmVVVjFRaXhGUVVGeFFpeHRRMEZEY0Vnc1NVRkJja0pETEVsQlFXdERlRUlzUjBGQlVTeHhSVUZCYVVWM1FpeEZRVUZ2UWl3NFFrRkZNVWw0UWl4SFFVRlJMRzFGUVVSak5VSXNNa0pCUVhOQ01rVXNSVUZCVnpsRUxFVkJRVTAyUkN4cFFrRkJhMEl6UWl4RlFVRnpRa1FzUlVGQmIwSTRRaXhMUVVGTFF5eExRVUZOYkVNc1JVRkJUeXhOUVVNMVF5eHBRa0ZQZGtZc1NVRkJWalZDTEZGQlEyMURMRWxCUVRGQ1JpeEZRVUZOTmtRc2JVSkJRMlpPTEVWQlFWbHdSU3d5UWtGQmMwSXlSU3hGUVVGWE9VUXNSVUZCVFRaRUxHbENRVUZyUWpOQ0xFVkJRWE5DUkN4RlFVRnZRamhDTEV0QlFVdERMRXRCUVUxc1F5eEZRVUZMYkVNc1QwRkJVeXhGUVVGSmEwTXNSVUZCVHl4SlFVRk5MRTFCVFRkS0xFbEJSMGx0UXl4RlFVaEJReXhGUVVGVGJrUXNSVUZCUzI1Q0xFOUJTMnhDTEVsQlFVdEVMRVZCUVVrc1JVRkJSMEVzUlVGQlNYVkVMRVZCUVUxMFJDeFBRVUZSUkN4SlFVTTFRalpFTEVWQlFWVXhRaXhGUVVGTGJFTXNUMEZCVXl4RlFVRkphME1zUlVGQlR5eEpRVUZOYjBJc1JVRkJUWFpFTEVkQlFVdDFSQ3hGUVVGTmRrUXNSMEZETlVJc2FVSkJRVzVDU3l4RlFVRk5hMFFzUlVGQlRYWkVMRXRCUVhWRExFOUJRWEJDU3l4RlFVRk5hMFFzUlVGQlRYWkVMRlZCUVd0RUxFbEJRVE5DU3l4RlFVRk5hMFFzUlVGQlRYWkVMRWxCUVVseFFpeFZRVU16Um1sRUxFOUJRWEZDU0N4RlFVTlFMRWxCUVZZMVJDeEhRVUV5UWl4VFFVRmFaMFFzUlVGQlRYWkVMRWRCUTNaQ2IwSXNSMEZCVVdsQ0xGbEJRVmxETEVWQlFYRkNjRUlzUlVGQlUzRkNMRVZCUVhOQ2JFTXNSVUZCVFd0RUxFVkJRVTEyUkN4VFFWSjBSbmRGTEVWQlVUQkhXQ3hGUVVGVFRpeEZRVUZOZGtRc1IwRkJTVTBzUlVGQlZTeEZRVUZIYlVNc1QwRkJaVEJDTEU5QlFWZEJMRVZCUVZkNlFpeEZRVUZaUXl4SlFVVjZUREpDTEVWQlFYRkNja01zYjBKQlFXOUNReXhGUVVGak4wSXNSVUZCVFd0RUxFVkJRVTEyUkN4SlFVRkxkVVFzUlVGQlRYWkVMRWRCUVVrMlJDeEhRVU5zUm5wRExFZEJRVkZwUWl4WlFVRlpReXhGUVVGeFFuQkNMRVZCUVZOeFFpeEZRVUZ6UW14RExFVkJRVTFyUkN4RlFVRk5ka1FzVTBGWWRFWjNSU3hGUVZjd1IxZ3NSVUZCVTA0c1JVRkJUWFpFTEVkQlFVbE5MRVZCUVZWRExFVkJRVkVzUlVGQlIydERMRVZCUVdWUUxFVkJRV052UXl4RlFVRnZRalZDTEVWQlFWbERMRVZCUVc5Q2FVSXNTMEZKZGs4c1NVRkJTelZFTEVWQlFVa3NSVUZCUjBFc1JVRkJTWFZFTEVWQlFVMTBSQ3hQUVVGUlJDeEpRVU0xUWpaRUxFVkJRVlV4UWl4RlFVRkxiRU1zVDBGQlV5eEZRVUZKYTBNc1JVRkJUeXhKUVVGTmIwSXNSVUZCVFhaRUxFZEJRVXQxUkN4RlFVRk5ka1FzUjBGRE1VSXNhVUpCUVc1Q1N5eEZRVUZOYTBRc1JVRkJUWFpFTEV0QlFYVkRMRTlCUVhCQ1N5eEZRVUZOYTBRc1JVRkJUWFpFTEZWQlFXdEVMRWxCUVROQ1N5eEZRVUZOYTBRc1JVRkJUWFpFTEVsQlFVbHhRaXhWUVVNM1JtbEVMRTlCUVhGQ1NDeEZRVU5RTEVsQlFWWTFSQ3hIUVVFeVFpeFRRVUZhWjBRc1JVRkJUWFpFTEVkQlEzWkNiMElzUjBGQlVXbENMRmxCUVZsRExFVkJRWEZDY0VJc1JVRkJVM0ZDTEVWQlFYTkNiRU1zUlVGQlRXdEVMRVZCUVUxMlJDeFRRWEJDZEVaM1JTeEZRVzlDTUVkWUxFVkJRVk5PTEVWQlFVMTJSQ3hIUVVGSlRTeEZRVUZWTEVWQlFVZHRReXhQUVVGbE1FSXNUMEZCVjBFc1JVRkJWM3BDTEVWQlFWbERMRWxCUlhwTU1rSXNSVUZCY1VKeVF5eHZRa0ZCYjBKRExFVkJRV00zUWl4RlFVRk5hMFFzUlVGQlRYWkVMRWxCUVV0MVJDeEZRVUZOZGtRc1IwRkJTVFpFTEVkQlEyeEdla01zUjBGQlVXbENMRmxCUVZsRExFVkJRWEZDY0VJc1JVRkJVM0ZDTEVWQlFYTkNiRU1zUlVGQlRXdEVMRVZCUVUxMlJDeFRRWFpDZEVaM1JTeEZRWFZDTUVkWUxFVkJRVk5PTEVWQlFVMTJSQ3hIUVVGSlRTeEZRVUZWUXl4RlFVRlJMRVZCUVVkclF5eEZRVUZsVUN4RlFVRmpiME1zUlVGQmIwSTFRaXhGUVVGWlF5eEZRVUZ2UW1sQ0xFdEJUWFpQTEVkQlFXTXNTVUZFUm5oRExFVkJRVXR1UWl4UFFVRlRjMFVzUlVGRFZDeERRVVZtTEVkQlFXOUNMR2xDUVVGVWJFVXNSMEZCSzBJc1QwRkJWa0VzUjBGQmIwTXNXVUZCYkVKQkxFVkJRVTFWTEZOQlEzUkVMRTFCUVU4c1IwRkhVRXNzUjBGQlVTd3dTa0ZKVHl4SlFVRlNXQ3hKUVVOVVZ5eEhRVUZSTEhOQ1FVVldRU3hIUVVGUkxHRkJSVWdzUTBGRFRDeEpRVUZKY1VRc1IwRkJZU3hGUVVscVFpeFJRVVl5UWl4SlFVRm9RblpETEVsQlFUWkNkVU1zUjBGQllTeEhRVVYyUXl4UFFVRldjRVVzUjBGQmEwTXNhVUpCUVZSQkxGRkJRVFpETEVsQlFXcENRU3hGUVVGTlowSXNVVUZCZDBJc1EwRkRja1lzU1VGQlNYRkVMRVZCUVZjc1VVRkZaU3hKUVVGdVFuUkRMRWRCUVdkRGMwTXNSVUZCVXpWRUxFdEJRVXNzYlVKQlFYRkNUQ3hGUVVGUExHdENRVU55Um5WRExFVkJRV3RDTEU5QlFWWXpReXhSUVVGNVF5eEpRVUZvUWtFc1JVRkJUVEpFTEUxQlFYZENMRmRCUVdGMlJTeE5RVUZOYTBNc1YwRkJWM1JDTEVWQlFVMHlSQ3hQUVVGVExIVkVRVUV3UkhaRkxFMUJRVTFyUXl4WFFVRlhkRUlzUlVGQlRUSkVMRTlCUVZNc1UwRkJWeXhKUVVOMlRTOUVMRTlCUVZNc1IwRkJSM2xGTEVWQlFWTTFSQ3hMUVVGTExHZENRVVZ3UTAwc1IwRkJVU3d5UWtGQk5rSnhSQ3hGUVVGaExHRkJRV1VzU1VGQlRTeExRVVExUkVNc1JVRkJVM3BGTEU5QlFWTXNSVUZCU1N4alFVRm5RbElzVFVGQlRXdERMRmRCUVZjclF5eEZRVUZUUXl4UlFVRlZMRWxCUVUwc1NVRkRVQ3hKUVVWd1JpeEpRVUZKUXl4RlFVRjNRaXhQUVVGV2RrVXNVVUZCZDBNc1NVRkJaa0VzUlVGQlRTdERMRTFCUVhWQ0wwTXNSVUZCVFN0RExGZEJRWGxDTEVsQlFWUXpReXhGUVVGMVFpeEpRVUZOUVN4RlFVRlBMRWxCUVUwc1IwRkZlRWxYTEVkQlFWRXNVVUZCVlRSQ0xFVkJRVkVzZFVKQlJERkNORUlzUlVGQllTeHBSRUZCY1VSdVJpeE5RVUZOYTBNc1YwRkJWMmxFTEVkQlFXTXNVVUZCVlVFc1JVRkJZU3hYUVVONlJDeFZRVU12UkhoRUxFZEJRVkVzSzBKQlFXMUVMRWxCUVdoQ1l5eEZRVUU0UWl4UlFVRlZMRWxCUVUwc1owTkJRV3REZWtJc1JVRkJUeXhyUWtGRGJFbFhMRWRCUVZGS0xGZEJRVmRZTEVWQlFVOUpMRVZCUVUxUkxFVkJRV05ZTEVWQlFWVlpMRWRCUTNoRVJTeEhRVUZSTEdOQlEzTkNMRWxCUVc1Q1owSXNTVUZEVkdoQ0xFZEJRVkVzSzBSQlFXbEZXQ3hGUVVGUExHdENRVU5vUmxjc1IwRkJVVW9zVjBGQlYxZ3NSVUZCVDBrc1JVRkJUVEpDTEVWQlFXbENPVUlzUlVGQlZWa3NSMEZETTBSRkxFZEJRVkVzVTBGRlNuRkVMRWxCUTBaeVJDeEhRVUZSTEdsTFFVRnRTMWdzUlVGQlR5eExRVUZQTWtJc1JVRkJhMElzSzBKQlFXbERNMElzUlVGQlR5eG5Ra0ZEYmxCWExFZEJRVkVzT0VSQlFXZEZXQ3hGUVVGUExHdExRVU12UlZjc1IwRkJVU3h0UWtGSFdrRXNSMEZCVVN4alFVZFNRU3hIUVVadFFpeFBRVUZXWml4SFFVRnJReXhwUWtGQlZFRXNSVUZGTVVJc2MwTkJRWGREU1N4RlFVRlBMRmRCUVdGS0xFVkJRVkVzVlVGSGNFVXNjME5CUVhkRFNTeEZRVUZQTEZkQlFXRktMRVZCUVZFc1ZVRmhhRVlzV1VGUWJVSXNTVUZCVWtrc1IwRkJlVUpwUXl4SlFVTnNRM1JDTEVkQlFWRXNjVUpCUTFKQkxFZEJRVkVzZVVOQlFYZEROa0lzUlVGQllTeG5Ra0ZCYTBKRkxFVkJRV3RDTEhWQ1FVTnFSeTlDTEVkQlFWRXNaME5CUVd0RFdDeEZRVUZQTEZkQlEycEVWeXhIUVVGUkxITkNRVWRJUVN4SFFVbE1lVVFzYTBKQlFXOUNMRk5CUVZORExFVkJRVTAxUkN4RlFVRlROa1FzUlVGQlkzaERMRVZCUVhOQ2VVTXNSVUZCWlVNc1JVRkJZek5GTEVWQlFWVTBSU3hGUVVGcFFucERMRVZCUVdVd1F5eEZRVUZ0UW5wRExFVkJRVmt3UXl4UlFVTXZTaXhKUVVGa01VTXNTVUZCTWtKQkxFZEJRV0VzUjBGRGJrUXNTVUZIU1RKRExFVkJTRUZvUml4RlFVRlJXQ3hUUVVGVE5FWXNUMEZCVDFJc1JVRkJUVWNzUjBGRk9VSk5MRVZCUVZrM1JpeFRRVUZUTkVZc1QwRkJUMUlzUlVGQlRVVXNVVUZGUnl4SlFVRTVRazhzUlVGQlZYSkNMR3RDUVVGdFJDeFZRVUZvUW1Vc1IwRkJkME1zVlVGQldqTkZMRWxCUTJ4R0swVXNSVUZCYzBJM1Jpd3lRa0ZCYzBJeVJTeEZRVUZYYjBJc1JVRkJWWEpDTEdsQ1FVRnJRak5DTEVWQlFYTkNOME1zVTBGQlV6aEdMR0ZCUVdGd1FpeFZRVUZMUkN4RlFVRlhWeXhGUVVGTlF5eEZRVUZqUXl4RlFVRmxRU3hGUVVGbExFMUJSMjVOTEVsQlNVbDRReXhGUVVwQlRpeFBRVUV5UXl4SlFVRnlRbWxFTEVkQlFXOURRU3hGUVVGdlFrd3NSVUZCUzBjc1IwRkJZMUVzYlVKQlFXZENkRUlzUlVGRGFrZ3ZRaXhQUVVFNFF5eEpRVUZ5UWl0RExFZEJRVzlEUVN4RlFVRnZRa3dzUlVGQlMwY3NSMEZCWTFNc2EwSkJRV1YyUWl4UFFVbDRSaXhKUVVGd1FpOUNMRWxCUjFSSkxFVkJSbE01UXl4VFFVRlRORVlzVDBGQlQxSXNSVUZCVFN4VFFVVm1NVU1zUlVGQlowSjFSQ3hSUVVGUkxIVkNRVUYzUWl4TlFVbHNSU3hKUVVGSmNrUXNSVUZCYzBJMVF5eFRRVUZUT0VZc1lVRkJZWEJDTEZWQlFVdEVMRVZCUVZkWExFVkJRVTFETEVWQlFXTkRMRVZCUVdWRExFZEJRMjVITTBNc1JVRkJiMEpUTEdOQlFXZENhME1zUlVGRmNFTXNTVUZCU1RkRUxFVkJRVThzZFVKQlExaEJMRWRCUVZFc09FSkJRVzFFTEVsQlFXaENZeXhGUVVFNFFpeG5Ra0ZCYTBJc1NVRkJUU3hMUVVGUk4wSXNSVUZCVFdsRUxFdEJRVThzVTBGRmRFZ3NTVUZCU1hORExFVkJRV2RDZGtRc1dVRkJXVU1zUlVGQmNVSndRaXhGUVVGVGNVSXNSVUZCYzBKc1F5eEZRVUZQYlVNc1JVRkJXU3hSUVVGSk1rSXNSVUZCVnpkRUxFVkJRVlU0UlN4RlFVRlhNME1zUlVGQlpWQXNSVUZCWTBVc1JVRkJhVUpOTEVWQlFWa3lReXhIUVVOcVRVOHNSVUZCWXpOR0xFOUJRVk1zU1VGRGVrSnRRaXhIUVVGUmQwVXNSMEZMVmxZc1JVRkdRVGxFTEVkQlFWRXNVMEZGWXpaRUxFVkJRV016UlN4SlFVZHNRM1ZHTEcxQ1FVRnhRaXhUUVVGVFppeEZRVUZOTlVRc1JVRkJVelpFTEVWQlFXTjRReXhGUVVGelFubERMRVZCUVdWRExFVkJRV05ETEVWQlFXbENla01zUjBGRGFrbHZReXhyUWtGQmEwSkRMRVZCUVUwMVJDeEZRVUZUTmtRc1JVRkJZM2hETEVWQlFYTkNlVU1zUlVGQlpVTXNSVUZCWXl4UFFVRlJReXhGUVVGcFFucERMRWRCUXpOSWIwTXNhMEpCUVd0Q1F5eEZRVUZOTlVRc1JVRkJVelpFTEVWQlFXTjRReXhGUVVGelFubERMRVZCUVdWRExFVkJRV01zVTBGQlZVTXNSVUZCYVVKNlF5eEhRVUZsTEVsQlJ6RkpjVVFzWjBKQlFXdENMRk5CUVZORExFVkJRV0UzUlN4RlFVRlRjVUlzUlVGQmMwSXlReXhGUVVGcFFucERMRWRCUXpGR0xFbEJSMGwxUkN4RlFVaEJiRUlzUlVGQlQybENMRVZCUVZsRkxFMUJRMjVDYUVJc1JVRkJaV01zUlVGQldXUXNZVUZETTBKcFFpeEZRVUZUU0N4RlFVRlpTU3hSUVVWeVFrTXNSVUZCV1N4SFFVTm9RaXhKUVVGTFNpeEZRVUZOTEVWQlFVZEJMRVZCUVUxRkxFVkJRVTlxUnl4UFFVRlJLMFlzVTBGRFNTeEpRVUV4UWtVc1JVRkJUMFlzUjBGQlMwc3NWMEZEY2tKRUxFVkJRVlYwUml4TFFVRkxjRUlzVTBGQlV6UkhMR05CUVdONFFpeEZRVUZOYjBJc1JVRkJUMFlzUjBGQlMwOHNVVUZGTVVSV0xHMUNRVUZ0UW1Zc1JVRkJUVFZFTEU5QlFWTnBSQ3hGUVVGWE5VSXNSVUZCYzBJeVJDeEZRVUZQUml4SFFVRkxVU3hMUVVGTlRpeEZRVUZQUml4SFFVRkxUeXhOUVVGUGNrSXNSVUZCYVVKNlF5eEhRVWt6U0N4WlFVUTBRaXhKUVVGcVFuRkRMRVZCUVZrc1QwRkJhMEpFTEd0Q1FVRnJRa01zUlVGQlRUVkVMRTlCUVZOcFJDeEZRVUZYTlVJc1JVRkJjMEl3UXl4RlFVRmpMRkZCUVZNc1UwRkJWVU1zVDBGQmFVSm1MRWRCUVZjc1IwRkJUeXhIUVVGUkxFZEJRMmhNYVVNc1IwRkhWRXNzVDBGQlQwTXNVVUZCVlZvaUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwyTnZiblpsY25SbGNpOWxaR2wwYjNJdWFuTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIG1vZGVsRGVmPXJlcXVpcmUoXCIuL21vZGVsLmpzXCIpLHdyYXBwZWRSZXN1bHRNb2RlbD1mdW5jdGlvbihlKXt2YXIgcj1lLl9kZWZzLHQ9ZS50ZW1wbGF0ZU5hbWUsbD1tb2RlbERlZi5nZXREZWYocix0KSxhPW1vZGVsRGVmLmdlbmVyYXRlUmVzdWx0TW9kZWwoZSk7cmV0dXJuIHJlcXVpcmUoXCIuL3dyYXBwZXIuanNcIikoYSxsLHIpfSx0cmFuc2xhdGVUZW1wbGF0ZT1mdW5jdGlvbigpe3ZhciBlPXJlcXVpcmUoXCIuL3BhcnNlci5qc1wiKTtyZXR1cm4gZS5hcHBseShlLGFyZ3VtZW50cyl9LGdlbmVyYXRlRWRpdG9ycz1mdW5jdGlvbigpe3ZhciBlPXJlcXVpcmUoXCIuL2VkaXRvci5qc1wiKTtyZXR1cm4gZS5hcHBseShlLGFyZ3VtZW50cyl9LGNoZWNrTW9kZWw9ZnVuY3Rpb24oKXt2YXIgZT1yZXF1aXJlKFwiLi9jaGVja21vZGVsLmpzXCIpO3JldHVybiBlLmFwcGx5KGUsYXJndW1lbnRzKX07bW9kdWxlLmV4cG9ydHM9e3RyYW5zbGF0ZVRlbXBsYXRlOnRyYW5zbGF0ZVRlbXBsYXRlLHdyYXBwZWRSZXN1bHRNb2RlbDp3cmFwcGVkUmVzdWx0TW9kZWwsZ2VuZXJhdGVSZXN1bHRNb2RlbDptb2RlbERlZi5nZW5lcmF0ZVJlc3VsdE1vZGVsLGdlbmVyYXRlRWRpdG9yczpnZW5lcmF0ZUVkaXRvcnMsY2hlY2tNb2RlbDpjaGVja01vZGVsfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltMWhhVzR1YW5NaVhTd2libUZ0WlhNaU9sc2liVzlrWld4RVpXWWlMQ0p5WlhGMWFYSmxJaXdpZDNKaGNIQmxaRkpsYzNWc2RFMXZaR1ZzSWl3aWRHVnRjR3hoZEdWRVpXWWlMQ0prWldaeklpd2lYMlJsWm5NaUxDSjBaVzF3YkdGMFpVNWhiV1VpTENKbWFXNWhiRTF2WkdWc1EyOXVkR1Z1ZEVSbFppSXNJbWRsZEVSbFppSXNJbVpwYm1Gc1RXOWtaV3hEYjI1MFpXNTBJaXdpWjJWdVpYSmhkR1ZTWlhOMWJIUk5iMlJsYkNJc0luZHlZWEJ3WlhJaUxDSjBjbUZ1YzJ4aGRHVlVaVzF3YkdGMFpTSXNJblIwSWl3aVlYQndiSGtpTENKaGNtZDFiV1Z1ZEhNaUxDSm5aVzVsY21GMFpVVmthWFJ2Y25NaUxDSm5aU0lzSW1Ob1pXTnJUVzlrWld3aUxDSmpiU0lzSW0xdlpIVnNaU0lzSW1WNGNHOXlkSE1pWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEdGQlIwRXNTVUZCU1VFc1UwRkJWME1zVVVGQlVTeGpRVVZ1UWtNc2JVSkJRWEZDTEZOQlFWTkRMRWRCUTJoRExFbEJRVWxETEVWQlFVOUVMRVZCUVZsRkxFMUJRMjVDUXl4RlFVRmxTQ3hGUVVGWlJ5eGhRVU16UWtNc1JVRkJkVUpRTEZOQlFWTlJMRTlCUVU5S0xFVkJRVTFGTEVkQlJUZERSeXhGUVVGdlFsUXNVMEZCVTFVc2IwSkJRVzlDVUN4SFFVdHlSQ3hQUVVoalJpeFJRVUZSTEdWQlExcFZMRU5CUVZGR0xFVkJRVzFDUml4RlFVRnpRa2dzU1VGTmVrUlJMR3RDUVVGdlFpeFhRVU4wUWl4SlFVRkpReXhGUVVGTFdpeFJRVUZSTEdWQlEycENMRTlCUVU5WkxFVkJRVWRETEUxQlFVMUVMRVZCUVVsRkxGbEJTV3hDUXl4blFrRkJhMElzVjBGRGNFSXNTVUZCU1VNc1JVRkJTMmhDTEZGQlFWRXNaVUZEYWtJc1QwRkJUMmRDTEVWQlFVZElMRTFCUVUxSExFVkJRVWxHTEZsQlIyeENSeXhYUVVGaExGZEJRMllzU1VGQlNVTXNSVUZCUzJ4Q0xGRkJRVkVzYlVKQlEycENMRTlCUVU5clFpeEZRVUZIVEN4TlFVRk5TeXhGUVVGSlNpeFpRVWQwUWtzc1QwRkJUME1zVVVGQlZTeERRVU5tVkN4clFrRkJiVUpCTEd0Q1FVTnVRbFlzYlVKQlFXOUNRU3h0UWtGRGNFSlJMRzlDUVVGeFFsWXNVMEZCVTFVc2IwSkJRemxDVFN4blFrRkJhVUpCTEdkQ1FVTnFRa1VzVjBGQldVRWlMQ0ptYVd4bElqb2lMM0J5YVhaaGRHVXZkRzF3TDJadmJ5NUhUMFV2YzNKakwycHpMMk52Ym5abGNuUmxjaTl0WVdsdUxtcHpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIG9iakV4dGVuZD1yZXF1aXJlKFwiLi9kb211dGlscy5qc1wiKS5vYmpFeHRlbmQsY29uc29sZT1yZXF1aXJlKFwiY29uc29sZS1icm93c2VyaWZ5XCIpLF92YWx1ZVNldD1mdW5jdGlvbihlLHQsbyxsKXt2YXIgcj1vLmluZGV4T2YoXCIuXCIpO2lmKC0xPT1yKWlmKHZvaWQgMD09PXRbb10pY29uc29sZS5sb2coXCJVbmRlZmluZWQgcHJvcCBcIitvK1wiIHdoaWxlIHNldHRpbmcgdmFsdWUgXCIrbCtcIiBpbiBtb2RlbC5fdmFsdWVTZXRcIik7ZWxzZSBpZihudWxsPT09dFtvXSlcIm9iamVjdFwiPT10eXBlb2YgbCYmbnVsbCE9PWwmJnZvaWQgMD09PWwucHVzaCYmY29uc29sZS5sb2coXCJudWxscHJvcG9iamVjdHZhbHVlXCIsbyxsKSx0W29dPWw7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgdFtvXSYmXCJmdW5jdGlvblwiPT10eXBlb2YgdFtvXS5wdXNoKXt2YXIgbjtpZihcInN0cmluZ1wiPT10eXBlb2YgbCl7dmFyIGk9bC5tYXRjaCgvXlxcWyguKilcXF0kLyk7aWYobnVsbD09PWkpdGhyb3dcIlVuZXhwZWN0ZWQgZGVmYXVsdCB2YWx1ZSBmb3IgYXJyYXkgcHJvcGVydHkgXCIrbytcIjogXCIrbDtuPWlbMV0uc3BsaXQoXCIsXCIpfWVsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGx8fHZvaWQgMD09PWwucHVzaCl0aHJvd1wiVW5leHBlY3RlZCBkZWZhdWx0IHZhbHVlIGZvciBhcnJheSBwcm9wZXJ0eSBcIitvK1wiOiBcIitsK1wiIHR5cGVvZiBcIit0eXBlb2YgbDtuPWx9Zm9yKHZhciBhPVtdLGQ9MDtkPG4ubGVuZ3RoO2QrKylcIkBcIj09bltkXS5zdWJzdHIoMCwxKT9hLnB1c2goX2dlbmVyYXRlTW9kZWwoZSxuW2RdLnN1YnN0cigxKSkpOm5bZF0ubGVuZ3RoPjAmJmEucHVzaChuW2RdKTt0W29dPWF9ZWxzZVwic3RyaW5nXCI9PXR5cGVvZiB0W29dfHxcImJvb2xlYW5cIj09dHlwZW9mIHRbb10/dFtvXT1sOlwib2JqZWN0XCI9PXR5cGVvZiB0W29dJiZudWxsIT09dFtvXSYmdm9pZCAwIT09dFtvXS5fd2lkZ2V0PyhcIm9iamVjdFwiPT10eXBlb2YgbCYmbnVsbCE9PWwmJmNvbnNvbGUubG9nKFwib2JqZWN0dmFsdWVcIixvLHRbb10uX3dpZGdldCxsKSx0W29dPWwpOmNvbnNvbGUubG9nKFwic2V0dGluZ1wiLHR5cGVvZiB0W29dLHRbb10sbyxsKTtlbHNle3ZhciBmPW8uc3Vic3RyKDAscik7X3ZhbHVlU2V0KGUsdFtmXSxvLnN1YnN0cihyKzEpLGwpfX0sX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZj1mdW5jdGlvbihlLHQsbyxsKXtpZih2b2lkIDAhPT1lW3RdJiZlW3RdLl9pbml0aWFsaXplZCYmIWVbdF0uX3dyaXRlYWJsZSl0aHJvdyBjb25zb2xlLmxvZyhcIl9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWZcIixlLHQsbyxsKSxcIlRyeWluZyB0byBhbHRlciBub24gd3JpdGVhYmxlIG1vZGVsOiBcIit0K1wiIC8gXCIrbztpZih2b2lkIDA9PT1lW3RdJiYoZVt0XT17X3dyaXRlYWJsZTohMH0sdm9pZCAwPT09bCYmKGw9e30pLHZvaWQgMD09PWwuY2F0ZWdvcnkmJnZvaWQgMD09PWVbdF0uX2NhdGVnb3J5JiYodC5tYXRjaCgvKF50fC5UKWhlbWUkLyl8fHQubWF0Y2goLyhec3wuUyl0eWxlJC8pfHx0Lm1hdGNoKC8oXmN8LkMpb2xvciQvKXx8dC5tYXRjaCgvKF5yfC5SKWFkaXVzJC8pP2wuY2F0ZWdvcnk9XCJzdHlsZVwiOmwuY2F0ZWdvcnk9XCJjb250ZW50XCIpKSx2b2lkIDAhPT1sKXtpZih2b2lkIDAhPT1sLm5hbWUmJihlW3RdLl9uYW1lPWwubmFtZSksdm9pZCAwIT09bC50aGVtZU92ZXJyaWRlJiYoZVt0XS5fdGhlbWVPdmVycmlkZT1sLnRoZW1lT3ZlcnJpZGUpLHZvaWQgMCE9PWwuZ2xvYmFsU3R5bGUpe2VbdF0uX2dsb2JhbFN0eWxlPWwuZ2xvYmFsU3R5bGU7dmFyIHI9bC5nbG9iYWxTdHlsZS5yZXBsYWNlKC9eKFxcJHRoZW1lfF90aGVtZV8pXFwuLyxcIlwiKSxuPXIuaW5kZXhPZihcIi5cIiksaT0tMSE9bj9yLnN1YnN0cigwLG4pOnI7X21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZihlLFwidGhlbWVcIixpKSwodm9pZCAwPT09ZVt0XS5fdGhlbWVPdmVycmlkZXx8ZVt0XS5fdGhlbWVPdmVycmlkZSkmJl9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZSx0LFwiY3VzdG9tU3R5bGU9ZmFsc2VcIil9dm9pZCAwIT09bC5jb250ZXh0TmFtZSYmKGVbdF0uX2NvbnRleHQ9bC5jb250ZXh0TmFtZSxcImJsb2NrXCI9PWwuY29udGV4dE5hbWUmJnZvaWQgMD09PWVbdF0uX2dsb2JhbFN0eWxlJiYoZVt0XS5fZ2xvYmFsU3R5bGU9XCJfdGhlbWVfLmJvZHlUaGVtZVwiLF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZSxcInRoZW1lXCIsXCJib2R5VGhlbWVcIiksKHZvaWQgMD09PWVbdF0uX3RoZW1lT3ZlcnJpZGV8fGVbdF0uX3RoZW1lT3ZlcnJpZGUpJiZfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGUsdCxcImN1c3RvbVN0eWxlPWZhbHNlXCIpKSksdm9pZCAwIT09bC5leHRlbmQmJihlW3RdLnR5cGU9bC5leHRlbmQpfWZvcih2YXIgYSBpbiBsKWwuaGFzT3duUHJvcGVydHkoYSkmJnZvaWQgMCE9PWxbYV0mJi0xPT1bXCJuYW1lXCIsXCJleHRlbmRcIixcImNvbnRleHROYW1lXCIsXCJnbG9iYWxTdHlsZVwiLFwidGhlbWVPdmVycmlkZVwiXS5pbmRleE9mKGEpJiYoZVt0XVtcIl9cIithXT1sW2FdKTt2b2lkIDAhPT1vJiZvLmxlbmd0aD4wJiYoZVt0XS5fcHJvcHM9dm9pZCAwIT09ZVt0XS5fcHJvcHMmJmVbdF0uX3Byb3BzLmxlbmd0aD4wP2VbdF0uX3Byb3BzK1wiIFwiK286byl9LF9yZW1vdmVQcmVmaXg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5tYXRjaCgvXlteQS1aXSsoW0EtWl0pKC4qKSQvKTtyZXR1cm4gbnVsbCE9PXQ/dFsxXS50b0xvd2VyQ2FzZSgpK3RbMl06bnVsbH0sX2dlbmVyYXRlTW9kZWxGcm9tRGVmPWZ1bmN0aW9uKGUsdCl7dmFyIG89e307Zm9yKHZhciBsIGluIGUpaWYoIWwubWF0Y2goL15fLiovKSYmZS5oYXNPd25Qcm9wZXJ0eShsKSl7dmFyIHI9ZVtsXTtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmbnVsbCE9PXImJnZvaWQgMCE9PXIuX2NvbXBsZXgmJnIuX2NvbXBsZXgpb1tsXT1fZ2VuZXJhdGVNb2RlbEZyb21EZWYocix0KTtlbHNlIGlmKFwidHlwZVwiPT1sKW9bbF09cjtlbHNle2lmKFwib2JqZWN0XCIhPXR5cGVvZiByKXRocm93IGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIG1vZGVsIGRlZlwiLGwscixlKSxcIlVuZXhwZWN0ZWQgbW9kZWwgZGVmIFtcIitsK1wiXT1cIityO29bbF09bnVsbH19aWYodm9pZCAwIT09ZS5fZGVmYXVsdFZhbHVlcyl7dmFyIG49ZS5fZGVmYXVsdFZhbHVlcztmb3IodmFyIGkgaW4gbiluLmhhc093blByb3BlcnR5KGkpJiZfdmFsdWVTZXQodCxvLGksbltpXSl9cmV0dXJuIG99LF9nZW5lcmF0ZU1vZGVsPWZ1bmN0aW9uKGUsdCl7dmFyIG89X2dldE1vZGVsRGVmKGUsdCwhMSwhMCk7cmV0dXJuIF9nZW5lcmF0ZU1vZGVsRnJvbURlZihvLGUpfSxfZ2V0RGVmPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9nZXRNb2RlbERlZihlLHQsITEsITApfSxfZ2V0TW9kZWxEZWY9ZnVuY3Rpb24oZSx0LG8sbCl7aWYodm9pZCAwPT09ZVt0XSl7aWYoLTEhPXQuaW5kZXhPZihcIiBcIikpcmV0dXJuIG51bGw7dmFyIHI9X3JlbW92ZVByZWZpeCh0KTtyZXR1cm4gbnVsbCE9PXI/X2dldE1vZGVsRGVmKGUscixvLGwpOm51bGx9dmFyIG49ZVt0XTtpZihcIm9iamVjdFwiIT10eXBlb2Ygbil0aHJvd1wiQmxvY2sgZGVmaW5pdGlvbiBtdXN0IGJlIGFuIG9iamVjdDogZm91bmQgXCIrbitcIiBmb3IgXCIrdDtpZih2b2lkIDA9PT1uLl9pbml0aWFsaXplZCl7aWYodm9pZCAwPT09bi50eXBlJiYoLTE9PXQuaW5kZXhPZihcIiBcIik/bi50eXBlPXQ6bi50eXBlPXQuc3Vic3RyKHQuaW5kZXhPZihcIiBcIikrMSkpLG4udHlwZSE9dCYmdm9pZCAwPT09bi5fd2lkZ2V0KXt2YXIgaT1fZ2V0TW9kZWxEZWYoZSxuLnR5cGUsITApO249b2JqRXh0ZW5kKGksbiksZVt0XT1ufWVsc2Ugdm9pZCAwPT09bi5fd2lkZ2V0JiZ2b2lkIDA9PT1uLl9wcm9wcyYmbi5fY29tcGxleDtuLl93cml0ZWFibGU9ITAsbi5faW5pdGlhbGl6ZWQ9ITB9aWYodm9pZCAwIT09bi5fcHJvcHMpe3ZhciBhPW4uX3Byb3BzO2lmKChhPWEuc3BsaXQoXCIgXCIpKS5sZW5ndGg+MCYmdm9pZCAwPT09bi5fd3JpdGVhYmxlKXRocm93IGNvbnNvbGUuZXJyb3IoXCJBbHRlcmluZyBhIG5vbiB3cml0YWJsZSBvYmplY3QgXCIsdCxhLG4pLFwiQWx0ZXJpbmcgYSBub24gd3JpdGFibGUgb2JqZWN0OiBcIit0K1wiIGRlZjogXCIrYTt2b2lkIDA9PT1uLl9wcm9jZXNzZWREZWZzJiYobi5fcHJvY2Vzc2VkRGVmcz17fSksdm9pZCAwPT09bi5fZ2xvYmFsU3R5bGVzJiYobi5fZ2xvYmFsU3R5bGVzPXt9KSx2b2lkIDA9PT1uLl9kZWZhdWx0VmFsdWVzJiYobi5fZGVmYXVsdFZhbHVlcz17fSk7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBmPWFbZF07aWYoMCE9PWYubGVuZ3RoKXt2YXIgcz1mLHU9bnVsbCxjPWYubWF0Y2goL14oW149XFxbXFxdXSspKFxcW1xcXSk/KD0/KSguKikkLyk7aWYobnVsbCE9PWMmJihmPWNbMV0sXCJbXVwiPT1jWzJdJiYodm9pZCAwPT09bltmXSYmKG5bZl09W10pLHU9W10pLFwiPVwiPT1jWzNdJiYodT1mLm1hdGNoKC8oXnZ8Vilpc2libGUkLyk/XCJ0cnVlXCI9PVN0cmluZyhjWzRdKS50b0xvd2VyQ2FzZSgpOmYubWF0Y2goL15jdXN0b21TdHlsZSQvKT9cInRydWVcIj09U3RyaW5nKGNbNF0pLnRvTG93ZXJDYXNlKCk6Y1s0XSkpLG51bGwhPT11JiZ2b2lkIDA9PT1uLl9kZWZhdWx0VmFsdWVzW2ZdJiYobi5fZGVmYXVsdFZhbHVlc1tmXT11KSx2b2lkIDA9PT1uW2ZdKXt2YXIgXz1fZ2V0TW9kZWxEZWYoZSx0K1wiIFwiK2YsITApO251bGw9PT1fJiYoXz1fZ2V0TW9kZWxEZWYoZSxmLCEwKSksbltmXT1ffW4uX3Byb2Nlc3NlZERlZnNbZl09cyxuLl9jb21wbGV4PSEwfX1kZWxldGUgbi5fcHJvcHN9aWYobylyZXR1cm4gbi5fd3JpdGVhYmxlPSExLG9iakV4dGVuZCh7fSxuKTtpZihsKXJldHVybiBuLl93cml0ZWFibGU9ITEsbjtpZih2b2lkIDA9PT1uLl93cml0ZWFibGV8fCExPT09bi5fd3JpdGVhYmxlKXRocm93XCJSZXRyaWV2aW5nIG5vbiB3cml0ZWFibGUgb2JqZWN0IGRlZmluaXRpb246IFwiK3Q7cmV0dXJuIG59LF9pbmNyZWFzZVVzZUNvdW50PWZ1bmN0aW9uKGUsdCl7aWYoZSl7aWYodm9pZCAwPT09dC5fdXNlY291bnQpdGhyb3cgY29uc29sZS5lcnJvcihcIkVSUk9SIHRyeWluZyB0byBiaW5kIGFuIHVudXNlZCBwcm9wZXJ0eSB3aGlsZSByZWFkb25seVwiLHQpLFwiRVJST1IgdHJ5aW5nIHRvIGJpbmQgYW4gdW51c2VkIHByb3BlcnR5XCJ9ZWxzZSB2b2lkIDA9PT10Ll91c2Vjb3VudCYmKHQuX3VzZWNvdW50PTApLHQuX3VzZWNvdW50Kyt9LGVuc3VyZUdsb2JhbFN0eWxlPWZ1bmN0aW9uKGUsdCxvLGwscixuLGksYSl7dmFyIGQ9byhuLGksYSk7aWYodm9pZCAwPT09ZVtsXS5fZ2xvYmFsU3R5bGVzW3JdKXtpZih0KXRocm93XCJDYW5ub3QgZmluZCBfZ2xvYmFsU3R5bGUgZm9yIFwiK3IrXCIgaW4gXCIrbCtcIiFcIjsoLTEhPXIuaW5kZXhPZihcIi5cIil8fFwib2JqZWN0XCI9PXR5cGVvZiBlW2xdW3JdJiZ2b2lkIDAhPT1lW2xdW3JdLl93aWRnZXQpJiYoZVtsXS5fZ2xvYmFsU3R5bGVzW3JdPWQpfWVsc2UgaWYoZVtsXS5fZ2xvYmFsU3R5bGVzW3JdIT1kKXRocm93XCJVbmV4cGVjdGVkIGNvbmZsaWN0aW5nIGdsb2JhbFN0eWxlIFsyXSBmb3IgXCIrbCtcIi9cIityK1wiOiBvbGQ9XCIrZVtsXS5fZ2xvYmFsU3R5bGVzW3JdK1wiIG5ldz1cIitkfSxtb2RlbEVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWU9ZnVuY3Rpb24oZSx0LG8sbCxyLG4saSxhLGQsZil7dmFyIHMsdSxjO2lmKFwiJFwiPT1pLnN1YnN0cigwLDEpKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEICQgaW4gYmluZGluZ1Byb3ZpZGVyOiBcIixpLHIpO3ZhciBfPWkuaW5kZXhPZihcIi5cIik7aWYoLTE9PV8pdGhyb3dcIlVuZXhwZWN0ZWQgZnVsbFBhdGg6IFwiK2krXCIvXCIrbitcIi9cIityK1wiL1wiK2ErXCIvXCIrZDtpZihzPWkuc3Vic3RyKDEsXy0xKSxjPWkuc3Vic3RyKF8rMSksXCJ0aGVtZVwiIT1zKXRocm93XCJVbmV4cGVjdGVkICQgc2VxdWVuY2U6IFwiK3MrXCIgaW4gXCIraTt2YXIgdj1jLmluZGV4T2YoXCIuXCIpO3U9XCIkcm9vdC5jb250ZW50KCkudGhlbWUoKS5cIisocz1jLnN1YnN0cigwLHYpKStcIigpLlwiKyhjPWMuc3Vic3RyKHYrMSkpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFwuXCIsXCJnXCIpLFwiKCkuXCIpfWVsc2UgaWYoXCIjXCI9PWkuc3Vic3RyKDAsMSkpY29uc29sZS53YXJuKFwiREVQUkVDQVRFRCAjIGluIGJpbmRpbmdQcm92aWRlcjogXCIsaSxyKSxzPWwsdT1cIiRyb290LmNvbnRlbnQoKS5cIisoYz1pLnN1YnN0cigxKSkucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXC5cIixcImdcIiksXCIoKS5cIik7ZWxzZSBpZihcIl90aGVtZV8uXCI9PWkuc3Vic3RyKDAsOCkpe3ZhciBwPWkuaW5kZXhPZihcIi5cIiw4KTt1PVwiJHJvb3QuY29udGVudCgpLnRoZW1lKCkuXCIrKHM9aS5zdWJzdHIoOCxwLTgpKStcIigpLlwiKyhjPWkuc3Vic3RyKHArMSkpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFwuXCIsXCJnXCIpLFwiKCkuXCIpfWVsc2VcIl9yb290Xy5cIj09aS5zdWJzdHIoMCw3KT8ocz1sLHU9XCIkcm9vdC5jb250ZW50KCkuXCIrKGM9aS5zdWJzdHIoNykpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFwuXCIsXCJnXCIpLFwiKCkuXCIpKToocz1yLGM9bitpLHU9aS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcLlwiLFwiZ1wiKSxcIigpLlwiKSk7aWYodm9pZCAwPT09dFtzXSl0aHJvd1wiQ2Fubm90IGZpbmQgbW9kZWwgZGVmIGZvciBbXCIrcytcIl1cIjt2YXIgZyxiPWMuaW5kZXhPZihcIi5cIiksaD0tMT09Yj9jOmMuc3Vic3RyKDAsYik7aWYoLTEhPXMuaW5kZXhPZihcIi1cIikpdGhyb3cgY29uc29sZS5lcnJvcihcIkVSUk9SIGNhbm5vdCB1c2UgLSBmb3IgYmxvY2sgbmFtZXNcIixzKSxcIkVSUk9SIHVuZXhwZWN0ZWQgY2hhciBpbiBibG9jayBuYW1lOiBcIitzO2lmKC0xIT1oLmluZGV4T2YoXCItXCIpKXRocm93IGNvbnNvbGUuZXJyb3IoXCJFUlJPUiBjYW5ub3QgdXNlIC0gZm9yIHByb3BlcnR5IG5hbWVzXCIsaCksXCJFUlJPUiB1bmV4cGVjdGVkIGNoYXIgaW4gcHJvcGVydHkgbmFtZTogXCIrcztpZihlKXJldHVybiB2b2lkIDAhPT10W3NdLl9nbG9iYWxTdHlsZSYmdm9pZCAwIT09dFtzXVtoXSYmXCJzdHlsZVwiPT10W3NdW2hdLl9jYXRlZ29yeSYmKHUrPVwiLl9kZWZhdWx0Q29tcHV0ZWRcIiksdTtpZihlKXtpZih2b2lkIDAhPT1hKXRocm93XCJDYW5ub3QgdXNlIGRlZmF1bHRWYWx1ZSBpbiByZWFkb25seSBtb2RlIVwiO2lmKGQpdGhyb3dcIkNhbm5vdCB1c2Ugb3ZlcnJpZGVEZWZhdWx0IGluIHJlYWRvbmx5IG1vZGUgZm9yIFwiK3MrXCIvXCIrYytcIi9cIitkK1wiIVwiO2lmKHZvaWQgMCE9PWYpdGhyb3dcIkNhbm5vdCBzZXQgY2F0ZWdvcnkgZm9yIFwiK3MrXCIvXCIrYytcIi9cIitmK1wiIGluIHJlYWRvbmx5IG1vZGUhXCI7Zz1fZ2V0TW9kZWxEZWYodCxzLCExLCEwKX1lbHNlITE9PT10W3NdLl93cml0ZWFibGUmJmNvbnNvbGUubG9nKFwiVE9ETyBkZWJ1ZyB1c2UgY2FzZXMgZm9yIHRoaXMgY29uZGl0aW9uXCIscyxjKSxnPV9nZXRNb2RlbERlZih0LHMsITE9PT10W3NdLl93cml0ZWFibGUpO2lmKG51bGw9PT1nKXRocm93XCJVbmV4cGVjdGVkIG1vZGVsIGZvciBbXCIrcytcIl1cIjtpZih2b2lkIDA9PT1nW2hdKXtpZihlKXRocm93XCJDYW5ub3QgZmluZCBwYXRoIFwiK2grXCIgZm9yIFwiK3MrXCIhXCI7X21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZih0LHMsaCksZz1fZ2V0TW9kZWxEZWYodCxzLCExKX12b2lkIDAhPT10W3NdLl9nbG9iYWxTdHlsZSYmdm9pZCAwIT09dFtzXVtoXSYmbnVsbCE9PXRbc11baF0mJlwic3R5bGVcIj09dFtzXVtoXS5fY2F0ZWdvcnkmJih1Kz1cIi5fZGVmYXVsdENvbXB1dGVkXCIpO3ZhciB5PWc7dHJ5e2lmKF9pbmNyZWFzZVVzZUNvdW50KGUseSksLTEhPWIpe3ZhciBtPWM7ZG97dmFyIHc9bS5zdWJzdHIoMCxiKTtpZih2b2lkIDA9PT15W3ddKXRocm93XCJGb3VuZCBhbiB1bmV4cGVjdGVkIHByb3AgXCIrdytcIiBmb3IgbW9kZWwgXCIrcytcIiBmb3IgXCIrYzt5PXlbd10sX2luY3JlYXNlVXNlQ291bnQoZSx5KSxiPShtPW0uc3Vic3RyKGIrMSkpLmluZGV4T2YoXCIuXCIpfXdoaWxlKC0xIT1iKTtpZih2b2lkIDA9PT15W21dfHxudWxsPT09eVttXSl0aHJvd1wiRm91bmQgYW4gdW5leHBlY3RlZCBwYXRoIHRlcm1pbmF0aW9uIFwiK20rXCIgZm9yIG1vZGVsIFwiK3MrXCIgZm9yIFwiK2M7eT15W21dfWVsc2UgeT15W2NdO2lmKG51bGw9PXkpdGhyb3dcIlVuZXhwZWN0ZWQgbnVsbCBtb2RlbCBmb3IgXCIrcytcIi9cIituK1wiL1wiK2k7dm9pZCAwIT09ZiYmKHkuX2NhdGVnb3J5PWYpLF9pbmNyZWFzZVVzZUNvdW50KGUseSl9Y2F0Y2goZSl7dGhyb3cgY29uc29sZS5lcnJvcihcIlRPRE8gRVJST1IgUHJvcGVydHkgbG9va3VwIGV4Y2VwdGlvblwiLGUscyxjLHIsaSx0KSxlfWlmKHZvaWQgMCE9PXRbc10uX2dsb2JhbFN0eWxlJiZcIm9iamVjdFwiPT10eXBlb2YgdFtzXVtoXSYmbnVsbCE9PXRbc11baF0mJnZvaWQgMCE9PXRbc11baF0uX2NhdGVnb3J5JiZcInN0eWxlXCI9PXRbc11baF0uX2NhdGVnb3J5KXt2YXIgeD1tb2RlbEVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUuYmluZCh2b2lkIDAsZSx0LG8sbCxyLFwiXCIpLE89LTEhPWMuaW5kZXhPZihcIi5cIik/Yy5zdWJzdHIoYy5pbmRleE9mKFwiLlwiKSk6XCJcIjtpZigtMSE9Ty5pbmRleE9mKFwiLlwiLDEpKXRocm93XCJUT0RPIHVuc3VwcG9ydGVkIG9iamVjdCBuZXN0aW5nISBcIitjO3ZhciBEPXRbc10uX2dsb2JhbFN0eWxlK1wiLlwiK2g7XCJvYmplY3RcIj09dHlwZW9mIHRbc11baF0mJm51bGwhPT10W3NdW2hdJiZ2b2lkIDAhPT10W3NdW2hdLl9nbG9iYWxTdHlsZSYmKEQ9dFtzXVtoXS5fZ2xvYmFsU3R5bGUpLGVuc3VyZUdsb2JhbFN0eWxlKHQsZSx4LHMsaCxELHZvaWQgMCwhMSk7dmFyIFM9RCtPO2lmKHZvaWQgMD09PWEmJm51bGwhPT10W3NdLl9kZWZhdWx0VmFsdWVzW2NdJiYoYT10W3NdLl9kZWZhdWx0VmFsdWVzW2NdKSxlbnN1cmVHbG9iYWxTdHlsZSh0LGUseCxzLGMsUyxhLGQpLHZvaWQgMCE9PWEpe2lmKGUpdGhyb3cgY29uc29sZS5lcnJvcihcIkNhbm5vdCBzZXQgYSBuZXcgdGhlbWUgZGVmYXVsdCB2YWx1ZVwiLFMuc3Vic3RyKDcpLGEsXCJ3aGlsZSBpbiByZWFkb25seSBtb2RlXCIpLFwiQ2Fubm90IHNldCBhIG5ldyB0aGVtZSBkZWZhdWx0IHZhbHVlIChcIithK1wiKSBmb3IgXCIrUy5zdWJzdHIoNykrXCIgd2hpbGUgaW4gcmVhZG9ubHkgbW9kZSFcIjtvKFwiZGVmYXVsdFwiLFMuc3Vic3RyKDcpLGEpfWE9bnVsbH1pZih2b2lkIDAhPT1hKWlmKHZvaWQgMD09PXRbc10uX2RlZmF1bHRWYWx1ZXNbY118fHZvaWQgMCE9PWQmJmQpe2lmKGUpdGhyb3dcIkNhbm5vdCBzZXQgbmV3IF9kZWZhdWx0VmFsdWVzIFsxXSBmb3IgXCIrYytcIiBpbiBcIitzK1wiIVwiO3Rbc10uX2RlZmF1bHRWYWx1ZXNbY109YX1lbHNlIGlmKG51bGw9PT1hKXtpZihlJiZudWxsIT09dFtzXS5fZGVmYXVsdFZhbHVlc1tjXSl0aHJvd1wiQ2Fubm90IHNldCBuZXcgX2RlZmF1bHRWYWx1ZXMgWzJdIGZvciBcIitjK1wiIGluIFwiK3MrXCIhXCI7dFtzXS5fZGVmYXVsdFZhbHVlc1tjXT1udWxsfWVsc2UgaWYodFtzXS5fZGVmYXVsdFZhbHVlc1tjXSE9YSl0aHJvdyBjb25zb2xlLmVycm9yKFwiVE9ETyBlcnJvciEhISBUcnlpbmcgdG8gc2V0IGEgbmV3IGRlZmF1bHQgdmFsdWUgZm9yIFwiK3MrXCIgXCIrYytcIiB3aGlsZSBpdCBhbHJlYWR5IGV4aXN0cyAoY3VycmVudDogXCIrdFtzXS5fZGVmYXVsdFZhbHVlc1tjXStcIiwgbmV3OiBcIithK1wiKVwiKSxcIlRyeWluZyB0byBzZXQgYSBuZXcgZGVmYXVsdCB2YWx1ZSBmb3IgXCIrcytcIiBcIitjK1wiIHdoaWxlIGl0IGFscmVhZHkgZXhpc3RzIChjdXJyZW50OiBcIit0W3NdLmRlZmF1bHRWYWx1ZXNbY10rXCIsIG5ldzogXCIrYStcIilcIjtyZXR1cm4gdX0sZ2VuZXJhdGVSZXN1bHRNb2RlbD1mdW5jdGlvbihlKXt2YXIgdD1lLl9kZWZzLG89ZS50ZW1wbGF0ZU5hbWUsbD1fZ2VuZXJhdGVNb2RlbCh0LG8pO3JldHVybiB2b2lkIDAhPT10LnRoZW1lJiYobC50aGVtZT1fZ2VuZXJhdGVNb2RlbCh0LFwidGhlbWVcIikpLGx9O21vZHVsZS5leHBvcnRzPXtlbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlOm1vZGVsRW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHZvaWQgMCwhMSksZ2V0QmluZFZhbHVlOm1vZGVsRW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHZvaWQgMCwhMCksZ2VuZXJhdGVNb2RlbDpfZ2VuZXJhdGVNb2RlbCxnZW5lcmF0ZVJlc3VsdE1vZGVsOmdlbmVyYXRlUmVzdWx0TW9kZWwsZ2V0RGVmOl9nZXREZWYsY3JlYXRlT3JVcGRhdGVCbG9ja0RlZjpfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltMXZaR1ZzTG1weklsMHNJbTVoYldWeklqcGJJbTlpYWtWNGRHVnVaQ0lzSW5KbGNYVnBjbVVpTENKamIyNXpiMnhsSWl3aVgzWmhiSFZsVTJWMElpd2laR1ZtY3lJc0ltMXZaR1ZzSWl3aWNISnZjQ0lzSW5aaGJIVmxJaXdpWkc5MFVHOXpJaXdpYVc1a1pYaFBaaUlzSW14dlp5SXNJbkIxYzJnaUxDSjJZV3gxWlhNaUxDSjJZV3gxWlhOVGRISnBibWNpTENKdFlYUmphQ0lzSW5Od2JHbDBJaXdpY21Weklpd2lhU0lzSW14bGJtZDBhQ0lzSW5OMVluTjBjaUlzSWw5blpXNWxjbUYwWlUxdlpHVnNJaXdpWDNkcFpHZGxkQ0lzSW5CeWIzQk9ZVzFsSWl3aVgyMXZaR1ZzUTNKbFlYUmxUM0pWY0dSaGRHVkNiRzlqYTBSbFppSXNJblJsYlhCc1lYUmxUbUZ0WlNJc0luQnliM0JsY25ScFpYTWlMQ0p1WVcxbFpGQnliM0JsY25ScFpYTWlMQ0pmYVc1cGRHbGhiR2w2WldRaUxDSmZkM0pwZEdWaFlteGxJaXdpWTJGMFpXZHZjbmtpTENKZlkyRjBaV2R2Y25raUxDSnVZVzFsSWl3aVgyNWhiV1VpTENKMGFHVnRaVTkyWlhKeWFXUmxJaXdpWDNSb1pXMWxUM1psY25KcFpHVWlMQ0puYkc5aVlXeFRkSGxzWlNJc0lsOW5iRzlpWVd4VGRIbHNaU0lzSW1kc2IySmhiRk4wZVd4bFUzVmlJaXdpY21Wd2JHRmpaU0lzSW5BaUxDSm5jeUlzSW1OdmJuUmxlSFJPWVcxbElpd2lYMk52Ym5SbGVIUWlMQ0psZUhSbGJtUWlMQ0owZVhCbElpd2libkFpTENKb1lYTlBkMjVRY205d1pYSjBlU0lzSWw5d2NtOXdjeUlzSWw5eVpXMXZkbVZRY21WbWFYZ2lMQ0p6ZEhJaUxDSjBiMHh2ZDJWeVEyRnpaU0lzSWw5blpXNWxjbUYwWlUxdlpHVnNSbkp2YlVSbFppSXNJbTF2WkdWc1JHVm1JaXdpWDJOdmJYQnNaWGdpTENKbGNuSnZjaUlzSWw5a1pXWmhkV3gwVm1Gc2RXVnpJaXdpWkdWbVlYVnNkSE1pTENKd2NtOXdNaUlzSWw5blpYUk5iMlJsYkVSbFppSXNJbDluWlhSRVpXWWlMQ0p5WlhSMWNtNURiRzl1WlNJc0luSmxZV1J2Ym14NUlpd2laR1ZtVDJKcUlpd2lkSGx3WlVSbFppSXNJbVJsWmlJc0lsOXdjbTlqWlhOelpXUkVaV1p6SWl3aVgyZHNiMkpoYkZOMGVXeGxjeUlzSW05eWFXZFFjbTl3SWl3aVpHVm1WbUZzZFdVaUxDSndjbTl3UkdWbUlpd2lVM1J5YVc1bklpd2lkbUZzSWl3aVgybHVZM0psWVhObFZYTmxRMjkxYm5RaUxDSmZkWE5sWTI5MWJuUWlMQ0psYm5OMWNtVkhiRzlpWVd4VGRIbHNaU0lzSW1kelFtbHVaR2x1WjFCeWIzWnBaR1Z5SWl3aWJXOWtaV3hPWVcxbElpd2ljR0YwYUNJc0ltZHpSblZzYkZCaGRHZ2lMQ0prWldaaGRXeDBWbUZzZFdVaUxDSnZkbVZ5Y21sa1pVUmxabUYxYkhRaUxDSm5iRzlpWVd4VGRIbHNaVUpwYm1ScGJtZENhVzVrVm1Gc2RXVWlMQ0p0YjJSbGJFVnVjM1Z5WlZCaGRHaEJibVJIWlhSQ2FXNWtWbUZzZFdVaUxDSjBhR1Z0WlZWd1pHRjBaWElpTENKeWIyOTBUVzlrWld4T1lXMWxJaXdpZDJsMGFHbHVJaXdpWm5Wc2JGQmhkR2dpTENKelpYUmpZWFJsWjI5eWVTSXNJbmRoY200aUxDSndNaUlzSWxKbFowVjRjQ0lzSW5Beklpd2ljSEp2Y0ZCdmN5SXNJbU5vYVd4a1RXOWtaV3dpTENKdGVYQmhkR2dpTENKbElpd2lZbWx1WkNJc0luVnVaR1ZtYVc1bFpDSXNJbk4xWWxCaGRHZ2lMQ0puYzFCaGRHZ2lMQ0prWldaaGRXeDBWbUZzZFdWeklpd2laMlZ1WlhKaGRHVlNaWE4xYkhSTmIyUmxiQ0lzSW5SbGJYQnNZWFJsUkdWbUlpd2lYMlJsWm5NaUxDSm1hVzVoYkUxdlpHVnNRMjl1ZEdWdWRDSXNJblJvWlcxbElpd2liVzlrZFd4bElpd2laWGh3YjNKMGN5SXNJbVZ1YzNWeVpWQmhkR2hCYm1SSFpYUkNhVzVrVm1Gc2RXVWlMQ0puWlhSQ2FXNWtWbUZzZFdVaUxDSm5aVzVsY21GMFpVMXZaR1ZzSWl3aVoyVjBSR1ZtSWl3aVkzSmxZWFJsVDNKVmNHUmhkR1ZDYkc5amEwUmxaaUpkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzWVVGRlFTeEpRVUZKUVN4VlFVRlpReXhSUVVGUkxHbENRVUZwUWtRc1ZVRkRja05GTEZGQlFWVkVMRkZCUVZFc2MwSkJSV3hDUlN4VlFVRlpMRk5CUVZORExFVkJRVTFETEVWQlFVOURMRVZCUVUxRExFZEJRekZETEVsQlFVbERMRVZCUVZOR0xFVkJRVXRITEZGQlFWRXNTMEZETVVJc1NVRkJaU3hIUVVGWVJDeEZRVU5HTEZGQlFUQkNMRWxCUVdaSUxFVkJRVTFETEVkQlEyWktMRkZCUVZGUkxFbEJRVWtzYTBKQlFXOUNTaXhGUVVGUExIZENRVUV3UWtNc1JVRkJVU3cwUWtGRGNFVXNSMEZCYjBJc1QwRkJhRUpHTEVWQlFVMURMRWRCUTBzc2FVSkJRVlJETEVkQlFTdENMRTlCUVZaQkxGRkJRWFZETEVsQlFXUkJMRVZCUVUxSkxFMUJRWEZDVkN4UlFVRlJVU3hKUVVGSkxITkNRVUYxUWtvc1JVRkJUVU1zUjBGRE4waEdMRVZCUVUxRExFZEJRVkZETEU5QlExUXNSMEZCTUVJc2FVSkJRV1pHTEVWQlFVMURMRWxCUVdkRUxHMUNRVUZ3UWtRc1JVRkJUVU1zUjBGQlRVc3NTMEZCYjBJc1EwRkRiRVlzU1VGQlNVTXNSVUZEU2l4SFFVRnhRaXhwUWtGQlZrd3NSVUZCYjBJc1EwRkROMElzU1VGQlNVMHNSVUZCWlU0c1JVRkJUVThzVFVGQlRTeGpRVU12UWl4SFFVRnhRaXhQUVVGcVFrUXNSVUZIUml4TFFVRk5MQ3REUVVGcFJGQXNSVUZCVHl4TFFVRlBReXhGUVVaeVJVc3NSVUZCVTBNc1JVRkJZU3hIUVVGSFJTeE5RVUZOTEZOQlNUVkNMRU5CUVVFc1IwRkJjVUlzYVVKQlFWWlNMRkZCUVRSRExFbEJRV1pCTEVWQlFVMUpMRXRCUjI1RUxFdEJRVTBzSzBOQlFXbEVUQ3hGUVVGUExFdEJRVTlETEVWQlFWRXNhMEpCUVhGQ1FTeEZRVVpzUjBzc1JVRkJVMHdzUlVGTFdDeEpRVVJCTEVsQlFVbFRMRVZCUVUwc1IwRkRSRU1zUlVGQlNTeEZRVUZIUVN4RlFVRkpUQ3hGUVVGUFRTeFBRVUZSUkN4SlFVTklMRXRCUVRGQ1RDeEZRVUZQU3l4SFFVRkhSU3hQUVVGUExFVkJRVWNzUjBGRmRFSklMRVZCUVVsTUxFdEJRVXRUTEdWQlFXVm9RaXhGUVVGTlVTeEZRVUZQU3l4SFFVRkhSU3hQUVVGUExFdEJRM1JEVUN4RlFVRlBTeXhIUVVGSFF5eFBRVUZUTEVkQlF6VkNSaXhGUVVGSlRDeExRVUZMUXl4RlFVRlBTeXhKUVVkd1Fsb3NSVUZCVFVNc1IwRkJVVlVzVFVGRGFVSXNhVUpCUVdaWUxFVkJRVTFETEVsQlFUSkRMR3RDUVVGbVJDeEZRVUZOUXl4SFFVVjRSRVFzUlVGQlRVTXNSMEZCVVVNc1JVRkRhVUlzYVVKQlFXWkdMRVZCUVUxRExFbEJRWEZETEU5QlFXaENSQ3hGUVVGTlF5eFRRVUZuUkN4SlFVRjJRa1FzUlVGQlRVTXNSMEZCVFdVc1UwRkRiRVVzYVVKQlFWUmtMRWRCUVN0Q0xFOUJRVlpCTEVkQlFXZENUQ3hSUVVGUlVTeEpRVUZKTEdOQlFXVktMRVZCUVUxRUxFVkJRVTFETEVkQlFVMWxMRkZCUVZOa0xFZEJSWFJIUml4RlFVRk5ReXhIUVVGUlF5eEhRVVZrVEN4UlFVRlJVU3hKUVVGSkxHbENRVUZyUWt3c1JVRkJUVU1zUjBGQlQwUXNSVUZCVFVNc1IwRkJUMEVzUlVGQlRVTXNUMEZGTTBRc1EwRkRUQ3hKUVVGSlpTeEZRVUZYYUVJc1JVRkJTMkVzVDBGQlR5eEZRVUZIV0N4SFFVTTVRa3dzVlVGQlZVTXNSVUZCVFVNc1JVRkJUV2xDTEVkQlFWZG9RaXhGUVVGTFlTeFBRVUZQV0N4RlFVRlRMRWRCUVVsRUxFdEJTVEZFWjBJc05rSkJRU3RDTEZOQlFWTnVRaXhGUVVGTmIwSXNSVUZCWTBNc1JVRkJXVU1zUjBGRE1VVXNVVUZCYTBNc1NVRkJka0owUWl4RlFVRkxiMElzU1VGQmFVTndRaXhGUVVGTGIwSXNSMEZCWTBjc1pVRkJhVUoyUWl4RlFVRkxiMElzUjBGQlkwa3NWMEZGZEVjc1RVRkVRVEZDTEZGQlFWRlJMRWxCUVVrc0swSkJRV2REVGl4RlFVRk5iMElzUlVGQlkwTXNSVUZCV1VNc1IwRkRkRVVzZDBOQlFUQkRSaXhGUVVGbExFMUJRVkZETEVWQmIwSjZSU3hSUVdwQ2FVTXNTVUZCZEVKeVFpeEZRVUZMYjBJc1MwRkRaSEJDTEVWQlFVdHZRaXhIUVVGblFpeERRVU51UWtrc1dVRkJXU3hSUVVsblFpeEpRVUZ1UWtZc1NVRkJaME5CTEVWQlFXdENMRk5CUTNSQ0xFbEJRVFZDUVN4RlFVRm5Ra2NzWlVGQmEwVXNTVUZCYUVONlFpeEZRVUZMYjBJc1IwRkJZMDBzV1VGRE1VVk9MRVZCUVdGV0xFMUJRVTBzYVVKQlFXMUNWU3hGUVVGaFZpeE5RVUZOTEdsQ1FVRnRRbFVzUlVGQllWWXNUVUZCVFN4cFFrRkJiVUpWTEVWQlFXRldMRTFCUVUwc2FVSkJRM1pKV1N4RlFVRm5Ra2NzVTBGQlZ5eFJRVVV6UWtnc1JVRkJaMEpITEZOQlFWY3NhVUpCVFVZc1NVRkJjRUpJTEVWQlFXbERMRU5CVHpGRExGRkJURzFETEVsQlFYaENRU3hGUVVGblFrc3NUMEZCY1VJelFpeEZRVUZMYjBJc1IwRkJZMUVzVFVGQlVVNHNSVUZCWjBKTExGZEJSUzlETEVsQlFXcERUQ3hGUVVGblFrOHNaMEpCUTNwQ04wSXNSVUZCUzI5Q0xFZEJRV05WTEdWQlFXbENVaXhGUVVGblFrOHNiMEpCUlZvc1NVRkJMMEpRTEVWQlFXZENVeXhaUVVFMFFpeERRVU55UkM5Q0xFVkJRVXR2UWl4SFFVRmpXU3hoUVVGbFZpeEZRVUZuUWxNc1dVRkZiRVFzU1VGQlNVVXNSVUZCYVVKWUxFVkJRV2RDVXl4WlFVRlpSeXhSUVVGUkxIVkNRVUYzUWl4SlFVTTNSVU1zUlVGQlNVWXNSVUZCWlRWQ0xGRkJRVkVzUzBGRE0wSXJRaXhIUVVGWExFZEJRVTVFTEVWQlFWVkdMRVZCUVdWc1FpeFBRVUZQTEVWQlFVZHZRaXhIUVVGTFJpeEZRVU5xUkdRc05rSkJRVFpDYmtJc1JVRkJUU3hSUVVGVGIwTXNVMEZGU3l4SlFVRjBRM0JETEVWQlFVdHZRaXhIUVVGalZTeG5Ra0ZCYjBNNVFpeEZRVUZMYjBJc1IwRkJZMVVzYVVKQlEyNUdXQ3cyUWtGQk5rSnVRaXhGUVVGTmIwSXNSVUZCWXl3d1FrRkhWaXhKUVVGb1EwVXNSVUZCWjBKbExHTkJRM3BDY2tNc1JVRkJTMjlDTEVkQlFXTnJRaXhUUVVGWGFFSXNSVUZCWjBKbExGbEJTVmdzVTBGQkwwSm1MRVZCUVdkQ1pTeHJRa0ZCYjBVc1NVRkJia055UXl4RlFVRkxiMElzUjBGQlkxa3NaVUZEZEVWb1F5eEZRVUZMYjBJc1IwRkJZMWtzWVVGQlpTeHZRa0ZEYkVOaUxEWkNRVUUyUW01Q0xFVkJRVTBzVVVGQlV5eHRRa0ZGU1N4SlFVRnlRMEVzUlVGQlMyOUNMRWRCUVdOVkxHZENRVUZwUXpsQ0xFVkJRVXR2UWl4SFFVRmpWU3hwUWtGRGFFWllMRFpDUVVFMlFtNUNMRVZCUVUxdlFpeEZRVUZqTERSQ1FVbHNRaXhKUVVFeFFrVXNSVUZCWjBKcFFpeFRRVUYxUW5aRExFVkJRVXR2UWl4SFFVRmpiMElzUzBGQlQyeENMRVZCUVdkQ2FVSXNVVUZIT1VZc1NVRkJTeXhKUVVGSlJTeExRVUZOYmtJc1JVRkJjVUpCTEVWQlFXZENiMElzWlVGQlpVUXNVMEZCYzBNc1NVRkJlRUp1UWl4RlFVRm5RbTFDTEV0QlFYZEhMRWRCUVdwR0xFTkJRVU1zVDBGQlVTeFRRVUZWTEdOQlFXVXNZMEZCWXl4cFFrRkJhVUp3UXl4UlFVRlJiME1zUzBGREwweDZReXhGUVVGTGIwSXNSMEZCWXl4SlFVRkpjVUlzUjBGQlRXNUNMRVZCUVdkQ2JVSXNVMEZIZEVJc1NVRkJaSEJDTEVkQlFUWkNRU3hGUVVGWFVDeFBRVUZUTEVsQlF6RkVaQ3hGUVVGTGIwSXNSMEZCWTNWQ0xGbEJRVFpETEVsQlFUZENNME1zUlVGQlMyOUNMRWRCUVdOMVFpeFJRVUY1UWpORExFVkJRVXR2UWl4SFFVRmpkVUlzVDBGQlR6ZENMRTlCUVZNc1JVRkJTV1FzUlVGQlMyOUNMRWRCUVdOMVFpeFBRVUZUTEVsQlFVMTBRaXhGUVVGaFFTeEpRVXR5UzNWQ0xHTkJRV2RDTEZOQlFWTkRMRWRCUXpOQ0xFbEJRVWxxUXl4RlFVRk5hVU1zUlVGQlNXNURMRTFCUVUwc2QwSkJRM0JDTEU5QlFXVXNUMEZCVWtVc1JVRkJaVUVzUlVGQlNTeEhRVUZIYTBNc1kwRkJaMEpzUXl4RlFVRkpMRWRCUVVzc1RVRkpjRVJ0UXl4elFrRkJkMElzVTBGQlUwTXNSVUZCVldoRUxFZEJRemRETEVsQlFVbFpMRVZCUVUwc1IwRkZWaXhKUVVGTExFbEJRVWxXTEV0QlFWRTRReXhGUVVObUxFbEJRVXM1UXl4RlFVRkxVU3hOUVVGTkxGTkJRVmR6UXl4RlFVRlRUaXhsUVVGbGVFTXNSMEZCVHl4RFFVTjRSQ3hKUVVGSlF5eEZRVUZSTmtNc1JVRkJVemxETEVkQlEzSkNMRWRCUVc5Q0xHbENRVUZVUXl4SFFVRXJRaXhQUVVGV1FTeFJRVUV5UXl4SlFVRnNRa0VzUlVGQlRUaERMRlZCUVRKQ09VTXNSVUZCVFRoRExGTkJRemxHY2tNc1JVRkJTVllzUjBGQlVUWkRMSE5DUVVGelFqVkRMRVZCUVU5SUxGRkJRM0JETEVkQlFWa3NVVUZCVWtVc1JVRkRWRlVzUlVGQlNWWXNSMEZCVVVNc1RVRkRVQ3hEUVVGQkxFZEJRVzlDTEdsQ1FVRlVRU3hGUVUxb1FpeE5RVVJCVEN4UlFVRlJiMFFzVFVGQlRTeDFRa0ZCZDBKb1JDeEZRVUZOUXl4RlFVRlBOa01zUjBGRE4wTXNlVUpCUVRKQ09VTXNSVUZCVHl4TFFVRlBReXhGUVVvdlExTXNSVUZCU1ZZc1IwRkJVU3hOUVZGc1FpeFJRVUZ6UXl4SlFVRXpRamhETEVWQlFWTkhMR1ZCUVN0Q0xFTkJRMnBFTEVsQlFVbERMRVZCUVZkS0xFVkJRVk5ITEdWQlEzaENMRWxCUVVzc1NVRkJTVVVzUzBGQlUwUXNSVUZEV2tFc1JVRkJVMVlzWlVGQlpWY3NTVUZETVVKMFJDeFZRVUZWUXl4RlFVRk5XU3hGUVVGTGVVTXNSVUZCVDBRc1JVRkJVME1zU1VGSk0wTXNUMEZCVDNwRExFZEJSMHhKTEdWQlFXbENMRk5CUVZOb1FpeEZRVUZOTWtJc1IwRkRiRU1zU1VGQlNYRkNMRVZCUVZkTkxHRkJRV0YwUkN4RlFVRk5Na0lzUjBGQlRTeEhRVUZQTEVkQlF5OURMRTlCUVU5dlFpeHpRa0ZCYzBKRExFVkJRVlZvUkN4SlFVZHlRM1ZFTEZGQlFWVXNVMEZCVTNaRUxFVkJRVTB5UWl4SFFVTXpRaXhQUVVGUE1rSXNZVUZCWVhSRUxFVkJRVTB5UWl4SFFVRk5MRWRCUVU4c1NVRkhja015UWl4aFFVRmxMRk5CUVZOMFJDeEZRVUZOTWtJc1JVRkJUVFpDTEVWQlFXRkRMRWRCUlc1RUxGRkJRWGxDTEVsQlFXUjZSQ3hGUVVGTE1rSXNSMEZCYzBJc1EwRkZjRU1zU1VGQk1FSXNSMEZCZEVKQkxFVkJRVXQwUWl4UlFVRlJMRXRCUVZrc1QwRkJUeXhMUVVWd1F5eEpRVUZKVHl4RlFVRk5aME1zWTBGQlkycENMRWRCUTNoQ0xFOUJRVmtzVDBGQlVtWXNSVUZGU3pCRExHRkJRV0YwUkN4RlFVRk5XU3hGUVVGTE5FTXNSVUZCWVVNc1IwRkpka01zUzBGSFVDeEpRVUZKUXl4RlFVRlRNVVFzUlVGQlN6SkNMRWRCUTJ4Q0xFZEJRWEZDTEdsQ1FVRldLMElzUlVGQmIwSXNTMEZCVFN3MlEwRkJLME5CTEVWQlFWTXNVVUZCVlM5Q0xFVkJSWFpITEZGQlFXdERMRWxCUVhaQ0swSXNSVUZCVDI1RExHRkJRVFpDTEVOQlZ6ZERMRkZCVkRCQ0xFbEJRV1p0UXl4RlFVRlBiRUlzVVVGRFZTeEhRVUYwUW1Jc1JVRkJTM1JDTEZGQlFWRXNTMEZEWm5GRUxFVkJRVTlzUWl4TFFVRlBZaXhGUVVWa0swSXNSVUZCVDJ4Q0xFdEJRVTlpTEVWQlFVdGFMRTlCUVU5WkxFVkJRVXQwUWl4UlFVRlJMRXRCUVU4c1NVRkxPVU54UkN4RlFVRlBiRUlzVFVGQlVXSXNVVUZCYVVNc1NVRkJiRUlyUWl4RlFVRlBla01zVVVGQmQwSXNRMEZETDBRc1NVRkJTVEJETEVWQlFWVk1MR0ZCUVdGMFJDeEZRVUZOTUVRc1JVRkJUMnhDTEUxQlFVMHNSMEZGT1VOclFpeEZRVVJsT1VRc1ZVRkJWU3RFTEVWQlFWTkVMRWRCUld4RE1VUXNSVUZCU3pKQ0xFZEJRVkVyUWl4WlFVTnhRaXhKUVVGc1FrRXNSVUZCVDNwRExHTkJRV3RFTEVsQlFXcENlVU1zUlVGQlQyWXNVVUZCWjBObExFVkJRVTlVTEZOQlpYaEhVeXhGUVVGUGJFTXNXVUZCWVN4RlFVTndRbXRETEVWQlFVOXVReXhqUVVGbExFVkJSM2hDTEZGQlFUUkNMRWxCUVdwQ2JVTXNSVUZCVDJZc1QwRkJkVUlzUTBGRGRrTXNTVUZCU1dsQ0xFVkJRVTFHTEVWQlFVOW1MRTlCUjJwQ0xFbEJSa0ZwUWl4RlFVRk5RU3hGUVVGSmFrUXNUVUZCVFN4TlFVVlNSeXhQUVVGVExGRkJRV2xETEVsQlFYSkNORU1zUlVGQlQyeERMRmRCUld4RExFMUJSRUV4UWl4UlFVRlJiMFFzVFVGQlRTeHJRMEZCYlVOMlFpeEZRVUZOYVVNc1JVRkJTMFlzUjBGRGRFUXNiVU5CUVhGREwwSXNSVUZCVHl4VFFVRlhhVU1zVDBGSE0wSXNTVUZCZWtKR0xFVkJRVTlITEdsQ1FVTm9Ra2dzUlVGQlQwY3NaVUZCYVVJc1UwRkhVeXhKUVVGNFFrZ3NSVUZCVDBrc1owSkJRMmhDU2l4RlFVRlBTU3hqUVVGblFpeFRRVWRYTEVsQlFYcENTaXhGUVVGUFVDeHBRa0ZEYUVKUExFVkJRVTlRTEdWQlFXbENMRWxCUnpGQ0xFbEJRVXNzU1VGQlNYUkRMRVZCUVVrc1JVRkJSMEVzUlVGQlNTdERMRVZCUVVrNVF5eFBRVUZSUkN4SlFVRkxMRU5CUTI1RExFbEJRVWxZTEVWQlFVOHdSQ3hGUVVGSkwwTXNSMEZEWml4SFFVRnZRaXhKUVVGb1FsZ3NSVUZCUzFrc1QwRkJWQ3hEUVVOQkxFbEJRVWxwUkN4RlFVRlhOMFFzUlVGRFdEaEVMRVZCUVZjc1MwRkZXRU1zUlVGQlZTOUVMRVZCUVV0UkxFMUJRVTBzWjBOQk1FSjZRaXhIUVhwQ1owSXNUMEZCV25WRUxFbEJRMFl2UkN4RlFVRlBLMFFzUlVGQlVTeEhRVVZITEUxQlFXUkJMRVZCUVZFc1ZVRkZhVUlzU1VGQmFFSlFMRVZCUVU5NFJDeExRVUZ6UW5kRUxFVkJRVTk0UkN4SFFVRlJMRWxCUTNaRU9FUXNSVUZCVnl4SlFVVkxMRXRCUVdSRExFVkJRVkVzUzBGRmRVSkVMRVZCUVRkQ09VUXNSVUZCUzFFc1RVRkJUU3hwUWtGQmFVVXNVVUZCY0VOM1JDeFBRVUZQUkN4RlFVRlJMRWxCUVVsdVFpeGpRVU4wUkRWRExFVkJRVXRSTEUxQlFVMHNhVUpCUXpaQ0xGRkJRWEJEZDBRc1QwRkJUMFFzUlVGQlVTeEpRVUZKYmtJc1kwRkRaRzFDTEVWQlFWRXNTMEZMWWl4UFFVRmlSQ3hSUVVOM1F5eEpRVUV2UWs0c1JVRkJUMUFzWlVGQlpXcEVMRXRCUlM5Q2QwUXNSVUZCVDFBc1pVRkJaV3BFTEVkQlFWRTRSQ3hSUVVsUUxFbEJRV2hDVGl4RlFVRlBlRVFzUjBGQmMwSXNRMEZEZEVNc1NVRkJTV2xGTEVWQlFVMWlMR0ZCUVdGMFJDeEZRVUZOTWtJc1JVRkJUeXhKUVVGTmVrSXNSMEZCVFN4SFFVTndReXhQUVVGU2FVVXNTVUZEUmtFc1JVRkJUV0lzWVVGQllYUkVMRVZCUVUxRkxFZEJRVTBzU1VGRmFrTjNSQ3hGUVVGUGVFUXNSMEZCVVdsRkxFVkJSMnBDVkN4RlFVRlBSeXhsUVVGbE0wUXNSMEZCVVRaRUxFVkJRemxDVEN4RlFVRlBWQ3hWUVVGWExGVkJSMkpUTEVWQlFVOW1MRTlCUjJoQ0xFZEJRVWxoTEVWQlIwWXNUMEZHUVVVc1JVRkJUMnhETEZsQlFXRXNSVUZEVURWQ0xGVkJRVlVzUjBGQlNUaEVMRWRCUlhSQ0xFZEJRVWxFTEVWQlJWUXNUMEZFUVVNc1JVRkJUMnhETEZsQlFXRXNSVUZEWW10RExFVkJSVkFzVVVGQlowTXNTVUZCY2tKQkxFVkJRVTlzUXl4aFFVRnRSQ3hKUVVGMFFtdERMRVZCUVU5c1F5eFhRVUZ6UWl4TFFVRk5MQ3REUVVGcFJFY3NSVUZEYmtrc1QwRkJUeXRDTEVkQlMxUlZMR3RDUVVGdlFpeFRRVUZUV0N4RlFVRlZlRVFzUjBGRGVrTXNSMEZCUzNkRUxFZEJSMFVzVVVGQk9FSXNTVUZCYmtKNFJDeEZRVUZOYjBVc1ZVRkZkRUlzVFVGRVFYWkZMRkZCUVZGdlJDeE5RVUZOTEhsRVFVRXdSR3BFTEVkQlEyeEZMRzlFUVVwM1FpeEpRVUZ1UWtFc1JVRkJUVzlGTEZsQlFUQkNjRVVzUlVGQlRXOUZMRlZCUVZrc1IwRkROMFJ3UlN4RlFVRk5iMFVzWVVGUFRrTXNhMEpCUVc5Q0xGTkJRVk4wUlN4RlFVRk5lVVFzUlVGQlZXTXNSVUZCYlVKRExFVkJRVmRETEVWQlFVMURMRVZCUVZsRExFVkJRV05ETEVkQlJUZEhMRWxCUVVsRExFVkJRVGhDVGl4RlFVRnJRa2NzUlVGQldVTXNSVUZCWTBNc1IwRkZPVVVzVVVGQmEwUXNTVUZCZGtNMVJTeEZRVUZMZDBVc1IwRkJWMVlzWTBGQlkxY3NSMEZCYzBJc1EwRkROMFFzUjBGQlNXaENMRVZCUVZVc1MwRkJUU3huUTBGQmEwTm5RaXhGUVVGUExFOUJRVk5FTEVWQlFWa3NUVUZEZUVRc1IwRkJkRUpETEVWQlFVdHdSU3hSUVVGUkxFMUJRU3RETEdsQ1FVRjZRa3dzUlVGQlMzZEZMRWRCUVZkRExGTkJRVGhFTEVsQlFXeERla1VzUlVGQlMzZEZMRWRCUVZkRExFZEJRVTE0UkN4WFFVTjJSMnBDTEVWQlFVdDNSU3hIUVVGWFZpeGpRVUZqVnl4SFFVRlJTU3hSUVVWdVF5eEhRVUZKTjBVc1JVRkJTM2RGTEVkQlFWZFdMR05CUVdOWExFbEJRVk5KTEVWQlFUWkNMRXRCUVUwc09FTkJRV2RFVEN4RlFVRlpMRWxCUVUxRExFVkJRVThzVTBGQlYzcEZMRVZCUVV0M1JTeEhRVUZYVml4alFVRmpWeXhIUVVGUkxGRkJRVlZKTEVkQlNYWk9ReXdyUWtGQmFVTXNVMEZCVTNKQ0xFVkJRVlY2UkN4RlFVRk5LMFVzUlVGQlkwTXNSVUZCWlRWRUxFVkJRV00yUkN4RlFVRlJReXhGUVVGVlVDeEZRVUZqUXl4RlFVRnBRazhzUjBGRGVFb3NTVUZCU1Znc1JVRkRRVFZFTEVWQlEwRTJSQ3hGUVVWS0xFZEJRVFpDTEV0QlFYcENVeXhGUVVGVGJrVXNUMEZCVHl4RlFVRkhMRWRCUVZjc1EwRkRhRU5xUWl4UlFVRlJjMFlzUzBGQlN5eHZRMEZCY1VOR0xFVkJRVlU1UkN4SFFVTTFSQ3hKUVVGSlpTeEZRVUZKSzBNc1JVRkJVemRGTEZGQlFWRXNTMEZEZWtJc1NVRkJWU3hIUVVGT09FSXNSVUZEUml4TFFVRk5MSGRDUVVFd1FpdERMRVZCUVZjc1NVRkJUVVFzUlVGQlV5eEpRVUZOTjBRc1JVRkJaU3hKUVVGTmRVUXNSVUZCWlN4SlFVRk5ReXhGUVVzeFJ5eEhRVWhCU2l4RlFVRlpWU3hGUVVGVGJrVXNUMEZCVHl4RlFVRkhiMElzUlVGQlNTeEhRVU51UTNORExFVkJRVTlUTEVWQlFWTnVSU3hQUVVGUGIwSXNSVUZCU1N4SFFVVldMRk5CUVdKeFF5eEZRVXRHTEV0QlFVMHNNRUpCUVRSQ1FTeEZRVUZaTEU5QlFWTlZMRVZCU25aRUxFbEJRVWxITEVWQlFVdGFMRVZCUVV0d1JTeFJRVUZSTEV0QlRYaENUeXhGUVVGTkxEUkNRVXhLTkVRc1JVRkJXVU1zUlVGQlN6RkVMRTlCUVU4c1JVRkJSM05GTEVsQlMydENMRTlCU2pkRFdpeEZRVUZQUVN4RlFVRkxNVVFzVDBGQlQzTkZMRVZCUVVzc1NVRkphME51UkN4UlFVRlJMRWxCUVVsdlJDeFBRVUZQTEUxQlFVOHNTMEZCVFN4WlFVVjZSaXhIUVVFMlFpeExRVUY2UWtvc1JVRkJVMjVGTEU5QlFVOHNSVUZCUnl4SFFVTTFRbXBDTEZGQlFWRnpSaXhMUVVGTExHOURRVUZ4UTBZc1JVRkJWVGxFTEVkQlF6VkViMFFzUlVGQldWRXNSVUZGV25CRkxFVkJRVTBzYjBKQlJFNDJSQ3hGUVVGUFV5eEZRVUZUYmtVc1QwRkJUeXhKUVVOVGJVSXNVVUZCVVN4SlFVRkpiMFFzVDBGQlR5eE5RVUZQTEV0QlFVMHNXVUZETTBRc1IwRkJOa0lzV1VGQmVrSktMRVZCUVZOdVJTeFBRVUZQTEVWQlFVY3NSMEZCYTBJc1EwRkRPVU1zU1VGQlNYZEZMRVZCUVV0TUxFVkJRVk0zUlN4UlFVRlJMRWxCUVVzc1IwRkhMMEpQTEVWQlFVMHNORUpCUms0MFJDeEZRVUZaVlN4RlFVRlRia1VzVDBGQlR5eEZRVUZIZDBVc1JVRkJTeXhKUVVWWExFOUJSQzlEWkN4RlFVRlBVeXhGUVVGVGJrVXNUMEZCVDNkRkxFVkJRVXNzU1VGRFowTnlSQ3hSUVVGUkxFbEJRVWx2UkN4UFFVRlBMRTFCUVU4c1MwRkJUU3hYUVVNeFJDeFhRVUY2UWtvc1JVRkJVMjVGTEU5QlFVOHNSVUZCUnl4SlFVTTFRbmxFTEVWQlFWbFJMRVZCUlZwd1JTeEZRVUZOTEc5Q1FVUk9Oa1FzUlVGQlQxTXNSVUZCVTI1RkxFOUJRVThzU1VGRFUyMUNMRkZCUVZFc1NVRkJTVzlFTEU5QlFVOHNUVUZCVHl4TFFVRk5MRk5CUldoRlpDeEZRVUZaY0VRc1JVRkRXbkZFTEVWQlFVOVJMRVZCUVZORExFVkJRMmhDZEVVc1JVRkJUWE5GTEVWQlFWTm9SQ3hSUVVGUkxFbEJRVWx2UkN4UFFVRlBMRTFCUVU4c1MwRkJUU3hSUVVkcVJDeFJRVUVyUWl4SlFVRndRblJHTEVWQlFVdDNSU3hIUVVFMFFpeExRVUZOTERoQ1FVRm5RMEVzUlVGQldTeEpRVVU1Uml4SlFYRkNTWFpGTEVWQmNrSkJkVVlzUlVGQlZXWXNSVUZCUzNCRkxGRkJRVkVzUzBGRGRrSmhMRWRCUVhWQ0xFZEJRVnB6UlN4RlFVRm5RbVlzUlVGQlQwRXNSVUZCU3pGRUxFOUJRVThzUlVGQlIzbEZMRWRCUlhKRUxFbEJRU3RDTEVkQlFUTkNhRUlzUlVGQlZXNUZMRkZCUVZFc1MwRkZjRUlzVFVGRVFWQXNVVUZCVVc5RUxFMUJRVTBzY1VOQlFYTkRjMElzUjBGRE9VTXNkME5CUVRCRFFTeEZRVVZzUkN4SlFVRTRRaXhIUVVFeFFuUkVMRVZCUVZOaUxGRkJRVkVzUzBGRmJrSXNUVUZFUVZBc1VVRkJVVzlFTEUxQlFVMHNkME5CUVhsRGFFTXNSMEZEYWtRc01rTkJRVFpEYzBRc1JVRkpja1FzUjBGQlNXWXNSVUZKUml4WlFVZzBReXhKUVVGcVEzcEVMRVZCUVV0M1JTeEhRVUZYZUVNc2JVSkJRWEZGTEVsQlFUbENhRU1zUlVGQlMzZEZMRWRCUVZkMFJDeEpRVUZ2UlN4VFFVRjJRMnhDTEVWQlFVdDNSU3hIUVVGWGRFUXNSMEZCVlZFc1dVRkRka2xrTEVkQlFVOHNjVUpCUlVaQkxFVkJTMVFzUjBGQlNUWkRMRVZCUVZVc1EwRkRXaXhSUVVFMFFpeEpRVUZxUW10Q0xFVkJRVGhDTEV0QlFVMHNORU5CUXk5RExFZEJRVWxETEVWQlFXbENMRXRCUVUwc2JVUkJRWEZFU2l4RlFVRlpMRWxCUVUxRExFVkJRVThzU1VGQlRVY3NSVUZCYTBJc1NVRkRha2tzVVVGQk1rSXNTVUZCYUVKUExFVkJRVFpDTEV0QlFVMHNNa0pCUVRaQ1dDeEZRVUZaTEVsQlFVMURMRVZCUVU4c1NVRkJUVlVzUlVGQll5eHhRa0ZEZUVoc1JpeEZRVUZSY1VRc1lVRkJZWFJFTEVWQlFVMTNSU3hIUVVGWExFZEJRVThzVVVGRlZpeEpRVUV2UW5oRkxFVkJRVXQzUlN4SFFVRlhhRVFzV1VGQmMwSXhRaXhSUVVGUlVTeEpRVUZKTERCRFFVRXlRMnRGTEVWQlFWZERMRWRCUXpWSGVFVXNSVUZCVVhGRUxHRkJRV0YwUkN4RlFVRk5kMFVzUjBGQk1FTXNTVUZCTDBKNFJTeEZRVUZMZDBVc1IwRkJWMmhFTEZsQlIzaEVMRWRCUVdNc1QwRkJWblpDTEVWQlFXZENMRXRCUVUwc2VVSkJRVEpDZFVVc1JVRkJXU3hKUVVkcVJTeFJRVUU0UWl4SlFVRnVRblpGTEVWQlFVMXBRaXhIUVVFd1FpeERRVVY2UXl4SFFVRkpkVU1zUlVGQlZTeExRVUZOTEc5Q1FVRnpRblpETEVWQlFWY3NVVUZCVlhORUxFVkJRVmtzU1VGRE0wVnlSQ3cyUWtGQk5rSnVRaXhGUVVGTmQwVXNSVUZCVjNSRUxFZEJRemxEYWtJc1JVRkJVWEZFTEdGQlFXRjBSQ3hGUVVGTmQwVXNSMEZCVnl4UlFVbEpMRWxCUVdwRGVFVXNSVUZCUzNkRkxFZEJRVmQ0UXl4dFFrRkJjVVVzU1VGQk9VSm9ReXhGUVVGTGQwVXNSMEZCVjNSRUxFbEJRVEpFTEU5QlFUbENiRUlzUlVGQlMzZEZMRWRCUVZkMFJDeEpRVUUyUkN4VFFVRjJRMnhDTEVWQlFVdDNSU3hIUVVGWGRFUXNSMEZCVlZFc1dVRkROMHRrTEVkQlFVOHNjVUpCUjFRc1NVRkJTVFpGTEVWQlFXRjRSaXhGUVVOcVFpeEpRVVZGTEVkQlJFRnRSU3hyUWtGQmEwSllMRVZCUVZWblF5eEpRVU5hTEVkQlFWcEVMRVZCUVdVc1EwRkRha0lzU1VGQlNVVXNSVUZCVTJwQ0xFVkJRMklzUlVGQlJ5eERRVU5FTEVsQlFVbDJSU3hGUVVGUGQwWXNSVUZCVHpORkxFOUJRVThzUlVGQlIzbEZMRWRCUXpWQ0xGRkJRU3RDTEVsQlFYQkNReXhGUVVGWGRrWXNSMEZEY0VJc1MwRkJUU3cwUWtGQk9FSkJMRVZCUVU4c1kwRkJaMEp6UlN4RlFVRlpMRkZCUVZWRExFVkJSMjVHWjBJc1JVRkJZVUVzUlVGQlYzWkdMRWRCUTNoQ2EwVXNhMEpCUVd0Q1dDeEZRVUZWWjBNc1IwRkZOVUpFTEVkQlJFRkZMRVZCUVZOQkxFVkJRVTh6UlN4UFFVRlBlVVVzUlVGQlZTeEpRVU5vUW01R0xGRkJRVkVzV1VGRFRpeEhRVUZhYlVZc1IwRkZWQ3hSUVVGcFF5eEpRVUYwUWtNc1JVRkJWME1zU1VGQmFVUXNUMEZCZGtKRUxFVkJRVmRETEVkQlEzcEVMRXRCUVUwc2QwTkJRVEJEUVN4RlFVRlRMR05CUVdkQ2JFSXNSVUZCV1N4UlFVRlZReXhGUVVWcVIyZENMRVZCUVdGQkxFVkJRVmRETEZGQlJYaENSQ3hGUVVGaFFTeEZRVUZYYUVJc1IwRkhNVUlzUjBGQlNTeE5RVUZQWjBJc1JVRkJiVVFzUzBGQlRTdzJRa0ZCSzBKcVFpeEZRVUZaTEVsQlFVMVRMRVZCUVZNc1NVRkJUVU1zVDBGRmVrY3NTVUZCYUVKRExFbEJRMVJOTEVWQlFWY3ZSQ3hWUVVGWmVVUXNSMEZIZWtKbUxHdENRVUZyUWxnc1JVRkJWV2RETEVkQlF6VkNMRTFCUVU5RkxFZEJSVkFzVFVGRVFUZEdMRkZCUVZGdlJDeE5RVUZOTEhWRFFVRjNRM2xETEVWQlFVZHVRaXhGUVVGWFF5eEZRVUZOY2tRc1JVRkJZemhFTEVWQlFWVnNSaXhIUVVNMVJqSkdMRVZCUjFJc1VVRkJORU1zU1VGQmFrTXpSaXhGUVVGTGQwVXNSMEZCVjNoRExHTkJRVzlGTEdsQ1FVRTNRbWhETEVWQlFVdDNSU3hIUVVGWGRFUXNTVUZCZFVRc1QwRkJPVUpzUWl4RlFVRkxkMFVzUjBGQlYzUkVMRk5CUVc5RkxFbEJRWFpEYkVJc1JVRkJTM2RGTEVkQlFWZDBSQ3hIUVVGVlVTeFhRVUZ0UlN4VFFVRjJRekZDTEVWQlFVdDNSU3hIUVVGWGRFUXNSMEZCVlZFc1ZVRkJjMElzUTBGRk5WQXNTVUZCU1RaRExFVkJRVzlDVHl3clFrRkJLMEpqTEZWQlFVdERMRVZCUVZkd1F5eEZRVUZWZWtRc1JVRkJUU3RGTEVWQlFXTkRMRVZCUVdVMVJDeEZRVUZqTEVsQlJUbElNRVVzUjBGQlowTXNSMEZCZEVKeVFpeEZRVUZMY0VVc1VVRkJVU3hMUVVGaGIwVXNSVUZCU3pGRUxFOUJRVTh3UkN4RlFVRkxjRVVzVVVGQlVTeE5RVUZSTEVkQlIzcEZMRWxCUVdkRExFZEJRVFZDZVVZc1JVRkJVWHBHTEZGQlFWRXNTVUZCU3l4SFFVRlZMRXRCUVUwc2IwTkJRWE5EYjBVc1JVRkZMMFVzU1VGQlNYTkNMRVZCUVZNdlJpeEZRVUZMZDBVc1IwRkJWM2hETEdGQlFXVXNTVUZCVFdRc1JVRkRWaXhwUWtGQk4wSnNRaXhGUVVGTGQwVXNSMEZCVjNSRUxFbEJRWFZFTEU5QlFUbENiRUlzUlVGQlMzZEZMRWRCUVZkMFJDeFRRVUYxUlN4SlFVRXhRMnhDTEVWQlFVdDNSU3hIUVVGWGRFUXNSMEZCVldNc1pVRkRla2dyUkN4RlFVRlRMMFlzUlVGQlMzZEZMRWRCUVZkMFJDeEhRVUZWWXl4alFVZHlRM05ETEd0Q1FVRnJRblJGTEVWQlFVMTVSQ3hGUVVGVll5eEZRVUZ0UWtNc1JVRkJWM1JFTEVWQlFWVTJSU3hQUVVGUlJpeEhRVUZYTEVkQlJUZEdMRWxCUVVsdVFpeEZRVUZoY1VJc1JVRkJVMFFzUlVGTk1VSXNVVUZLTWtJc1NVRkJhRUp1UWl4SFFVRjNSU3hQUVVGNlF6TkZMRVZCUVV0M1JTeEhRVUZYY2tJc1pVRkJaWE5DTEV0QlFXZENSU3hGUVVGbE0wVXNSVUZCUzNkRkxFZEJRVmR5UWl4bFFVRmxjMElzU1VGRmRrbElMR3RDUVVGclFuUkZMRVZCUVUxNVJDeEZRVUZWWXl4RlFVRnRRa01zUlVGQlYwTXNSVUZCVFVNc1JVRkJXVU1zUlVGQlkwTXNVVUZGY0VVc1NVRkJha0pFTEVWQlFUaENMRU5CUTNaRExFZEJRVWxzUWl4RlFVVkdMRTFCUkVFelJDeFJRVUZSYjBRc1RVRkJUU3gxUTBGQmQwTjNRaXhGUVVGWE0wUXNUMEZCVHl4SFFVRkpORVFzUlVGQll5d3dRa0ZEY0VZc2VVTkJRVEpEUVN4RlFVRmxMRk5CUVZkRUxFVkJRVmN6UkN4UFFVRlBMRWRCUVVzc01rSkJSWEJIWjBVc1JVRkJZU3hWUVVGWFRDeEZRVUZYTTBRc1QwRkJUeXhIUVVGSk5FUXNSMEZKYUVSQkxFVkJRV1VzUzBGSmFrSXNVVUZCTWtJc1NVRkJhRUpCTEVWQlExUXNVVUZCYlVRc1NVRkJlRU16UlN4RlFVRkxkMFVzUjBGQlYzSkNMR1ZCUVdWelFpeFRRVUZ0UkN4SlFVRnVRa2NzUjBGQmEwTkJMRVZCUVd0Q0xFTkJRelZJTEVkQlFVbHVRaXhGUVVGVkxFdEJRVTBzZVVOQlFUSkRaMElzUlVGQlR5eFBRVUZUUkN4RlFVRlpMRWxCUXpOR2VFVXNSVUZCUzNkRkxFZEJRVmR5UWl4bFFVRmxjMElzUjBGQlVVVXNUMEZGZGtNc1IwRkJjVUlzVDBGQmFrSkJMRVZCUVhWQ0xFTkJRM3BDTEVkQlFVbHNRaXhIUVVGeFJDeFBRVUY2UTNwRUxFVkJRVXQzUlN4SFFVRlhja0lzWlVGQlpYTkNMRWRCUXpkRExFdEJRVTBzZVVOQlFUSkRRU3hGUVVGUExFOUJRVk5FTEVWQlFWa3NTVUZITDBWNFJTeEZRVUZMZDBVc1IwRkJWM0pDTEdWQlFXVnpRaXhIUVVGUkxGVkJRMnhETEVkQlFVbDZSU3hGUVVGTGQwVXNSMEZCVjNKQ0xHVkJRV1Z6UWl4SlFVRlRSU3hGUVVWcVJDeE5RVVJCTjBVc1VVRkJVVzlFTEUxQlFVMHNkVVJCUVhsRWMwSXNSVUZCV1N4SlFVRk5ReXhGUVVGUExITkRRVUYzUTNwRkxFVkJRVXQzUlN4SFFVRlhja0lzWlVGQlpYTkNMRWRCUVZFc1ZVRkJXVVVzUlVGQlpTeExRVU53VFN4NVEwRkJNa05JTEVWQlFWa3NTVUZCVFVNc1JVRkJUeXh6UTBGQmQwTjZSU3hGUVVGTGQwVXNSMEZCVjNkQ0xHTkJRV04yUWl4SFFVRlJMRlZCUVZsRkxFVkJRV1VzU1VGTGVrd3NUMEZCVHk5RUxFZEJSMHh4Uml4dlFrRkJjMElzVTBGQlUwTXNSMEZEYWtNc1NVRkJTV3hITEVWQlFVOXJSeXhGUVVGWlF5eE5RVU51UWk5RkxFVkJRV1U0UlN4RlFVRlpPVVVzWVVGRk0wSm5SaXhGUVVGdlFuQkdMR1ZCUVdWb1FpeEZRVUZOYjBJc1IwRlBOME1zV1VGS05rSXNTVUZCYkVKd1FpeEZRVUZaTEZGQlEzSkNiMGNzUlVGQmEwSkRMRTFCUVZGeVJpeGxRVUZsYUVJc1JVRkJUU3hWUVVjeFEyOUhMRWRCUjFSRkxFOUJRVTlETEZGQlFWVXNRMEZGWmtNc01FSkJRVEpDTVVJc0swSkJRU3RDWXl4VlFVRkxReXhIUVVGWExFZEJSVEZGV1N4aFFVRmpNMElzSzBKQlFTdENZeXhWUVVGTFF5eEhRVUZYTEVkQlF6ZEVZU3hqUVVGbE1VWXNaVUZEWm1sR0xHOUNRVUZ4UWtFc2IwSkJRM0pDVlN4UFFVRlJjRVFzVVVGRFVuRkVMSFZDUVVGM1FucEdJaXdpWm1sc1pTSTZJaTl3Y21sMllYUmxMM1J0Y0M5bWIyOHVSMDlGTDNOeVl5OXFjeTlqYjI1MlpYSjBaWEl2Ylc5a1pXd3Vhbk1pZlE9PSIsIlwidXNlIHN0cmljdFwiO3ZhciAkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LmpRdWVyeTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5qUXVlcnk6bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIiksY29udmVydGVyVXRpbHM9cmVxdWlyZShcIi4vdXRpbHMuanNcIiksZWxhYm9yYXRlRGVjbGFyYXRpb25zPXJlcXVpcmUoXCIuL2RlY2xhcmF0aW9ucy5qc1wiKSxwcm9jZXNzU3R5bGVzaGVldFJ1bGVzPXJlcXVpcmUoXCIuL3N0eWxlc2hlZXQuanNcIiksbW9kZWxEZWY9cmVxdWlyZShcIi4vbW9kZWwuanNcIiksZG9tdXRpbHM9cmVxdWlyZShcIi4vZG9tdXRpbHMuanNcIiksd3JhcEVsZW1lbnRXaXRoQ29uZGl0aW9uPWZ1bmN0aW9uKGUsdCxvKXt2YXIgYT1kb211dGlscy5nZXRBdHRyaWJ1dGUodCxlKTt0cnl7dmFyIGk9Y29udmVydGVyVXRpbHMuY29uZGl0aW9uQmluZGluZyhhLG8pOyQodCkuYmVmb3JlKFwiXFx4M2MhLS0ga28gaWY6IFwiK2krXCIgLS1cXHgzZVwiKSwkKHQpLmFmdGVyKFwiXFx4M2MhLS0gL2tvIC0tXFx4M2VcIiksZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKHQsZSl9Y2F0Y2gobyl7dGhyb3cgY29uc29sZS53YXJuKFwiTW9kZWwgZW5zdXJlIHBhdGggZmFpbGVkIGluIGlmL3ZhcmlhbnRcIix0LGEsZSksb319LHJlcGxhY2VkQXR0cmlidXRlcz1mdW5jdGlvbihlLHQpe2RvbXV0aWxzLnNldEF0dHJpYnV0ZShlLHQsZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGUsXCJyZXBsYWNlZFwiK3QpKX0scHJvY2Vzc1N0eWxlPWZ1bmN0aW9uKGUsdCxvLGEpe3ZhciBpLHI9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGUsXCJyZXBsYWNlZHN0eWxlXCIpLGw9bnVsbDthJiYoaT17dW5pcXVlSWQ6XCIkZGF0YVwiLGF0dHI6e2lkOlwiaWRcIn19KTt2YXIgZD1udWxsIT09ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGUsXCJkYXRhLWtvLWRpc3BsYXlcIik7bnVsbD09PShsPWVsYWJvcmF0ZURlY2xhcmF0aW9ucyhyLHZvaWQgMCx0LG8sZSxpLGQpKT9sPXI6ZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGUsXCJyZXBsYWNlZHN0eWxlXCIpLG51bGwhPT1sJiYobC50cmltKCkubGVuZ3RoPjA/ZG9tdXRpbHMuc2V0QXR0cmlidXRlKGUsXCJzdHlsZVwiLGwpOmRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlLFwic3R5bGVcIikpfSxfZml4UmVsYXRpdmVQYXRoPWZ1bmN0aW9uKGUsdCxvLGEpe3ZhciBpPXQoZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGEsZSkpO251bGwhPT1pJiZkb211dGlscy5zZXRBdHRyaWJ1dGUoYSxlLGkpfSxwcm9jZXNzQmxvY2s9ZnVuY3Rpb24oZSx0LG8sYSxpLHIsbCxkLHMsYyl7dHJ5e3ZhciBuO2lmKFwiYmxvY2tcIj09ciluPWRvbXV0aWxzLmdldEF0dHJpYnV0ZShlLFwiZGF0YS1rby1ibG9ja1wiKSxkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZSxcImRhdGEta28tYmxvY2tcIik7ZWxzZXtpZihcInRlbXBsYXRlXCIhPXIpdGhyb3dcIlVuZXhwZWN0ZWQgY29udGV4dCBuYW1lIHdoaWxlIHByb2Nlc3NpbmcgYmxvY2s6IFwiK3I7bj1sfSQoXCJbZGF0YS1rby1yZW1vdmVdXCIsZSkucmVtb3ZlKCk7Zm9yKHZhciB1PSQoXCJbZGF0YS1rby1ibG9ja11cIixlKS5yZXBsYWNlV2l0aChcIjxyZXBsYWNlZGJsb2NrPlwiKSxtPVtcImhyZWZcIixcInNyY1wiLFwiZGF0YS1rby1wbGFjZWhvbGRlci1zcmNcIixcImJhY2tncm91bmRcIl0saD0wO2g8bS5sZW5ndGg7aCsrKXt2YXIgcD1fZml4UmVsYXRpdmVQYXRoLmJpbmQodm9pZCAwLG1baF0saSk7JChcIltcIittW2hdK1wiXVwiLGUpLmVhY2gocCl9dmFyIGI9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGUsXCJkYXRhLWtvLXByb3BlcnRpZXNcIik7bnVsbD09PWImJihiPVwiXCIpLCQoXCJbZGF0YS1rby1wcm9wZXJ0aWVzXVwiLGUpLmVhY2goZnVuY3Rpb24oZSx0KXtiLmxlbmd0aD4wJiYoYis9XCIgXCIpLGIrPWRvbXV0aWxzLmdldEF0dHJpYnV0ZSh0LFwiZGF0YS1rby1wcm9wZXJ0aWVzXCIpLGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZSh0LFwiZGF0YS1rby1wcm9wZXJ0aWVzXCIpfSksbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZih0LG4sYix7Y29udGV4dE5hbWU6cn0pO3ZhciB2PW1vZGVsRGVmLmVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUuYmluZCh2b2lkIDAsdCxvLGwsbixcIlwiKTtcImJsb2NrXCI9PXImJnYoXCJpZFwiLFwiXCIpLCQoXCJzdHlsZVwiLGUpLmVhY2goZnVuY3Rpb24oZSxhKXt2YXIgcj1kb211dGlscy5nZXRJbm5lckh0bWwoYSksZD1tb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmLmJpbmQodm9pZCAwLHQpLHM9bW9kZWxEZWYuZW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHZvaWQgMCx0LG8sbCksdT1wcm9jZXNzU3R5bGVzaGVldFJ1bGVzKHIsdm9pZCAwLHMsZCxvLGksbCxuKTtpZih1IT1yKWlmKFwiXCIhPT11LnRyaW0oKSl7dmFyIG09Yyh1KTtkb211dGlscy5zZXRBdHRyaWJ1dGUoYSxcImRhdGEtYmluZFwiLFwidGVtcGxhdGU6IHsgbmFtZTogJ1wiK20rXCInIH1cIiksZG9tdXRpbHMuc2V0Q29udGVudChhLFwiXCIpfWVsc2UgZG9tdXRpbHMucmVtb3ZlRWxlbWVudHMoJChhKSl9KSxwcm9jZXNzU3R5bGUoZSxpLHYscyk7Zm9yKHZhciBmPVtcImRhdGEta28tZGlzcGxheVwiLFwiZGF0YS1rby1lZGl0YWJsZVwiLFwiZGF0YS1rby13cmFwXCIsXCJocmVmXCJdLGs9MDtrPGYubGVuZ3RoO2srKyl7aWYoZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGUsZltrXSkpdGhyb3cgY29uc29sZS53YXJuKFwiRVJST1I6IFVuc3VwcG9ydGVkIFwiK2Zba10rXCIgdXNlZCB0b2dldGhlciB3aXRoIGRhdGEta28tYmxvY2tcIixlKSxcIkVSUk9SOiBVbnN1cHBvcnRlZCBcIitmW2tdK1wiIHVzZWQgdG9nZXRoZXIgd2l0aCBkYXRhLWtvLWJsb2NrXCJ9cmV0dXJuICQoXCJbZGF0YS1rby1saW5rXVwiLGUpLmVhY2goZnVuY3Rpb24oZSx0KXt2YXIgbz1kb211dGlscy5nZXRBdHRyaWJ1dGUodCxcImRhdGEta28tbGlua1wiKSxhPWRvbXV0aWxzLmdldEF0dHJpYnV0ZSh0LFwicmVwbGFjZWRzdHlsZVwiKTtudWxsPT1hJiYoYT1cIlwiKSxhPVwiXCIhPT1hP1wiLWtvLWF0dHItaHJlZjogQFwiK28rXCI7IFwiK2E6XCIta28tYXR0ci1ocmVmOiBAXCIrbyxkb211dGlscy5zZXRBdHRyaWJ1dGUodCxcInJlcGxhY2Vkc3R5bGVcIixhKSxkb211dGlscy5zZXRBdHRyaWJ1dGUodCxcImRhdGEta28td3JhcFwiLG8pLGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZSh0LFwiZGF0YS1rby1saW5rXCIpfSksJChcIltyZXBsYWNlZHN0eWxlXVwiLGUpLmVhY2goZnVuY3Rpb24oZSx0KXtwcm9jZXNzU3R5bGUodCxpLHYsITEpfSksJChcIltyZXBsYWNlZGh0dHAtZXF1aXZdXCIsZSkuZWFjaChmdW5jdGlvbihlLHQpe3JlcGxhY2VkQXR0cmlidXRlcyh0LFwiaHR0cC1lcXVpdlwiKX0pLCQoXCJbZGF0YS1rby1kaXNwbGF5XVwiLGUpLmVhY2goZnVuY3Rpb24oZSx0KXt3cmFwRWxlbWVudFdpdGhDb25kaXRpb24oXCJkYXRhLWtvLWRpc3BsYXlcIix0LHYpfSksJChcIltkYXRhLWtvLWVkaXRhYmxlXVwiLGUpLmVhY2goZnVuY3Rpb24oZSx0KXt2YXIgbyxhLGkscixsLGQscz1kb211dGlscy5nZXRBdHRyaWJ1dGUodCxcImRhdGEta28tZWRpdGFibGVcIik7aWYocy5sYXN0SW5kZXhPZihcIi5cIik+MCl7dmFyIG49cy5zdWJzdHIoMCxzLmxhc3RJbmRleE9mKFwiLlwiKSk7bD12KG4pfWVsc2UgbD12KHMpO2lmKGQ9XCJ3eXNpd3lnQ2xpY2s6IGZ1bmN0aW9uKG9iaiwgZXZ0KSB7ICRyb290LnNlbGVjdEl0ZW0oXCIrbCtcIiwgJGRhdGEpOyByZXR1cm4gZmFsc2UgfSwgY2xpY2tCdWJibGU6IGZhbHNlLCB3eXNpd3lnQ3NzOiB7IHNlbGVjdGVkaXRlbTogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oXCIrbCtcIikgfSwgc2Nyb2xsSW50b1ZpZXc6ICRyb290LmlzU2VsZWN0ZWRJdGVtKFwiK2wrXCIpXCIsXCJpbWdcIiE9ZG9tdXRpbHMuZ2V0TG93ZXJUYWdOYW1lKHQpKXthPWRvbXV0aWxzLmdldElubmVySHRtbCh0KTt2YXIgdT12KHMsYSwhMCxcInd5c2l3eWdcIik7aWYobz1cIlwiLGRvbXV0aWxzLmdldEF0dHJpYnV0ZSh0LFwiaWRcIil8fChvKz1cInd5c2l3eWdJZDogaWQoKSsnX1wiK3MucmVwbGFjZShcIi5cIixcIl9cIikrXCInLCBcIiksdm9pZCAwIT09ZCYmKG8rPWQrXCIsIFwiKSxvKz1cInd5c2l3eWdPckh0bWw6IFwiK3UsXCJ0ZFwiPT1kb211dGlscy5nZXRMb3dlclRhZ05hbWUodCkpe3ZhciBtPSQoJzxkaXYgZGF0YS1rby13cmFwPVwiZmFsc2VcIiBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCVcIj48L2Rpdj4nKVswXTtkb211dGlscy5zZXRBdHRyaWJ1dGUobSxcImRhdGEtYmluZFwiLG8pO3ZhciBoPWRvbXV0aWxzLmdldElubmVySHRtbCgkKFwiPGRpdj48L2Rpdj5cIikuYXBwZW5kKG0pKTtkb211dGlscy5zZXRDb250ZW50KHQsaCl9ZWxzZSByPShudWxsIT09KGk9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJkYXRhLWJpbmRcIikpP2krXCIsIFwiOlwiXCIpK28sZG9tdXRpbHMuc2V0QXR0cmlidXRlKHQsXCJkYXRhLWJpbmRcIixyKSxkb211dGlscy5zZXRDb250ZW50KHQsXCJcIik7ZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKHQsXCJkYXRhLWtvLWVkaXRhYmxlXCIpfWVsc2V7dmFyIHA9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJ3aWR0aFwiKTtpZihcIlwiPT09cCYmKHA9bnVsbCksbnVsbD09PXApdGhyb3cgY29uc29sZS5lcnJvcihcIkVSUk9SOiBkYXRhLWtvLWVkaXRhYmxlIGltYWdlcyBtdXN0IGRlY2xhcmUgYSBXSURUSCBhdHRyaWJ1dGUhXCIsdCksXCJFUlJPUjogZGF0YS1rby1lZGl0YWJsZSBpbWFnZXMgbXVzdCBkZWNsYXJlIGEgV0lEVEggYXR0cmlidXRlIVwiO3ZhciBiPWRvbXV0aWxzLmdldEF0dHJpYnV0ZSh0LFwiaGVpZ2h0XCIpO1wiXCI9PT1iJiYoYj1udWxsKTt2YXIgZj1kb211dGlscy5nZXRBdHRyaWJ1dGUodCxcImFsaWduXCIpLGs9KGk9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJkYXRhLWJpbmRcIikpJiZpLm1hdGNoKC92aXJ0dWFsQXR0cjoge1tefV0qIGhlaWdodDogKFteLH1dKilbLH1dLyk7ayYmKGI9a1sxXSk7dmFyIGc9aSYmaS5tYXRjaCgvdmlydHVhbEF0dHI6IHtbXn1dKiB3aWR0aDogKFteLH1dKilbLH1dLyk7ZyYmKHA9Z1sxXSk7dmFyIHcsQSx5PVwiXCI7KGE9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJkYXRhLWtvLXBsYWNlaG9sZGVyLXNyY1wiKSk/eT1kb211dGlscy5nZXRBdHRyaWJ1dGUodCxcInNyY1wiKTphPWRvbXV0aWxzLmdldEF0dHJpYnV0ZSh0LFwic3JjXCIpLHAmJmI/dz1wK1wiKyd4JytcIitiOmI/cHx8KHc9XCInaCcrXCIrYitcIisnJ1wiKTp3PVwiJ3cnK1wiK3ArXCIrJydcIjt2YXIgeD1ifHxkb211dGlscy5nZXRBdHRyaWJ1dGUodCxcImRhdGEta28tcGxhY2Vob2xkZXItaGVpZ2h0XCIpLF89cHx8ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJkYXRhLWtvLXBsYWNlaG9sZGVyLXdpZHRoXCIpO2lmKGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZSh0LFwic3JjXCIpLGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZSh0LFwiZGF0YS1rby1lZGl0YWJsZVwiKSxkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUodCxcImRhdGEta28tcGxhY2Vob2xkZXItaGVpZ2h0XCIpLGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZSh0LFwiZGF0YS1rby1wbGFjZWhvbGRlci13aWR0aFwiKSxkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUodCxcImRhdGEta28tcGxhY2Vob2xkZXItc3JjXCIpLGEmJihBPVwieyB3aWR0aDogXCIrXytcIiwgaGVpZ2h0OiBcIit4K1wiLCB0ZXh0OiBcIit3K1wifVwiKSwhX3x8IXgpdGhyb3cgY29uc29sZS5lcnJvcihcIklNRyBkYXRhLWtvLWVkaXRhYmxlIG11c3QgZGVjbGFyZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMsIG9yIHRoZWlyIHBsYWNlaG9sZGVyIGNvdW50ZXJwYXJ0cyBkYXRhLWtvLXBsYWNlaG9sZGVyLXdpZHRoL2RhdGEta28tcGxhY2Vob2xkZXItaGVpZ2h0XCIsdCksXCJFUlJPUjogSU1HIGRhdGEta28tZWRpdGFibGUgTVVTVCBkZWNsYXJlIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcywgb3IgdGhlaXIgcGxhY2Vob2xkZXIgY291bnRlcnBhcnRzIGRhdGEta28tcGxhY2Vob2xkZXItd2lkdGgvZGF0YS1rby1wbGFjZWhvbGRlci1oZWlnaHRcIjt2YXIgRD12KHMseSwhMSxcInd5c2l3eWdcIik7cj0obnVsbCE9PWk/aStcIiwgXCI6XCJcIikrKG89XCJ3eXNpd3lnU3JjOiB7IHdpZHRoOiBcIitwK1wiLCBoZWlnaHQ6IFwiK2IrXCIsIHNyYzogXCIrRCtcIiwgcGxhY2Vob2xkZXI6IFwiK0ErXCIgfVwiKSxkb211dGlscy5zZXRBdHRyaWJ1dGUodCxcImRhdGEtYmluZFwiLHIpO3ZhciBJPWModCksUj1cInsgd2lkdGg6IFwiK3A7XCJsZWZ0XCI9PWY/Uis9XCIsIGZsb2F0OiAnbGVmdCdcIjpcInJpZ2h0XCI9PWY/Uis9XCIsIGZsb2F0OiAncmlnaHQnXCI6XCJjZW50ZXJcIj09ZiYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUuZGVidWc/Y29uc29sZS5kZWJ1ZyhcIklnbm9yaW5nIGFsaWduPWNlbnRlciBvbiBhbiBpbWcgdGFnOiB3ZSBkb24ndCBrbm93IGhvdyB0byBlbXVsYXRlIHRoaXMgYWxpZ25tZW50IGluIHRoZSBlZGl0b3IhXCIpOlwidG9wXCI9PWY/Uis9XCIsIHZlcnRpY2FsQWxpZ246ICd0b3AnXCI6XCJtaWRkbGVcIj09Zj9SKz1cIiwgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcIjpcImJvdHRvbVwiPT1mJiYoUis9XCIsIHZlcnRpY2FsQWxpZ246ICdib3R0b20nXCIpKSxSKz1cIn1cIiwkKHQpLmJlZm9yZShcIlxceDNjIS0tIGtvIHd5c2l3eWdJbWc6IHsgX2RhdGE6ICRkYXRhLCBfaXRlbTogXCIrbCtcIiwgX3RlbXBsYXRlOiAnXCIrSStcIicsIF9lZGl0VGVtcGxhdGU6ICdpbWctd3lzaXd5ZycsIF9zcmM6IFwiK0QrXCIsIF93aWR0aDogXCIrcCtcIiwgX2hlaWdodDogXCIrYitcIiwgX2FsaWduOiBcIisobnVsbD09PWY/dm9pZCAwOlwiJ1wiK2YrXCInXCIpK1wiLCBfc2l6ZTogXCIrdytcIiwgX21ldGhvZDogXCIrdm9pZCAwK1wiLCBfcGxhY2Vob2xkZXJzcmM6IFwiK0ErXCIsIF9zdHlsZWJpbmQ6IFwiK1IrXCIgfSAtLVxceDNlXCIpLCQodCkuYWZ0ZXIoXCJcXHgzYyEtLSAva28gLS1cXHgzZVwiKX19KSwkKFwiW2hyZWZdXCIsZSkuZWFjaChmdW5jdGlvbihlLHQpe3ZhciBvPWRvbXV0aWxzLmdldEF0dHJpYnV0ZSh0LFwiaHJlZlwiKSxhPVwid3lzaXd5Z0hyZWY6ICdcIitjb252ZXJ0ZXJVdGlscy5hZGRTbGFzaGVzKG8pK1wiJ1wiLGk9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJkYXRhLWJpbmRcIikscj0obnVsbCE9PWk/aStcIiwgXCI6XCJcIikrYTtkb211dGlscy5zZXRBdHRyaWJ1dGUodCxcImRhdGEtYmluZFwiLHIpfSksJChcInJlcGxhY2VkYmxvY2tcIixlKS5lYWNoKGZ1bmN0aW9uKGUscil7dmFyIHM9dVtlXSxtPXByb2Nlc3NCbG9jayhzLHQsbyxhLGksXCJibG9ja1wiLG4sZCwhMCxjKSxoPW1vZGVsRGVmLmVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUodCxvLGwsbixcIlwiLG0pOyQocikuYmVmb3JlKFwiXFx4M2MhLS0ga28gYmxvY2s6IHsgZGF0YTogXCIrY29udmVydGVyVXRpbHMuYWRkU2xhc2hlcyhoKStcIiwgdGVtcGxhdGU6ICdibG9jaycgfSAtLVxceDNlXCIpLCQocikuYWZ0ZXIoXCJcXHgzYyEtLSAva28gLS1cXHgzZVwiKSwkKHIpLnJlbW92ZSgpfSksJCgkKFwiW2RhdGEta28td3JhcF1cIixlKS5nZXQoKS5yZXZlcnNlKCksZSkuZWFjaChmdW5jdGlvbihlLHQpe3ZhciBvPWRvbXV0aWxzLmdldEF0dHJpYnV0ZSh0LFwiZGF0YS1rby13cmFwXCIpO2lmKHZvaWQgMD09PW98fFwiXCI9PT1vfHxcInRydWVcIj09PW8pdGhyb3dcIlVuc3VwcG9ydGVkIGVtcHR5IHZhbHVlIGZvciBkYXRhLWtvLXdyYXA6IHVzZSBmYWxzZSB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhbHdheXMgcmVtb3ZlIHRoZSB0YWdcIjt2YXIgYSxpLHI9Y29udmVydGVyVXRpbHMuY29uZGl0aW9uQmluZGluZyhvLHYpLGw9ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJkYXRhLWJpbmRcIik7aWYoXCJcIiE9PWwmJm51bGwhPT1sJiZsLm1hdGNoKC8oYmxvY2t8d3lzaXd5Z09ySHRtbCk6Lykpe3ZhciBkPVwiXFx4M2MhLS0ga28gXCIrbCtcIiAtLVxceDNlXCIrZG9tdXRpbHMuZ2V0SW5uZXJIdG1sKHQpK1wiXFx4M2MhLS0gL2tvIC0tXFx4M2VcIjthPWMoZCksZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKHQsXCJkYXRhLWtvLXdyYXBcIiksaT1jKHQpLGRvbXV0aWxzLnJlcGxhY2VIdG1sKHQsXCJcXHgzYyEtLSBrbyB0ZW1wbGF0ZTogLyogc3BlY2lhbCAqLyAodHlwZW9mIHRlbXBsYXRlTW9kZSAhPSAndW5kZWZpbmVkJyAmJiB0ZW1wbGF0ZU1vZGUgPT0gJ3d5c2l3eWcnKSB8fCBcIityK1wiID8gJ1wiK2krXCInIDogJ1wiK2ErXCInIC0tXFx4M2VcXHgzYyEtLSAva28gLS1cXHgzZVwiKX1lbHNlIGE9Yyhkb211dGlscy5nZXRJbm5lckh0bWwodCkpLGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZSh0LFwiZGF0YS1rby13cmFwXCIpLGRvbXV0aWxzLnNldENvbnRlbnQodCxcIlxceDNjIS0tIGtvIHRlbXBsYXRlOiAnXCIrYStcIicgLS1cXHgzZVxceDNjIS0tIC9rbyAtLVxceDNlXCIpLGk9Yyh0KSxkb211dGlscy5yZXBsYWNlSHRtbCh0LFwiXFx4M2MhLS0ga28gdGVtcGxhdGU6ICh0eXBlb2YgdGVtcGxhdGVNb2RlICE9ICd1bmRlZmluZWQnICYmIHRlbXBsYXRlTW9kZSA9PSAnd3lzaXd5ZycpIHx8IFwiK3IrXCIgPyAnXCIraStcIicgOiAnXCIrYStcIicgLS1cXHgzZVxceDNjIS0tIC9rbyAtLVxceDNlXCIpfSksYyhlLG4sXCJzaG93XCIpLGEobCxuLHIsZCksbn1jYXRjaCh0KXt0aHJvdyBjb25zb2xlLmVycm9yKFwiRXhjZXB0aW9uIHdoaWxlIHBhcnNpbmcgdGhlIHRlbXBsYXRlXCIsdCxlKSx0fX07ZnVuY3Rpb24gY29uZGl0aW9uYWxfcmVwbGFjZShlKXtyZXR1cm4gZS5yZXBsYWNlKC88IS0tXFxbaWYgKFteXFxdXSopXFxdPigoPzooPyEtLSlbXFxzXFxTXSkqPyk8IVxcW2VuZGlmXFxdLS0+L2csZnVuY3Rpb24oZSx0LG8pe3ZhciBhPVwiXFx4M2MhLS0gY2M6c3RhcnQgLS1cXHgzZVwiO2ErPW8ucmVwbGFjZSgvPChbQS1aYS16Ol0rKS9nLFwiXFx4M2MhLS0gY2M6Ym86JDEgLS1cXHgzZTxjY1wiKS5yZXBsYWNlKC88XFwvKFtBLVphLXo6XSspPi9nLFwiXFx4M2MhLS0gY2M6YmM6JDEgLS1cXHgzZTwvY2M+XFx4M2MhLS0gY2M6YWM6JDEgLS1cXHgzZVwiKS5yZXBsYWNlKC9cXC8+L2csXCIvPlxceDNjIS0tIGNjOnNjIC0tXFx4M2VcIiksYSs9XCJcXHgzYyEtLSBjYzplbmQgLS1cXHgzZVwiO3ZhciBpPSc8cmVwbGFjZWRjYyBjb25kaXRpb249XCInK3QrJ1wiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiPic7cmV0dXJuIGkrPSQoXCI8ZGl2PlwiKS5hcHBlbmQoJChhKSkuaHRtbCgpLnJlcGxhY2UoL148IS0tIGNjOnN0YXJ0IC0tPi8sXCJcIikucmVwbGFjZSgvPCEtLSBjYzplbmQgLS0+JC8sXCJcIiksaSs9XCI8L3JlcGxhY2VkY2M+XCJ9KX12YXIgdHJhbnNsYXRlVGVtcGxhdGU9ZnVuY3Rpb24oZSx0LG8sYSl7dmFyIGk9e30scj1jb25kaXRpb25hbF9yZXBsYWNlKHQucmVwbGFjZSgvKDxbXj5dK1xccykoc3R5bGV8aHR0cC1lcXVpdikoPVwiW15cIl0qXCJbXj5dKj4pL2dpLGZ1bmN0aW9uKGUsdCxvLGEpe3JldHVybiB0K1wicmVwbGFjZWRcIitvK2F9KSksbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiAkLnBhcnNlSFRNTD8kKCQucGFyc2VIVE1MKHIsITEpKTokKHIpLGQ9bFswXSxzPVtdLGM9ZnVuY3Rpb24oZSx0LG8sYSl7cy5wdXNoKHtyb290OmUsYmxvY2s6dCxjb250ZXh0Om8sY29udGFpbmVyOmF9KX0sbj1mdW5jdGlvbihlLHQsbyl7aWYodm9pZCAwPT09aS50aGVtZXMmJihpLnRoZW1lcz17fSksdm9pZCAwPT09aS50aGVtZXNbZV0mJihpLnRoZW1lc1tlXT17fSksdm9pZCAwPT09aS50aGVtZXNbZV1bdF18fG51bGw9PT1pLnRoZW1lc1tlXVt0XSlpLnRoZW1lc1tlXVt0XT1vO2Vsc2UgaWYobnVsbCE9byl7dmFyIGE9aS50aGVtZXNbZV1bdF07YSE9byYmY29uc29sZS5sb2coXCJFcnJvciBzZXR0aW5nIGEgbmV3IGRlZmF1bHQgZm9yIHByb3BlcnR5IFwiK3QrXCIgaW4gdGhlbWUgXCIrZStcIi4gb2xkOlwiK2ErXCIgbmV3OlwiK28rXCIhXCIpfX0sdT0kKFwiW2RhdGEta28tY29udGFpbmVyXVwiLGwpLG09e307dS5lYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIG89ZG9tdXRpbHMuZ2V0QXR0cmlidXRlKHQsXCJkYXRhLWtvLWNvbnRhaW5lclwiKStcIkJsb2Nrc1wiO2RvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZSh0LFwiZGF0YS1rby1jb250YWluZXJcIiksZG9tdXRpbHMuc2V0QXR0cmlidXRlKHQsXCJkYXRhLWJpbmRcIixcImJsb2NrOiBcIitvKTt2YXIgYT0kKFwiPiBbZGF0YS1rby1ibG9ja11cIix0KTtkb211dGlscy5yZW1vdmVFbGVtZW50cyhhLCEwKSxtW29dPWF9KSxtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGksXCJpZFwiKSxtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGksXCJib2R5VGhlbWVcIiksbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZihpLFwiYmxvY2tzXCIsXCJibG9ja3NbXVwiKSxtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGksXCJ0ZXh0XCIpLHByb2Nlc3NCbG9jayhkLGksbixjLG8sXCJ0ZW1wbGF0ZVwiLGUsdm9pZCAwLCExLGEpO3ZhciBoPWZ1bmN0aW9uKHQscixsKXtwcm9jZXNzQmxvY2sobCxpLG4sYyxvLFwiYmxvY2tcIixlLHQsITAsYSl9O2Zvcih2YXIgcCBpbiBtKWlmKG0uaGFzT3duUHJvcGVydHkocCkpe3ZhciBiPW1bcF0sdj1wO21vZGVsRGVmLmVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUoaSxuLGUsZSxcIlwiLHYrXCIuYmxvY2tzXCIsXCJbXVwiKSxiLmVhY2goaC5iaW5kKHZvaWQgMCx2KSl9dmFyIGY9e19kZWZzOmksdGVtcGxhdGVOYW1lOmUsX2Jsb2NrczpzfTtyZXR1cm4gdm9pZCAwIT09aVtlXS5fdmVyc2lvbiYmKGYudmVyc2lvbj1pW2VdLl92ZXJzaW9uKSxmfTttb2R1bGUuZXhwb3J0cz10cmFuc2xhdGVUZW1wbGF0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluQmhjbk5sY2k1cWN5SmRMQ0p1WVcxbGN5STZXeUlrSWl3aWQybHVaRzkzSWl3aVoyeHZZbUZzSWl3aVkyOXVjMjlzWlNJc0luSmxjWFZwY21VaUxDSmpiMjUyWlhKMFpYSlZkR2xzY3lJc0ltVnNZV0p2Y21GMFpVUmxZMnhoY21GMGFXOXVjeUlzSW5CeWIyTmxjM05UZEhsc1pYTm9aV1YwVW5Wc1pYTWlMQ0p0YjJSbGJFUmxaaUlzSW1SdmJYVjBhV3h6SWl3aWQzSmhjRVZzWlcxbGJuUlhhWFJvUTI5dVpHbDBhVzl1SWl3aVlYUjBjbWxpZFhSbElpd2laV3hsYldWdWRDSXNJbUpwYm1ScGJtZFFjbTkyYVdSbGNpSXNJbU52Ym1RaUxDSm5aWFJCZEhSeWFXSjFkR1VpTENKaWFXNWthVzVuSWl3aVkyOXVaR2wwYVc5dVFtbHVaR2x1WnlJc0ltSmxabTl5WlNJc0ltRm1kR1Z5SWl3aWNtVnRiM1psUVhSMGNtbGlkWFJsSWl3aVpTSXNJbmRoY200aUxDSnlaWEJzWVdObFpFRjBkSEpwWW5WMFpYTWlMQ0poZEhSeWFXSjFkR1ZPWVcxbElpd2ljMlYwUVhSMGNtbGlkWFJsSWl3aWNISnZZMlZ6YzFOMGVXeGxJaXdpZEdWdGNHeGhkR1ZWY214RGIyNTJaWEowWlhJaUxDSmhaR1JWYm1seGRXVkpaQ0lzSW01bGQwSnBibVJwYm1keklpd2ljM1I1YkdVaUxDSnVaWGRUZEhsc1pTSXNJblZ1YVhGMVpVbGtJaXdpWVhSMGNpSXNJbWxrSWl3aWNtVnRiM1psUkdsemNHeGhlVTV2Ym1VaUxDSjFibVJsWm1sdVpXUWlMQ0owY21sdElpd2liR1Z1WjNSb0lpd2lYMlpwZUZKbGJHRjBhWFpsVUdGMGFDSXNJbWx1WkdWNElpd2libVYzVlhKc0lpd2ljSEp2WTJWemMwSnNiMk5ySWl3aVpHVm1jeUlzSW5Sb1pXMWxWWEJrWVhSbGNpSXNJbUpzYjJOclVIVnphR1Z5SWl3aVkyOXVkR1Y0ZEU1aGJXVWlMQ0p5YjI5MFRXOWtaV3hPWVcxbElpd2lZMjl1ZEdGcGJtVnlUbUZ0WlNJc0ltZGxibVZ5WVhSbFZXNXBjWFZsU1dRaUxDSjBaVzF3YkdGMFpVTnlaV0YwYjNJaUxDSjBaVzF3YkdGMFpVNWhiV1VpTENKeVpXMXZkbVVpTENKbWFYaGxaRUpzYjJOcmN5SXNJbkpsY0d4aFkyVlhhWFJvSWl3aWRYSnNZWFIwY25NaUxDSnBJaXdpWm5WdVl5SXNJbUpwYm1RaUxDSmxZV05vSWl3aVpHRjBZVVJsWm5NaUxDSmpjbVZoZEdWUGNsVndaR0YwWlVKc2IyTnJSR1ZtSWl3aVpXNXpkWEpsVUdGMGFFRnVaRWRsZEVKcGJtUldZV3gxWlNJc0ltZGxkRWx1Ym1WeVNIUnRiQ0lzSW1Kc2IyTnJSR1ZtYzFWd1pHRjBaWElpTENKc2IyTmhiRmRwZEdoQ2FXNWthVzVuVUhKdmRtbGtaWElpTENKMGJYQk9ZVzFsSWl3aWMyVjBRMjl1ZEdWdWRDSXNJbkpsYlc5MlpVVnNaVzFsYm5Seklpd2libTkwYzNWd2NHOXlkR1ZrSWl3aWFpSXNJblZ5YkZaaGNpSXNJbkpsY0ZOMGVXeGxJaXdpYm1WM1FtbHVaR2x1WnlJc0ltUmxabUYxYkhSV1lXeDFaU0lzSW1OMWNuSmxiblJDYVc1a2FXNW5jeUlzSW1SaGRHRkNhVzVrSWl3aWFYUmxiVUpwYm1SV1lXeDFaU0lzSW5ObGJHVmpkRUpwYm1ScGJtY2lMQ0prWVhSaFJXUnBkR0ZpYkdVaUxDSnNZWE4wU1c1a1pYaFBaaUlzSW5OMVluTWlMQ0p6ZFdKemRISWlMQ0puWlhSTWIzZGxjbFJoWjA1aGJXVWlMQ0p0YjJSbGJFSnBibVJXWVd4MVpTSXNJbkpsY0d4aFkyVWlMQ0ozY21Gd2NHbHVaMFJwZGlJc0ltNWxkME52Ym5SbGJuUWlMQ0poY0hCbGJtUWlMQ0ozYVdSMGFDSXNJbVZ5Y205eUlpd2lhR1ZwWjJoMElpd2lZV3hwWjI0aUxDSmtlVzVJWldsbmFIUWlMQ0p0WVhSamFDSXNJbVI1YmxkcFpIUm9JaXdpYzJsNlpTSXNJbkJzWVdObGFHOXNaR1Z5YzNKaklpd2lkbUZzZFdVaUxDSndiR2hsYVdkb2RDSXNJbkJzZDJsa2RHZ2lMQ0ppYVc1a2FXNW5WbUZzZFdVaUxDSjBiWEJzVG1GdFpTSXNJbU52Ym5SaGFXNWxja0pwYm1RaUxDSmtaV0oxWnlJc0ltMWxkR2h2WkNJc0ltRjBkSEpXWVd4MVpTSXNJbUZrWkZOc1lYTm9aWE1pTENKaWJHOWphMFZzWlcxbGJuUWlMQ0ppYkc5amEwNWhiV1VpTENKblpYUWlMQ0p5WlhabGNuTmxJaXdpYVc1dVpYSlViWEJzVG1GdFpTSXNJbTkxZEdWeVZHMXdiRTVoYldVaUxDSmpiMjVrUW1sdVpHbHVaeUlzSW1sdWJtVnlWRzF3YkVOdmJuUmxiblFpTENKeVpYQnNZV05sU0hSdGJDSXNJbU52Ym1ScGRHbHZibUZzWDNKbGNHeGhZMlVpTENKb2RHMXNJaXdpWTI5dVpHbDBhVzl1SWl3aVltOWtlU0lzSW1Sa0lpd2liM1YwY0hWMElpd2lkSEpoYm5Oc1lYUmxWR1Z0Y0d4aGRHVWlMQ0p5WlhCc1lXTmxaRWgwYld3aUxDSndNU0lzSW5BeUlpd2ljRE1pTENKamIyNTBaVzUwSWl3aWNHRnljMlZJVkUxTUlpd2lZbXh2WTJ0eklpd2lYMkpzYjJOclVIVnphR1Z5SWl3aWNtOXZkRTVoYldVaUxDSndkWE5vSWl3aWNtOXZkQ0lzSW1Kc2IyTnJJaXdpWTI5dWRHVjRkQ0lzSW1OdmJuUmhhVzVsY2lJc0ltNWhiV1VpTENKclpYa2lMQ0oyWVd3aUxDSndjbVZqVm1Gc0lpd2liRzluSWl3aVkyOXVkR0ZwYm1WeWN5SXNJbU52Ym5SaGFXNWxjbk5FYjIwaUxDSmpiMjUwWVdsdVpYSkNiRzlqYTNNaUxDSmliRzlqYTFCeWIyTmxjM01pTENKd2NtOXdJaXdpYUdGelQzZHVVSEp2Y0dWeWRIa2lMQ0owWlcxd2JHRjBaVVJsWmlJc0lsOWtaV1p6SWl3aVgySnNiMk5yY3lJc0lsOTJaWEp6YVc5dUlpd2lkbVZ5YzJsdmJpSXNJbTF2WkhWc1pTSXNJbVY0Y0c5eWRITWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUjBFc1NVRkJTVUVzUlVGQmRVSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVhOQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlpTeFBRVUZKTEV0QlF6TkhReXhSUVVGVlF5eFJRVUZSTEhOQ1FVTnNRa01zWlVGQmFVSkVMRkZCUVZFc1kwRkRla0pGTEhOQ1FVRjNRa1lzVVVGQlVTeHhRa0ZEYUVOSExIVkNRVUY1UWtnc1VVRkJVU3h0UWtGRGFrTkpMRk5CUVZkS0xGRkJRVkVzWTBGRGJrSkxMRk5CUVZkTUxGRkJRVkVzYVVKQlJXNUNUU3g1UWtGQk1rSXNVMEZCVTBNc1JVRkJWME1zUlVGQlUwTXNSMEZETVVRc1NVRkJTVU1zUlVGQlQwd3NVMEZCVTAwc1lVRkJZVWdzUlVGQlUwUXNSMEZGTVVNc1NVRkRSU3hKUVVGSlN5eEZRVUZWV0N4bFFVRmxXU3hwUWtGQmFVSklMRVZCUVUxRUxFZEJRM0JFWWl4RlFVRkZXU3hIUVVGVFRTeFBRVUZQTEd0Q1FVRnBRa1lzUlVGQlZTeFhRVU0zUTJoQ0xFVkJRVVZaTEVkQlFWTlBMRTFCUVUwc2MwSkJRMnBDVml4VFFVRlRWeXhuUWtGQlowSlNMRVZCUVZORUxFZEJRMnhETEUxQlFVOVZMRWRCUlZBc1RVRkVRV3hDTEZGQlFWRnRRaXhMUVVGTExIbERRVUV3UTFZc1JVRkJVMFVzUlVGQlRVZ3NSMEZEYUVWVkxFbEJTMDVGTEcxQ1FVRnhRaXhUUVVGVFdDeEZRVUZUV1N4SFFVTjZRMllzVTBGQlUyZENMR0ZCUVdGaUxFVkJRVk5aTEVWQlFXVm1MRk5CUVZOTkxHRkJRV0ZJTEVWQlFWTXNWMEZCWVZrc1MwRkhlRVpGTEdGQlFXVXNVMEZCVTJRc1JVRkJVMlVzUlVGQmMwSmtMRVZCUVdsQ1pTeEhRVU14UlN4SlFVVkpReXhGUVVaQlF5eEZRVUZSY2tJc1UwRkJVMDBzWVVGQllVZ3NSVUZCVXl4cFFrRkRka050UWl4RlFVRlhMRXRCUlZoSUxFbEJRV0ZETEVWQlFXTXNRMEZETjBKSExGTkJRVlVzVVVGRFZrTXNTMEZCVFN4RFFVTktReXhIUVVGSkxGRkJTVklzU1VGQlNVTXNSVUZCTUVVc1QwRkJkRVF4UWl4VFFVRlRUU3hoUVVGaFNDeEZRVUZUTEcxQ1FVdDBReXhSUVVocVFtMUNMRVZCUVZkNlFpeHpRa0ZCYzBKM1FpeFBRVUZQVFN4RlFVRlhWQ3hGUVVGelFtUXNSVUZCYVVKRUxFVkJRVk5wUWl4RlFVRmhUU3hKUVVrNVIwb3NSVUZCVjBRc1JVRk5XSEpDTEZOQlFWTlhMR2RDUVVGblFsSXNSVUZCVXl4cFFrRkhia0lzVDBGQlltMUNMRWxCUTBWQkxFVkJRVk5OTEU5QlFVOURMRTlCUVZNc1JVRkRNMEkzUWl4VFFVRlRaMElzWVVGQllXSXNSVUZCVXl4UlFVRlRiVUlzUjBGRGJrTjBRaXhUUVVGVFZ5eG5Ra0ZCWjBKU0xFVkJRVk1zVjBGTmVrTXlRaXhwUWtGQmJVSXNVMEZCVXpWQ0xFVkJRVmRuUWl4RlFVRnpRbUVzUlVGQlR6VkNMRWRCUTNSRkxFbEJRMGsyUWl4RlFVRlRaQ3hGUVVSSWJFSXNVMEZCVTAwc1lVRkJZVWdzUlVGQlUwUXNTVUZGTVVJc1QwRkJXRGhDTEVkQlEwWm9ReXhUUVVGVFowSXNZVUZCWVdJc1JVRkJVMFFzUlVGQlZ6aENMRWxCU3pGRFF5eGhRVUZsTEZOQlFWTTVRaXhGUVVGVEswSXNSVUZCVFVNc1JVRkJZME1zUlVGQllXeENMRVZCUVhOQ2JVSXNSVUZCWVVNc1JVRkJaVU1zUlVGQlpVTXNSVUZCYTBKRExFZEJSWFpLTEVsQlJVRXNTVUZCU1VNc1JVRkhTaXhIUVVGdFFpeFRRVUZtVEN4RlFVTkdTeXhGUVVGbE1VTXNVMEZCVTAwc1lVRkJZVWdzUlVGQlV5eHBRa0ZET1VOSUxGTkJRVk5YTEdkQ1FVRm5RbElzUlVGQlV5eHhRa0ZETjBJc1EwRkJRU3hIUVVGdFFpeFpRVUZtYTBNc1JVRkhWQ3hMUVVGTkxHMUVRVUZ4UkVFc1JVRkdNMFJMTEVWQlFXVktMRVZCVVdwQ0wwTXNSVUZCUlN4dFFrRkJiMEpaTEVkQlFWTjNReXhUUVUwdlFpeEpRVXBCTEVsQlFVbERMRVZCUVdOeVJDeEZRVUZGTEd0Q1FVRnRRbGtzUjBGQlV6QkRMRmxCUVZrc2JVSkJSM2hFUXl4RlFVRlhMRU5CUVVNc1QwRkJVU3hOUVVGUExEQkNRVUV5UWl4alFVTnFSRU1zUlVGQlNTeEZRVUZIUVN4RlFVRkpSQ3hGUVVGVGFrSXNUMEZCVVd0Q0xFbEJRVXNzUTBGRmVFTXNTVUZCU1VNc1JVRkJUMnhDTEdsQ1FVRnBRbTFDTEZWQlFVdDBRaXhGUVVGWGJVSXNSVUZCVTBNc1IwRkJTVGRDTEVkQlEzcEVNMElzUlVGQlJTeEpRVUZOZFVRc1JVRkJVME1zUjBGQlN5eEpRVUZMTlVNc1IwRkJVeXRETEV0QlFVdEdMRWRCUnpORExFbEJRVWxITEVWQlFWZHVSQ3hUUVVGVFRTeGhRVUZoU0N4RlFVRlRMSE5DUVVNM1FpeFBRVUZpWjBRc1NVRkJiVUpCTEVWQlFWY3NTVUZEYkVNMVJDeEZRVUZGTEhWQ1FVRjNRbGtzUjBGQlV5dERMRXRCUVVzc1UwRkJVMjVDTEVWQlFVODFRaXhIUVVOc1JHZEVMRVZCUVZOMFFpeFBRVUZUTEVsQlFVZHpRaXhIUVVGelFpeExRVU12UTBFc1IwRkJjMEp1UkN4VFFVRlRUU3hoUVVGaFNDeEZRVUZUTEhOQ1FVTnlSRWdzVTBGQlUxY3NaMEpCUVdkQ1VpeEZRVUZUTEhkQ1FVZHdRMG9zVTBGQlUzRkVMSFZDUVVGMVFteENMRVZCUVUxUkxFVkJRV05UTEVWQlFWVXNRMEZCUldRc1dVRkJZVUVzU1VGRk4wVXNTVUZCU1dwRExFVkJRV3RDVEN4VFFVRlRjMFFzTUVKQlFUQkNTaXhWUVVGTGRFSXNSVUZCVjA4c1JVRkJUVU1zUlVGQlkwY3NSVUZCWlVrc1JVRkJZeXhKUVVOMlJ5eFRRVUZtVEN4SFFVRjNRbXBETEVWQlFXZENMRXRCUVUwc1NVRkZiRVJpTEVWQlFVVXNVVUZCVTFrc1IwRkJVeXRETEV0QlFVc3NVMEZCVTI1Q0xFVkJRVTgxUWl4SFFVTjJReXhKUVVGSmEwSXNSVUZCVVhKQ0xGTkJRVk56UkN4aFFVRmhia1FzUjBGRk9VSnZSQ3hGUVVGdFFuaEVMRk5CUVZOeFJDeDFRa0ZCZFVKSUxGVkJRVXQwUWl4RlFVRlhUeXhIUVVOdVJYTkNMRVZCUVRKQ2VrUXNVMEZCVTNORUxEQkNRVUV3UWtvc1ZVRkJTM1JDTEVWQlFWZFBMRVZCUVUxRExFVkJRV05ITEVkQlEyeEhhRUlzUlVGQlYzaENMSFZDUVVGMVFuVkNMRTlCUVU5TkxFVkJRVmMyUWl4RlFVRXdRa1FzUlVGQmEwSndRaXhGUVVGamFrSXNSVUZCYzBKdlFpeEZRVUZsU1N4SFFVVjJTaXhIUVVGSmNFSXNSMEZCV1VRc1JVRkRaQ3hIUVVGM1FpeExRVUZ3UWtNc1JVRkJVMDBzVDBGQlpTeERRVU14UWl4SlFVRkpOa0lzUlVGQlZXaENMRVZCUVdkQ2JrSXNSMEZET1VKMFFpeFRRVUZUWjBJc1lVRkJZV0lzUlVGQlV5eFpRVUZoTEhOQ1FVRjVRbk5FTEVWQlFWVXNUMEZGTDBWNlJDeFRRVUZUTUVRc1YwRkJWM1pFTEVWQlFWTXNVMEZITjBKSUxGTkJRVk15UkN4bFFVRmxjRVVzUlVGQlJWa3NUVUZMYUVOakxHRkJRV0ZrTEVWQlFWTmxMRVZCUVhOQ1pDeEZRVUZwUW05RExFZEJTVGRFTEVsQlJFRXNTVUZCU1c5Q0xFVkJRV1VzUTBGQlF5eHJRa0ZCYlVJc2JVSkJRVzlDTEdWQlFXZENMRkZCUTJ4RlF5eEZRVUZKTEVWQlFVZEJMRVZCUVVsRUxFVkJRV0V2UWl4UFFVRlJaME1zU1VGQlN5eERRVVUxUXl4SFFVUlhOMFFzVTBGQlUwMHNZVUZCWVVnc1JVRkJVM2xFTEVWQlFXRkRMRWxCUjNKRUxFMUJSRUZ1UlN4UlFVRlJiVUlzUzBGQlN5eHpRa0ZCZDBJclF5eEZRVUZoUXl4SFFVRkxMRzlEUVVGeFF6RkVMRWRCUTNSR0xITkNRVUYzUW5sRUxFVkJRV0ZETEVkQlFVc3NiME5CYjA5d1JDeFBRUzlPUVhSRkxFVkJRVVVzYVVKQlFXdENXU3hIUVVGVEswTXNTMEZCU3l4VFFVRlRia0lzUlVGQlR6VkNMRWRCUTJoRUxFbEJRVWt5UkN4RlFVRlRPVVFzVTBGQlUwMHNZVUZCWVVnc1JVRkJVeXhuUWtGRGVFTTBSQ3hGUVVGWEwwUXNVMEZCVTAwc1lVRkJZVWdzUlVGQlV5eHBRa0ZETVVNc1RVRkJUelJFTEVsQlFUaERRU3hGUVVGWExFbEJReTlEUVN4RlFVRktMRXRCUVdKQkxFVkJRVFJDTEcxQ1FVRnhRa1FzUlVGQlV5eExRVUZQUXl4RlFVTnlSQ3h0UWtGQmNVSkVMRVZCUTNKRE9VUXNVMEZCVTJkQ0xHRkJRV0ZpTEVWQlFWTXNaMEpCUVdsQ05FUXNSMEZEYUVRdlJDeFRRVUZUWjBJc1lVRkJZV0lzUlVGQlV5eGxRVUZuUWpKRUxFZEJReTlET1VRc1UwRkJVMWNzWjBKQlFXZENVaXhGUVVGVExHdENRVWR3UTFvc1JVRkJSU3hyUWtGQmJVSlpMRWRCUVZNclF5eExRVUZMTEZOQlFWTnVRaXhGUVVGUE5VSXNSMEZEYWtSakxHRkJRV0ZrTEVWQlFWTmxMRVZCUVhOQ1pDeEhRVUZwUWl4TFFVY3ZSR0lzUlVGQlJTeDFRa0ZCZDBKWkxFZEJRVk1yUXl4TFFVRkxMRk5CUVZOdVFpeEZRVUZQTlVJc1IwRkRkRVJYTEcxQ1FVRnRRbGdzUlVGQlV5eG5Ra0ZIT1VKYUxFVkJRVVVzYjBKQlFYRkNXU3hIUVVGVEswTXNTMEZCU3l4VFFVRlRia0lzUlVGQlR6VkNMRWRCUTI1RVJpeDVRa0ZCZVVJc2EwSkJRVzFDUlN4RlFVRlRReXhMUVVkMlJHSXNSVUZCUlN4eFFrRkJjMEpaTEVkQlFWTXJReXhMUVVGTExGTkJRVk51UWl4RlFVRlBOVUlzUjBGRGNFUXNTVUZCU1RaRUxFVkJRVmxETEVWQlFYRkNReXhGUVVGcFFrTXNSVUZQYkVSRExFVkJRMEZETEVWQlRFRkRMRVZCUVdWMFJTeFRRVUZUVFN4aFFVRmhTQ3hGUVVGVExHOUNRVTFzUkN4SFFVRkpiVVVzUlVGQllVTXNXVUZCV1N4TFFVRlBMRVZCUVVjc1EwRkRja01zU1VGQlNVTXNSVUZCVDBZc1JVRkJZVWNzVDBGQlR5eEZRVUZIU0N4RlFVRmhReXhaUVVGWkxFMUJRek5FU0N4RlFVRm5RbWhGTEVWQlFXZENiMFVzVVVGRmFFTktMRVZCUVdkQ2FFVXNSVUZCWjBKclJTeEhRVWxzUXl4SFFVWkJSQ3hGUVVGblFpeDFSRUZCZVVSRUxFVkJRV2RDTEd0SFFVRnZSMEVzUlVGQlowSXNOa05CUVN0RFFTeEZRVUZuUWl4SlFVVnVUeXhQUVVGeVEzQkZMRk5CUVZNd1JTeG5Ra0ZCWjBKMlJTeEhRVUZ0UWl4RFFVYzVRemhFTEVWQlFXVnFSU3hUUVVGVGMwUXNZVUZCWVc1RUxFZEJRM0pETEVsQlFVbDNSU3hGUVVGcFFuWkZMRVZCUVdkQ2EwVXNSVUZCWTB3c1IwRkJZeXhGUVVGTkxGZEJZWFpGTEVkQldrRkVMRVZCUVdFc1IwRkZVbWhGTEZOQlFWTk5MR0ZCUVdGSUxFVkJRVk1zVVVGRGJFTTJSQ3hIUVVGakxIRkNRVUYxUWswc1JVRkJZVTBzVVVGQlVTeEpRVUZMTEV0QlFVOHNXVUZITTBNc1NVRkJiRUpRTEVsQlExUk1MRWRCUVdOTExFVkJRV2RDTEUxQlIyaERUQ3hIUVVGakxHdENRVUZ2UWxjc1JVRkZUeXhOUVVGeVF6TkZMRk5CUVZNd1JTeG5Ra0ZCWjBKMlJTeEhRVUZyUWl4RFFVTTNReXhKUVVGSk1FVXNSVUZCWTNSR0xFVkJRVVVzYzBWQlFYTkZMRWRCUXpGR1V5eFRRVUZUWjBJc1lVRkJZVFpFTEVWQlFXRXNXVUZCWVdJc1IwRkRhRVFzU1VGQlNXTXNSVUZCWVRsRkxGTkJRVk56UkN4aFFVRmhMMFFzUlVGQlJTeGxRVUZsZDBZc1QwRkJUMFlzU1VGREwwUTNSU3hUUVVGVE1FUXNWMEZCVjNaRUxFVkJRVk15UlN4UlFVYzNRbGdzUjBGQlowTXNVVUZFYUVORUxFVkJRV3RDYkVVc1UwRkJVMDBzWVVGQllVZ3NSVUZCVXl4alFVTldLMFFzUlVGQmEwSXNTMEZCVHl4SlFVRk5SaXhGUVVOMFJXaEZMRk5CUVZOblFpeGhRVUZoWWl4RlFVRlRMRmxCUVdGblJTeEhRVU0xUTI1RkxGTkJRVk13UkN4WFFVRlhka1FzUlVGQlV5eEpRVVV2UWtnc1UwRkJVMWNzWjBKQlFXZENVaXhGUVVGVExIZENRVU0zUWl4RFFVTk1MRWxCUVVrMlJTeEZRVUZSYUVZc1UwRkJVMDBzWVVGQllVZ3NSVUZCVXl4VFFVVXpReXhIUVVSakxFdEJRVlkyUlN4SlFVRmpRU3hGUVVGUkxFMUJRMW9zVDBGQlZrRXNSVUZGUml4TlFVUkJkRVlzVVVGQlVYVkdMRTFCUVUwc2FVVkJRV3RGT1VVc1IwRkRNVVVzYVVWQlJWSXNTVUZCU1N0RkxFVkJRVk5zUml4VFFVRlRUU3hoUVVGaFNDeEZRVUZUTEZWQlF6ZENMRXRCUVZnclJTeEpRVUZsUVN4RlFVRlRMRTFCUlRWQ0xFbEJRVWxETEVWQlFWRnVSaXhUUVVGVFRTeGhRVUZoU0N4RlFVRlRMRk5CUzNaRGFVWXNSMEZJU214Q0xFVkJRV3RDYkVVc1UwRkJVMDBzWVVGQllVZ3NSVUZCVXl4bFFVZGtLMFFzUlVGQlowSnRRaXhOUVVGTkxEUkRRVU55UkVRc1NVRkJWMFlzUlVGQlUwVXNSVUZCVlN4SlFVTnNReXhKUVVGSlJTeEZRVUZYY0VJc1IwRkJiVUpCTEVWQlFXZENiVUlzVFVGQlRTd3lRMEZEY0VSRExFbEJRVlZPTEVWQlFWRk5MRVZCUVZNc1NVRk5MMElzU1VGUFNVTXNSVUZSUVVNc1JVRm1RVU1zUlVGQlVTeEpRVVphZUVJc1JVRkJaV3BGTEZOQlFWTk5MR0ZCUVdGSUxFVkJRVk1zTkVKQlNUVkRjMFlzUlVGQlVYcEdMRk5CUVZOTkxHRkJRV0ZJTEVWQlFWTXNUMEZGZGtNNFJDeEZRVUZsYWtVc1UwRkJVMDBzWVVGQllVZ3NSVUZCVXl4UFFVazFRelpGTEVkQlFWTkZMRVZCUTFoTExFVkJRVTlRTEVWQlFWRXNVVUZCVlVVc1JVRkRaa0VzUlVGRlFVWXNTVUZEVms4c1JVRkJUeXhQUVVGVFRDeEZRVUZUTEU5QlJucENTeXhGUVVGUExFOUJRVk5RTEVWQlFWRXNUVUZMTVVJc1NVRkJTVlVzUlVGQlYxSXNSMEZCVld4R0xGTkJRVk5OTEdGQlFXRklMRVZCUVZNc09FSkJRM0JFZDBZc1JVRkJWVmdzUjBGQlUyaEdMRk5CUVZOTkxHRkJRV0ZJTEVWQlFWTXNOa0pCV1hSRUxFZEJWa0ZJTEZOQlFWTlhMR2RDUVVGblFsSXNSVUZCVXl4UFFVTnNRMGdzVTBGQlUxY3NaMEpCUVdkQ1VpeEZRVUZUTEc5Q1FVTnNRMGdzVTBGQlUxY3NaMEpCUVdkQ1VpeEZRVUZUTERoQ1FVTnNRMGdzVTBGQlUxY3NaMEpCUVdkQ1VpeEZRVUZUTERaQ1FVTnNRMGdzVTBGQlUxY3NaMEpCUVdkQ1VpeEZRVUZUTERKQ1FVVTVRamhFTEVsQlEwWjFRaXhGUVVGcFFpeFpRVUZqUnl4RlFVRlZMR0ZCUVdWRUxFVkJRVmNzVjBGQllVZ3NSVUZCVHl4TlFVZHdSa2tzU1VGQldVUXNSVUZIWml4TlFVUkJhRWNzVVVGQlVYVkdMRTFCUVUwc2QwcEJRWGxLT1VVc1IwRkRha3NzSzBwQlIxSXNTVUZCU1hsR0xFVkJRV1Y0Uml4RlFVRm5RbXRGTEVWQlFXTnRRaXhIUVVGUExFVkJRVThzVjBGRkwwUjBRaXhIUVVGblF5eFBRVUZ3UWtRc1JVRkJNa0pCTEVWQlFXdENMRXRCUVU4c1MwRkVhRVZHTEVWQlFXRXNkMEpCUVRCQ1owSXNSVUZCVVN4aFFVRmxSU3hGUVVGVExGVkJRVmxWTEVWQlFXVXNhMEpCUVc5Q1NpeEZRVUZwUWl4TlFVVjJTWGhHTEZOQlFWTm5RaXhoUVVGaFlpeEZRVUZUTEZsQlFXRm5SU3hIUVVVMVF5eEpRVUZKTUVJc1JVRkJWM0JFTEVWQlFXZENkRU1zUjBGRk0wSXlSaXhGUVVGblFpeFpRVUZqWkN4RlFVTnlRaXhSUVVGVVJ5eEZRVUZwUWxjc1IwRkJhVUlzYTBKQlEzQkNMRk5CUVZSWUxFVkJRV3RDVnl4SFFVRnBRaXh0UWtGRE1VSXNWVUZCVkZnc1NVRkJLME1zYlVKQlFXcENla1lzVVVGQlVYRkhMRTFCUVhGQ2NrY3NVVUZCVVhGSExFMUJRVTBzYlVkQlEyaEZMRTlCUVZSYUxFVkJRV2RDVnl4SFFVRnBRaXg1UWtGRGVFSXNWVUZCVkZnc1JVRkJiVUpYTEVkQlFXbENMRFJDUVVNelFpeFZRVUZVV0N4SlFVRnRRbGNzUjBGQmFVSXNPRUpCUXpkRFFTeEhRVUZwUWl4SlFVVnFRblpITEVWQlFVVlpMRWRCUVZOTkxFOUJRVThzYVVSQlFXZEVNa1FzUlVGQlowSXNhVUpCUVc5Q2VVSXNSVUZCVnl3d1EwRkJLME5FTEVWQlFXVXNZVUZCWlZvc1JVRkJVU3hqUVVGblFrVXNSVUZCVXl4alFVRXdRaXhQUVVGV1F5eFBRVUZwUW5oRUxFVkJRVmtzU1VGQlQzZEVMRVZCUVZFc1MwRkJVU3haUVVGalNTeEZRVUZQTEcxQ1FYWkVjRlJUTEVWQmRVUTJWU3h6UWtGQmQwSlNMRVZCUVdsQ0xHbENRVUZ0UWswc1JVRkJaMElzWVVGRE4xcDJSeXhGUVVGRldTeEhRVUZUVHl4TlFVRk5MSGxDUVUxeVFtNUNMRVZCUVVVc1UwRkJWVmtzUjBGQlV5dERMRXRCUVVzc1UwRkJVMjVDTEVWQlFVODFRaXhIUVVONFF5eEpRVUZKT0VZc1JVRkJXV3BITEZOQlFWTk5MR0ZCUVdGSUxFVkJRVk1zVVVGRE0wTTJSQ3hGUVVGaExHbENRVUZ2UW5CRkxHVkJRV1Z6Unl4WFFVRlhSQ3hIUVVGaExFbEJRM2hGTDBJc1JVRkJhMEpzUlN4VFFVRlRUU3hoUVVGaFNDeEZRVUZUTEdGQlEycEVaMFVzUjBGQlowTXNUMEZCY0VKRUxFVkJRVEpDUVN4RlFVRnJRaXhMUVVGUExFbEJRVTFHTEVWQlF6RkZhRVVzVTBGQlUyZENMR0ZCUVdGaUxFVkJRVk1zV1VGQllXZEZMRXRCUnpsRE5VVXNSVUZCUlN4blFrRkJhVUpaTEVkQlFWTXJReXhMUVVGTExGTkJRVk51UWl4RlFVRlBOVUlzUjBGREwwTXNTVUZCU1dkSExFVkJRV1YyUkN4RlFVRlpZaXhIUVVVelFuRkZMRVZCUVZsdVJTeGhRVUZoYTBVc1JVRkJZMnBGTEVWQlFVMURMRVZCUVdORExFVkJRV0ZzUWl4RlFVRnpRaXhSUVVGVGQwSXNSVUZCWTBnc1IwRkJaU3hGUVVGTlJTeEhRVVV4U1d0RExFVkJRV2xDTlVVc1UwRkJVM05FTERCQ1FVRXdRbTVDTEVWQlFVMURMRVZCUVdOSExFVkJRV1ZKTEVWQlFXTXNSMEZCU1RCRUxFZEJSemRITjBjc1JVRkJSVmtzUjBGQlUwMHNUMEZCVHl3MlFrRkJORUppTEdWQlFXVnpSeXhYUVVGWGRrSXNSMEZCYTBJc1owTkJRekZHY0VZc1JVRkJSVmtzUjBGQlUwOHNUVUZCVFN4elFrRkRha0p1UWl4RlFVRkZXU3hIUVVGVGQwTXNWMEZOWW5CRUxFVkJRVVZCTEVWQlFVVXNhVUpCUVd0Q1dTeEhRVUZUYTBjc1RVRkJUVU1zVlVGQlYyNUhMRWRCUVZNclF5eExRVUZMTEZOQlFWTnVRaXhGUVVGUE5VSXNSMEZETlVVc1NVRkJTVVVzUlVGQlQwd3NVMEZCVTAwc1lVRkJZVWdzUlVGQlV5eG5Ra0ZETVVNc1VVRkJiMElzU1VGQlZFVXNSMEZCYVVNc1MwRkJWRUVzUjBGQmQwSXNVMEZCVkVFc1JVRkRhRVFzUzBGQlRTeHBSMEZIVWl4SlFXbENTV3RITEVWQlFXVkRMRVZCYWtKbVF5eEZRVUZqTjBjc1pVRkJaVmtzYVVKQlFXbENTQ3hGUVVGTlJDeEhRV1Z3UkN0RUxFVkJRVmR1UlN4VFFVRlRUU3hoUVVGaFNDeEZRVUZUTEdGQlNUbERMRWRCUVdsQ0xFdEJRV0puUlN4SFFVRm5ReXhQUVVGaVFTeEhRVUZ4UWtFc1JVRkJVMnRDTEUxQlFVMHNNRUpCUVRKQ0xFTkJSWEJHTEVsQlFVbHhRaXhGUVVGdFFpeGpRVUZoZGtNc1JVRkJWeXhWUVVGVGJrVXNVMEZCVTNORUxHRkJRV0Z1UkN4SFFVRlhMSEZDUVVONlJtOUhMRVZCUVdkQ09VUXNSVUZCWjBKcFJTeEhRVU5vUXpGSExGTkJRVk5YTEdkQ1FVRm5RbElzUlVGQlV5eG5Ra0ZEYkVOeFJ5eEZRVUZuUWk5RUxFVkJRV2RDZEVNc1IwRkRhRU5JTEZOQlFWTXlSeXhaUVVGWmVFY3NSVUZCVXl3eVIwRkJPRWR6Unl4RlFVRmpMRTlCUVZWRUxFVkJRV2RDTEZGQlFWbEVMRVZCUVdkQ0xHMURRVWRvVGtFc1JVRkJaMEk1UkN4RlFVRm5RbnBETEZOQlFWTnpSQ3hoUVVGaGJrUXNTVUZEZEVSSUxGTkJRVk5YTEdkQ1FVRm5RbElzUlVGQlV5eG5Ra0ZEYkVOSUxGTkJRVk13UkN4WFFVRlhka1FzUlVGQlV5eDVRa0ZCZVVKdlJ5eEZRVUZuUWl3NFFrRkRkRVZETEVWQlFXZENMMFFzUlVGQlowSjBReXhIUVVOb1EwZ3NVMEZCVXpKSExGbEJRVmw0Unl4RlFVRlRMRFpHUVVGblIzTkhMRVZCUVdNc1QwRkJWVVFzUlVGQlowSXNVVUZCV1VRc1JVRkJaMElzWjBOQlMzUk5PVVFzUlVGQlowSjBReXhGUVVGVGRVTXNSVUZCWXl4UlFVVjJRMDRzUlVGQldVVXNSVUZCWlVrc1JVRkJZMHdzUlVGQllVVXNSMEZGTDBOSExFVkJSVXdzVFVGQlR6bENMRWRCUlZBc1RVRkVRV3hDTEZGQlFWRjFSaXhOUVVGTkxIVkRRVUYzUTNKRkxFVkJRVWRVTEVkQlEyNUVVeXhKUVV0V0xGTkJRVk5uUnl4dlFrRkJiMEpETEVkQlF6TkNMRTlCUVU5QkxFVkJRVXRxUXl4UlFVRlJMREJFUVVFeVJDeFRRVUZUVXl4RlFVRlBlVUlzUlVGQlYwTXNSMEZEZUVjc1NVRkJTVU1zUlVGQlN5d3dRa0ZEVkVFc1IwRkJUVVFzUlVGQlMyNURMRkZCUVZFc2FVSkJRV3RDTERoQ1FVTTNRa0VzVVVGQlVTeHZRa0ZCYjBJc2RVUkJRelZDUVN4UlFVRlJMRTlCUVU4c01FSkJRM1pDYjBNc1IwRkJUU3gzUWtGRFRpeEpRVUZKUXl4RlFVRlRMREJDUVVFd1FrZ3NSVUZCVlN3eVFrRkxha1FzVDBGS1FVY3NSMEZCVlRGSUxFVkJRVVVzVTBGQlUzZEdMRTlCUVU5NFJpeEZRVUZGZVVnc1NVRkJTMGdzVDBGRGFFTnFReXhSUVVGUkxIRkNRVUZ6UWl4SlFVTTVRa0VzVVVGQlVTeHRRa0ZCYjBJc1NVRkRMMEp4UXl4SFFVRlZMR3RDUVUxa0xFbEJRVWxETEd0Q1FVRnZRaXhUUVVGVGVFVXNSVUZCWTIxRkxFVkJRVTB6Uml4RlFVRnpRblZDTEVkQlEzcEZMRWxCUVVsUUxFVkJRVThzUjBGRFVHbEdMRVZCUVdWUUxHOUNRVUZ2UWtNc1JVRkJTMnBETEZGQlFWRXNhVVJCUVd0RUxGTkJRVk5UTEVWQlFVOHJRaXhGUVVGSlF5eEZRVUZKUXl4SFFVTTFTQ3hQUVVGUFJpeEZRVUZMTEZkQlFXRkRMRVZCUVV0RExFdEJTVFZDUXl4RlFVRm5ReXh0UWtGQlptaEpMRVZCUVVWcFNTeFZRVUV3UW1wSkxFVkJRVVZCTEVWQlFVVnBTU3hWUVVGVlRDeEhRVUZqTEVsQlFWVTFTQ3hGUVVGRk5FZ3NSMEZEY2tab1NDeEZRVUZWYjBnc1JVRkJVU3hIUVVWc1FrVXNSVUZCVXl4SFFVTlVReXhGUVVGbExGTkJRVk5ETEVWQlFWVjJRaXhGUVVGWEwwUXNSVUZCWVVVc1IwRkROVVJyUml4RlFVRlBSeXhMUVVGTExFTkJRMVpETEV0QlFVMUdMRVZCUTA1SExFMUJRVTh4UWl4RlFVTlFNa0lzVVVGQlV6RkdMRVZCUTFReVJpeFZRVUZYZWtZc1MwRkxXRW9zUlVGQlpTeFRRVUZUT0VZc1JVRkJUVU1zUlVGQlMwTXNSMEZIY2tNc1VVRkdPRUlzU1VGQmJrSnFSeXhGUVVGaExGTkJRVzFDUVN4RlFVRmhMRTlCUVVrc1UwRkRlRUlzU1VGQmVrSkJMRVZCUVdFc1QwRkJSU3RHTEV0QlFYVkNMMFlzUlVGQllTeFBRVUZGSzBZc1IwRkJVU3hUUVVNdlFpeEpRVUU1UWk5R0xFVkJRV0VzVDBGQlJTdEdMRWRCUVUxRExFbEJRWE5FTEU5QlFUbENhRWNzUlVGQllTeFBRVUZGSzBZc1IwRkJUVU1zUjBGQlpXaEhMRVZCUVdFc1QwRkJSU3RHTEVkQlFVMURMRWRCUVU5RExFOUJRMjVJTEVkQlFVa3NUVUZCVDBFc1JVRkJjVU1zUTBGRGJrUXNTVUZCU1VNc1JVRkJWV3hITEVWQlFXRXNUMEZCUlN0R0xFZEJRVTFETEVkQlF5OUNSU3hIUVVGWFJDeEhRVUZMZWtrc1VVRkJVVEpKTEVsQlFVa3NORU5CUVRoRFNDeEZRVUZOTEdGQlFXVkVMRVZCUVU4c1UwRkJWMGNzUlVGQlZTeFJRVUZWUkN4RlFVRk5MRTlCU1M5SlJ5eEZRVUZoTDBrc1JVRkJSU3h6UWtGQmRVSm5TU3hIUVVOMFEyZENMRVZCUVdkQ0xFZEJRM0JDUkN4RlFVRlhjRVlzUzBGQlN5eFRRVUZUYmtJc1JVRkJUelZDTEVkQlF6bENMRWxCUVVsdlF5eEZRVUZuUW5aRExGTkJRVk5OTEdGQlFXRklMRVZCUVZNc2NVSkJRWFZDTEZOQlJURkZTQ3hUUVVGVFZ5eG5Ra0ZCWjBKU0xFVkJRVk1zY1VKQlEyeERTQ3hUUVVGVFowSXNZVUZCWVdJc1JVRkJVeXhaUVVGaExGVkJRVmx2UXl4SFFVVjRSQ3hKUVVGSmFVY3NSVUZCYTBKcVNpeEZRVUZGTEc5Q1FVRnhRbGtzUjBGRE4wTklMRk5CUVZNeVJDeGxRVUZsTmtVc1IwRkJhVUlzUjBGRmVrTkVMRVZCUVdOb1J5eEhRVUZwUW1sSExFbEJTMnBEZWtrc1UwRkJVM0ZFTEhWQ1FVRjFRbXhDTEVWQlFVMHNUVUZGZEVOdVF5eFRRVUZUY1VRc2RVSkJRWFZDYkVJc1JVRkJUU3hoUVVWMFEyNURMRk5CUVZOeFJDeDFRa0ZCZFVKc1FpeEZRVUZOTEZOQlFWVXNXVUZIYUVSdVF5eFRRVUZUY1VRc2RVSkJRWFZDYkVJc1JVRkJUU3hSUVVWMFEwUXNZVUZCWVRsQ0xFVkJRVk1yUWl4RlFVRk5ReXhGUVVGamRVWXNSVUZCWTNoSExFVkJRWE5DTEZkQlFWbDNRaXhQUVVGalppeEhRVUZYTEVWQlFVOWpMRWRCUlRGSUxFbEJRVWxuUnl4RlFVRmxMRk5CUVZOc1J5eEZRVUZsVWl4RlFVRlBOVUlzUjBGRGFFUTRRaXhoUVVGaE9VSXNSVUZCVXl0Q0xFVkJRVTFETEVWQlFXTjFSaXhGUVVGamVFY3NSVUZCYzBJc1VVRkJVM2RDTEVWQlFXTklMRWRCUVdVc1JVRkJUVVVzU1VGSE5VZ3NTVUZCU3l4SlFVRkphVWNzUzBGQlVVZ3NSVUZEWml4SFFVRkpRU3hGUVVGalNTeGxRVUZsUkN4SFFVRlBMRU5CUTNSRExFbEJRVWxHTEVWQlFXdENSQ3hGUVVGalJ5eEhRVU5vUTI1SExFVkJRV2RDYlVjc1JVRkZjRUl6U1N4VFFVRlRjMFFzTUVKQlFUQkNia0lzUlVGQlRVTXNSVUZCWTA4c1JVRkJZMEVzUlVGQll5eEhRVUZKU0N4RlFVRm5RaXhWUVVGWExFMUJSV3hJYVVjc1JVRkJaMEowUml4TFFVRkxkVVlzUlVGQllYaEdMRlZCUVV0MFFpeEZRVUZYV1N4SlFVZDBSQ3hKUVVGSmNVY3NSVUZCWXl4RFFVTm9Ra01zVFVGQlR6TkhMRVZCUTFCUkxHRkJRV05CTEVWQlEyUnZSeXhSUVVGVGNrSXNSMEZQV0N4WlFVb3lReXhKUVVGb1EzWkdMRVZCUVV0UkxFZEJRV054Unl4WFFVTTFRa2dzUlVGQldVa3NVVUZCVlRsSExFVkJRVXRSTEVkQlFXTnhSeXhWUVVkd1EwZ3NSMEZKVkVzc1QwRkJUME1zVVVGQlZXaERJaXdpWm1sc1pTSTZJaTl3Y21sMllYUmxMM1J0Y0M5bWIyOHVSMDlGTDNOeVl5OXFjeTlqYjI1MlpYSjBaWEl2Y0dGeWMyVnlMbXB6SW4wPSIsIlwidXNlIHN0cmljdFwiO3ZhciBjc3NQYXJzZT1yZXF1aXJlKFwibWVuc2NoL2xpYi9wYXJzZXIuanNcIiksY29uc29sZT1yZXF1aXJlKFwiY29uc29sZS1icm93c2VyaWZ5XCIpLGNvbnZlcnRlclV0aWxzPXJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLGVsYWJvcmF0ZURlY2xhcmF0aW9ucz1yZXF1aXJlKFwiLi9kZWNsYXJhdGlvbnMuanNcIiksX3JlbW92ZU9wdGlvbmFsUXVvdGVzPWZ1bmN0aW9uKGUpe3JldHVyblwiJ1wiIT1lWzBdJiYnXCInIT1lWzBdfHxlW2UubGVuZ3RoLTFdIT1lWzBdP2U6ZS5zdWJzdHIoMSxlLmxlbmd0aC0yKS5yZXBsYWNlKC9cXFxcKFtcXHNcXFNdKS9nbSxcIiQxXCIpfSxfcHJvY2Vzc1N0eWxlU2hlZXRSdWxlc19wcm9jZXNzQmxvY2tEZWY9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG8scyxyLGw9MDtsPHQubGVuZ3RoO2wrKylpZihcInJ1bGVcIj09dFtsXS50eXBlKXtmb3IodmFyIG49dFtsXS5zZWxlY3RvcnMsaT0hMSxhPSExLGM9MDtjPG4ubGVuZ3RoO2MrKyluW2NdLm1hdGNoKC86cHJldmlldyQvKT9hPSEwOmk9ITA7aWYoYSYmaSl0aHJvdyBjb25zb2xlLmxvZyhcImNhbm5vdCBtaXggc2VsZWN0b3JzIHR5cGUgKDpwcmV2aWV3IGFuZCBkZWNsYXJhdGlvbnMpIGluIEBzdXBwb3J0cyAta28tYmxvY2tkZWZzIFwiLG4pLFwiQ2Fubm90IG1peCBzZWxlY3RvcnMgdHlwZSAoOnByZXZpZXcgYW5kIGRlY2xhcmF0aW9ucykgaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnNcIjtpZighYSYmIWkpdGhyb3cgY29uc29sZS5sb2coXCJjYW5ub3QgZmluZCBrbm93biBzZWxlY3RvcnMgaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnMgXCIsbiksXCJDYW5ub3QgZmluZCBrbm93biBzZWxlY3RvcnMgaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnNcIjtpZihpKXtvPVwiXCIscz17fSxyPXRbbF0uZGVjbGFyYXRpb25zO2Zvcih2YXIgcCx1PTA7dTxyLmxlbmd0aDt1KyspXCJwcm9wZXJ0eVwiPT1yW3VdLnR5cGUmJihwPV9yZW1vdmVPcHRpb25hbFF1b3RlcyhyW3VdLnZhbHVlKSxcImxhYmVsXCI9PXJbdV0ubmFtZT9zLm5hbWU9cDpcImNvbnRleHRcIj09clt1XS5uYW1lP3MuY29udGV4dE5hbWU9cDpcInByb3BlcnRpZXNcIj09clt1XS5uYW1lP289cDpcInRoZW1lXCI9PXJbdV0ubmFtZT9zLmdsb2JhbFN0eWxlPVwiX3RoZW1lXy5cIitwOlwidGhlbWVPdmVycmlkZVwiPT1yW3VdLm5hbWU/cy50aGVtZU92ZXJyaWRlPVwidHJ1ZVwiPT1TdHJpbmcocCkudG9Mb3dlckNhc2UoKTpzW3JbdV0ubmFtZV09cCk7Zm9yKHZhciBkPTA7ZDxuLmxlbmd0aDtkKyspZShuW2RdLG8scyl9aWYoYSlmb3IodmFyIGY9MDtmPG4ubGVuZ3RoO2YrKyl7ZShuW2ZdLnN1YnN0cigwLG5bZl0uaW5kZXhPZihcIjpcIikpLHZvaWQgMCx7cHJldmlld0JpbmRpbmdzOnRbbF0uZGVjbGFyYXRpb25zfSl9fX0scHJvY2Vzc1N0eWxlc2hlZXRSdWxlcz1mdW5jdGlvbihlLHQsbyxzLHIsbCxuLGkpe3ZhciBhLGM9ZSxwPW51bGw7aWYodm9pZCAwPT09dCl7dmFyIHU9Y3NzUGFyc2UoZSx7Y29tbWVudHM6ITAscG9zaXRpb246ITB9KTtpZihcInN0eWxlc2hlZXRcIiE9dS50eXBlfHx2b2lkIDA9PT11LnN0eWxlc2hlZXQpdGhyb3cgY29uc29sZS5sb2coXCJ1bmFibGUgdG8gcHJvY2VzcyBzdHlsZVNoZWV0XCIsdSksXCJVbmFibGUgdG8gcGFyc2Ugc3R5bGVzaGVldFwiO3Q9dS5zdHlsZXNoZWV0LnJ1bGVzfWZvcih2YXIgZD10Lmxlbmd0aC0xO2Q+PTA7ZC0tKXtpZihcInN1cHBvcnRzXCI9PXRbZF0udHlwZSYmXCIta28tYmxvY2tkZWZzXCI9PXRbZF0ubmFtZSlfcHJvY2Vzc1N0eWxlU2hlZXRSdWxlc19wcm9jZXNzQmxvY2tEZWYocyx0W2RdLnJ1bGVzKSxjPWNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKGMsdFtkXS5wb3NpdGlvbi5zdGFydCxwLDAsMCwwLFwiXCIpO2Vsc2UgaWYoXCJtZWRpYVwiPT10W2RdLnR5cGV8fFwic3VwcG9ydHNcIj09dFtkXS50eXBlKWM9cHJvY2Vzc1N0eWxlc2hlZXRSdWxlcyhjLHRbZF0ucnVsZXMsbyxzLHIsbCxuLGkpO2Vsc2UgaWYoXCJjb21tZW50XCI9PXRbZF0udHlwZSk7ZWxzZSBpZihcInJ1bGVcIj09dFtkXS50eXBlKXtmb3IodmFyIGY9dFtkXS5zZWxlY3RvcnMsaD1cIlwiLG09bnVsbCx2PTA7djxmLmxlbmd0aDt2Kyspe2gubGVuZ3RoPjAmJihoKz1cIiwgXCIpO3ZhciB5PWZbdl0ubWF0Y2goL1xcW2RhdGEta28tYmxvY2s9KFteIF0qKVxcXS8pO2lmKG51bGwhPT15KXtpZihudWxsIT09bSYmbSE9eVsxXSl0aHJvd1wiRm91bmQgbXVsdGlwbGUgYmxvY2stbWF0Y2ggYXR0cmlidXRlIHNlbGVjdG9yczogY2Fubm90IHRyYW5zbGF0ZSBpdCAoXCIrbStcIiB2cyBcIit5WzFdK1wiKVwiO209eVsxXX1oKz1cIlxceDNjIS0tIGtvIHRleHQ6IHRlbXBsYXRlTW9kZSA9PSd3eXNpd3lnJyA/ICcjbWFpbi13eXNpd3lnLWFyZWEgJyA6ICcnIC0tXFx4M2VcXHgzYyEtLSAva28gLS1cXHgzZVwiK2Zbdl19aWYobSl7dmFyIGs9XCJcXHgzYyEtLSBrbyBmb3JlYWNoOiAkcm9vdC5maW5kT2JqZWN0c09mVHlwZSgkZGF0YSwgJ1wiK20rXCInKSAtLVxceDNlXCIseD1wLGc9XCIgXCI7dFtkXS5kZWNsYXJhdGlvbnMubGVuZ3RoPjAmJih0W2RdLmRlY2xhcmF0aW9uc1swXS5wb3NpdGlvbi5zdGFydC5saW5lIT10W2RdLnBvc2l0aW9uLmVuZC5saW5lJiYoZz1cIlxcblwiK25ldyBBcnJheSh0W2RdLnBvc2l0aW9uLnN0YXJ0LmNvbCkuam9pbihcIiBcIikpLHg9dFtkXS5kZWNsYXJhdGlvbnNbdFtkXS5kZWNsYXJhdGlvbnMubGVuZ3RoLTFdLnBvc2l0aW9uLmVuZCksbnVsbD09PXg/Yys9ZytcIlxceDNjIS0tIC9rbyAtLVxceDNlXCI6Yz14PT1wP2NvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKGMseCxwLDAsMCwwLGcrXCJcXHgzYyEtLSAva28gLS1cXHgzZVwiKTpjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShjLHgscCwwLDAsMCxnK1wifVwiK2crXCJcXHgzYyEtLSAva28gLS1cXHgzZVwiKSxoPWsrZytoLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxbZGF0YS1rby1ibG9jaz1cIittK1wiXFxcXF1cIixcImdcIiksXCJcXHgzYyEtLSBrbyB0ZXh0OiAnIycraWQoKSAtLVxceDNlXCIrbStcIlxceDNjIS0tIC9rbyAtLVxceDNlXCIpLHMobSxcIlwiLHtjb250ZXh0TmFtZTpcImJsb2NrXCJ9KX12YXIgYj1tfHxpO2E9by5iaW5kKHRoaXMsYixcIlwiKTt2YXIgdz1lbGFib3JhdGVEZWNsYXJhdGlvbnMoYyx0W2RdLmRlY2xhcmF0aW9ucyxsLGEpO251bGwhPT13JiYoYz13KSxjPWNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKGMsdFtkXS5wb3NpdGlvbi5zdGFydCx0W2RdLnBvc2l0aW9uLmVuZCwwLDAsMCxoKX1lbHNlIGNvbnNvbGUubG9nKFwiVW5rbm93biBydWxlIHR5cGVcIix0W2RdLnR5cGUsXCJ3aGlsZSBwYXJzaW5nIDxzdHlsZT4gcnVsZXNcIik7cD10W2RdLnBvc2l0aW9uLnN0YXJ0fXJldHVybiBjfTttb2R1bGUuZXhwb3J0cz1wcm9jZXNzU3R5bGVzaGVldFJ1bGVzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OMGVXeGxjMmhsWlhRdWFuTWlYU3dpYm1GdFpYTWlPbHNpWTNOelVHRnljMlVpTENKeVpYRjFhWEpsSWl3aVkyOXVjMjlzWlNJc0ltTnZiblpsY25SbGNsVjBhV3h6SWl3aVpXeGhZbTl5WVhSbFJHVmpiR0Z5WVhScGIyNXpJaXdpWDNKbGJXOTJaVTl3ZEdsdmJtRnNVWFZ2ZEdWeklpd2ljM1J5SWl3aWJHVnVaM1JvSWl3aWMzVmljM1J5SWl3aWNtVndiR0ZqWlNJc0lsOXdjbTlqWlhOelUzUjViR1ZUYUdWbGRGSjFiR1Z6WDNCeWIyTmxjM05DYkc5amEwUmxaaUlzSW1Kc2IyTnJSR1ZtYzFWd1pHRjBaWElpTENKeWRXeGxjeUlzSW5CeWIzQmxjblJwWlhNaUxDSnVZVzFsWkZCeWIzQnpJaXdpWkdWamJITWlMQ0pwSWl3aWRIbHdaU0lzSW5ObGJITWlMQ0p6Wld4bFkzUnZjbk1pTENKb1lYTkVaV05zWVhKaGRHbHZibk1pTENKb1lYTlFjbVYyYVdWM2N5SXNJbW9pTENKdFlYUmphQ0lzSW14dlp5SXNJbVJsWTJ4aGNtRjBhVzl1Y3lJc0luWmhiQ0lzSW1zaUxDSjJZV3gxWlNJc0ltNWhiV1VpTENKamIyNTBaWGgwVG1GdFpTSXNJbWRzYjJKaGJGTjBlV3hsSWl3aWRHaGxiV1ZQZG1WeWNtbGtaU0lzSWxOMGNtbHVaeUlzSW5SdlRHOTNaWEpEWVhObElpd2liQ0lzSW0waUxDSnBibVJsZUU5bUlpd2lkVzVrWldacGJtVmtJaXdpY0hKbGRtbGxkMEpwYm1ScGJtZHpJaXdpY0hKdlkyVnpjMU4wZVd4bGMyaGxaWFJTZFd4bGN5SXNJbk4wZVd4bElpd2liRzlqWVd4WGFYUm9RbWx1WkdsdVoxQnliM1pwWkdWeUlpd2lkR2hsYldWVmNHUmhkR1Z5SWl3aWRHVnRjR3hoZEdWVmNteERiMjUyWlhKMFpYSWlMQ0p5YjI5MFRXOWtaV3hPWVcxbElpd2lkR1Z0Y0d4aGRHVk9ZVzFsSWl3aVltbHVaR2x1WjFCeWIzWnBaR1Z5SWl3aWJtVjNVM1I1YkdVaUxDSnNZWE4wVTNSaGNuUWlMQ0p6ZEhsc1pWTm9aV1YwSWl3aVkyOXRiV1Z1ZEhNaUxDSndiM05wZEdsdmJpSXNJbk4wZVd4bGMyaGxaWFFpTENKeVpXMXZkbVZUZEhsc1pTSXNJbk4wWVhKMElpd2libVYzVTJWc0lpd2labTkxYm1SQ2JHOWphMDFoZEdOb0lpd2liRzl2Y0ZCeVpXWnBlQ0lzSW1WdVpDSXNJbk53WVdOcGJtY2lMQ0pzYVc1bElpd2lRWEp5WVhraUxDSmpiMndpTENKcWIybHVJaXdpVW1WblJYaHdJaXdpYkc5allXeENiRzlqYTA1aGJXVWlMQ0ppYVc1a0lpd2lkR2hwY3lJc0ltVnNZV0p2Y21GMFpXUlRkSGxzWlNJc0ltMXZaSFZzWlNJc0ltVjRjRzl5ZEhNaVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxHRkJUMEVzU1VGQlNVRXNVMEZCVjBNc1VVRkJVU3gzUWtGRGJrSkRMRkZCUVZWRUxGRkJRVkVzYzBKQlEyeENSU3hsUVVGcFFrWXNVVUZCVVN4alFVTjZRa2NzYzBKQlFYZENTQ3hSUVVGUkxIRkNRWGRDYUVOSkxITkNRVUYzUWl4VFFVRlRReXhIUVVOdVF5eE5RVUZsTEV0QlFWWkJMRVZCUVVrc1NVRkJkVUlzUzBGQlZrRXNSVUZCU1N4SlFVRmpRU3hGUVVGSlFTeEZRVUZKUXl4UFFVRlBMRWxCUVUxRUxFVkJRVWtzUjBGTE1VUkJMRVZCU0V0QkxFVkJRVWxGTEU5QlFVOHNSVUZCUjBZc1JVRkJTVU1zVDBGQlR5eEhRVUZIUlN4UlFVRlJMR1ZCUVdkQ0xFOUJUVGxFUXl4M1EwRkJNRU1zVTBGQlUwTXNSVUZCYTBKRExFZEJSM1pGTEVsQlJrRXNTVUZCU1VNc1JVRkJXVU1zUlVGQldVTXNSVUZGYmtKRExFVkJRVWtzUlVGQlIwRXNSVUZCU1Vvc1JVRkJUVXdzVDBGQlVWTXNTVUZEYUVNc1IwRkJjVUlzVVVGQmFrSktMRVZCUVUxSkxFZEJRVWRETEV0QlFXZENMRU5CU1ROQ0xFbEJTRUVzU1VGQlNVTXNSVUZCVDA0c1JVRkJUVWtzUjBGQlIwY3NWVUZEYUVKRExFZEJRV3RDTEVWQlEyeENReXhIUVVGakxFVkJRMVJETEVWQlFVa3NSVUZCUjBFc1JVRkJTVW9zUlVGQlMxZ3NUMEZCVVdVc1NVRkRNMEpLTEVWQlFVdEpMRWRCUVVkRExFMUJRVTBzWVVGRGFFSkdMRWRCUVdNc1JVRkZaRVFzUjBGQmEwSXNSVUZIZEVJc1IwRkJTVU1zUjBGQlpVUXNSVUZGYWtJc1RVRkVRV3hDTEZGQlFWRnpRaXhKUVVGSkxHOUdRVUZ4Ums0c1IwRkRNMFlzYlVaQlJWSXNTVUZCUzBjc1NVRkJaMEpFTEVWQlJXNUNMRTFCUkVGc1FpeFJRVUZSYzBJc1NVRkJTU3d3UkVGQk1rUk9MRWRCUTJwRkxIbEVRVVZTTEVkQlFVbEZMRVZCUVdsQ0xFTkJRMjVDVUN4RlFVRmhMRWRCUTJKRExFVkJRV0VzUjBGRllrTXNSVUZCVVVnc1JVRkJUVWtzUjBGQlIxTXNZVUZEYWtJc1NVRkJTeXhKUVVGWFF5eEZRVUZRUXl4RlFVRkpMRVZCUVZGQkxFVkJRVWxhTEVWQlFVMVNMRTlCUVZGdlFpeEpRVUV3UWl4WlFVRnFRbG9zUlVGQlRWa3NSMEZCUjFZc1QwRkRka1JUTEVWQlFVMXlRaXh6UWtGQmMwSlZMRVZCUVUxWkxFZEJRVWRETEU5QlEyaENMRk5CUVdwQ1lpeEZRVUZOV1N4SFFVRkhSU3hMUVVGcFFtWXNSVUZCVjJVc1MwRkJUMGdzUlVGRGRFSXNWMEZCYWtKWUxFVkJRVTFaTEVkQlFVZEZMRXRCUVcxQ1ppeEZRVUZYWjBJc1dVRkJZMG9zUlVGRGNFTXNZMEZCYWtKWUxFVkJRVTFaTEVkQlFVZEZMRXRCUVhOQ2FFSXNSVUZCWVdFc1JVRkRNMElzVTBGQmFrSllMRVZCUVUxWkxFZEJRVWRGTEV0QlFXbENaaXhGUVVGWGFVSXNXVUZCWXl4WFFVRmhUQ3hGUVVNdlF5eHBRa0ZCYWtKWUxFVkJRVTFaTEVkQlFVZEZMRXRCUVhsQ1ppeEZRVUZYYTBJc1kwRkJOa01zVVVGQk4wSkRMRTlCUVU5UUxFZEJRVXRSTEdOQlF6ZEZjRUlzUlVGQlYwTXNSVUZCVFZrc1IwRkJSMFVzVFVGQlVVZ3NSMEZOYmtNc1NVRkJTeXhKUVVGSlV5eEZRVUZKTEVWQlFVZEJMRVZCUVVscVFpeEZRVUZMV0N4UFFVRlJORUlzU1VGREwwSjRRaXhGUVVGcFFrOHNSVUZCUzJsQ0xFZEJRVWwwUWl4RlFVRlpReXhIUVVjeFF5eEhRVUZKVHl4RlFVTkdMRWxCUVVzc1NVRkJTV1VzUlVGQlNTeEZRVUZIUVN4RlFVRkpiRUlzUlVGQlMxZ3NUMEZCVVRaQ0xFbEJRVXNzUTBGSGNFTjZRaXhGUVVaeFFrOHNSVUZCUzJ0Q0xFZEJRVWMxUWl4UFFVRlBMRVZCUVVkVkxFVkJRVXRyUWl4SFFVRkhReXhSUVVGUkxGZEJSWFJDUXl4RlFVRlhMRU5CUVVWRExHZENRVVI0UWpOQ0xFVkJRVTFKTEVkQlFVZFRMR3RDUVZkeVEyVXNkVUpCUVhsQ0xGTkJRVk5ETEVWQlFVODNRaXhGUVVGUE9FSXNSVUZCTUVJdlFpeEZRVUZyUW1kRExFVkJRV05ETEVWQlFYTkNReXhGUVVGbFF5eEhRVU5xU2l4SlFXMUNTVU1zUlVGdVFrRkRMRVZCUVZkUUxFVkJRMWhSTEVWQlFWa3NTMEZGYUVJc1VVRkJiMElzU1VGQlZISkRMRVZCUVhOQ0xFTkJReTlDTEVsQlFVbHpReXhGUVVGaGJFUXNVMEZCVTNsRExFVkJRVThzUTBGREwwSlZMRlZCUVZVc1JVRkRWa01zVlVGQlZTeEpRVVZhTEVkQlFYVkNMR05CUVc1Q1JpeEZRVUZYYWtNc1YwRkJkMFFzU1VGQmVrSnBReXhGUVVGWFJ5eFhRVVYyUkN4TlFVUkJia1FzVVVGQlVYTkNMRWxCUVVrc0swSkJRV2RETUVJc1IwRkRkRU1zTmtKQlJWSjBReXhGUVVGUmMwTXNSVUZCVjBjc1YwRkJWM3BETEUxQlUyaERMRWxCUVVzc1NVRkJTVWtzUlVGQlNVb3NSVUZCVFV3c1QwRkJVeXhGUVVGSFV5eEhRVUZMTEVWQlFVZEJMRWxCUVVzc1EwRkRNVU1zUjBGQmNVSXNXVUZCYWtKS0xFVkJRVTFKTEVkQlFVZERMRTFCUVhWRExHbENRVUZxUWt3c1JVRkJUVWtzUjBGQlIyRXNTMEZETVVOdVFpeDNRMEZCZDBORExFVkJRV3RDUXl4RlFVRk5TU3hIUVVGSFNpeFBRVU51Ulc5RExFVkJRVmMzUXl4bFFVRmxiVVFzV1VGQldVNHNSVUZCVlhCRExFVkJRVTFKTEVkQlFVZHZReXhUUVVGVFJ5eE5RVUZQVGl4RlFVRlhMRVZCUVVjc1JVRkJSeXhGUVVGSExGTkJUM2hHTEVkQlFYRkNMRk5CUVdwQ2NrTXNSVUZCVFVrc1IwRkJSME1zVFVGQmIwTXNXVUZCYWtKTUxFVkJRVTFKTEVkQlFVZERMRXRCUXpsREswSXNSVUZCVjFJc2RVSkJRWFZDVVN4RlFVRlZjRU1zUlVGQlRVa3NSMEZCUjBvc1RVRkJUemhDTEVWQlFUQkNMMElzUlVGQmEwSm5ReXhGUVVGalF5eEZRVUZ6UWtNc1JVRkJaVU1zVVVGRGRFb3NSMEZCY1VJc1YwRkJha0pzUXl4RlFVRk5TU3hIUVVGSFF5eFhRVVZpTEVkQlFYRkNMRkZCUVdwQ1RDeEZRVUZOU1N4SFFVRkhReXhMUVVGblFpeERRVWxzUXl4SlFVaEJMRWxCUVVsRExFVkJRVTlPTEVWQlFVMUpMRWRCUVVkSExGVkJRMmhDY1VNc1JVRkJVeXhIUVVOVVF5eEZRVUZyUWl4TFFVTmlia01zUlVGQlNTeEZRVUZIUVN4RlFVRkpTaXhGUVVGTFdDeFBRVUZSWlN4SlFVRkxMRU5CUTJoRGEwTXNSVUZCVDJwRUxFOUJRVk1zU1VGQlIybEVMRWRCUVZVc1RVRkRha01zU1VGQlNXcERMRVZCUVZGTUxFVkJRVXRKTEVkQlFVZERMRTFCUVUwc05rSkJRekZDTEVkQlFXTXNUMEZCVmtFc1JVRkJaMElzUTBGRGJFSXNSMEZCZDBJc1QwRkJjRUpyUXl4SFFVRTBRa0VzUjBGQmJVSnNReXhGUVVGTkxFZEJRVWtzUzBGQlRTeDNSVUZCTUVWclF5eEZRVUZyUWl4UFFVRlRiRU1zUlVGQlRTeEhRVUZMTEVsQlEyNU1hME1zUlVGQmEwSnNReXhGUVVGTkxFZEJSVEZDYVVNc1IwRkJWU3hyUjBGQk9FWjBReXhGUVVGTFNTeEhRVVV2Unl4SFFVRkpiVU1zUlVGQmFVSXNRMEZEYmtJc1NVRkJTVU1zUlVGQllTeDFSRUZCZFVSRUxFVkJRV3RDTEZsQlJYUkdSU3hGUVVGTlZpeEZRVU5PVnl4RlFVRlZMRWxCUTFab1JDeEZRVUZOU1N4SFFVRkhVeXhoUVVGaGJFSXNUMEZCVXl4SlFVTTNRa3NzUlVGQlRVa3NSMEZCUjFNc1lVRkJZU3hIUVVGSE1rSXNVMEZCVTBjc1RVRkJUVTBzVFVGQlVXcEVMRVZCUVUxSkxFZEJRVWR2UXl4VFFVRlRUeXhKUVVGSlJTeFBRVU40UlVRc1JVRkJWU3hMUVVGUExFbEJRVXRGTEUxQlFVMXNSQ3hGUVVGTlNTeEhRVUZIYjBNc1UwRkJVMGNzVFVGQlRWRXNTMEZCVFVNc1MwRkJTeXhOUVVWcVJVd3NSVUZCVFM5RExFVkJRVTFKTEVkQlFVZFRMR0ZCUVdGaUxFVkJRVTFKTEVkQlFVZFRMR0ZCUVdGc1FpeFBRVUZUTEVkQlFVYzJReXhUUVVGVFR5eExRVVUzUkN4UFFVRlNRU3hGUVVGaldDeEhRVUZaV1N4RlFWUmFMSEZDUVZWVFdpeEZRVUZzUWxjc1IwRkJUMVlzUlVGQmMwSTVReXhsUVVGbGJVUXNXVUZCV1U0c1JVRkJWVmNzUlVGQlMxWXNSVUZCVnl4RlFVRkhMRVZCUVVjc1JVRkJSMWNzUlVGV2JFWXNjMEpCVjBaNlJDeGxRVUZsYlVRc1dVRkJXVTRzUlVGQlZWY3NSVUZCUzFZc1JVRkJWeXhGUVVGSExFVkJRVWNzUlVGQlIxY3NSVUZCVlN4SlFVRk5RU3hGUVZnMVJTeHpRa0ZaYkVKS0xFVkJRVk5GTEVWQlFXRkZMRVZCUVZWS0xFVkJRVTh2UXl4UlFVRlJMRWxCUVVsM1JDeFBRVUZQTEc5Q1FVRnpRbElzUlVGQmEwSXNUVUZCVHl4TFFVRk5MRzFEUVVGcFEwRXNSVUZCYTBJc2MwSkJSV3hMT1VNc1JVRkJhVUk0UXl4RlFVRnBRaXhIUVVGSkxFTkJRVVV6UWl4WlFVRmhMRlZCU1haRUxFbEJRVWx2UXl4RlFVRnBRbFFzUjBGQmIwTllMRVZCUTNwRVF5eEZRVUZyUWt3c1JVRkJlVUo1UWl4TFFVRkxReXhMUVVGTlJpeEZRVUZuUWl4SlFVTjBSU3hKUVVGSlJ5eEZRVUZyUW1wRkxITkNRVUZ6UWpSRExFVkJRVlZ3UXl4RlFVRk5TU3hIUVVGSFV5eGhRVUZqYlVJc1JVRkJjMEpITEVkQlF6TkZMRTlCUVhCQ2MwSXNTVUZCTUVKeVFpeEZRVUZYY1VJc1IwRkZla055UWl4RlFVRlhOME1zWlVGQlpXMUVMRmxCUVZsT0xFVkJRVlZ3UXl4RlFVRk5TU3hIUVVGSGIwTXNVMEZCVTBjc1RVRkJUek5ETEVWQlFVMUpMRWRCUVVkdlF5eFRRVUZUVHl4SlFVRkxMRVZCUVVjc1JVRkJSeXhGUVVGSFNDeFJRVVY2UjNSRUxGRkJRVkZ6UWl4SlFVRkpMRzlDUVVGeFFsb3NSVUZCVFVrc1IwRkJSME1zUzBGQlRTd3JRa0ZGYkVSblF5eEZRVUZaY2tNc1JVRkJUVWtzUjBGQlIyOURMRk5CUVZOSExFMUJSV2hETEU5QlFVOVFMRWRCUjFSelFpeFBRVUZQUXl4UlFVRlZMMElpTENKbWFXeGxJam9pTDNCeWFYWmhkR1V2ZEcxd0wyWnZieTVIVDBVdmMzSmpMMnB6TDJOdmJuWmxjblJsY2k5emRIbHNaWE5vWldWMExtcHpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKSxqc2VwPXJlcXVpcmUoXCJqc2VwXCIpO2pzZXAuYWRkQmluYXJ5T3AoXCJvclwiLDEpLGpzZXAuYWRkQmluYXJ5T3AoXCJhbmRcIiwyKSxqc2VwLmFkZEJpbmFyeU9wKFwiZXFcIiw2KSxqc2VwLmFkZEJpbmFyeU9wKFwibmVxXCIsNiksanNlcC5hZGRCaW5hcnlPcChcImx0XCIsNyksanNlcC5hZGRCaW5hcnlPcChcImx0ZVwiLDcpLGpzZXAuYWRkQmluYXJ5T3AoXCJndFwiLDcpLGpzZXAuYWRkQmluYXJ5T3AoXCJndGVcIiw3KTt2YXIgYWRkU2xhc2hlcz1mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bXFxcXFwiJ1xcclxcblxcdFxcdlxcZlxcYl0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXHUwMDAwL2csXCJcXFxcMFwiKX0scmVtb3ZlU3R5bGU9ZnVuY3Rpb24oZSxyLG4sdCxvLGksYSl7Zm9yKHZhciBzPWUuc3BsaXQoXCJcXG5cIikscD1vLGw9aSx1PTErdDt1PHIubGluZTt1KyspcCs9c1t1LTEtdF0ubGVuZ3RoKzE7aWYocCs9ci5jb2wsbnVsbCE9PW4pe2Zvcih2YXIgZD0xK3Q7ZDxuLmxpbmU7ZCsrKWwrPXNbZC0xLXRdLmxlbmd0aCsxO2wrPW4uY29sfWVsc2UgbCs9ZS5sZW5ndGgrMTtyZXR1cm4gZS5zdWJzdHIoMCxwLTEpK2ErZS5zdWJzdHIobC0xKX0sZXhwcmVzc2lvbkdlbmVyYXRvcj1mdW5jdGlvbihlLHIsbil7cmV0dXJuIGZ1bmN0aW9uIGUocixuLHQsbyl7aWYodm9pZCAwPT09dCYmKHQ9ITApLHZvaWQgMCE9PW8mJlwiSWRlbnRpZmllclwiIT09ci50eXBlJiZcIk1lbWJlckV4cHJlc3Npb25cIiE9PXIudHlwZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgY29uc29sZS5kZWJ1ZyYmY29uc29sZS5kZWJ1ZyhcIkNhbm5vdCBhcHBseSBkZWZhdWx0IHZhbHVlIHRvIHZhcmlhYmxlIHdoZW4gdXNpbmcgZXhwcmVzc2lvbnNcIiksXCJCaW5hcnlFeHByZXNzaW9uXCI9PT1yLnR5cGV8fFwiTG9naWNhbEV4cHJlc3Npb25cIj09PXIudHlwZSlyZXR1cm5cIihcIitlKHIubGVmdCxuLHQpK1wiIFwiK2Z1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlXCJvclwiOnJldHVyblwifHxcIjtjYXNlXCJhbmRcIjpyZXR1cm5cIiYmXCI7Y2FzZVwibHRcIjpyZXR1cm5cIjxcIjtjYXNlXCJsdGVcIjpyZXR1cm5cIjw9XCI7Y2FzZVwiZ3RcIjpyZXR1cm5cIj5cIjtjYXNlXCJndGVcIjpyZXR1cm5cIj49XCI7Y2FzZVwiZXFcIjpyZXR1cm5cIj09XCI7Y2FzZVwibmVxXCI6cmV0dXJuXCIhPVwiO2RlZmF1bHQ6cmV0dXJuIGV9fShyLm9wZXJhdG9yKStcIiBcIitlKHIucmlnaHQsbix0KStcIilcIjtpZihcIkNhbGxFeHByZXNzaW9uXCI9PT1yLnR5cGUpe3ZhciBpPXIuYXJndW1lbnRzLm1hcChmdW5jdGlvbihyKXtyZXR1cm4gZShyLG4sdCl9KTtyZXR1cm4gZShyLmNhbGxlZSxuLHQpK1wiKFwiK2kuam9pbihcIiwgXCIpK1wiKVwifWlmKFwiVW5hcnlFeHByZXNzaW9uXCI9PT1yLnR5cGUpcmV0dXJuIHIub3BlcmF0b3IrZShyLmFyZ3VtZW50LG4sdCk7aWYoXCJNZW1iZXJFeHByZXNzaW9uXCI9PXIudHlwZSYmci5jb21wdXRlZCl0aHJvd1wiVW5leHBlY3RlZCBjb21wdXRlZCBtZW1iZXIgZXhwcmVzc2lvblwiO2lmKFwiTWVtYmVyRXhwcmVzc2lvblwiIT1yLnR5cGV8fHIuY29tcHV0ZWQpe2lmKFwiTGl0ZXJhbFwiPT09ci50eXBlKXJldHVybiByLnJhdztpZihcIklkZW50aWZpZXJcIj09PXIudHlwZSl7dmFyIGE9ci5uYW1lO3JldHVybiB0P24oYSxvKStcIigpXCI6YX1pZihcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiPT09ci50eXBlKXJldHVyblwiKFwiK2Uoci50ZXN0LG4sdCkrXCIgPyBcIitlKHIuY29uc2VxdWVudCxuLHQpK1wiIDogXCIrZShyLmFsdGVybmF0ZSxuLHQpK1wiKVwiO3Rocm93XCJDb21wb3VuZFwiPT09ci50eXBlP1wiU3ludGF4IGVycm9yIGluIGV4cHJlc3Npb246IG9wZXJhdG9yIGV4cGVjdGVkIGFmdGVyIFwiK2Uoci5ib2R5WzBdLG4sITEpOlwiRm91bmQgYW4gdW5zdXBwb3J0ZWQgZXhwcmVzc2lvbiB0eXBlOiBcIityLnR5cGV9dmFyIHM9ZShyLm9iamVjdCxuLCExKStcIi5cIitlKHIucHJvcGVydHksbiwhMSk7cmV0dXJuIHQmJlwiTWF0aFwiIT09ci5vYmplY3QubmFtZSYmXCJDb2xvclwiIT09ci5vYmplY3QubmFtZSYmXCJVdGlsXCIhPT1yLm9iamVjdC5uYW1lP24ocyxvKStcIigpXCI6c30oZSxyLHZvaWQgMCxuKX0sZXhwcmVzc2lvbkJpbmRpbmc9ZnVuY3Rpb24oZSxyLG4pe3ZhciB0O2lmKG51bGwhPW4pe3ZhciBvPWUudHJpbSgpLnJlcGxhY2UoL0BcXFsoW15cXF1dKylcXF18QChbYS16QS1aMC05XFwuX10rKVxcYi9nLFwiIyMjdmFyIyMjXCIpO2lmKFwiIyMjdmFyIyMjXCI9PShvPW8ucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csXCJcXFxcJCZcIikpKXQ9W251bGwsbl07ZWxzZSBpZihvPVwiXlwiK28ucmVwbGFjZSgvIyMjdmFyIyMjL2csXCIoLispXCIpK1wiJFwiLCEodD1uLnRyaW0oKS5tYXRjaChuZXcgUmVnRXhwKG8pKSkpdGhyb3cgY29uc29sZS5sb2coXCJDYW5ub3QgZmluZCBtYXRjaGVzXCIsdCxcImZvclwiLG4sZSxvLGUpLFwiQ2Fubm90IGZpbmQgZGVmYXVsdCB2YWx1ZSBmb3IgXCIrZStcIiBpbiBcIitufXRyeXt2YXIgaT0wLGE9XCInXCIrZS5yZXBsYWNlKC9AXFxbKFteXFxdXSspXFxdfEAoW2EtekEtWjAtOVxcLl9dKylcXGJ8KCcpL2csZnVuY3Rpb24oZSxuLG8sYSl7aWYoYSlyZXR1cm5cIlxcXFxcIithO2krKzt2YXIgcyxwPW58fG87aWYodCYmKHZvaWQgMCE9PXRbaV0/cz10W2ldLnRyaW0oKTpjb25zb2xlLmxvZyhcIkFCWlpaIENhbm5vdCBmaW5kIGRlZmF1bHQgdmFsdWUgZm9yXCIscCxcImluXCIsdCxcImFzXCIsaSkpLG4pe3ZhciBsPWpzZXAobik7cmV0dXJuXCInK1wiK2V4cHJlc3Npb25HZW5lcmF0b3IobCxyLHMpK1wiKydcIn1yZXR1cm5cIicrXCIrcihwLHMpK1wiKCkrJ1wifSkrXCInXCI7cmV0dXJuIGE9YS5yZXBsYWNlKC8oXnxbXlxcXFxdKScnXFwrL2csXCIkMVwiKS5yZXBsYWNlKC9cXCsnJy9nLFwiXCIpLDA9PT1pJiZcImZhbHNlXCIhPT1hJiZcInRydWVcIiE9PWEmJmNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGV4cHJlc3Npb24gd2l0aCBubyB2YWxpZCBAdmFyaWFibGUgcmVmZXJlbmNlc1wiLGUpLGF9Y2F0Y2gocil7dGhyb3dcIkV4Y2VwdGlvbiBwYXJzaW5nIGV4cHJlc3Npb24gXCIrZStcIiBcIityfX0sY29uZGl0aW9uQmluZGluZz1mdW5jdGlvbihlLHIpe3ZhciBuPWpzZXAoZSk7cmV0dXJuIGV4cHJlc3Npb25HZW5lcmF0b3IobixyKX07bW9kdWxlLmV4cG9ydHM9e2FkZFNsYXNoZXM6YWRkU2xhc2hlcyxyZW1vdmVTdHlsZTpyZW1vdmVTdHlsZSxjb25kaXRpb25CaW5kaW5nOmNvbmRpdGlvbkJpbmRpbmcsZXhwcmVzc2lvbkJpbmRpbmc6ZXhwcmVzc2lvbkJpbmRpbmd9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5WMGFXeHpMbXB6SWwwc0ltNWhiV1Z6SWpwYkltTnZibk52YkdVaUxDSnlaWEYxYVhKbElpd2lhbk5sY0NJc0ltRmtaRUpwYm1GeWVVOXdJaXdpWVdSa1UyeGhjMmhsY3lJc0luTjBjaUlzSW5KbGNHeGhZMlVpTENKeVpXMXZkbVZUZEhsc1pTSXNJbk4wZVd4bElpd2ljM1JoY25SUWIzTWlMQ0psYm1SUWIzTWlMQ0p6YTJsd1VtOTNjeUlzSW5OMFlYSjBUMlptYzJWMElpd2laVzVrVDJabWMyVjBJaXdpYVc1elpYSjBJaXdpYzNSNWJHVlNiM2R6SWl3aWMzQnNhWFFpTENKemRHRnlkQ0lzSW1WdVpDSXNJbklpTENKc2FXNWxJaXdpYkdWdVozUm9JaXdpWTI5c0lpd2ljaklpTENKemRXSnpkSElpTENKbGVIQnlaWE56YVc5dVIyVnVaWEpoZEc5eUlpd2libTlrWlNJc0ltSnBibVJwYm1kUWNtOTJhV1JsY2lJc0ltUmxabFpoYkNJc0ltZGxiaUlzSW14dmIydDFjRzFsYldKbGNpSXNJblI1Y0dVaUxDSmtaV0oxWnlJc0lteGxablFpTENKdmNDSXNJbTFoY0U5d1pYSmhkRzl5SWl3aWIzQmxjbUYwYjNJaUxDSnlhV2RvZENJc0ltRnlaM01pTENKaGNtZDFiV1Z1ZEhNaUxDSnRZWEFpTENKdUlpd2lZMkZzYkdWbElpd2lhbTlwYmlJc0ltRnlaM1Z0Wlc1MElpd2lZMjl0Y0hWMFpXUWlMQ0p5WVhjaUxDSnBaQ0lzSW01aGJXVWlMQ0owWlhOMElpd2lZMjl1YzJWeGRXVnVkQ0lzSW1Gc2RHVnlibUYwWlNJc0ltSnZaSGtpTENKdFpTSXNJbTlpYW1WamRDSXNJbkJ5YjNCbGNuUjVJaXdpZFc1a1pXWnBibVZrSWl3aVpYaHdjbVZ6YzJsdmJrSnBibVJwYm1jaUxDSmxlSEJ5WlhOemFXOXVJaXdpWkdWbVlYVnNkRlpoYkhWbElpd2liV0YwWTJobGN5SXNJbU5vWldOcklpd2lkSEpwYlNJc0ltMWhkR05vSWl3aVVtVm5SWGh3SWl3aWJHOW5JaXdpZG1GeWN5SXNJbkpsYzNWc2RDSXNJbkF4SWl3aWNESWlMQ0p3TXlJc0luWmhjazVoYldVaUxDSndZWEp6WlhSeVpXVWlMQ0psY25KdmNpSXNJbVVpTENKamIyNWthWFJwYjI1Q2FXNWthVzVuSWl3aVkyOXVaR2wwYVc5dUlpd2liVzlrZFd4bElpd2laWGh3YjNKMGN5SmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNZVUZEUVN4SlFVRkpRU3hSUVVGVlF5eFJRVUZSTEhOQ1FVTnNRa01zUzBGQlQwUXNVVUZCVVN4UlFVVnVRa01zUzBGQlMwTXNXVUZCV1N4TFFVRk5MRWRCUTNaQ1JDeExRVUZMUXl4WlFVRlpMRTFCUVU4c1IwRkRlRUpFTEV0QlFVdERMRmxCUVZrc1MwRkJUU3hIUVVOMlFrUXNTMEZCUzBNc1dVRkJXU3hOUVVGUExFZEJRM2hDUkN4TFFVRkxReXhaUVVGWkxFdEJRVTBzUjBGRGRrSkVMRXRCUVV0RExGbEJRVmtzVFVGQlR5eEhRVU40UWtRc1MwRkJTME1zV1VGQldTeExRVUZOTEVkQlEzWkNSQ3hMUVVGTFF5eFpRVUZaTEUxQlFVOHNSMEZGZUVJc1NVRkJTVU1zVjBGQllTeFRRVUZUUXl4SFFVTjRRaXhQUVVGUFFTeEZRVUZKUXl4UlFVRlJMSE5DUVVGMVFpeFJRVUZSUVN4UlFVRlJMRlZCUVZjc1VVRkhia1ZETEZsQlFXTXNVMEZCVTBNc1JVRkJUME1zUlVGQlZVTXNSVUZCVVVNc1JVRkJWVU1zUlVGQllVTXNSVUZCVjBNc1IwRkpjRVlzU1VGSVFTeEpRVUZKUXl4RlFVRlpVQ3hGUVVGTlVTeE5RVUZOTEUxQlEzaENReXhGUVVGUlRDeEZRVU5TVFN4RlFVRk5UQ3hGUVVORVRTeEZRVUZKTEVWQlFVbFNMRVZCUVZWUkxFVkJRVWxXTEVWQlFWTlhMRXRCUVUxRUxFbEJRVXRHTEVkQlFWTkdMRVZCUVZWSkxFVkJRVWtzUlVGQlNWSXNSMEZCVlZVc1QwRkJVeXhGUVVWcVJ5eEhRVVJCU2l4SFFVRlRVaXhGUVVGVFlTeEpRVU5JTEU5QlFWaGFMRVZCUVdsQ0xFTkJRMjVDTEVsQlFVc3NTVUZCU1dFc1JVRkJTeXhGUVVGSldpeEZRVUZWV1N4RlFVRkxZaXhGUVVGUFZTeExRVUZOUnl4SlFVRk5UQ3hIUVVGUFNDeEZRVUZWVVN4RlFVRkxMRVZCUVVsYUxFZEJRVlZWTEU5QlFWTXNSVUZEYWtkSUxFZEJRVTlTTEVWQlFVOVpMRk5CUTFSS0xFZEJRVTlXTEVWQlFVMWhMRTlCUVZNc1JVRkZOMElzVDBGRVpXSXNSVUZCVFdkQ0xFOUJRVThzUlVGQlIxQXNSVUZCVVN4SFFVRkxTQ3hGUVVGVFRpeEZRVUZOWjBJc1QwRkJUMDRzUlVGQlRTeEpRVWwwUlU4c2IwSkJRWE5DTEZOQlFWTkRMRVZCUVUxRExFVkJRV2xDUXl4SFFUUkVlRVFzVDBGd1EwRXNVMEZCVTBNc1JVRkJTVWdzUlVGQlRVTXNSVUZCYVVKSExFVkJRV05HTEVkQlMyaEVMRkZCU2pKQ0xFbEJRV2hDUlN4SlFVRTJRa0VzUjBGQlpTeFJRVVZxUXl4SlFVRllSaXhIUVVGM1F5eGxRVUZrUml4RlFVRkxTeXhOUVVGMVF5eHhRa0ZCWkV3c1JVRkJTMHNzVFVGQmVVUXNiVUpCUVdwQ0wwSXNVVUZCVVdkRExFOUJRWEZDYUVNc1VVRkJVV2RETEUxQlFVMHNhVVZCUlhwSkxIRkNRVUZrVGl4RlFVRkxTeXhOUVVFMlF5eHpRa0ZCWkV3c1JVRkJTMHNzUzBGRE0wTXNUVUZCVHl4SlFVRk5SaXhGUVVGSlNDeEZRVUZMVHl4TFFVRk5UaXhGUVVGcFFrY3NSMEZCWjBJc1NVRTNRbXBGTEZOQlFYRkNTU3hIUVVOdVFpeFBRVUZSUVN4SFFVTk9MRWxCUVVzc1MwRkRTQ3hOUVVGUExFdEJRMVFzU1VGQlN5eE5RVU5JTEUxQlFVOHNTMEZEVkN4SlFVRkxMRXRCUTBnc1RVRkJUeXhKUVVOVUxFbEJRVXNzVFVGRFNDeE5RVUZQTEV0QlExUXNTVUZCU3l4TFFVTklMRTFCUVU4c1NVRkRWQ3hKUVVGTExFMUJRMGdzVFVGQlR5eExRVU5VTEVsQlFVc3NTMEZEU0N4TlFVRlBMRXRCUTFRc1NVRkJTeXhOUVVOSUxFMUJRVThzUzBGRFZDeFJRVU5GTEU5QlFVOUJMRWRCVlRCRVF5eERRVUZaVkN4RlFVRkxWU3hWUVVGWkxFbEJRVTFRTEVWQlFVbElMRVZCUVV0WExFMUJRVTlXTEVWQlFXbENSeXhIUVVGblFpeEpRVU5zU2l4SFFVRnJRaXh0UWtGQlpFb3NSVUZCUzBzc1MwRkJNa0lzUTBGRGVrTXNTVUZCU1U4c1JVRkJUMW9zUlVGQlMyRXNWVUZCVlVNc1NVRkJTU3hUUVVGVFF5eEhRVU55UXl4UFFVRlBXaXhGUVVGSldTeEZRVUZIWkN4RlFVRnBRa2NzUzBGRmFrTXNUMEZCVDBRc1JVRkJTVWdzUlVGQlMyZENMRTlCUVZGbUxFVkJRV2xDUnl4SFFVRm5RaXhKUVVGTlVTeEZRVUZMU3l4TFFVRkxMRTFCUVZFc1NVRkROVVVzUjBGQmEwSXNiMEpCUVdScVFpeEZRVUZMU3l4TFFVTmtMRTlCUVU5TUxFVkJRVXRWTEZOQlFWZFFMRVZCUVVsSUxFVkJRVXRyUWl4VFFVRlZha0lzUlVGQmFVSkhMRWRCUTNSRUxFZEJRV2xDTEc5Q1FVRmlTaXhGUVVGTFN5eE5RVUU0UWt3c1JVRkJTMjFDTEZOQlEycEVMRXRCUVUwc2QwTkJSVVFzUjBGQmFVSXNiMEpCUVdKdVFpeEZRVUZMU3l4TlFVRXJRa3dzUlVGQlMyMUNMRk5CU1RkRExFTkJRVUVzUjBGQmEwSXNXVUZCWkc1Q0xFVkJRVXRMTEV0QlEyUXNUMEZCVDB3c1JVRkJTMjlDTEVsQlExQXNSMEZCYTBJc1pVRkJaSEJDTEVWQlFVdExMRXRCUVhWQ0xFTkJRM0pETEVsQlFVbG5RaXhGUVVGTGNrSXNSVUZCUzNOQ0xFdEJRMlFzVDBGQlNXeENMRVZCUVhGQ1NDeEZRVUZuUW05Q0xFVkJRVWx1UWl4SFFVRlZMRXRCUXpORGJVSXNSVUZEVUN4SFFVRnJRaXd3UWtGQlpISkNMRVZCUVV0TExFdEJRMlFzVFVGQlR5eEpRVUZOUml4RlFVRkpTQ3hGUVVGTGRVSXNTMEZCVFhSQ0xFVkJRV2xDUnl4SFFVRm5RaXhOUVVGUlJDeEZRVUZKU0N4RlFVRkxkMElzVjBGQldYWkNMRVZCUVdsQ1J5eEhRVUZuUWl4TlFVRlJSQ3hGUVVGSlNDeEZRVUZMZVVJc1ZVRkJWM2hDTEVWQlFXbENSeXhIUVVGblFpeEpRVU51VEN4TFFVRnJRaXhoUVVGa1NpeEZRVUZMU3l4TFFVTlNMSFZFUVVGNVJFWXNSVUZCU1Vnc1JVRkJTekJDTEV0QlFVc3NSMEZCU1hwQ0xFZEJRV2xDTEVkQlJUVkdMSGxEUVVFeVEwUXNSVUZCUzBzc1MwRmtkRVFzU1VGQlNYTkNMRVZCUVV0NFFpeEZRVUZKU0N4RlFVRkxORUlzVDBGQlVUTkNMRWRCUVdsQ0xFZEJRVk1zU1VGQlRVVXNSVUZCU1Vnc1JVRkJTelpDTEZOQlFWVTFRaXhIUVVGcFFpeEhRVU01Uml4UFFVRkpSeXhIUVVGeFF5eFRRVUZ5UWtvc1JVRkJTelJDTEU5QlFVOU9MRTFCUVhkRExGVkJRWEpDZEVJc1JVRkJTelJDTEU5QlFVOU9MRTFCUVhsRExGTkJRWEpDZEVJc1JVRkJTelJDTEU5QlFVOU9MRXRCUVhkQ2NrSXNSVUZCWjBJd1FpeEZRVUZKZWtJc1IwRkJWU3hMUVVNNVNYbENMRVZCWjBKS2VFSXNRMEZCU1Vnc1JVRkJUVU1zVDBGQmFVSTJRaXhGUVVGWE5VSXNTVUZITTBNMlFpeHJRa0ZCYjBJc1UwRkJVME1zUlVGQldTOUNMRVZCUVdsQ1owTXNSMEZETlVRc1NVRkJTVU1zUlVGRFNpeEhRVUZKTEUxQlFVOUVMRVZCUVhWRUxFTkJRMmhGTEVsQlFVbEZMRVZCUVZGSUxFVkJRVmRKTEU5QlFVOTRSQ3hSUVVGUkxITkRRVUYxUXl4aFFVVTNSU3hIUVVGaExHTkJSR0oxUkN4RlFVRlJRU3hGUVVGTmRrUXNVVUZCVVN4elEwRkJkVU1zVTBGRGJrTnpSQ3hGUVVGVkxFTkJRVU1zUzBGQlRVUXNVVUZKZWtNc1IwRkdRVVVzUlVGQlVTeEpRVUZOUVN4RlFVRk5ka1FzVVVGQlVTeGhRVUZqTEZGQlFWVXNUVUZEY0VSelJDeEZRVUZWUkN4RlFVRmhSeXhQUVVGUFF5eE5RVUZOTEVsQlFVbERMRTlCUVU5SUxFdEJTVGRETEUxQlJFRTNSQ3hSUVVGUmFVVXNTVUZCU1N4elFrRkJkVUpNTEVWQlFWTXNUVUZCVDBRc1JVRkJZMFFzUlVGQldVY3NSVUZCVDBnc1IwRkRPVVVzYVVOQlFXMURRU3hGUVVGaExFOUJRVk5ETEVWQlNYSkZMRWxCUTBVc1NVRkJTVThzUlVGQlR5eEZRVU5RUXl4RlFVRlRMRWxCUVUxVUxFVkJRVmR3UkN4UlFVRlJMREJEUVVFeVF5eFRRVUZUZVVRc1JVRkJUMHNzUlVGQlNVTXNSVUZCU1VNc1IwRkZka2NzUjBGQlNVRXNSVUZCU1N4TlFVRlBMRXRCUVU5QkxFVkJRM1JDU2l4SlFVTkJMRWxCUTBsMFF5eEZRVVJCTWtNc1JVRkJWVWdzUjBGQlRVTXNSVUZWY0VJc1IwRlNTVlFzVTBGRE1rSXNTVUZCYkVKQkxFVkJRVkZOTEVkQlEycENkRU1zUlVGQlUyZERMRVZCUVZGTkxFZEJRVTFLTEU5QlJYWkNPVVFzVVVGQlVXbEZMRWxCUVVrc2MwTkJRWFZEVFN4RlFVRlRMRXRCUVUxWUxFVkJRVk1zUzBGQlRVMHNTVUZKYWtaRkxFVkJRVWtzUTBGRFRpeEpRVUZKU1N4RlFVRlpkRVVzUzBGQlMydEZMRWRCUlhKQ0xFMUJRVThzUzBGRVR6TkRMRzlDUVVGdlFpdERMRVZCUVZjM1F5eEZRVUZwUWtNc1IwRkRkRU1zUzBGRk1VSXNUVUZCVHl4TFFVRlBSQ3hGUVVGblFqUkRMRVZCUVZNelF5eEhRVUZWTEZOQlF6bERMRWxCVFV3c1QwRk1RWFZETEVWQlFWTkJMRVZCUVU4M1JDeFJRVUZSTEdsQ1FVRnJRaXhOUVVGTlFTeFJRVUZSTEZGQlFWTXNTVUZGY0VRc1NVRkJWRFJFTEVkQlFYbENMRlZCUVZoRExFZEJRV2xETEZOQlFWaEJMRWRCUTNSRGJrVXNVVUZCVVhsRkxFMUJRVTBzTWtSQlFUUkVaaXhIUVVWeVJWTXNSVUZEVUN4TlFVRlBUeXhIUVVOUUxFdEJRVTBzWjBOQlFXdERhRUlzUlVGQllTeEpRVUZOWjBJc1NVRkpNMFJETEdsQ1FVRnRRaXhUUVVGVFF5eEZRVUZYYWtRc1IwRkRla01zU1VGQlNUWkRMRVZCUVZsMFJTeExRVUZMTUVVc1IwRkZja0lzVDBGRVkyNUVMRzlDUVVGdlFpdERMRVZCUVZjM1F5eEpRVWt2UTJ0RUxFOUJRVTlETEZGQlFWVXNRMEZEWmpGRkxGZEJRVmxCTEZkQlExcEhMRmxCUVdGQkxGbEJRMkp2UlN4cFFrRkJhMEpCTEdsQ1FVTnNRbXhDTEd0Q1FVRnRRa0VpTENKbWFXeGxJam9pTDNCeWFYWmhkR1V2ZEcxd0wyWnZieTVIVDBVdmMzSmpMMnB6TDJOdmJuWmxjblJsY2k5MWRHbHNjeTVxY3lKOSIsIlwidXNlIHN0cmljdFwiO3ZhciBrbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5rbzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rbzpudWxsLGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKTtmdW5jdGlvbiB3cmFwKGUpe3ZhciB0PXR5cGVvZiBlO2lmKFwib2JqZWN0XCI9PT10JiYoZT9lLmNvbnN0cnVjdG9yPT1EYXRlP3Q9XCJkYXRlXCI6XCJbb2JqZWN0IEFycmF5XVwiPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkmJih0PVwiYXJyYXlcIik6dD1cIm51bGxcIiksXCJhcnJheVwiPT10KXt2YXIgbj1rby5vYnNlcnZhYmxlQXJyYXkoKTtpZighZXx8MD09PWUubGVuZ3RoKXJldHVybiBuO2Zvcih2YXIgbz0wLHI9ZS5sZW5ndGg7bzxyOysrbyluLnB1c2god3JhcChlW29dKSk7cmV0dXJuIG59aWYoXCJvYmplY3RcIj09dCl7dmFyIGE9e307Zm9yKHZhciBpIGluIGUpe3ZhciBsPWVbaV07YVtpXT13cmFwKGwpfXJldHVybiBrby5vYnNlcnZhYmxlKGEpfWlmKFwiZnVuY3Rpb25cIj09dClyZXR1cm4gZTt2YXIgcz1rby5vYnNlcnZhYmxlKCk7cmV0dXJuIHMoZSksc312YXIgX2dldE9wdGlvbnNPYmplY3RLZXlzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLnNwbGl0KFwifFwiKSxuPVtdLG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIHI9dFtvXS5zcGxpdChcIj1cIik7bi5wdXNoKHJbMF0udHJpbSgpKX1yZXR1cm4gbn0sX21ha2VDb21wdXRlZD1mdW5jdGlvbihlLHQsbixvLHIsYSl7cmV0dXJuIGtvLmNvbXB1dGVkKHtyZWFkOmZ1bmN0aW9uKCl7dmFyIG49ZSgpO2lmKG51bGw9PT1uKXt2YXIgaT1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKG8pO3JldHVybiB2b2lkIDA9PT1pfHxcImN1c3RvbVwiPT1pP2tvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodCk6YVtpXVtyXX1yZXR1cm4gbn0sd3JpdGU6ZnVuY3Rpb24oaSl7dmFyIGwscz1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKG8pO2lmKGw9dm9pZCAwPT09c3x8XCJjdXN0b21cIj09cz9rby51dGlscy5wZWVrT2JzZXJ2YWJsZSh0KTphW3NdW3JdLG4pZShpPT1sP251bGw6aSk7ZWxzZXt2YXIgdT1rby51dGlscy5wZWVrT2JzZXJ2YWJsZShlKTtpPT1sJiZudWxsPT09dXx8ZShpKX19fSl9LF9uZXh0VmFyaWFudEZ1bmN0aW9uPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIG89ZS51dGlscy51bndyYXBPYnNlcnZhYmxlKHQpLHI9MDtyPG4ubGVuZ3RoJiZlLnV0aWxzLnBlZWtPYnNlcnZhYmxlKG5bcl0pIT1vO3IrKyk7cj09bi5sZW5ndGgmJihjb25zb2xlLndhcm4oXCJEaWRuJ3QgZmluZCBhIHZhcmlhbnQhXCIsdCxvLG4pLHI9bi5sZW5ndGgtMSk7dmFyIGE9cisxO2E9PW4ubGVuZ3RoJiYoYT0wKSx0KGUudXRpbHMucGVla09ic2VydmFibGUoblthXSkpfSxfZ2V0VmFyaWFudHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5fdmFyaWFudDtpZihcIm9iamVjdFwiIT10eXBlb2YgZVt0XXx8dm9pZCAwPT09ZVt0XS5fd2lkZ2V0fHxcInN0cmluZ1wiIT10eXBlb2YgZVt0XS5fb3B0aW9ucyYmXCJib29sZWFuXCIhPT1lW3RdLl93aWRnZXQpdGhyb3cgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgdmFyaWFudCBkZWNsYXJhdGlvblwiLHQsZVt0XSksXCJVbmV4cGVjdGVkIHZhcmlhbnQgZGVjbGFyYXRpb246IGNhbm5vdCBmaW5kIHByb3BlcnR5IFwiK3QrXCIgb3IgaXRzIF9vcHRpb25zIHN0cmluZyBhbmQgaXQgaXMgbm90IGEgYm9vbGVhblwiO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlW3RdLl9vcHRpb25zP19nZXRPcHRpb25zT2JqZWN0S2V5cyhlW3RdLl9vcHRpb25zKTpbITAsITFdfSxfbWFrZUNvbXB1dGVkRnVuY3Rpb249ZnVuY3Rpb24oZSx0LG4sbyxyLGEsaSl7aWYodm9pZCAwPT09ZSl7aWYodm9pZCAwPT09by51dGlscy51bndyYXBPYnNlcnZhYmxlKGkpLnR5cGUpdGhyb3cgY29uc29sZS5sb2coXCJUT0RPIEVSUk9SIEZvdW5kIGEgbm9uLXR5cGVkIGRlZiBcIixlLGkpLFwiRm91bmQgYSBub24tdHlwZWQgZGVmIFwiK2U7dmFyIGw9by51dGlscy51bndyYXBPYnNlcnZhYmxlKG8udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpKS50eXBlKTtcIm9iamVjdFwiIT10eXBlb2YoZT10W2xdKSYmY29uc29sZS5sb2coXCJUT0RPIEVSUk9SIEZvdW5kIGEgbm9uLW9iamVjdCBkZWYgXCIsZSxcImZvclwiLGwpfXZvaWQgMD09PXImJnZvaWQgMCE9PWEmJmEmJihyPWkpO3ZhciBzPVwiJHJvb3QuY29udGVudCgpLlwiLHU9ZS5fZ2xvYmFsU3R5bGVzO2lmKHZvaWQgMCE9PXUpZm9yKHZhciBwIGluIHUpaWYodS5oYXNPd25Qcm9wZXJ0eShwKSl7dmFyIGIsYyx2LGQ9XCIkcm9vdC5jb250ZW50KCkudGhlbWUoKS5zY2hlbWVcIjtpZih1W3BdLnN1YnN0cigwLHMubGVuZ3RoKSE9cyl0aHJvd1wiVU5FWFBFQ1RFRCBnbG9iYWxTdHlsZSBwYXRoIChcIit1W3BdK1wiKSBvdXRzaWRlIHNlbGZQYXRoIChcIitzK1wiKVwiO3Y9dVtwXS5zdWJzdHIocy5sZW5ndGgpLGM9cixkLnN1YnN0cigwLHMubGVuZ3RoKT09cz9iPWQuc3Vic3RyKHMubGVuZ3RoKTooY29uc29sZS5sb2coXCJJUyBUSElTIENPUlJFQ1Q/XCIsZCxzKSxiPWQpO2Zvcih2YXIgZj1jLGg9di5zcGxpdChcIigpLlwiKSxfPVwiXCIsZz0hMCxrPTA7azxoLmxlbmd0aDtrKyspYz1vLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYylbaFtrXV0sZz9cInRoZW1lXCI9PWhba10mJihnPSExKTooXy5sZW5ndGg+MCYmKF8rPVwiLlwiKSxfKz1oW2tdKTtmb3IodmFyIHc9Yi5zcGxpdChcIigpLlwiKSxtPTA7bTx3Lmxlbmd0aDttKyspZj1vLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZilbd1ttXV07Zm9yKHZhciBPPXAuc3BsaXQoXCIuXCIpLHk9aSxSPTA7UjxPLmxlbmd0aDtSKyspeT1vLnV0aWxzLnVud3JhcE9ic2VydmFibGUoeSlbT1tSXV07aWYoIW8uaXNPYnNlcnZhYmxlKHkpKXRocm93XCJVbmV4cGVjdGVkIG5vbiBvYnNlcnZhYmxlIHRhcmdldCBcIitwK1wiL1wiK187eS5fZGVmYXVsdENvbXB1dGVkPV9tYWtlQ29tcHV0ZWQoeSxjLCEwLGYsXyxuKX1pZih2b2lkIDAhPT1lLl92YXJpYW50KXtmb3IodmFyIEY9ZS5fdmFyaWFudC5zcGxpdChcIi5cIiksUz1pLGo9by51dGlscy51bndyYXBPYnNlcnZhYmxlKGkpLEM9MDtDPEYubGVuZ3RoO0MrKylTPW8udXRpbHMudW53cmFwT2JzZXJ2YWJsZShTKVtGW0NdXTtpZih2b2lkIDAhPT1TLl9kZWZhdWx0Q29tcHV0ZWQmJihjb25zb2xlLmxvZyhcIkZvdW5kIHZhcmlhbnQgb24gYSBzdHlsZSBwcm9wZXJ0eTogYmV3YXJlIHZhcmlhbnRzIHNob3VsZCBiZSBvbmx5IHVzZWQgb24gY29udGVudCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBtYXRjaCB0aGUgdGhlbWUgZmFsbGJhY2sgYmVoYXZpb3VyXCIsZS5fdmFyaWFudCksUz1TLl9kZWZhdWx0Q29tcHV0ZWQpLHZvaWQgMD09PVMpdGhyb3cgY29uc29sZS5sb2coXCJFUlJPUiBsb29raW5nIGZvciB2YXJpYW50IHRhcmdldFwiLGUuX3ZhcmlhbnQsaSksXCJFUlJPUiBsb29raW5nIGZvciB2YXJpYW50IHRhcmdldCBcIitlLl92YXJpYW50O2ouX25leHRWYXJpYW50PV9uZXh0VmFyaWFudEZ1bmN0aW9uLmJpbmQoUyxvLFMsX2dldFZhcmlhbnRzKGUpKX1mb3IodmFyIHggaW4gZSlpZihlLmhhc093blByb3BlcnR5KHgpKXt2YXIgUD1lW3hdO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBQJiZudWxsIT09UCYmdm9pZCAwIT09UC5fY29udGV4dCYmXCJibG9ja1wiPT1QLl9jb250ZXh0KXt2YXIgQj1yW3hdKCksRT1fbWFrZUNvbXB1dGVkRnVuY3Rpb24odFt4XSx0LG4sbyxyLGEsQik7aVt4XShFKX1lbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBQJiZudWxsIT09UCYmXCJibG9ja3NcIj09UC50eXBlKXtmb3IodmFyIEQsSSxULEE9clt4XSgpLFY9QS5ibG9ja3MoKSxVPTA7VTxWLmxlbmd0aDtVKyspRD1vLnV0aWxzLnVud3JhcE9ic2VydmFibGUoVltVXSksST1vLnV0aWxzLnVud3JhcE9ic2VydmFibGUoRC50eXBlKSxUPV9tYWtlQ29tcHV0ZWRGdW5jdGlvbih0W0ldLHQsbixvLHIsYSxEKSxWW1VdKFQpO3ZhciBXPUEuYmxvY2tzO19hdWdtZW50QmxvY2tzT2JzZXJ2YWJsZShXLF9ibG9ja0luc3RydW1lbnRGdW5jdGlvbi5iaW5kKEEsdm9pZCAwLHQsbixvLHZvaWQgMCxyLGEpKSxyW3hdLl93cmFwPV9tYWtlQmxvY2tzV3JhcC5iaW5kKHJbeF0sVy5faW5zdHJ1bWVudEJsb2NrKSxyW3hdLl91bndyYXA9X3Vud3JhcC5iaW5kKHJbeF0pfX1yZXR1cm4gaX0sX2F1Z21lbnRCbG9ja3NPYnNlcnZhYmxlPWZ1bmN0aW9uKGUsdCl7ZS5faW5zdHJ1bWVudEJsb2NrPXQsdm9pZCAwPT09ZS5vcmlnUHVzaCYmKGUub3JpZ1B1c2g9ZS5wdXNoLGUucHVzaD1fbWFrZVB1c2guYmluZChlKSxlLm9yaWdTcGxpY2U9ZS5zcGxpY2UsZS5zcGxpY2U9X21ha2VTcGxpY2UuYmluZChlKSl9LF9tYWtlQmxvY2tzV3JhcD1mdW5jdGlvbihlLHQpe3ZhciBuPWtvLnRvSlModCksbz1uLmJsb2NrcztuLmJsb2Nrcz1bXTt2YXIgcj13cmFwKG4pKCk7X2F1Z21lbnRCbG9ja3NPYnNlcnZhYmxlKHIuYmxvY2tzLGUpO2Zvcih2YXIgYT0wO2E8by5sZW5ndGg7YSsrKXt2YXIgaT1rby50b0pTKG9bYV0pO2kuaWQ9XCJibG9ja19cIithLHIuYmxvY2tzLnB1c2goaSl9dGhpcyhyKX0sX21ha2VQdXNoPWZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXRocm93XCJBcnJheSBwdXNoIHdpdGggbXVsdGlwbGUgYXJndW1lbnRzIG5vdCBpbXBsZW1lbnRlZFwiO2lmKGFyZ3VtZW50cy5sZW5ndGg+MCYma28uaXNPYnNlcnZhYmxlKGFyZ3VtZW50c1swXSkmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0uX3Vud3JhcD9hcmd1bWVudHNbMF09YXJndW1lbnRzWzBdLl91bndyYXAoKTpjb25zb2xlLmxvZyhcIldBUk46IHB1c2hpbmcgb2JzZXJ2YWJsZSB3aXRoIG5vIF91bndyYXAgZnVuY3Rpb24gKFRPRE8gcmVtb3ZlIG1lLCBleHBlY3RlZCBjb25kaXRpb24pXCIpKSxrby5pc09ic2VydmFibGUoYXJndW1lbnRzWzBdKSlyZXR1cm4gdGhpcy5vcmlnUHVzaC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGU9dGhpcy5faW5zdHJ1bWVudEJsb2NrKGFyZ3VtZW50c1swXSk7cmV0dXJuIHRoaXMub3JpZ1B1c2guYXBwbHkodGhpcyxbZV0pfSxfbWFrZVNwbGljZT1mdW5jdGlvbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg+Myl0aHJvd1wiQXJyYXkgc3BsaWNlIHdpdGggbXVsdGlwbGUgb2JqZWN0cyBub3QgaW1wbGVtZW50ZWRcIjtpZihhcmd1bWVudHMubGVuZ3RoPjImJmtvLmlzT2JzZXJ2YWJsZShhcmd1bWVudHNbMl0pJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgYXJndW1lbnRzWzJdLl91bndyYXA/YXJndW1lbnRzWzJdPWFyZ3VtZW50c1syXS5fdW53cmFwKCk6Y29uc29sZS5sb2coXCJXQVJOOiBzcGxpY2luZyBvYnNlcnZhYmxlIHdpdGggbm8gX3Vud3JhcCBmdW5jdGlvbiAoVE9ETyByZW1vdmUgbWUsIGV4cGVjdGVkIGNvbmRpdGlvbilcIikpLGFyZ3VtZW50cy5sZW5ndGg+MiYmIWtvLmlzT2JzZXJ2YWJsZShhcmd1bWVudHNbMl0pKXt2YXIgZT10aGlzLl9pbnN0cnVtZW50QmxvY2soYXJndW1lbnRzWzJdKTtyZXR1cm4gdGhpcy5vcmlnU3BsaWNlLmFwcGx5KHRoaXMsW2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sZV0pfXJldHVybiB0aGlzLm9yaWdTcGxpY2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxfYmxvY2tJbnN0cnVtZW50RnVuY3Rpb249ZnVuY3Rpb24oZSx0LG4sbyxyLGEsaSxsKXt2b2lkIDA9PT1yJiYocj1sKTt2YXIgcz13cmFwKHIpO3JldHVybiBzKF9tYWtlQ29tcHV0ZWRGdW5jdGlvbihlLHQsbixvLGEsaSxzKCkpKSxzLl91bndyYXA9X3Vud3JhcC5iaW5kKHMpLHN9LF93cmFwPWZ1bmN0aW9uKGUsdCl7dGhpcyhrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGUoa28sdCx2b2lkIDAsITApKSl9LF91bndyYXA9ZnVuY3Rpb24oKXtyZXR1cm4ga28udG9KUyh0aGlzKX0sX21vZGVsSW5zdHJ1bWVudD1mdW5jdGlvbihlLHQsbil7dmFyIG89X2Jsb2NrSW5zdHJ1bWVudEZ1bmN0aW9uLmJpbmQodm9pZCAwLHQsbixuLnRoZW1lcykscj1vKGtvLGUsdm9pZCAwLCEwKTtyZXR1cm4gci5fd3JhcD1fd3JhcC5iaW5kKHIsbyksci5fdW53cmFwPV91bndyYXAuYmluZChyKSxyfTttb2R1bGUuZXhwb3J0cz1fbW9kZWxJbnN0cnVtZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5keVlYQndaWEl1YW5NaVhTd2libUZ0WlhNaU9sc2lhMjhpTENKM2FXNWtiM2NpTENKbmJHOWlZV3dpTENKamIyNXpiMnhsSWl3aWNtVnhkV2x5WlNJc0luZHlZWEFpTENKMklpd2lkSGx3WlU5bWRpSXNJbU52Ym5OMGNuVmpkRzl5SWl3aVJHRjBaU0lzSWs5aWFtVmpkQ0lzSW5CeWIzUnZkSGx3WlNJc0luUnZVM1J5YVc1bklpd2lZMkZzYkNJc0luSWlMQ0p2WW5ObGNuWmhZbXhsUVhKeVlYa2lMQ0pzWlc1bmRHZ2lMQ0pwSWl3aWJDSXNJbkIxYzJnaUxDSjBJaXdpYXlJc0luZDJJaXdpYjJKelpYSjJZV0pzWlNJc0luUXlJaXdpWDJkbGRFOXdkR2x2Ym5OUFltcGxZM1JMWlhseklpd2liM0IwYVc5dWN5SXNJbTl3ZEdsdmJuTkRiM1Z3YkdWeklpd2ljM0JzYVhRaUxDSnZjSFJ6SWl3aWIzQjBJaXdpZEhKcGJTSXNJbDl0WVd0bFEyOXRjSFYwWldRaUxDSjBZWEpuWlhRaUxDSmtaV1lpTENKdWRXeHNTV1pGY1hWaGJDSXNJbk5qYUdWdFpWTmxiR1ZqZEc5eUlpd2lkR2hsYldWUVlYUm9JaXdpZEdobGJXVnpJaXdpWTI5dGNIVjBaV1FpTENKeVpXRmtJaXdpZG1Gc0lpd2ljMk5vWlcxbElpd2lkWFJwYkhNaUxDSjFibmR5WVhCUFluTmxjblpoWW14bElpd2lkM0pwZEdVaUxDSjJZV3gxWlNJc0ltUmxabFpoYkNJc0luQmxaV3RQWW5ObGNuWmhZbXhsSWl3aVkzVnljbVZ1ZENJc0lsOXVaWGgwVm1GeWFXRnVkRVoxYm1OMGFXOXVJaXdpY0hKdmNDSXNJblpoY21saGJuUnpJaXdpWTNWeWNtVnVkRlpoYkhWbElpd2lkMkZ5YmlJc0ltNWxlSFJXWVhKcFlXNTBJaXdpWDJkbGRGWmhjbWxoYm5Seklpd2lkbUZ5YVdGdWRGQnliM0FpTENKZmRtRnlhV0Z1ZENJc0lsOTNhV1JuWlhRaUxDSmZiM0IwYVc5dWN5SXNJbVZ5Y205eUlpd2lYMjFoYTJWRGIyMXdkWFJsWkVaMWJtTjBhVzl1SWl3aVpHVm1jeUlzSW5Sb2JYTWlMQ0pqYjI1MFpXNTBUVzlrWld3aUxDSnBjME52Ym5SbGJuUWlMQ0owZVhCbElpd2liRzluSWl3aWMyVnNabEJoZEdnaUxDSndjQ0lzSWw5bmJHOWlZV3hUZEhsc1pYTWlMQ0p3SWl3aWFHRnpUM2R1VUhKdmNHVnlkSGtpTENKelkyaGxiV1ZRWVhSb0lpd2lkbTBpTENKd1lYUm9JaXdpYzJOb1pXMWxVR0YwYUU5eWFXY2lMQ0p6ZFdKemRISWlMQ0p3WVhSb1VHRnlkSE1pTENKemEybHdJaXdpYzJOb1pXMWxVR0Z5ZEhNaUxDSnBNeUlzSW5SUVlYSjBjeUlzSW1reUlpd2lhWE5QWW5ObGNuWmhZbXhsSWl3aVgyUmxabUYxYkhSRGIyMXdkWFJsWkNJc0luQlFZWEowY3lJc0luQlVZWEpuWlhRaUxDSndVR0Z5Wlc1MElpd2lhVFFpTENKZmJtVjRkRlpoY21saGJuUWlMQ0ppYVc1a0lpd2ljSEp2Y0RJaUxDSmZZMjl1ZEdWNGRDSXNJbkJ5YjNCV2JTSXNJbTVsZDFadElpd2liMnhrUW14dlkyc2lMQ0ppYkc5amExUjVjR1VpTENKdVpYZENiRzlqYXlJc0ltMWhhVzVXYlNJc0ltSnNiMk5yYzFadElpd2lZbXh2WTJ0eklpd2lhV0lpTENKaWJHOWphM05QWW5NaUxDSmZZWFZuYldWdWRFSnNiMk5yYzA5aWMyVnlkbUZpYkdVaUxDSmZZbXh2WTJ0SmJuTjBjblZ0Wlc1MFJuVnVZM1JwYjI0aUxDSjFibVJsWm1sdVpXUWlMQ0pmZDNKaGNDSXNJbDl0WVd0bFFteHZZMnR6VjNKaGNDSXNJbDlwYm5OMGNuVnRaVzUwUW14dlkyc2lMQ0pmZFc1M2NtRndJaXdpYVc1emRISjFiV1Z1ZENJc0ltOXlhV2RRZFhOb0lpd2lYMjFoYTJWUWRYTm9JaXdpYjNKcFoxTndiR2xqWlNJc0luTndiR2xqWlNJc0lsOXRZV3RsVTNCc2FXTmxJaXdpYVc1d2RYUk5iMlJsYkNJc0ltMXZaR1ZzSWl3aWRHOUtVeUlzSW1sdWNIVjBJaXdpY21Weklpd2liMkpxSWl3aWFXUWlMQ0owYUdseklpd2lZWEpuZFcxbGJuUnpJaXdpWVhCd2JIa2lMQ0pwYm5OMGNuVnRaVzUwWldRaUxDSnJibTlqYTI5MWRDSXNJbk5sYkdZaUxDSnRiMlJsYkVOdmJuUmxiblFpTENKelpXeG1NaUlzSW5WdWQzSmhjSEJsWkNJc0lsOXRiMlJsYkVsdWMzUnlkVzFsYm5RaUxDSnRiMlJsYkVSbFppSXNJbDlwYm5OMGNuVnRaVzUwSWl3aWJXOWtkV3hsSWl3aVpYaHdiM0owY3lKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1lVRk5RU3hKUVVGSlFTeEhRVUYzUWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVZjc1IwRkJjMElzYjBKQlFWaERMRTlCUVhsQ1FTeFBRVUZYTEVkQlFVa3NTMEZEY0VkRExGRkJRVlZETEZGQlFWRXNjMEpCUlhSQ0xGTkJRVk5ETEV0QlFVdERMRWRCUTFvc1NVRkJTVU1zVTBGQmFVSkVMRVZCVlhKQ0xFZEJWR2RDTEZkQlFWcERMRWxCUTBWRUxFVkJRMFZCTEVWQlFVVkZMR0ZCUVdWRExFdEJRVTFHTEVWQlFWVXNUMEZEVXl4clFrRkJja05ITEU5QlFVOURMRlZCUVZWRExGTkJRVk5ETEV0QlFVdFFMRXRCUVhkQ1F5eEZRVUZWTEZOQlJURkZRU3hGUVVGVkxGRkJTVU1zVTBGQldFRXNSVUZCYjBJc1EwRkZkRUlzU1VGQlNVOHNSVUZCU1dRc1IwRkJSMlVzYTBKQlExZ3NTVUZCUzFRc1IwRkJhMElzU1VGQllrRXNSVUZCUlZVc1QwRkJZeXhQUVVGUFJpeEZRVU5xUXl4SlFVRkxMRWxCUVVsSExFVkJRVWtzUlVGQlIwTXNSVUZCU1Zvc1JVRkJSVlVzVDBGQlVVTXNSVUZCU1VNc1NVRkJTMFFzUlVGQlIwZ3NSVUZCUlVzc1MwRkJTMlFzUzBGQlMwTXNSVUZCUlZjc1MwRkRlRVFzVDBGQlQwZ3NSVUZGUml4SFFVRmxMRlZCUVZoUUxFVkJRWEZDTEVOQlJUbENMRWxCUVVsaExFVkJRVWtzUjBGRFVpeEpRVUZMTEVsQlFVbERMRXRCUVV0bUxFVkJRVWNzUTBGRFppeEpRVUZKWjBJc1JVRkJTMmhDTEVWQlFVVmxMRWRCUTFoRUxFVkJRVVZETEVkQlFVdG9RaXhMUVVGTGFVSXNSMEZGWkN4UFFVRlBkRUlzUjBGQlIzVkNMRmRCUVZkSUxFZEJSV2hDTEVkQlFXVXNXVUZCV0dJc1JVRkZWQ3hQUVVGUFJDeEZRVWxRTEVsQlFVbHJRaXhGUVVGTGVFSXNSMEZCUjNWQ0xHRkJSVm9zVDBGRVFVTXNSVUZCUjJ4Q0xFZEJRMGxyUWl4RlFVOVlMRWxCUVVsRExITkNRVUYzUWl4VFFVRlRReXhIUVVkdVF5eEpRVVpCTEVsQlFVbERMRVZCUVdsQ1JDeEZRVUZSUlN4TlFVRk5MRXRCUXk5Q1F5eEZRVUZQTEVkQlEwWmFMRVZCUVVrc1JVRkJSMEVzUlVGQlNWVXNSVUZCWlZnc1QwRkJVVU1zU1VGQlN5eERRVU01UXl4SlFVRkpZU3hGUVVGTlNDeEZRVUZsVml4SFFVRkhWeXhOUVVGTkxFdEJRMnhEUXl4RlFVRkxWaXhMUVVGTFZ5eEZRVUZKTEVkQlFVZERMRkZCUlc1Q0xFOUJRVTlHTEVkQlNVeEhMR05CUVdkQ0xGTkJRVk5ETEVWQlFWRkRMRVZCUVV0RExFVkJRV0ZETEVWQlFXZENReXhGUVVGWFF5eEhRV3REYUVZc1QwRnFRMVYwUXl4SFFVRkhkVU1zVTBGQlV5eERRVU53UWtNc1MwRkJVU3hYUVVOT0xFbEJRVWxETEVWQlFVMVNMRWxCUTFZc1IwRkJXU3hQUVVGU1VTeEZRVUZqTEVOQlEyaENMRWxCUVVsRExFVkJRVk14UXl4SFFVRkhNa01zVFVGQlRVTXNhVUpCUVdsQ1VpeEhRVU4yUXl4WlFVRnhRaXhKUVVGV1RTeEhRVUZ0UXl4VlFVRldRU3hGUVVNelFqRkRMRWRCUVVjeVF5eE5RVUZOUXl4cFFrRkJhVUpXTEVkQlJURkNTU3hGUVVGUFNTeEhRVUZSVEN4SFFVZDRRaXhQUVVGUFNTeEhRVWRZU1N4TlFVRlRMRk5CUVZORExFZEJRMmhDTEVsQlEwbERMRVZCUkVGTUxFVkJRVk14UXl4SFFVRkhNa01zVFVGQlRVTXNhVUpCUVdsQ1VpeEhRVkYyUXl4SFFVeEZWeXhQUVVSdFFpeEpRVUZXVEN4SFFVRnRReXhWUVVGV1FTeEZRVU42UWpGRExFZEJRVWN5UXl4TlFVRk5TeXhsUVVGbFpDeEhRVVY0UWtrc1JVRkJUMGtzUjBGQlVVd3NSMEZIY0VKR0xFVkJRMmxDUml4RlFVRnFRbUVzUjBGQlUwTXNSVUZCWlN4TFFVTm9Ra1FzVDBGRFVDeERRVU5NTEVsQlFVbEhMRVZCUVZWcVJDeEhRVUZITWtNc1RVRkJUVXNzWlVGQlpXWXNSMEZEYkVOaExFZEJRVk5ETEVkQlFYTkNMRTlCUVZwRkxFZEJRV3RDYUVJc1JVRkJUMkVzVVVGUmNFUkpMSEZDUVVGMVFpeFRRVUZUYkVRc1JVRkJTVzFFTEVWQlFVMURMRWRCU1RWRExFbEJTRUVzU1VGQlNVTXNSVUZCWlhKRUxFVkJRVWN5UXl4TlFVRk5ReXhwUWtGQmFVSlBMRWRCUjNCRGJFTXNSVUZCU1N4RlFVRkhRU3hGUVVGSmJVTXNSVUZCVTNCRExGRkJRMXBvUWl4RlFVRkhNa01zVFVGQlRVc3NaVUZCWlVrc1JVRkJVMjVETEV0QlF6VkNiME1zUlVGR1pYQkRMRXRCUzJwRFFTeEhRVUZMYlVNc1JVRkJVM0JETEZOQlEyaENZaXhSUVVGUmJVUXNTMEZCU3l4NVFrRkJNRUpJTEVWQlFVMUZMRVZCUVdORUxFZEJRek5FYmtNc1JVRkJTVzFETEVWQlFWTndReXhQUVVGVExFZEJSM2hDTEVsQlFVbDFReXhGUVVGamRFTXNSVUZCU1N4RlFVTnNRbk5ETEVkQlFXVklMRVZCUVZOd1F5eFRRVUZSZFVNc1JVRkJZeXhIUVVkc1JFb3NSVUZHWjBKdVJDeEZRVUZITWtNc1RVRkJUVXNzWlVGQlpVa3NSVUZCVTBjc1RVRkxMME5ETEdGQlFXVXNVMEZCVTNSQ0xFZEJRekZDTEVsQlFVbDFRaXhGUVVGamRrSXNSVUZCU1hkQ0xGTkJSWFJDTEVkQlFXZERMR2xDUVVGeVFuaENMRVZCUVVsMVFpeFRRVUZwUlN4SlFVRTNRblpDTEVWQlFVbDFRaXhIUVVGaFJTeFRRVUZwUlN4cFFrRkJPVUo2UWl4RlFVRkpkVUlzUjBGQllVY3NWVUZCYzBRc1dVRkJOMEl4UWl4RlFVRkpkVUlzUjBGQllVVXNVVUZGYUVzc1RVRkVRWGhFTEZGQlFWRXdSQ3hOUVVGTkxHbERRVUZyUTBvc1JVRkJZWFpDTEVWQlFVbDFRaXhKUVVNelJDeDNSRUZCTUVSQkxFVkJRV01zYTBSQlQyaEdMRTFCVEhkRExHbENRVUUzUW5aQ0xFVkJRVWwxUWl4SFFVRmhSeXhUUVVOVWJrTXNjMEpCUVhOQ1V5eEZRVUZKZFVJc1IwRkJZVWNzVlVGRmRrTXNSVUZCUXl4SFFVRk5MRWxCUzNoQ1JTeHpRa0ZCZDBJc1UwRkJVelZDTEVWQlFVczJRaXhGUVVGTlF5eEZRVUZOYUVVc1JVRkJTV2xGTEVWQlFXTkRMRVZCUVZjNVF5eEhRVU5xUml4UlFVRnJRaXhKUVVGUVl5eEZRVUZ2UWl4RFFVTTNRaXhSUVVGcFJDeEpRVUYwUTJ4RExFVkJRVWN5UXl4TlFVRk5ReXhwUWtGQmFVSjRRaXhIUVVGSEswTXNTMEZGZEVNc1RVRkVRV2hGTEZGQlFWRnBSU3hKUVVGSkxHOURRVUZ4UTJ4RExFVkJRVXRrTEVkQlEyaEVMSGxDUVVFeVFtTXNSVUZGYmtNc1NVRkJTV2xETEVWQlFVOXVSU3hGUVVGSE1rTXNUVUZCVFVNc2FVSkJRV2xDTlVNc1JVRkJSekpETEUxQlFVMURMR2xDUVVGcFFuaENMRWRCUVVjclF5eE5RVVV2UXl4cFFrRkVia0pxUXl4RlFVRk5Oa0lzUlVGQlMwa3NTMEZEYTBKb1JTeFJRVUZSYVVVc1NVRkJTU3h4UTBGQmMwTnNReXhGUVVGTExFMUJRVTlwUXl4UlFVZHNSU3hKUVVGb1FrWXNVVUZCYlVRc1NVRkJZa01zUjBGQk5FSkJMRWxCUXpORlJDeEZRVUZsTjBNc1IwRkhha0lzU1VGQlNXbEVMRVZCUVZjc2JVSkJSVmhETEVWQlFVdHdReXhGUVVGSmNVTXNZMEZEWWl4UlFVRnBRaXhKUVVGT1JDeEZRVU5VTEVsQlFVc3NTVUZCU1VVc1MwRkJTMFlzUlVGRFdpeEhRVUZKUVN4RlFVRkhSeXhsUVVGbFJDeEhRVUZKTEVOQlEzaENMRWxCUTBsRkxFVkJRVmxETEVWQlFVbERMRVZCUkdoQ1F5eEZRVUZwUWl4cFEwRkhja0lzUjBGQlNWQXNSVUZCUjBVc1IwRkJSMDBzVDBGQlR5eEZRVUZIVkN4RlFVRlRja1FzVTBGQlYzRkVMRVZCU1hSRExFdEJRVTBzWjBOQlFXdERReXhGUVVGSFJTeEhRVUZMTEhWQ1FVRjVRa2dzUlVGQlZ5eEpRVWh3Ums4c1JVRkJUMDRzUlVGQlIwVXNSMEZCUjAwc1QwRkJUMVFzUlVGQlUzSkVMRkZCUXpkQ01rUXNSVUZCUzFZc1JVRkpTRmtzUlVGQlpVTXNUMEZCVHl4RlFVRkhWQ3hGUVVGVGNrUXNVMEZCVjNGRUxFVkJReTlEU3l4RlFVRmhSeXhGUVVGbFF5eFBRVUZQVkN4RlFVRlRja1FzVTBGRk5VTmlMRkZCUVZGcFJTeEpRVUZKTEcxQ1FVRnZRbE1zUlVGQlowSlNMRWRCUTJoRVN5eEZRVUZoUnl4SFFWRm1MRWxCVEVFc1NVRkJTWHBETEVWQlFXbENkVU1zUlVGRmFrSkpMRVZCUVZsSUxFVkJRVXRvUkN4TlFVRk5MRTlCUTNaQ1V5eEZRVUZaTEVkQlExb3lReXhIUVVGUExFVkJRMFl2UkN4RlFVRkpMRVZCUVVkQkxFVkJRVWs0UkN4RlFVRlZMMFFzVDBGQlVVTXNTVUZEY0VNd1JDeEZRVUZMTTBVc1JVRkJSekpETEUxQlFVMURMR2xDUVVGcFFpdENMRWRCUVVsSkxFVkJRVlU1UkN4SlFVVjZReXRFTEVWQlEydENMRk5CUVdoQ1JDeEZRVUZWT1VRc1MwRkJaU3RFTEVkQlFVOHNTVUZGYUVNelF5eEZRVUZWY2tJc1QwRkJVeXhKUVVGSGNVSXNSMEZCWVN4TFFVTjJRMEVzUjBGQllUQkRMRVZCUVZVNVJDeEpRVXN6UWl4SlFVUkJMRWxCUVVsblJTeEZRVUZqVUN4RlFVRlhPVU1zVFVGQlRTeFBRVU14UW5ORUxFVkJRVXNzUlVGQlIwRXNSVUZCUzBRc1JVRkJXV3BGTEU5QlFWRnJSU3hKUVVONFF6bERMRVZCUVdsQ2NFTXNSVUZCUnpKRExFMUJRVTFETEdsQ1FVRnBRbElzUjBGQlowSTJReXhGUVVGWlF5eEpRVTE2UlN4SlFVaEJMRWxCUTBsRExFVkJRVk5ZTEVWQlFVVTFReXhOUVVGTkxFdEJRMnBDU3l4RlFVRlRZaXhGUVVOS1owVXNSVUZCU3l4RlFVRkhRU3hGUVVGTFJDeEZRVUZQYmtVc1QwRkJVVzlGTEVsQlEyNURia1FzUlVGQlUycERMRVZCUVVjeVF5eE5RVUZOUXl4cFFrRkJhVUpZTEVkQlFWRnJSQ3hGUVVGUFF5eEpRVWR3UkN4SlFVRkxjRVlzUlVGQlIzRkdMR0ZCUVdGd1JDeEhRVUZUTEV0QlFVMHNiME5CUVhORGRVTXNSVUZCU1N4SlFVRk5ia01zUlVGRmNFWktMRVZCUVU5eFJDeHBRa0ZCYlVKMFJDeGpRVUZqUXl4RlFVRlJNRU1zUjBGVU9VSXNSVUZUSzBOMlF5eEZRVUZuUWtNc1JVRkJWekpDTEVkQlIyeEhMRkZCUVRKQ0xFbEJRV2hDT1VJc1JVRkJTWGRDTEZOQlFYbENMRU5CUzNSRExFbEJTa0VzU1VGQlNUWkNMRVZCUVZOeVJDeEZRVUZKZDBJc1UwRkJVemxDTEUxQlFVMHNTMEZGTlVJMFJDeEZRVUZWY0VVc1JVRkRWbkZGTEVWQlFWVjZSaXhGUVVGSE1rTXNUVUZCVFVNc2FVSkJRV2xDZUVJc1IwRkRMMEp6UlN4RlFVRkxMRVZCUVVkQkxFVkJRVXRJTEVWQlFVOTJSU3hQUVVGUk1FVXNTVUZEYmtOR0xFVkJRVlY0Uml4RlFVRkhNa01zVFVGQlRVTXNhVUpCUVdsQ05FTXNSMEZCVTBRc1JVRkJUMGNzU1VGTmRFUXNVVUZLZFVNc1NVRkJOVUpHTEVWQlFWRkdMRzFDUVVOcVFtNUdMRkZCUVZGcFJTeEpRVUZKTEhGS1FVRnpTbXhETEVWQlFVbDNRaXhWUVVOMFN6aENMRVZCUVZWQkxFVkJRVkZHTEhWQ1FVVkZMRWxCUVZoRkxFVkJSVlFzVFVGRVFYSkdMRkZCUVZGcFJTeEpRVUZKTEcxRFFVRnZRMnhETEVWQlFVbDNRaXhUUVVGVmRFTXNSMEZEZUVRc2IwTkJRWE5EWXl4RlFVRkpkMElzVTBGRmJFUXJRaXhGUVVGUlJTeGhRVUZsZWtNc2NVSkJRWEZDTUVNc1MwRkJTMG9zUlVGQlUzaEdMRVZCUVVsM1JpeEZRVUZUYUVNc1lVRkJZWFJDTEVsQlIzUkdMRWxCUVVzc1NVRkJTVEpFTEV0QlFWTXpSQ3hGUVVOb1FpeEhRVUZKUVN4RlFVRkpkVU1zWlVGQlpXOUNMRWRCUVZFc1EwRkROMElzU1VGQlNYQkVMRVZCUVUxUUxFVkJRVWt5UkN4SFFVTmtMRWRCUVd0Q0xHbENRVUZRY0VRc1IwRkJNa0lzVDBGQlVrRXNVVUZCZFVNc1NVRkJhRUpCTEVWQlFVbHhSQ3hWUVVFeVF5eFRRVUZvUW5KRUxFVkJRVWx4UkN4VFFVRnhRaXhEUVVNelJ5eEpRVUZKUXl4RlFVRlRPVUlzUlVGQllUUkNMRXRCUTNSQ1J5eEZRVUZSYkVNc2MwSkJRWE5DUXl4RlFVRkxPRUlzUjBGQlVUbENMRVZCUVUxRExFVkJRVTFvUlN4RlFVRkphVVVzUlVGQlkwTXNSVUZCVnpaQ0xFZEJRM2hHTTBVc1JVRkJSWGxGTEVkQlFVOUhMRkZCUTBvc1IwRkJhMElzYVVKQlFWQjJSQ3hIUVVFeVFpeFBRVUZTUVN4SFFVRTBRaXhWUVVGYVFTeEZRVUZKTUVJc1MwRkJhMElzUTBGSmVrVXNTVUZJUVN4SlFVVkpPRUlzUlVGQlZVTXNSVUZCVjBNc1JVRkdja0pETEVWQlFWTnVReXhGUVVGaE5FSXNTMEZEZEVKUkxFVkJRVmRFTEVWQlFVOUZMRk5CUldKRExFVkJRVXNzUlVGQlIwRXNSVUZCUzBZc1JVRkJVM0pHTEU5QlFWRjFSaXhKUVVOeVEwNHNSVUZCVjJwSExFVkJRVWN5UXl4TlFVRk5ReXhwUWtGQmFVSjVSQ3hGUVVGVFJTeEpRVU01UTB3c1JVRkJXV3hITEVWQlFVY3lReXhOUVVGTlF5eHBRa0ZCYVVKeFJDeEZRVUZUT1VJc1RVRkRMME5uUXl4RlFVRlhja01zYzBKQlFYTkNReXhGUVVGTGJVTXNSMEZCV1c1RExFVkJRVTFETEVWQlFVMW9SU3hGUVVGSmFVVXNSVUZCWTBNc1JVRkJWeXRDTEVkQlF6TkdTU3hGUVVGVFJTeEhRVUZKU2l4SFFVZG1MRWxCUVVsTExFVkJRVmxLTEVWQlFVOUZMRTlCUlhaQ1J5eDVRa0ZCZVVKRUxFVkJRVmRGTEhsQ1FVRjVRbVFzUzBGQlMxRXNUMEZCVVU4c1JVRkJWelZETEVWQlFVMURMRVZCUVUxb1JTeFBRVUZKTWtjc1JVRkJWekZETEVWQlFXTkRMRWxCUlRsSVJDeEZRVUZoTkVJc1IwRkJUMlVzVFVGQlVVTXNaMEpCUVdkQ2FrSXNTMEZCU3pOQ0xFVkJRV0UwUWl4SFFVRlJWeXhGUVVGVlRTeHJRa0ZEYUVZM1F5eEZRVUZoTkVJc1IwRkJUMnRDTEZGQlFWVkJMRkZCUVZGdVFpeExRVUZMTTBJc1JVRkJZVFJDTEV0QlNUbEVMRTlCUVU5NlJTeEhRVWRNY1VZc2VVSkJRVEpDTEZOQlFWTkVMRVZCUVZkUkxFZEJRMnBFVWl4RlFVRlZUU3hwUWtGQmJVSkZMRTlCUTBrc1NVRkJkRUpTTEVWQlFWVlRMRmRCUTI1Q1ZDeEZRVUZWVXl4VFFVRlhWQ3hGUVVGVmNrWXNTMEZETDBKeFJpeEZRVUZWY2tZc1MwRkJUeXRHTEZWQlFWVjBRaXhMUVVGTFdTeEhRVU5vUTBFc1JVRkJWVmNzVjBGQllWZ3NSVUZCVlZrc1QwRkRha05hTEVWQlFWVlpMRTlCUVZORExGbEJRVmw2UWl4TFFVRkxXU3hMUVVsd1Ewc3NaMEpCUVd0Q0xGTkJRVk5ITEVWQlFWbE5MRWRCUTNwRExFbEJRVWxETEVWQlFWRjJTQ3hIUVVGSGQwZ3NTMEZCUzBZc1IwRkRhRUpITEVWQlFWRkdMRVZCUVUxcVFpeFBRVU5zUW1sQ0xFVkJRVTFxUWl4UFFVRlRMRWRCUTJZc1NVRkJTVzlDTEVWQlFVMXlTQ3hMUVVGTGEwZ3NSVUZCVEd4SUxFZEJRMVp2Unl4NVFrRkJlVUpwUWl4RlFVRkpjRUlzVDBGQlVWVXNSMEZEY2tNc1NVRkJTeXhKUVVGSkwwWXNSVUZCU1N4RlFVRkhRU3hGUVVGSmQwY3NSVUZCVFhwSExFOUJRVkZETEVsQlFVc3NRMEZEY2tNc1NVRkJTVEJITEVWQlFVMHpTQ3hIUVVGSGQwZ3NTMEZCUzBNc1JVRkJUWGhITEVsQlJYaENNRWNzUlVGQlNVTXNSMEZCU3l4VFFVRlhNMGNzUlVGRGNFSjVSeXhGUVVGSmNFSXNUMEZCVDI1R0xFdEJRVXQzUnl4SFFVVnNRa1VzUzBGQlMwZ3NTVUZIU0ZJc1ZVRkJXU3hYUVVOa0xFZEJRVWxaTEZWQlFWVTVSeXhQUVVGVExFVkJRVWNzUzBGQlRTeHhSRUZUYUVNc1IwRlFTVGhITEZWQlFWVTVSeXhQUVVGVExFZEJRVXRvUWl4SFFVRkhjVVlzWVVGQllYbERMRlZCUVZVc1RVRkRha0lzYlVKQlFYaENRU3hWUVVGVkxFZEJRVWRtTEZGQlEzUkNaU3hWUVVGVkxFZEJRVXRCTEZWQlFWVXNSMEZCUjJZc1ZVRkZOVUkxUnl4UlFVRlJhVVVzU1VGQlNTd3lSa0ZIV0hCRkxFZEJRVWR4Uml4aFFVRmhlVU1zVlVGQlZTeEpRVWszUWl4UFFVRlBSQ3hMUVVGTFdpeFRRVUZUWXl4TlFVRk5SaXhMUVVGTlF5eFhRVWhxUXl4SlFVRkpSU3hGUVVGbFNDeExRVUZMWml4cFFrRkJhVUpuUWl4VlFVRlZMRWxCUTI1RUxFOUJRVTlFTEV0QlFVdGFMRk5CUVZOakxFMUJRVTFHTEV0QlFVMHNRMEZCUTBjc1MwRk5iRU5ZTEZsQlFXTXNWMEZEYUVJc1IwRkJTVk1zVlVGQlZUbEhMRTlCUVZNc1JVRkJSeXhMUVVGTkxIRkVRVkZvUXl4SFFWQkpPRWNzVlVGQlZUbEhMRTlCUVZNc1IwRkJTMmhDTEVkQlFVZHhSaXhoUVVGaGVVTXNWVUZCVlN4TlFVTnFRaXh0UWtGQmVFSkJMRlZCUVZVc1IwRkJSMllzVVVGRGRFSmxMRlZCUVZVc1IwRkJTMEVzVlVGQlZTeEhRVUZIWml4VlFVVTFRalZITEZGQlFWRnBSU3hKUVVGSkxEUkdRVWRhTUVRc1ZVRkJWVGxITEU5QlFWTXNTVUZCVFdoQ0xFZEJRVWR4Uml4aFFVRmhlVU1zVlVGQlZTeEpRVUZMTEVOQlF6RkVMRWxCUVVsRkxFVkJRV1ZJTEV0QlFVdG1MR2xDUVVGcFFtZENMRlZCUVZVc1NVRkRia1FzVDBGQlQwUXNTMEZCUzFZc1YwRkJWMWtzVFVGQlRVWXNTMEZCVFN4RFFVRkRReXhWUVVGVkxFZEJRVWxCTEZWQlFWVXNSMEZCU1VVc1NVRkZhRVVzVDBGQlQwZ3NTMEZCUzFZc1YwRkJWMWtzVFVGQlRVWXNTMEZCVFVNc1dVRkxia053UWl4NVFrRkJNa0lzVTBGQlUzaEZMRVZCUVVzMlFpeEZRVUZOZWtJc1JVRkJVVEpHTEVWQlFWVkRMRVZCUVUxRExFVkJRV05xUlN4RlFVRlhhMFVzVVVGRkwwVXNTVUZCVWtZc1NVRkJjVUpCTEVWQlFVOUZMRWRCUlhaRExFbEJRVWxXTEVWQlFVMXlTQ3hMUVVGTE5rZ3NSMEZMWml4UFFVaEJVaXhGUVVGSk5VUXNjMEpCUVhOQ05VSXNSVUZCU3paQ0xFVkJRVTE2UWl4RlFVRlJNa1lzUlVGQlZVVXNSVUZCWTJwRkxFVkJRVmQzUkN4TlFVVm9Sa0VzUlVGQlNWZ3NVVUZCVlVFc1VVRkJVVzVDTEV0QlFVczRRaXhIUVVOd1FrRXNSMEZIVEdRc1RVRkJVU3hUUVVGVFNTeEZRVUZaY1VJc1IwRkZMMEpTTEV0QlJHbENOMGdzUjBGQlJ6SkRMRTFCUVUxRExHbENRVUZwUW05RkxFVkJRVmRvU0N4SFFVRkpjVWtzVDBGQlZ6RkNMRWRCUVZjc1RVRkpPVVZKTEZGQlFWVXNWMEZEV2l4UFFVRlBMMGNzUjBGQlIzZElMRXRCUVV0TExFOUJSMkpUTEdsQ1FVRnRRaXhUUVVGVFppeEZRVUZQWjBJc1JVRkJWWGhGTEVkQlF5OURMRWxCUVVsNVJTeEZRVUZqT1VJc2VVSkJRWGxDWkN4VlFVRkxaU3hGUVVGWE5FSXNSVUZCVlhoRkxFVkJRVTFCTEVWQlFXRXNVVUZEY0VZeVJDeEZRVUZOWXl4RlFVRlplRWtzUjBGQlNYVklMRTlCUVU5YUxFZEJRVmNzUjBGSk5VTXNUMEZHUVdVc1JVRkJTV1FzVFVGQlVVRXNUVUZCVFdoQ0xFdEJRVXM0UWl4RlFVRkxZeXhIUVVNMVFtUXNSVUZCU1Znc1VVRkJWVUVzVVVGQlVXNUNMRXRCUVVzNFFpeEhRVU53UWtFc1IwRkhWR1VzVDBGQlQwTXNVVUZCVlVvaUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwyTnZiblpsY25SbGNpOTNjbUZ3Y0dWeUxtcHpJbjA9IiwidmFyIHRpbnljb2xvcj1yZXF1aXJlKFwidGlueWNvbG9yMlwiKTtmdW5jdGlvbiBDb2xvcih0KXt0aGlzLmdldEJyaWdodG5lc3M9ZnVuY3Rpb24obil7cmV0dXJuIHQobikuZ2V0QnJpZ2h0bmVzcygpfSx0aGlzLmlzTGlnaHQ9ZnVuY3Rpb24obil7cmV0dXJuIHQobikuaXNMaWdodCgpfSx0aGlzLmlzRGFyaz1mdW5jdGlvbihuKXtyZXR1cm4gdChuKS5pc0RhcmsoKX0sdGhpcy5nZXRMdW1pbmFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHQobikuZ2V0THVtaW5hbmNlKCl9LHRoaXMubGlnaHRlbj1mdW5jdGlvbihuLGkpe3JldHVybiB0KG4pLmxpZ2h0ZW4oaSkudG9IZXhTdHJpbmcoKX0sdGhpcy5icmlnaHRlbj1mdW5jdGlvbihuLGkpe3JldHVybiB0KG4pLmJyaWdodGVuKGkpLnRvSGV4U3RyaW5nKCl9LHRoaXMuZGFya2VuPWZ1bmN0aW9uKG4saSl7cmV0dXJuIHQobikuZGFya2VuKGkpLnRvSGV4U3RyaW5nKCl9LHRoaXMuZGVzYXR1cmF0ZT1mdW5jdGlvbihuLGkpe3JldHVybiB0KG4pLmRlc2F0dXJhdGUoaSkudG9IZXhTdHJpbmcoKX0sdGhpcy5zYXR1cmF0ZT1mdW5jdGlvbihuLGkpe3JldHVybiB0KG4pLnNhdHVyYXRlKGkpLnRvSGV4U3RyaW5nKCl9LHRoaXMuZ3JleXNjYWxlPWZ1bmN0aW9uKG4pe3JldHVybiB0KG4pLmdyZXlzY2FsZSgpLnRvSGV4U3RyaW5nKCl9LHRoaXMuc3Bpbj1mdW5jdGlvbihuLGkpe3JldHVybiB0KG4pLnNwaW4oaSkudG9IZXhTdHJpbmcoKX0sdGhpcy5jb21wbGVtZW50PWZ1bmN0aW9uKG4pe3JldHVybiB0KG4pLmNvbXBsZW1lbnQoKS50b0hleFN0cmluZygpfSx0aGlzLm1peD10Lm1peCx0aGlzLnJlYWRhYmlsaXR5PXQucmVhZGFiaWxpdHksdGhpcy5pc1JlYWRhYmxlPXQuaXNSZWFkYWJsZSx0aGlzLm1vc3RSZWFkYWJsZT10Lm1vc3RSZWFkYWJsZX12YXIgY29sb3JQbHVnaW49ZnVuY3Rpb24odCl7Z2xvYmFsLkNvbG9yPW5ldyBDb2xvcih0aW55Y29sb3IpfTttb2R1bGUuZXhwb3J0cz1jb2xvclBsdWdpbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltTnZiRzl5TG1weklsMHNJbTVoYldWeklqcGJJblJwYm5samIyeHZjaUlzSW5KbGNYVnBjbVVpTENKRGIyeHZjaUlzSW5Sb2FYTWlMQ0puWlhSQ2NtbG5hSFJ1WlhOeklpd2lZMjlzYjNJaUxDSnBjMHhwWjJoMElpd2lhWE5FWVhKcklpd2laMlYwVEhWdGFXNWhibU5sSWl3aWJHbG5hSFJsYmlJc0ltRnRiM1Z1ZENJc0luUnZTR1Y0VTNSeWFXNW5JaXdpWW5KcFoyaDBaVzRpTENKa1lYSnJaVzRpTENKa1pYTmhkSFZ5WVhSbElpd2ljMkYwZFhKaGRHVWlMQ0puY21WNWMyTmhiR1VpTENKemNHbHVJaXdpWTI5dGNHeGxiV1Z1ZENJc0ltMXBlQ0lzSW5KbFlXUmhZbWxzYVhSNUlpd2lhWE5TWldGa1lXSnNaU0lzSW0xdmMzUlNaV0ZrWVdKc1pTSXNJbU52Ykc5eVVHeDFaMmx1SWl3aWRtMGlMQ0puYkc5aVlXd2lMQ0p0YjJSMWJHVWlMQ0psZUhCdmNuUnpJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3hKUVVGSlFTeFZRVUZaUXl4UlFVRlJMR05CUlhoQ0xGTkJRVk5ETEUxQlFVMUdMRWRCUTJKSExFdEJRVXRETEdOQlFXZENMRk5CUVZORExFZEJRelZDTEU5QlFVOU1MRVZCUVZWTExFZEJRVTlFTEdsQ1FVVXhRa1FzUzBGQlMwY3NVVUZCVlN4VFFVRlRSQ3hIUVVOMFFpeFBRVUZQVEN4RlFVRlZTeXhIUVVGUFF5eFhRVVV4UWtnc1MwRkJTMGtzVDBGQlV5eFRRVUZUUml4SFFVTnlRaXhQUVVGUFRDeEZRVUZWU3l4SFFVRlBSU3hWUVVVeFFrb3NTMEZCUzBzc1lVRkJaU3hUUVVGVFNDeEhRVU16UWl4UFFVRlBUQ3hGUVVGVlN5eEhRVUZQUnl4blFrRkpNVUpNTEV0QlFVdE5MRkZCUVZVc1UwRkJVMG9zUlVGQlQwc3NSMEZETjBJc1QwRkJUMVlzUlVGQlZVc3NSMEZCVDBrc1VVRkJVVU1zUjBGQlVVTXNaVUZGTVVOU0xFdEJRVXRUTEZOQlFWY3NVMEZCVTFBc1JVRkJUMHNzUjBGRE9VSXNUMEZCVDFZc1JVRkJWVXNzUjBGQlQwOHNVMEZCVTBZc1IwRkJVVU1zWlVGRk0wTlNMRXRCUVV0VkxFOUJRVk1zVTBGQlUxSXNSVUZCVDBzc1IwRkROVUlzVDBGQlQxWXNSVUZCVlVzc1IwRkJUMUVzVDBGQlQwZ3NSMEZCVVVNc1pVRkZla05TTEV0QlFVdFhMRmRCUVdFc1UwRkJVMVFzUlVGQlQwc3NSMEZEYUVNc1QwRkJUMVlzUlVGQlZVc3NSMEZCVDFNc1YwRkJWMG9zUjBGQlVVTXNaVUZGTjBOU0xFdEJRVXRaTEZOQlFWY3NVMEZCVTFZc1JVRkJUMHNzUjBGRE9VSXNUMEZCVDFZc1JVRkJWVXNzUjBGQlQxVXNVMEZCVTB3c1IwRkJVVU1zWlVGRk0wTlNMRXRCUVV0aExGVkJRVmtzVTBGQlUxZ3NSMEZEZUVJc1QwRkJUMHdzUlVGQlZVc3NSMEZCVDFjc1dVRkJXVXdzWlVGRmRFTlNMRXRCUVV0akxFdEJRVThzVTBGQlUxb3NSVUZCVDBzc1IwRkRNVUlzVDBGQlQxWXNSVUZCVlVzc1IwRkJUMWtzUzBGQlMxQXNSMEZCVVVNc1pVRkZka05TTEV0QlFVdGxMRmRCUVdFc1UwRkJVMklzUjBGRGVrSXNUMEZCVDB3c1JVRkJWVXNzUjBGQlQyRXNZVUZCWVZBc1pVRkhka05TTEV0QlFVdG5RaXhKUVVGTmJrSXNSVUZCVlcxQ0xFbEJRM0pDYUVJc1MwRkJTMmxDTEZsQlFXTndRaXhGUVVGVmIwSXNXVUZETjBKcVFpeExRVUZMYTBJc1YwRkJZWEpDTEVWQlFWVnhRaXhYUVVNMVFteENMRXRCUVV0dFFpeGhRVUZsZEVJc1JVRkJWWE5DTEdGQlIyaERMRWxCUVVsRExGbEJRV01zVTBGQlUwTXNSMEZEZWtKRExFOUJRVTkyUWl4TlFVRlJMRWxCUVVsQkxFMUJRVTFHTEZsQlJ6TkNNRUlzVDBGQlQwTXNVVUZCVlVvaUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwyVjRkQzlqYjJ4dmNpNXFjeUo5IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciAkICAgICAgID0gcmVxdWlyZSgnanF1ZXJ5JylcbnZhciBrbyAgICAgID0gcmVxdWlyZSgna25vY2tvdXQnKVxudmFyIGNvbnNvbGUgPSByZXF1aXJlKCdjb25zb2xlLWJyb3dzZXJpZnknKVxuXG5mdW5jdGlvbiBoYW5kbGVNYWlsaW5nTmFtZSh2aWV3TW9kZWwpIHtcbiAgdmFyIG9yaWdpbmFsVmFsdWVcbiAgdmlld01vZGVsLnRpdGxlTW9kZSAgICAgICAgID0ga28ub2JzZXJ2YWJsZSgnc2hvdycpXG4gIHZpZXdNb2RlbC5tZXRhZGF0YS5uYW1lICAgICA9IGtvLm9ic2VydmFibGUodmlld01vZGVsLm1ldGFkYXRhLm5hbWUpXG5cbiAgdmlld01vZGVsLm1haWxpbmdOYW1lICAgICAgID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZpZXdNb2RlbC5tZXRhZGF0YS5uYW1lKClcbiAgfSwgdmlld01vZGVsKVxuXG4gIHZpZXdNb2RlbC5lbmFibGVFZGl0TWFpbGluZ05hbWUgID0gZnVuY3Rpb24gKGRhdGEsIGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coJ2VuYWJsZUVkaXRNYWlsaW5nTmFtZScsIGRhdGEpXG4gICAgb3JpZ2luYWxWYWx1ZSA9IHZpZXdNb2RlbC5tZXRhZGF0YS5uYW1lKClcbiAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdlZGl0JylcbiAgfVxuXG4gIHZpZXdNb2RlbC5jYW5jZWxFZGl0TWFpbGluZ05hbWUgID0gZnVuY3Rpb24gKGRhdGEsIGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coJ2NhbmNlbEVkaXRNYWlsaW5nTmFtZScpXG4gICAgdmlld01vZGVsLm1ldGFkYXRhLm5hbWUob3JpZ2luYWxWYWx1ZSlcbiAgICBvcmlnaW5hbFZhbHVlID0gJydcbiAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdzaG93JylcbiAgfVxuXG4gIHZpZXdNb2RlbC5zYXZlRWRpdE1haWxpbmdOYW1lICA9IGZ1bmN0aW9uIChkYXRhLCBldmVudCkge1xuICAgIGNvbnNvbGUubG9nKCdzYXZlRWRpdE1haWxpbmdOYW1lJywgdmlld01vZGVsLm1ldGFkYXRhLm5hbWUoKSlcbiAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdzYXZpbmcnKVxuICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KCdlZGl0LXRpdGxlLWFqYXgtcGVuZGluZycpKVxuXG4gICAgJC5hamF4KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAgICB2aWV3TW9kZWwubWV0YWRhdGEudXJsLnVwZGF0ZSxcbiAgICAgIGRhdGE6ICAge1xuICAgICAgICBuYW1lOiB2aWV3TW9kZWwubWV0YWRhdGEubmFtZSgpLFxuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChtb3NhaWNvTWFpbGluZykge1xuICAgICAgICB2aWV3TW9kZWwubWV0YWRhdGEubmFtZSggbW9zYWljb01haWxpbmcubWV0YS5uYW1lIClcbiAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLnN1Y2Nlc3Modmlld01vZGVsLnQoJ2VkaXQtdGl0bGUtYWpheC1zdWNjZXNzJykpXG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdlZGl0LXRpdGxlLWFqYXgtZmFpbCcpKVxuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9yaWdpbmFsVmFsdWUgPSAnJ1xuICAgICAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdzaG93JylcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZU1haWxpbmdOYW1lXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgc2x1Z0ZpbGVuYW1lID0gcmVxdWlyZSgnLi4vLi4vLi4vc2hhcmVkL3NsdWctZmlsZW5hbWUuanMnKVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdm9pZGxhYnMvbW9zYWljby93aWtpL01vc2FpY28tUGx1Z2luc1xuXG4vLy8vLy9cbi8vIFZJRVctTU9ERUwgUExVR0lOU1xuLy8vLy8vXG5cbmNvbnN0IHNlcnZlclN0b3JhZ2UgPSByZXF1aXJlKCcuL2N1c3RvbS1zZXJ2ZXItc3RvcmFnZScpXG5jb25zdCBlZGl0VGl0bGUgPSByZXF1aXJlKCcuL2N1c3RvbS1lZGl0LXRpdGxlJylcbmxldCB0ZXh0RWRpdG9yID0gcmVxdWlyZSgnLi9jdXN0b20tdGV4dC1lZGl0b3InKVxuY29uc3QgZ2FsbGVyeSA9IHJlcXVpcmUoJy4vY3VzdG9tLWdhbGxlcnknKVxuY29uc3QgcmVtb3ZlSW1hZ2UgPSByZXF1aXJlKCcuL2N1c3RvbS1yZW1vdmUtZ2FsbGVyeS1pbWFnZScpXG4vLyB3aWRnZXRzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdm9pZGxhYnMvbW9zYWljby93aWtpL01vc2FpY28tUGx1Z2lucyN3aWRnZXQtcGx1Z2luc1xuY29uc3Qgd2lkZ2V0QmdpbWFnZSA9IHJlcXVpcmUoJy4vY3VzdG9tLXdpZGdldC1iZ2ltYWdlJylcblxuY29uc3Qgc2V0RWRpdG9ySWNvbiA9IG9wdHMgPT4gdmlld01vZGVsID0+IHtcbiAgdmlld01vZGVsLmxvZ29QYXRoID0gZmFsc2VcbiAgdmlld01vZGVsLmxvZ29VcmwgPSBmYWxzZVxuICB2aWV3TW9kZWwubG9nb0FsdCA9IGZhbHNlXG4gIHZpZXdNb2RlbC5icmFuZE5hbWUgPSBvcHRzLmJyYW5kTmFtZVxufVxuXG5mdW5jdGlvbiBleHRlbmRWaWV3TW9kZWwob3B0cywgY3VzdG9tRXh0ZW5zaW9ucykge1xuICBjdXN0b21FeHRlbnNpb25zLnB1c2goc2VydmVyU3RvcmFnZSlcbiAgY3VzdG9tRXh0ZW5zaW9ucy5wdXNoKHNldEVkaXRvckljb24ob3B0cykpXG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaChlZGl0VGl0bGUpXG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaChnYWxsZXJ5KG9wdHMpKVxuICBjdXN0b21FeHRlbnNpb25zLnB1c2gocmVtb3ZlSW1hZ2UpXG4gIC8vIHdpZGdldCBzaG91bGQgYmUgZGlmZmVyZW50aWF0aW5nIG9mIFZNIGV4dGVuc2lvbnMgYnlcbiAgLy8gdGVtcGxhdGUtbG9hZGVyLmpzI3BsdWdpbnNDYWxsXG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaCh3aWRnZXRCZ2ltYWdlKG9wdHMpKVxufVxuXG4vLy8vLy9cbi8vIEtOT0NLT1VUIEVYVEVORFxuLy8vLy8vXG5cbmZ1bmN0aW9uIHRlbXBsYXRlVXJsQ29udmVydGVyKG9wdHMpIHtcbiAgdmFyIGFzc2V0cyA9IG9wdHMubWV0YWRhdGEuYXNzZXRzIHx8IHt9XG4gIHJldHVybiBmdW5jdGlvbiBjdXN0b21UZW1wbGF0ZVVybENvbnZlcnRlcih1cmwpIHtcbiAgICBpZiAoIXVybCkgcmV0dXJuIG51bGxcbiAgICBjb25zb2xlLmxvZygnY3VzdG9tVGVtcGxhdGVVcmxDb252ZXJ0ZXInLCB1cmwpXG4gICAgLy8gaGFuZGxlOiBbdW5zdWJzY3JpYmVfbGlua10gb3IgbWFpbHRvOlttYWlsXVxuICAgIGlmICgvXFxdJC8udGVzdCh1cmwpKSByZXR1cm4gbnVsbFxuICAgIC8vIGhhbmRsZSBhYnNvbHV0ZSB1cmw6IGh0dHBcbiAgICBpZiAoL15odHRwLy50ZXN0KHVybCkpIHJldHVybiBudWxsXG4gICAgLy8gaGFuZGxlIEVTUCB0YWdzOiBpbiBVUkwgPCVcbiAgICBpZiAoLzwlLy50ZXN0KHVybCkpIHJldHVybiBudWxsXG4gICAgLy8gaGFuZGxlIG90aGVyIHVybHM6IGltZy9zb2NpYWxfZGVmL3R3aXR0ZXJfb2sucG5nXG4gICAgdmFyIHVybFJlZ2V4cCA9IC8oW15cXC9dKikkL1xuICAgIHZhciBleHRlbnRpb25SZWdleHAgPSAvXFwuWzAtOWEtel0rJC9cbiAgICAvLyBhcyBpdCBpcyBkb25lLCBhbGwgZmlsZXMgYXJlIGZsYXR0ZW4gaW4gYXNzZXQgZm9sZGVyICh1cGxvYWRzIG9yIFMzKVxuICAgIHVybCA9IHVybFJlZ2V4cC5leGVjKHVybClbMV1cbiAgICAvLyBoYW5kbGUgZXZlcnkgb3RoZXIgY2FzZTpcbiAgICAvLyAgICp8VU5TVUJ8KlxuICAgIC8vICAgI3BvdWljXG4gICAgaWYgKCFleHRlbnRpb25SZWdleHAudGVzdCh1cmwpKSByZXR1cm4gbnVsbFxuICAgIGNvbnNvbGUubG9nKCdjdXN0b21UZW1wbGF0ZVVybENvbnZlcnRlcicsIHVybClcbiAgICAvLyBBbGwgaW1hZ2VzIGF0IHVwbG9hZGVkIGFyZSByZW5hbWVkIHdpdGggbWQ1XG4gICAgLy8gICAgYmxvY2sgdGh1bWJuYWlscyBhcmUgYmFzZWQgb24gaHRtbCBibG9jayBJRFxuICAgIC8vICAgID0+IHdlIG5lZWQgdG8gbWFpbnRhaW4gYSBkaWN0aW9uYXJ5IG9mIG5hbWUgLT4gbWQ1IG5hbWVcbiAgICAvLyAgICBoZXJlIGNvbWUgdGhlIGFzc2V0cyBibG9ja1xuICAgIC8vIHdlIHN0aWxsIGtlZXAgdGhlIHNsdWcgcGFydCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZWFzb24gd2l0aCBvbGQgaW1hZ2UgbmFtZSBjb252ZW50aW9uc1xuICAgIHVybCA9IHNsdWdGaWxlbmFtZSh1cmwpXG4gICAgdXJsID0gYXNzZXRzW3VybF0gPyBvcHRzLmltZ1Byb2Nlc3NvckJhY2tlbmQgKyBhc3NldHNbdXJsXSA6IG51bGxcbiAgICByZXR1cm4gdXJsXG4gIH1cbn1cblxuLy8ga25vY2tvdXQgaXMgYSBnbG9iYWwgb2JqZWN0LlxuLy8gU28gd2UgY2FuIGV4dGVuZCBpdCBlYXNpbHlcblxuLy8gdGhpcyBlcXVpdmFsZW50IHRvIHRoZSBvcmlnaW5hbCBhcHAuanMjYXBwbHlCaW5kaW5nT3B0aW9uc1xuZnVuY3Rpb24gZXh0ZW5kS25vY2tvdXQob3B0cykge1xuICAvLy0tLS0tIFRJTllNQ0VcblxuICAvLyBDaGFuZ2UgdGlueU1DRSBmdWxsIGVkaXRvciBvcHRpb25zXG4gIGlmIChvcHRzLmxhbmcgPT09ICdmcicpIHtcbiAgICB0ZXh0RWRpdG9yLmxhbmd1YWdlX3VybCA9ICcvdGlueW1jZS1sYW5ncy9mcl9GUi5qcydcbiAgICB0ZXh0RWRpdG9yLmxhbmd1YWdlID0gJ2ZyX0ZSJ1xuICAgIHRpbnltY2UudXRpbC5JMThuLmFkZCgnZnJfRlInLCB7XG4gICAgICBDYW5jZWw6ICdBbm51bGVyJyxcbiAgICAgICdpbiBwaXhlbCc6ICdlbiBwaXhlbCcsXG4gICAgICAnRW50ZXIgYSBmb250LXNpemUnOiAnRW50cmV6IHVuZSB0YWlsbGUgZGUgcG9saWNlJyxcbiAgICAgICdMZXR0ZXIgc3BhY2luZyc6ICdJbnRlcmxldHRyYWdlJyxcbiAgICAgICdGb250IHNpemUnOiAnVGFpbGxlIGRlIHBvbGljZScsXG4gICAgICAnRm9udCBzaXplOiAnOiAnVGFpbGxlIDogJyxcbiAgICAgICdtaW5pbXVtIHNpemU6IDhweCc6ICd0YWlsbGUgbWluaW11bSA6IDhweCcsXG4gICAgICAnbm8gZGVjaW1hbHMnOiAncGFzIGRlIGTDqWNpbWFsZXMnLFxuICAgIH0pXG4gIH1cbiAgLy8tIGh0dHBzOi8vd3d3LnRpbnltY2UuY29tL2RvY3MvY29uZmlndXJlL3VybC1oYW5kbGluZy8jY29udmVydF91cmxzXG4gIHRleHRFZGl0b3IgPSAkLmV4dGVuZCh7IGNvbnZlcnRfdXJsczogZmFsc2UgfSwgdGV4dEVkaXRvciwgb3B0cy50aW55bWNlKVxuICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5mdWxsT3B0aW9ucyA9IHRleHRFZGl0b3JcblxuICAvLyBtaXJyb3Igb3B0aW9ucyB0byB0aGUgc21hbGwgdmVyc2lvbiBvZiB0aW55bWNlXG4gIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnN0YW5kYXJkT3B0aW9ucyA9IHtcbiAgICBjb252ZXJ0X3VybHM6IGZhbHNlLFxuICAgIGV4dGVybmFsX3BsdWdpbnM6IHtcbiAgICAgIHBhc3RlOiB0ZXh0RWRpdG9yLmV4dGVybmFsX3BsdWdpbnMucGFzdGUsXG4gICAgfSxcbiAgICB0aGVtZV91cmw6IHRleHRFZGl0b3IudGhlbWVfdXJsLFxuICAgIHNraW5fdXJsOiB0ZXh0RWRpdG9yLnNraW5fdXJsLFxuICB9XG5cbiAgLy8tLS0tLSBVUkxTIEhBTkRMSU5HXG5cbiAgLy8gVGhpcyBpcyBub3QgdXNlZCBieSBrbm9ja291dCBwZXIgc2UuXG4gIC8vIFN0b3JlIHRoaXMgZnVuY3Rpb24gaW4gS08gZ2xvYmFsIG9iamVjdCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgYnkgdGVtcGxhdGUtbG9hZGVyLmpzI3RlbXBsYXRlTG9hZGVyXG4gIC8vIGN1c3RvbVRlbXBsYXRlVXJsQ29udmVydGVyIGlzIHVzZWQ6XG4gIC8vICAtIGZvciBwcmV2aWV3IGltYWdlcyBvbiBsZWZ0IGJhclxuICAvLyAgLSBmb3Igc3RhdGljIGxpbmtzIGluIHRlbXBsYXRlc1xuICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYy50ZW1wbGF0ZVVybENvbnZlcnRlciA9IHRlbXBsYXRlVXJsQ29udmVydGVyKFxuICAgIG9wdHNcbiAgKVxuXG4gIC8vIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCBpbiB0aGUgZWRpdG9yIHRlbXBsYXRlXG4gIHZhciBpbWdQcm9jZXNzb3JCYWNrZW5kID0gdXJsLnBhcnNlKG9wdHMuaW1nUHJvY2Vzc29yQmFja2VuZClcblxuICAvLyBzZW5kIHRoZSBub24tcmVzaXplZCBpbWFnZSB1cmxcbiAga28uYmluZGluZ0hhbmRsZXJzLmZpbGV1cGxvYWQucmVtb3RlRmlsZVByZXByb2Nlc3NvciA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICBjb25zb2xlLmluZm8oJ1JFTU9URSBGSUxFIFBSRVBST0NFU1NPUicpXG4gICAgY29uc29sZS5sb2coZmlsZSlcbiAgICB2YXIgZmlsZVVybCA9IHVybC5mb3JtYXQoe1xuICAgICAgcHJvdG9jb2w6IGltZ1Byb2Nlc3NvckJhY2tlbmQucHJvdG9jb2wsXG4gICAgICBob3N0OiBpbWdQcm9jZXNzb3JCYWNrZW5kLmhvc3QsXG4gICAgICBwYXRobmFtZTogaW1nUHJvY2Vzc29yQmFja2VuZC5wYXRobmFtZSxcbiAgICB9KVxuICAgIGZpbGUudXJsID0gdXJsLnJlc29sdmUoZmlsZVVybCwgdXJsLnBhcnNlKGZpbGUudXJsKS5wYXRobmFtZSlcbiAgICByZXR1cm4gZmlsZVxuICB9XG5cbiAgLy8gcHVzaCBcImNvbnZlcnRlZFVybFwiIG1ldGhvZCB0byB0aGUgd3lzaXd5Z1NyYyBiaW5kaW5nXG4gIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLmNvbnZlcnRlZFVybCA9IGZ1bmN0aW9uKFxuICAgIHNyYyxcbiAgICBtZXRob2QsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gICkge1xuICAgIHZhciBpbWFnZU5hbWUgPSB1cmwucGFyc2Uoc3JjKS5wYXRobmFtZVxuICAgIGlmICghaW1hZ2VOYW1lKSBjb25zb2xlLndhcm4oJ25vIHBhdGhuYW1lIGZvciBpbWFnZScsIHNyYylcbiAgICBjb25zb2xlLmluZm8oJ0NPTlZFUlRFRCBVUkwnLCBpbWFnZU5hbWUsIG1ldGhvZCwgd2lkdGgsIGhlaWdodClcbiAgICBpbWFnZU5hbWUgPSBpbWFnZU5hbWUucmVwbGFjZSgnL2ltZy8nLCAnJylcbiAgICB2YXIgcGF0aCA9IG9wdHMuYmFzZVBhdGggKyAnLycgKyBtZXRob2RcbiAgICBwYXRoID0gcGF0aCArICcvJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0ICsgJy8nICsgaW1hZ2VOYW1lXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLnBsYWNlaG9sZGVyVXJsID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdGV4dCkge1xuICAgIC8vIGNvbnNvbGUuaW5mbygnUExBQ0VIT0xERVIgVVJMJywgd2lkdGgsIGhlaWdodCwgdGV4dClcbiAgICByZXR1cm4gb3B0cy5iYXNlUGF0aCArICcvcGxhY2Vob2xkZXIvJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0ICsgJy5wbmcnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV4dGVuZFZpZXdNb2RlbCxcbiAgZXh0ZW5kS25vY2tvdXQsXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGNvbnNvbGUgPSByZXF1aXJlKCdjb25zb2xlLWJyb3dzZXJpZnknKVxudmFyICQgICAgICAgPSByZXF1aXJlKCdqcXVlcnknKVxudmFyIGtvICAgICAgPSByZXF1aXJlKCdrbm9ja291dCcpXG52YXIgX2ZpbmQgICA9IHJlcXVpcmUoJ2xvZGFzaC5maW5kJylcblxuZnVuY3Rpb24gZ2FsbGVyeUxvYWRlciggb3B0cyApIHtcblxuICB2YXIgZ2FsbGVyeVVybCA9IG9wdHMuZmlsZXVwbG9hZENvbmZpZy51cmxcblxuICByZXR1cm4gZnVuY3Rpb24gKHZpZXdNb2RlbCkge1xuXG4gICAgdmlld01vZGVsLm1haWxpbmdHYWxsZXJ5ICAgICAgICA9IGtvLm9ic2VydmFibGVBcnJheShbXSlcbiAgICB2aWV3TW9kZWwudGVtcGxhdGVHYWxsZXJ5ICAgICAgID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKVxuICAgIHZpZXdNb2RlbC5tYWlsaW5nR2FsbGVyeVN0YXR1cyAgPSBrby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgIHZpZXdNb2RlbC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMgPSBrby5vYnNlcnZhYmxlKGZhbHNlKVxuXG4gICAgZnVuY3Rpb24gbG9hZEdhbGxlcnkoIHR5cGUgKSB7XG4gICAgICB2YXIgdXJsICAgICAgPSBnYWxsZXJ5VXJsWyB0eXBlIF1cbiAgICAgIHZhciBnYWxsZXJ5ICA9IHZpZXdNb2RlbFsgdHlwZSArICdHYWxsZXJ5JyBdXG4gICAgICB2YXIgc3RhdHVzICAgPSB2aWV3TW9kZWxbIHR5cGUgKyAnR2FsbGVyeVN0YXR1cycgXVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGF0dXMoJ2xvYWRpbmcnKVxuICAgICAgICAvLyByZXRyaWV2ZSB0aGUgZnVsbCBsaXN0IG9mIHJlbW90ZSBmaWxlc1xuICAgICAgICAkLmdldEpTT04odXJsLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZpbGVzLmxlbmd0aDsgaSsrKSBkYXRhLmZpbGVzW2ldID0gdmlld01vZGVsLnJlbW90ZUZpbGVQcm9jZXNzb3IoZGF0YS5maWxlc1tpXSlcbiAgICAgICAgICBzdGF0dXMoIGRhdGEuZmlsZXMubGVuZ3RoIClcbiAgICAgICAgICBnYWxsZXJ5KCBkYXRhLmZpbGVzLnJldmVyc2UoKSApXG4gICAgICAgIH0pLmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RhdHVzKCBmYWxzZSApXG4gICAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdVbmV4cGVjdGVkIGVycm9yIGxpc3RpbmcgZmlsZXMnKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyB1c2VkIGFzIGEgcGFyYW1hdGVyIGluIGZpbGV1cGxvYWQgYmluZGluZ1xuICAgIC8vIHNlZSB0b29sYm94LnRtcGwuaHRtbCBgI3Rvb2xpbWFnZXNnYWxsZXJ5IGZpbGV1cGxvYWRgXG4gICAgLy8gZmlsZXVwbG9hZCBiaW5kaW5nIHdpbGwgaXRlcmF0ZSBvbiBldmVyeSB1cGxvYWRlZCBmaWxlIGFuZCBjYWxsIHRoaXMgY2FsbGJhY2tcbiAgICAvLyBmaWxldXBsb2FkLmpzID0+IGUudHlwZSA9PSAnZmlsZXVwbG9hZGRvbmUnIGZvciBtb3JlIGRldGFpbHNcbiAgICBmdW5jdGlvbiBsb2FkSW1hZ2UoIHR5cGUgKSB7XG4gICAgICB2YXIgZ2FsbGVyeSAgPSB2aWV3TW9kZWxbIHR5cGUgKyAnR2FsbGVyeScgXVxuICAgICAgdmFyIHN0YXR1cyAgID0gdmlld01vZGVsWyB0eXBlICsgJ0dhbGxlcnlTdGF0dXMnIF1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoIGltZyApIHtcbiAgICAgICAgdmFyIGltYWdlTmFtZSAgICAgICAgID0gaW1nLm5hbWVcbiAgICAgICAgLy8gY2FsbCBnYWxsZXJ5KCksIGJlY2F1c2UgaXQgaXMgYSBrbm9ja291dCBvYnNlcnZhYmxlIGFuZCBub3QgYSByZWFsIGFycmF5XG4gICAgICAgIC8vIERvbid0IHNob3cgdHdpY2UgdGhlIHNhbWUgaW1hZ2VcbiAgICAgICAgdmFyIGlzQWxyZWFkeVVwbG9hZGVkID0gX2ZpbmQoIGdhbGxlcnkoKSwgZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGUubmFtZSA9PT0gaW1hZ2VOYW1lXG4gICAgICAgIH0pXG4gICAgICAgIGlmICggaXNBbHJlYWR5VXBsb2FkZWQgKSByZXR1cm5cbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBnYWxsZXJ5IHVudGlsIGl0IGhhcyBiZWVuIG9wZW5lZCBvbmNlXG4gICAgICAgIC8vIFRoaXMgd2FzIGxlYWRpbmcgdG8gcHJldmVudGluZyB0aGUgd2hvbGUgZ2FsbGVyeSB0byBiZSBmZXRjaGVk4oCmXG4gICAgICAgIC8vIOKApmlmIHdlIGhhZCB1cGxvYWRlZCBhbiBpbWFnZSBpbiB0aGUgZWRpdG9yXG4gICAgICAgIGlmICggc3RhdHVzKCkgPT09IGZhbHNlICkgcmV0dXJuXG4gICAgICAgIGdhbGxlcnkudW5zaGlmdCggaW1nIClcbiAgICAgICAgc3RhdHVzKCBnYWxsZXJ5KCkubGVuZ3RoIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2aWV3TW9kZWwubG9hZE1haWxpbmdHYWxsZXJ5ICAgID0gbG9hZEdhbGxlcnkoICdtYWlsaW5nJyApXG4gICAgdmlld01vZGVsLmxvYWRUZW1wbGF0ZUdhbGxlcnkgICA9IGxvYWRHYWxsZXJ5KCAndGVtcGxhdGUnIClcbiAgICB2aWV3TW9kZWwubG9hZE1haWxpbmdJbWFnZSAgICAgID0gbG9hZEltYWdlKCAnbWFpbGluZycgKVxuICAgIHZpZXdNb2RlbC5sb2FkVGVtcGxhdGVJbWFnZSAgICAgPSBsb2FkSW1hZ2UoICd0ZW1wbGF0ZScgKVxuXG4gICAgY29uc3QgZ2FsbGVyeU9wZW4gPSB2aWV3TW9kZWwuc2hvd0dhbGxlcnkuc3Vic2NyaWJlKCBuZXdWYWx1ZSA9PiB7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHRydWUgJiYgdmlld01vZGVsLm1haWxpbmdHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHZpZXdNb2RlbC5sb2FkTWFpbGluZ0dhbGxlcnkoKVxuICAgICAgICBnYWxsZXJ5T3Blbi5kaXNwb3NlKClcbiAgICAgIH1cbiAgICB9IClcblxuICAgIGNvbnN0IHRhYkNoYW5nZSA9IHZpZXdNb2RlbC5zZWxlY3RlZEltYWdlVGFiLnN1YnNjcmliZSggbmV3VmFsdWUgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSAxICYmIHZpZXdNb2RlbC50ZW1wbGF0ZUdhbGxlcnlTdGF0dXMoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmlld01vZGVsLmxvYWRUZW1wbGF0ZUdhbGxlcnkoKVxuICAgICAgICB0YWJDaGFuZ2UuZGlzcG9zZSgpXG4gICAgICB9XG4gICAgfSwgdmlld01vZGVsLCAnY2hhbmdlJylcblxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnYWxsZXJ5TG9hZGVyXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGNvbnNvbGUgPSByZXF1aXJlKCdjb25zb2xlLWJyb3dzZXJpZnknKVxudmFyICQgICAgICAgPSByZXF1aXJlKCdqcXVlcnknKVxudmFyIGtvICAgICAgPSByZXF1aXJlKCdrbm9ja291dCcpXG5cbmZ1bmN0aW9uIHJlbW92ZUdhbGxlcnlJbWFnZSggdmlld01vZGVsICkge1xuXG4gIHZpZXdNb2RlbC5yZW1vdmVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCBldmVudCkge1xuICAgIHZhciBkZWxldGVVcmwgPSBkYXRhLmRlbGV0ZVVybFxuXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogICAgZGVsZXRlVXJsLFxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIC8vIGB0eXBlYCBvcHRpb25zIGlzIGFuIGFsaWFzIGZvciBgbWV0aG9kYCBvcHRpb24uXG4gICAgICAvLyBVc2UgYHR5cGVgIGJlY2F1c2UgYG1ldGhvZGAgaXMgbm90IHN1cHBvcnRlZCBqUXVlcnkgcHJpb3IgdG8gMS45LjAuXG4gICAgICAvLyBhY3R1YWwgYm93ZXIgdmVyc2lvbiBpcyAxLjEyLjQgOihcbiAgICAgIHR5cGU6ICAgJ0RFTEVURScsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5zdWNjZXNzKHZpZXdNb2RlbC50KCdnYWxsZXJ5LXJlbW92ZS1pbWFnZS1zdWNjZXNzJykpXG4gICAgICAgIHZhciBnYWxsZXJ5ICA9IHZpZXdNb2RlbFsgdHlwZSArICdHYWxsZXJ5JyBdXG4gICAgICAgIHZhciBzdGF0dXMgICA9IHZpZXdNb2RlbFsgdHlwZSArICdHYWxsZXJ5U3RhdHVzJyBdXG4gICAgICAgIHN0YXR1cyggcmVzLmZpbGVzLmxlbmd0aCApXG4gICAgICAgIGdhbGxlcnkoIHJlcy5maWxlcy5yZXZlcnNlKCkgKVxuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdnYWxsZXJ5LXJlbW92ZS1pbWFnZS1mYWlsJykpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlR2FsbGVyeUltYWdlXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGNvbnNvbGUgPSByZXF1aXJlKCdjb25zb2xlLWJyb3dzZXJpZnknKVxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKVxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKVxudmFyIF9vbWl0ID0gcmVxdWlyZSgnbG9kYXNoLm9taXQnKVxudmFyIGlzRW1haWwgPSByZXF1aXJlKCd2YWxpZGF0b3IvbGliL2lzRW1haWwnKVxuXG5mdW5jdGlvbiBnZXREYXRhKHZpZXdNb2RlbCkge1xuICAvLyBnYXRoZXIgbWV0YVxuICAvLyByZW1vdmUga2V5cyB0aGF0IGFyZW4ndCBuZWNlc3NhcnkgdG8gdXBkYXRlXG4gIHZhciBkYXRhcyA9IF9vbWl0KGtvLnRvSlModmlld01vZGVsLm1ldGFkYXRhKSwgWyd1cmxDb252ZXJ0ZXInLCAndGVtcGxhdGUnXSlcbiAgZGF0YXMuZGF0YSA9IHZpZXdNb2RlbC5leHBvcnRKUygpXG4gIHJldHVybiBkYXRhc1xufVxuXG52YXIgbG9hZGVyID0gZnVuY3Rpb24odmlld01vZGVsKSB7XG4gIGNvbnNvbGUuaW5mbygnaW5pdCBzZXJ2ZXIgc3RvcmFnZSAoc2F2ZSwgdGVzdCwgZG93bmxvYWQpJylcblxuICAvLy8vLy9cbiAgLy8gU0FWRVxuICAvLy8vLy9cblxuICB2YXIgc2F2ZUNtZCA9IHtcbiAgICBuYW1lOiAnU2F2ZScsIC8vIGwxMG4gaGFwcGVucyBpbiB0aGUgdGVtcGxhdGVcbiAgICBlbmFibGVkOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICB9XG4gIHNhdmVDbWQuZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHNhdmVDbWQuZW5hYmxlZChmYWxzZSlcbiAgICB2YXIgZGF0YSA9IGdldERhdGEodmlld01vZGVsKVxuICAgIGNvbnNvbGUuaW5mbygnU0FWRSBEQVRBJylcbiAgICBjb25zb2xlLmxvZyhkYXRhKVxuXG4gICAgLy8gZm9yY2UgSlNPTiBmb3IgYm9keXBhcnNlciB0byBjYXRjaCB1cFxuICAgIC8vID0+IGtlZXAgdHlwZXMgc2VydmVyIHNpZGVcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgc3VjY2Vzczogb25Qb3N0U3VjY2VzcyxcbiAgICAgIGVycm9yOiBvblBvc3RFcnJvcixcbiAgICAgIGNvbXBsZXRlOiBvblBvc3RDb21wbGV0ZSxcbiAgICB9KVxuXG4gICAgLy8gdXNlIGNhbGxiYWNrIGZvciBlYXNpZXIgalF1ZXJ5IHVwZGF0ZXNcbiAgICAvLyA9PiBEZXByZWNhdGlvbiBub3RpY2UgZm9yIC5zdWNjZXNzKCksIC5lcnJvcigpLCBhbmQgLmNvbXBsZXRlKClcbiAgICBmdW5jdGlvbiBvblBvc3RTdWNjZXNzKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICBjb25zb2xlLmxvZygnc2F2ZSBzdWNjZXNzJylcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5zdWNjZXNzKHZpZXdNb2RlbC50KCdzYXZlLW1lc3NhZ2Utc3VjY2VzcycpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUG9zdEVycm9yKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgY29uc29sZS5sb2coJ3NhdmUgZXJyb3InKVxuICAgICAgY29uc29sZS5sb2coZXJyb3JUaHJvd24pXG4gICAgICB2aWV3TW9kZWwubm90aWZpZXIuZXJyb3Iodmlld01vZGVsLnQoJ3NhdmUtbWVzc2FnZS1lcnJvcicpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUG9zdENvbXBsZXRlKCkge1xuICAgICAgc2F2ZUNtZC5lbmFibGVkKHRydWUpXG4gICAgfVxuICB9XG5cbiAgLy8vLy8vXG4gIC8vIEVNQUlMXG4gIC8vLy8vL1xuXG4gIHZhciB0ZXN0Q21kID0ge1xuICAgIG5hbWU6ICdUZXN0JywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgIGVuYWJsZWQ6IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gIH1cbiAgdGVzdENtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5pbmZvKCdURVNUJylcbiAgICBjb25zb2xlLmxvZyh2aWV3TW9kZWwubWV0YWRhdGEudXJsLnNlbmQpXG4gICAgdGVzdENtZC5lbmFibGVkKGZhbHNlKVxuICAgIHZhciBlbWFpbCA9IHZpZXdNb2RlbC50KCdJbnNlcnQgaGVyZSB0aGUgcmVjaXBpZW50IGVtYWlsIGFkZHJlc3MnKVxuICAgIGVtYWlsID0gZ2xvYmFsLnByb21wdCh2aWV3TW9kZWwudCgnVGVzdCBlbWFpbCBhZGRyZXNzJyksIGVtYWlsKVxuXG4gICAgLy8gRG9uJ3QgdmFsaWRhdGUgYG51bGxgIHZhbHVlcyA9PiBpc0VtYWlsIHdpbGwgZXJyb3JcbiAgICBpZiAoIWVtYWlsKSByZXR1cm4gdGVzdENtZC5lbmFibGVkKHRydWUpXG5cbiAgICBpZiAoIWlzRW1haWwoZW1haWwpKSB7XG4gICAgICBnbG9iYWwuYWxlcnQodmlld01vZGVsLnQoJ0ludmFsaWQgZW1haWwgYWRkcmVzcycpKVxuICAgICAgcmV0dXJuIHRlc3RDbWQuZW5hYmxlZCh0cnVlKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdUT0RPIHRlc3RpbmcuLi4nLCBlbWFpbClcbiAgICB2YXIgbWV0YWRhdGEgPSBrby50b0pTKHZpZXdNb2RlbC5tZXRhZGF0YSlcbiAgICB2YXIgZGF0YXMgPSB7XG4gICAgICByY3B0OiBlbWFpbCxcbiAgICAgIGh0bWw6IHZpZXdNb2RlbC5leHBvcnRIVE1MKCksXG4gICAgfVxuICAgICQuYWpheCh7XG4gICAgICB1cmw6IHZpZXdNb2RlbC5tZXRhZGF0YS51cmwuc2VuZCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZGF0YTogZGF0YXMsXG4gICAgICBzdWNjZXNzOiBvblRlc3RTdWNjZXNzLFxuICAgICAgZXJyb3I6IG9uVGVzdEVycm9yLFxuICAgICAgY29tcGxldGU6IG9uVGVzdENvbXBsZXRlLFxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBvblRlc3RTdWNjZXNzKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICBjb25zb2xlLmxvZygndGVzdCBzdWNjZXNzJylcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5zdWNjZXNzKHZpZXdNb2RlbC50KCdUZXN0IGVtYWlsIHNlbnQuLi4nKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRlc3RFcnJvcihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgIGNvbnNvbGUubG9nKCd0ZXN0IGVycm9yJylcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yVGhyb3duKVxuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKFxuICAgICAgICB2aWV3TW9kZWwudCgnVW5leHBlY3RlZCBlcnJvciB0YWxraW5nIHRvIHNlcnZlcjogY29udGFjdCB1cyEnKVxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVGVzdENvbXBsZXRlKCkge1xuICAgICAgdGVzdENtZC5lbmFibGVkKHRydWUpXG4gICAgfVxuICB9XG5cbiAgLy8vLy8vXG4gIC8vIFpJUFxuICAvLy8vLy9cblxuICB2YXIgZG93bmxvYWRDbWQgPSB7XG4gICAgbmFtZTogJ0Rvd25sb2FkJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgIGVuYWJsZWQ6IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gIH1cbiAgZG93bmxvYWRDbWQuZXhlY3V0ZSA9IGZ1bmN0aW9uIGRvd25sb2FkWmlwKGZvcm1hdCkge1xuICAgIGNvbnNvbGUuaW5mbyhgRE9XTkxPQUQg4oCTICR7Zm9ybWF0fWApXG4gICAgZG93bmxvYWRDbWQuZW5hYmxlZChmYWxzZSlcbiAgICB2aWV3TW9kZWwubm90aWZpZXIuaW5mbyh2aWV3TW9kZWwudCgnRG93bmxvYWRpbmcuLi4nKSlcbiAgICB2aWV3TW9kZWwuZXhwb3J0SFRNTHRvVGV4dGFyZWEoJyNkb3dubG9hZEh0bWxUZXh0YXJlYScpXG4gICAgJCgnI2Rvd25sb2FkSHRtbEZpbGVuYW1lJykudmFsKHZpZXdNb2RlbC5tZXRhZGF0YS5uYW1lKCkpXG4gICAgJCgnI2Rvd25sb2FkRm9ybScpXG4gICAgICAuYXR0cignYWN0aW9uJywgYCR7dmlld01vZGVsLm1ldGFkYXRhLnVybC56aXB9P2Zvcm1hdD0ke2Zvcm1hdH1gKVxuICAgICAgLnN1Ym1pdCgpXG4gICAgZG93bmxvYWRDbWQuZW5hYmxlZCh0cnVlKVxuICB9XG4gIHZpZXdNb2RlbC5zYXZlID0gc2F2ZUNtZFxuICB2aWV3TW9kZWwudGVzdCA9IHRlc3RDbWRcbiAgdmlld01vZGVsLmRvd25sb2FkID0gZG93bmxvYWRDbWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZGVib3VuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKVxuXG4vLy8vLy9cbi8vIERFRklORSBUSU5ZTUNFIENVU1RPTSBQTFVHSU5TXG4vLy8vLy9cblxuLy8tLS0tLSBMRVRURVIgU1BBQ0lOR1xuXG4vLyBjb252ZXJ0IGEgZmlib25hY2NpIHN1aXRlIHRvIGVtXG52YXIgZGVmYXVsdHMgPSBbMCwgMSwgMiwgMywgNSwgOCwgMTNdXG4ubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBNYXRoLnJvdW5kKChlICogMC4xKSAqIDEwMCkgLyAxMDAgfSlcbi5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkgKyAnPScgKyBpICsgJ2VtJyB9KVxuLmpvaW4oJyAnKVxuXG50aW55bWNlLlBsdWdpbk1hbmFnZXIuYWRkKCdzcGFjaW5nJywgYWRkTGV0dGVyU3BhY2luZylcblxuZnVuY3Rpb24gYWRkTGV0dGVyU3BhY2luZyhlZGl0b3IsIHVybCkge1xuICBlZGl0b3IuYWRkQnV0dG9uKCdsZXR0ZXJzcGFjaW5nc2VsZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtYXRzICAgPSBlZGl0b3Iuc2V0dGluZ3Muc3BhY2luZ19mb3JtYXRzIHx8IGRlZmF1bHRzXG4gICAgdmFyIGl0ZW1zICAgICA9IGZvcm1hdHMuc3BsaXQoJyAnKS5tYXAoIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgdGV4dCAgPSBpdGVtXG4gICAgICB2YXIgdmFsdWUgPSBpdGVtXG4gICAgICAvLyBBbGxvdyB0ZXh0PXZhbHVlIGZvbnQgc2l6ZXMuXG4gICAgICB2YXIgdmFsdWVzID0gaXRlbS5zcGxpdCgnPScpXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGV4dCA9IHZhbHVlc1swXVxuICAgICAgICB2YWx1ZSA9IHZhbHVlc1sxXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt0ZXh0OiB0ZXh0LCB2YWx1ZTogdmFsdWUsfVxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBzZXRMZXR0ZXJTcGFjaW5nKGUpIHtcbiAgICAgIGlmICghZS5jb250cm9sLnNldHRpbmdzLnZhbHVlKSByZXR1cm5cbiAgICAgIHRpbnltY2UuYWN0aXZlRWRpdG9yLmZvcm1hdHRlci5yZWdpc3RlcignbGV0dGVyLXNwYWNpbmcnLCB7XG4gICAgICAgIGlubGluZSA6ICdzcGFuJyxcbiAgICAgICAgc3R5bGVzIDogeyAnbGV0dGVyLXNwYWNpbmcnIDogZS5jb250cm9sLnNldHRpbmdzLnZhbHVlIH0sXG4gICAgICB9KVxuICAgICAgdGlueW1jZS5hY3RpdmVFZGl0b3IuZm9ybWF0dGVyLmFwcGx5KCdsZXR0ZXItc3BhY2luZycpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICAgICAgICdsaXN0Ym94JyxcbiAgICAgIHRleHQ6ICAgICAgICdMZXR0ZXIgc3BhY2luZycsXG4gICAgICB0b29sdGlwOiAgICAnTGV0dGVyIHNwYWNpbmcnLFxuICAgICAgdmFsdWVzOiAgICAgaXRlbXMsXG4gICAgICBmaXhlZFdpZHRoOiB0cnVlLFxuICAgICAgb25jbGljazogICAgc2V0TGV0dGVyU3BhY2luZyxcbiAgICB9XG5cbiAgfSlcbn1cblxuLy8tLS0tLSBGUkVFIEZPTlQgU0laRVxuXG4vLyBVdGlsIGZ1bmN0aW9uIGNvcGllZCBmcm9tIFRpbnkgTUNFXG5mdW5jdGlvbiBlYWNoKG8sIGNiLCBzKSB7XG4gIHZhciBuLCBsO1xuXG4gIGlmICghbykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcyA9IHMgfHwgbztcblxuICBpZiAoby5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEluZGV4ZWQgYXJyYXlzLCBuZWVkZWQgZm9yIFNhZmFyaVxuICAgIGZvciAobiA9IDAsIGwgPSBvLmxlbmd0aDsgbiA8IGw7IG4rKykge1xuICAgICAgaWYgKGNiLmNhbGwocywgb1tuXSwgbiwgbykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBIYXNodGFibGVzXG4gICAgZm9yIChuIGluIG8pIHtcbiAgICAgIGlmIChvLmhhc093blByb3BlcnR5KG4pKSB7XG4gICAgICAgIGlmIChjYi5jYWxsKHMsIG9bbl0sIG4sIG8pID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbi8vIGluc3BpcmVkIGJ5IHRpbnltY2UuanMjNDQyNjVcbnRpbnltY2UuUGx1Z2luTWFuYWdlci5hZGQoJ2ZvbnRzaXplZGlhbG9nJywgZm9udHNpemVkaWFsb2cpO1xuXG5mdW5jdGlvbiBmb250c2l6ZWRpYWxvZyhlZGl0b3IsIHVybCkge1xuICBjb25zb2xlLmRpcihlZGl0b3IpXG4gIHZhciBmb250U2l6ZU1pbiAgICAgPSA4XG4gIHZhciBmb250U2l6ZU1heCAgICAgPSA2NjZcbiAgdmFyIHNlbGVjdGlvbkZzICAgICA9IGZhbHNlXG4gIHZhciBkaWFsb2dIZWxwVGV4dCAgPSBbXG4gICAgdGlueW1jZS51dGlsLkkxOG4udHJhbnNsYXRlKCdtaW5pbXVtIHNpemU6IDhweCcpLFxuICAgIHRpbnltY2UudXRpbC5JMThuLnRyYW5zbGF0ZSgnbm8gZGVjaW1hbHMnKSxcbiAgXVxuICAubWFwKCBmdW5jdGlvbiAodCkgeyByZXR1cm4gJ+KAoiAnICsgdH0gKVxuICAuam9pbiggJzxicj4nICk7XG5cbiAgZWRpdG9yLmFkZEJ1dHRvbignZm9udHNpemVkaWFsb2didXR0b24nLCB7XG4gICAgdGV4dDogICAgICAgICAnRm9udCBzaXplJyxcbiAgICB0b29sdGlwOiAgICAgICdGb250IHNpemUnLFxuICAgIC8vIGFkZCBhIGNsYXNzIHRvIGZpeCBidXR0b24gd2lkdGhcbiAgICAvLyBIYXZlbid0IGZvdW5kIGEgd2F5IHRvIHVwZGF0ZSB0b29sYmFyIHNpemUgZHluYW1pY2FsbHlcbiAgICAvLyBpdGVyYXRpbmcgb3ZlciBodHRwczovL3d3dy50aW55bWNlLmNvbS9kb2NzL2FwaS90aW55bWNlLnVpL3RpbnltY2UudWkuYnV0dG9uLyNwYXJlbnRzXG4gICAgLy8gYW5kIGNhbGxpbmcgLnJlZmxvdygpIGRvZXNuJ3QgbWFrZSB0aGUgdHJpY2tcbiAgICBjbGFzc2VzOiAgICAgICdmb250c2l6ZWRpYWxvZ2J1dHRvbicsXG4gICAgaWNvbjogICAgICAgICBmYWxzZSxcbiAgICBvblBvc3RSZW5kZXI6IGFmdGVyQnRuSW5pdCxcbiAgICBvbmNsaWNrOiAgICAgIG9wZW5Gc0RpYWxvZyxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXJCdG5Jbml0KGluaXRFdmVudCkge1xuICAgIHZhciBidG5JbnN0YW5jZSA9IGluaXRFdmVudC5jb250cm9sXG4gICAgdmFyIGZvcm1hdE5hbWUgID0gJ2ZvbnRzaXplJ1xuICAgIHZhciBzZWxmICAgICAgICA9IHRoaXNcblxuICAgIGVkaXRvci5vbignbm9kZUNoYW5nZScsIGRlYm91bmNlKG9uTm9kZUNoYW5nZSwgMTUwKSApXG5cbiAgICBmdW5jdGlvbiBvbk5vZGVDaGFuZ2UoIGUgKSB7XG4gICAgICBlYWNoKGUucGFyZW50cywgZ2V0Rm9udFNpemUpXG4gICAgICBpZiAoIXNlbGVjdGlvbkZzKSB7XG4gICAgICAgIHNlbGVjdGlvbkZzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlLnBhcmVudHNbMF0gfHwgZS5lbGVtZW50LCBudWxsKVxuICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGb250U2l6ZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlLmZvbnRTaXplKSB7XG4gICAgICAgIGJ0bkluc3RhbmNlLnRleHQoIHRpbnltY2UudXRpbC5JMThuLnRyYW5zbGF0ZSgnRm9udCBzaXplOiAnKSArIG5vZGUuc3R5bGUuZm9udFNpemUpXG4gICAgICAgIHNlbGVjdGlvbkZzID0gbm9kZS5zdHlsZS5mb250U2l6ZVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbkZzID0gZmFsc2VcbiAgICAgIGJ0bkluc3RhbmNlLnRleHQoIHRpbnltY2UudXRpbC5JMThuLnRyYW5zbGF0ZSgnRm9udCBzaXplJykgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5Gc0RpYWxvZyhidG5FdmVudCkge1xuICAgIHZhciBpbml0VmFsdWUgPSBzZWxlY3Rpb25GcyA/IC9eKFxcZCspLy5leGVjKHNlbGVjdGlvbkZzKSA6IG51bGxcbiAgICBpbml0VmFsdWUgICAgID0gQXJyYXkuaXNBcnJheShpbml0VmFsdWUpID8gaW5pdFZhbHVlWzBdIDogJydcblxuICAgIGVkaXRvci53aW5kb3dNYW5hZ2VyLm9wZW4oe1xuICAgICAgdGl0bGU6ICdFbnRlciBhIGZvbnQtc2l6ZScsXG4gICAgICB3aWR0aDogMzIwLFxuICAgICAgaGVpZ2h0OiAxMjAsXG4gICAgICBib2R5OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAgICAgICAnbGFiZWwnLFxuICAgICAgICAgIG11bHRpbGluZTogIHRydWUsXG4gICAgICAgICAgdGV4dDogICAgICAgJycsXG4gICAgICAgICAgLy8gbXVsdGlsaW5lIOKAnGhhY2vigJ0gZnJvbTpcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LmRldnN1bW8uY29tL3RlY2hub3Rlcy8yMDE0LzA3L3RpbnltY2UtNC1tdWx0aS1saW5lLWxhYmVscy1pbi1wb3B1cC1kaWFsb2dzL1xuICAgICAgICAgIG9uUG9zdFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRFbCgpLmlubmVySFRNTCA9IGRpYWxvZ0hlbHBUZXh0O1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAgICAgJ3RleHRib3gnLFxuICAgICAgICAgIG5hbWU6ICAgICAnYnNkaWFsb2dmb250c2l6ZScsXG4gICAgICAgICAgbGFiZWw6ICAgICdpbiBwaXhlbCcsXG4gICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiAgICAgaW5pdFZhbHVlLFxuICAgICAgICAgIG9uUG9zdFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuYXR0cih7XG4gICAgICAgICAgICAgIHR5cGU6ICAgJ251bWJlcicsXG4gICAgICAgICAgICAgIG1pbjogICAgZm9udFNpemVNaW4sXG4gICAgICAgICAgICAgIHN0ZXA6ICAgMSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG9uc3VibWl0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbmV3Rm9udFNpemUgPSB+fmUuZGF0YS5ic2RpYWxvZ2ZvbnRzaXplXG4gICAgICAgIGlmIChuZXdGb250U2l6ZSA+PSBmb250U2l6ZU1pbiAmJiBuZXdGb250U2l6ZSA8PSBmb250U2l6ZU1heCkge1xuICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnRm9udFNpemUnLCBmYWxzZSwgbmV3Rm9udFNpemUgKyAncHgnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRpbnlNQ0Ugbm90aWZpY2F0aW9ucyBhcmUgdmVyeSBzbWFsbOKAplxuICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcHV0IHRoZW0gZm9yIG5vd1xuICAgICAgICAgIC8vIGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyLm9wZW4oe1xuICAgICAgICAgIC8vICAgdGV4dDogJ0ludmFsaWQgZm9udCBzaXplJyxcbiAgICAgICAgICAvLyAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgLy8gfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbn1cblxuLy8vLy8vXG4vLyBDT05GSUdVUkFUSU9OXG4vLy8vLy9cblxudmFyIHRpbnltY2VDb25maWdGdWxsID0ge1xuICB0b29sYmFyMTogJ2JvbGQgaXRhbGljIGZvcmVjb2xvciBiYWNrY29sb3IgaHIgfCBmb250c2l6ZWRpYWxvZ2J1dHRvbiBzdHlsZXNlbGVjdCBsZXR0ZXJzcGFjaW5nc2VsZWN0IHJlbW92ZWZvcm1hdCB8IGxpbmsgdW5saW5rIHwgcGFzdGV0ZXh0IGNvZGUnLFxuICAvLy0gYWRkIGNvbG9ycGlja2VyICYgY3VzdG9tIHBsdWdpbnNcbiAgLy8tIGh0dHBzOi8vd3d3LnRpbnltY2UuY29tL2RvY3MvcGx1Z2lucy9jb2xvcnBpY2tlci9cbiAgcGx1Z2luczogW1wibGluayBociBwYXN0ZSBsaXN0cyB0ZXh0Y29sb3IgY29sb3JwaWNrZXIgY29kZSBzcGFjaW5nIGZvbnRzaXplZGlhbG9nXCJdLFxuICAvLy0gaHR0cHM6Ly93d3cudGlueW1jZS5jb20vZG9jcy9jb25maWd1cmUvY29udGVudC1mb3JtYXR0aW5nLyNzdHlsZV9mb3JtYXRzXG4gIHN0eWxlX2Zvcm1hdHM6IFtcbiAgICB7dGl0bGU6ICdJbmxpbmUnLCBpdGVtczogW1xuICAgICAge3RpdGxlOiAnQm9sZCcgICAgICAgICAsIGljb246IFwiYm9sZFwiICAgICAgICAgLCBpbmxpbmU6ICdzdHJvbmcnfSxcbiAgICAgIHt0aXRsZTogJ0l0YWxpYycgICAgICAgLCBpY29uOiBcIml0YWxpY1wiICAgICAgICwgaW5saW5lOiAnZW0nfSxcbiAgICAgIHt0aXRsZTogJ1VuZGVybGluZScgICAgLCBpY29uOiBcInVuZGVybGluZVwiICAgICwgaW5saW5lOiAnc3BhbicsIHN0eWxlczogeyd0ZXh0LWRlY29yYXRpb24nIDogJ3VuZGVybGluZSd9fSxcbiAgICAgIHt0aXRsZTogJ1N0cmlrZXRocm91Z2gnLCBpY29uOiBcInN0cmlrZXRocm91Z2hcIiwgaW5saW5lOiAnc3BhbicsIHN0eWxlczogeyd0ZXh0LWRlY29yYXRpb24nIDogJ2xpbmUtdGhyb3VnaCd9fSxcbiAgICAgIHt0aXRsZTogJ1N1cGVyc2NyaXB0JyAgLCBpY29uOiBcInN1cGVyc2NyaXB0XCIgICwgaW5saW5lOiAnc3VwJ30sXG4gICAgICB7dGl0bGU6ICdTdWJzY3JpcHQnICAgICwgaWNvbjogXCJzdWJzY3JpcHRcIiAgICAsIGlubGluZTogJ3N1Yid9LFxuICAgICAge3RpdGxlOiAnQ29kZScgICAgICAgICAsIGljb246IFwiY29kZVwiICAgICAgICAgLCBpbmxpbmU6ICdjb2RlJ30sXG4gICAgXX0sXG4gICAge3RpdGxlOiAnQWxpZ25tZW50JywgaXRlbXM6IFtcbiAgICAgIHt0aXRsZTogJ0xlZnQnICAgLCBpY29uOiBcImFsaWdubGVmdFwiICAgLCBibG9jazogJ2RpdicsIHN0eWxlczogeyd0ZXh0LWFsaWduJyA6ICdsZWZ0J319LFxuICAgICAge3RpdGxlOiAnQ2VudGVyJyAsIGljb246IFwiYWxpZ25jZW50ZXJcIiAsIGJsb2NrOiAnZGl2Jywgc3R5bGVzOiB7J3RleHQtYWxpZ24nIDogJ2NlbnRlcid9fSxcbiAgICAgIHt0aXRsZTogJ1JpZ2h0JyAgLCBpY29uOiBcImFsaWducmlnaHRcIiAgLCBibG9jazogJ2RpdicsIHN0eWxlczogeyd0ZXh0LWFsaWduJyA6ICdyaWdodCd9fSxcbiAgICAgIHt0aXRsZTogJ0p1c3RpZnknLCBpY29uOiBcImFsaWduanVzdGlmeVwiLCBibG9jazogJ2RpdicsIHN0eWxlczogeyd0ZXh0LWFsaWduJyA6ICdqdXN0aWZ5J319LFxuICAgIF19LFxuICBdLFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbnltY2VDb25maWdGdWxsXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qga28gPSByZXF1aXJlKCdrbm9ja291dCcpXG5jb25zdCBjb25zb2xlID0gcmVxdWlyZSgnY29uc29sZS1icm93c2VyaWZ5JylcblxuLy8gd2UgbmVlZCB0byBkZWNsYXJlIHdoaWNoIHBhcmFtYXRlcnMgYXJlIHN1cHBvcnRlZFxuLy8gc28gaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnMgd2UgY2FuIHdyaXRlOlxuLy8gYmdpbWFnZSB7XG4vLyAgIGxhYmVsOiBCYWNrZ3JvdW5kIEltYWdlO1xuLy8gICB3aWRnZXQ6IGJnaW1hZ2U7XG4vLyAgIHNpemU6IDIwMHgxMDA7IC8vIDw9IG5vdCB1c2VkIGFueW1vcmVcbi8vIH1cblxuLy8gb3RoZXIg4oCcbmF0aXZl4oCdIHdpZGdldHMgYXJlIGRlZmluZWQgaW4gY29udmVydGVyL2VkaXRvci5qc1xuLy8gc2l6ZSBpcyBkZWFjdGl2YXRlIGZvciBub3c6IGJhY2tncm91bmQtaW1hZ2VzIGFyZSB1c2VkIGZvciByZXBlYXRpbmcgcGF0dGVybnNcbmNvbnN0IGRlZmF1bHRQYXJhbWV0ZXJzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8vIHNpemU6IGAxMDB4MTAwYCxcbn0pXG5jb25zdCB0cmFuc3BhcmVudEdpZiA9IGBkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFQLy8vd0FBQUNINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQ1JBRUFPdz09YFxuXG5jb25zdCBpc1ZhbGlkU2l6ZSA9IHNpemUgPT4gLyhcXGQrKXgoXFxkKykvLnRlc3Qoc2l6ZS50cmltKCkpXG5cbmZ1bmN0aW9uIGh0bWwocHJvcEFjY2Vzc29yLCBvbmZvY3VzYmluZGluZywgcGFyYW1ldGVycykge1xuICByZXR1cm4gYFxuICAgIDxpbnB1dCBzaXplPVwiN1wiIHR5cGU9XCJoaWRkZW5cIiB2YWx1ZT1cIm5vdGhpbmdcIiBpZD1cIiR7cHJvcEFjY2Vzc29yfVwiIGRhdGEtYmluZD1cInZhbHVlOiAke3Byb3BBY2Nlc3Nvcn0sICR7b25mb2N1c2JpbmRpbmd9XCIgLz5cbiAgICA8YnV0dG9uIGRhdGEtYmluZD1cInRleHQ6ICRyb290LnQoJ3dpZGdldC1iZ2ltYWdlLWJ1dHRvbicpLCBjbGljazogJHJvb3Qub3BlbkRpYWxvZ0dhbGxlcnkuYmluZCgkZWxlbWVudCwgJyR7cHJvcEFjY2Vzc29yfScsICcke3BhcmFtZXRlcnN9Jyk7XCI+cGljayBhbiBpbWFnZTwvYnV0dG9uPlxuICAgIDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6ICRyb290LnJlc2V0QmdpbWFnZS5iaW5kKCRlbGVtZW50LCAnJHtwcm9wQWNjZXNzb3J9JywgJyR7cGFyYW1ldGVyc30nKSwgYnV0dG9uOiB7aWNvbnM6IHtwcmltYXJ5OiAnZmFzIGZhLWVyYXNlcid9LCB0ZXh0OiBmYWxzZSwgbGFiZWw6ICRyb290LnQoJ3dpZGdldC1iZ2ltYWdlLXJlc2V0JykgfVwiPjwvYnV0dG9uPlxuICBgXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3B0cyA9PiB7XG4gIGNvbnN0IHsgYmFzZVBhdGggfSA9IG9wdHNcblxuICBmdW5jdGlvbiB3aWRnZXQoJCwga28sIGtvanF1aSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWRnZXQ6ICdiZ2ltYWdlJyxcbiAgICAgIGRlZmF1bHRQYXJhbWV0ZXJzLFxuICAgICAgaHRtbCxcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2aWV3TW9kZWwodm0pIHtcbiAgICB2bS5zaG93RGlhbG9nR2FsbGVyeSA9IGtvLm9ic2VydmFibGUoZmFsc2UpXG4gICAgdm0uY3VycmVudEJnaW1hZ2UgPSBrby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgIHZtLnNldEJnSW1hZ2UgPSAoaW1hZ2VOYW1lLCBpbWcsIGV2ZW50KSA9PiB7XG4gICAgICAvLyBpbWFnZXMgaGF2ZSB0byBiZSBvbiBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICAvLyA9PiBUZXN0aW5nIGJ5IGVtYWlsIG5lZWRzIGl0IHRoYXQgd2F5XG4gICAgICAvLyA9PiBaSVAgZG93bmxvYWQgbmVlZHMgaXQgdGhhdCB3YXlcbiAgICAgIC8vIHZtLmN1cnJlbnRCZ2ltYWdlKCkoIGAkeyBiYXNlUGF0aCB9L2NvdmVyLyR7IHZtLmN1cnJlbnRCZ3NpemUoKSB9LyR7IGltYWdlTmFtZSB9YCApXG4gICAgICB2bS5jdXJyZW50QmdpbWFnZSgpKGAke2Jhc2VQYXRofS9pbWcvJHtpbWFnZU5hbWV9YClcbiAgICAgIHZtLmNsb3NlRGlhbG9nR2FsbGVyeSgpXG4gICAgfVxuICAgIHZtLnJlc2V0QmdpbWFnZSA9IChwcm9wQWNjZXNzb3IsIHBhcmFtZXRlcnMsIGJsb2NrUHJvcGVydGllcywgZXZlbnQpID0+IHtcbiAgICAgIGJsb2NrUHJvcGVydGllc1twcm9wQWNjZXNzb3JdKHRyYW5zcGFyZW50R2lmKVxuICAgIH1cbiAgICB2bS5vcGVuRGlhbG9nR2FsbGVyeSA9IChcbiAgICAgIHByb3BBY2Nlc3NvcixcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICBibG9ja1Byb3BlcnRpZXMsXG4gICAgICBldmVudFxuICAgICkgPT4ge1xuICAgICAgLy8gdG8gc2V0IHRoZSByaWdodCBwcm9wZXJ0eSwgc3RvcmUgdGhlIGNvbmNlcm5lZCBzZXR0ZXJcbiAgICAgIHZtLmN1cnJlbnRCZ2ltYWdlKGJsb2NrUHJvcGVydGllc1twcm9wQWNjZXNzb3JdLmJpbmQoYmxvY2tQcm9wZXJ0aWVzKSlcbiAgICAgIHZtLnNob3dEaWFsb2dHYWxsZXJ5KHRydWUpXG4gICAgfVxuICAgIHZtLmNsb3NlRGlhbG9nR2FsbGVyeSA9ICgpID0+IHtcbiAgICAgIHZtLmN1cnJlbnRCZ2ltYWdlKGZhbHNlKVxuICAgICAgdm0uc2hvd0RpYWxvZ0dhbGxlcnkoZmFsc2UpXG4gICAgfVxuXG4gICAgY29uc3QgZGlhbG9nR2FsbGVyeU9wZW4gPSB2bS5zaG93RGlhbG9nR2FsbGVyeS5zdWJzY3JpYmUobmV3VmFsdWUgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB0cnVlICYmIHZtLm1haWxpbmdHYWxsZXJ5U3RhdHVzKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHZtLmxvYWRNYWlsaW5nR2FsbGVyeSgpXG4gICAgICAgIGRpYWxvZ0dhbGxlcnlPcGVuLmRpc3Bvc2UoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZGdldCxcbiAgICB2aWV3TW9kZWwsXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO3ZhciBjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIiksJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsaW5saW5lRG9jdW1lbnQ9cmVxdWlyZShcImp1aWNlL2xpYi9pbmxpbmVcIikoe30pLmlubGluZURvY3VtZW50LGlubGluZXJQbHVnaW49ZnVuY3Rpb24oZSl7ZS5pbmxpbmU9ZnVuY3Rpb24oZSl7JChcIltzdHlsZV06bm90KFtyZXBsYWNlZHN0eWxlXSlcIixlKS5lYWNoKGZ1bmN0aW9uKGUsbil7dmFyIGk9JChuKTtpLmF0dHIoXCJyZXBsYWNlZHN0eWxlXCIsaS5hdHRyKFwic3R5bGVcIikpfSk7dmFyIG49W107JCgnc3R5bGVbZGF0YS1pbmxpbmU9XCJ0cnVlXCJdJyxlKS5lYWNoKGZ1bmN0aW9uKGUsaSl7dmFyIHQ9JChpKS5odG1sKCk7dD0odD10LnJlcGxhY2UoLzwhLS0ga28gKCg/IS0tKS4pKj8gLS0+L2csXCJcIikpLnJlcGxhY2UoLzwhLS0gXFwva28gLS0+L2csXCJcIiksbi5wdXNoKHQpLCQoaSkucmVtb3ZlQXR0cihcImRhdGEtaW5saW5lXCIpfSk7dmFyIGk9bi5qb2luKFwiXFxuXCIpLHQ9ZnVuY3Rpb24obixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9ZSksJChuLGkpfTt0LnJvb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gJChcIjpyb290XCIsZSl9LGlubGluZURvY3VtZW50KHQsaSx7c3R5bGVBdHRyaWJ1dGVOYW1lOlwicmVwbGFjZWRzdHlsZVwifSl9fTttb2R1bGUuZXhwb3J0cz1pbmxpbmVyUGx1Z2luO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1sdWJHbHVaWEl1YW5NaVhTd2libUZ0WlhNaU9sc2lZMjl1YzI5c1pTSXNJbkpsY1hWcGNtVWlMQ0lrSWl3aWQybHVaRzkzSWl3aVoyeHZZbUZzSWl3aWFXNXNhVzVsUkc5amRXMWxiblFpTENKcGJteHBibVZ5VUd4MVoybHVJaXdpZG0waUxDSnBibXhwYm1VaUxDSmtiMk1pTENKbFlXTm9JaXdpYVc1a1pYZ2lMQ0psYkNJc0lpUmxiQ0lzSW1GMGRISWlMQ0p6ZEhsc1pTSXNJbVZzWlcxbGJuUWlMQ0pqYjI1MFpXNTBJaXdpYUhSdGJDSXNJbkpsY0d4aFkyVWlMQ0p3ZFhOb0lpd2ljbVZ0YjNabFFYUjBjaUlzSW5OMGVXeGxWR1Y0ZENJc0ltcHZhVzRpTENJa1kyOXVkR1Y0ZENJc0luTmxiR1ZqZEc5eUlpd2lZMjl1ZEdWNGRDSXNJbkp2YjNRaUxDSnpkSGxzWlVGMGRISnBZblYwWlU1aGJXVWlMQ0p0YjJSMWJHVWlMQ0psZUhCdmNuUnpJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRU3hoUVVWQkxFbEJRVWxCTEZGQlFWVkRMRkZCUVZFc2MwSkJRMnhDUXl4RlFVRjFRaXh2UWtGQldFTXNUMEZCZVVKQkxFOUJRV1VzVDBGQmMwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVVrc1MwRkRNMGRETEdWQlFXbENTaXhSUVVGUkxHMUNRVUZTUVN4RFFVRTBRaXhKUVVGSlNTeGxRVVZxUkVNc1kwRkJaMElzVTBGQlUwTXNSMEZETTBKQkxFVkJRVWRETEU5QlFWTXNVMEZCVTBNc1IwRkZia0pRTEVWQlFVVXNLMEpCUVdkRFR5eEhRVUZMUXl4TFFVRkxMRk5CUVZORExFVkJRVTlETEVkQlF6RkVMRWxCUVVsRExFVkJRVTFZTEVWQlFVVlZMRWRCUTFwRExFVkJRVWxETEV0QlFVc3NaMEpCUVdsQ1JDeEZRVUZKUXl4TFFVRkxMRmxCUjNKRExFbEJRVWxETEVWQlFWRXNSMEZEV21Jc1JVRkJSU3cwUWtGQk5rSlBMRWRCUVV0RExFdEJRVXNzVTBGQlUwTXNSVUZCVDBzc1IwRkRka1FzU1VGQlNVTXNSVUZCVldZc1JVRkJSV01zUjBGQlUwVXNUMEZGZWtKRUxFZEJSRUZCTEVWQlFWVkJMRVZCUVZGRkxGRkJRVkVzTWtKQlFUUkNMRXRCUTNCRFFTeFJRVUZSTEdsQ1FVRnJRaXhKUVVNMVEwb3NSVUZCVFVzc1MwRkJTMGdzUjBGRFdHWXNSVUZCUldNc1IwRkJVMHNzVjBGQlZ5eHBRa0ZGZUVJc1NVRkJTVU1zUlVGQldWQXNSVUZCVFZFc1MwRkJTeXhOUVVOMlFrTXNSVUZCVnl4VFFVRlRReXhGUVVGVlF5eEhRVVZvUXl4WlFVUnpRaXhKUVVGWVFTeEpRVUYzUWtFc1JVRkJWV3BDTEVkQlEzUkRVQ3hGUVVGRmRVSXNSVUZCVlVNc1NVRkZja0pHTEVWQlFWTkhMRXRCUVU4c1YwRkRaQ3hQUVVGUGVrSXNSVUZCUlN4UlFVRlRUeXhKUVVWd1Frb3NaVUZCWlcxQ0xFVkJRVlZHTEVWQlFWY3NRMEZCUlUwc2JVSkJRVzlDTEc5Q1FVazVSRU1zVDBGQlQwTXNVVUZCVlhoQ0lpd2labWxzWlNJNklpOXdjbWwyWVhSbEwzUnRjQzltYjI4dVIwOUZMM055WXk5cWN5OWxlSFF2YVc1c2FXNWxjaTVxY3lKOSIsIlwidXNlIHN0cmljdFwiO3ZhciBsc0xvYWRlcixsc0NvbW1hbmRQbHVnaW5GYWN0b3J5LGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKSxrbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5rbzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rbzpudWxsLCQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cualF1ZXJ5OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmpRdWVyeTpudWxsO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKCl7fTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklteHZZMkZzYzNSdmNtRm5aUzVxY3lKZExDSnVZVzFsY3lJNld5SnNjMHh2WVdSbGNpSXNJbXh6UTI5dGJXRnVaRkJzZFdkcGJrWmhZM1J2Y25raUxDSmpiMjV6YjJ4bElpd2ljbVZ4ZFdseVpTSXNJbXR2SWl3aWQybHVaRzkzSWl3aVoyeHZZbUZzSWl3aUpDSXNJbTF2WkhWc1pTSXNJbVY0Y0c5eWRITWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUlVFc1NVRk5TVUVzVTBGcFFrRkRMSFZDUVhaQ1FVTXNVVUZCVlVNc1VVRkJVU3h6UWtGRGJFSkRMRWRCUVhkQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlZ5eEhRVUZ6UWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVZjc1IwRkJTU3hMUVVOd1IwTXNSVUZCZFVJc2IwSkJRVmhHTEU5QlFYbENRU3hQUVVGbExFOUJRWE5DTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCWlN4UFFVRkpMRXRCZVVjdlIwVXNUMEZCVDBNc1VVRkJWU0lzSW1acGJHVWlPaUl2Y0hKcGRtRjBaUzkwYlhBdlptOXZMa2RQUlM5emNtTXZhbk12WlhoMEwyeHZZMkZzYzNSdmNtRm5aUzVxY3lKOSIsInZhciB1dGlsUGx1Z2luPWZ1bmN0aW9uKGUpe2dsb2JhbC5VdGlsPXtkZWNvZGVVUkk6ZGVjb2RlVVJJLGVuY29kZVVSSTplbmNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50OmRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUklDb21wb25lbnQ6ZW5jb2RlVVJJQ29tcG9uZW50fX07bW9kdWxlLmV4cG9ydHM9dXRpbFBsdWdpbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluVjBhV3d1YW5NaVhTd2libUZ0WlhNaU9sc2lkWFJwYkZCc2RXZHBiaUlzSW5adElpd2laMnh2WW1Gc0lpd2lWWFJwYkNJc0ltUmxZMjlrWlZWU1NTSXNJbVZ1WTI5a1pWVlNTU0lzSW1SbFkyOWtaVlZTU1VOdmJYQnZibVZ1ZENJc0ltVnVZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDSXNJbTF2WkhWc1pTSXNJbVY0Y0c5eWRITWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMRWxCUVVsQkxGZEJRV0VzVTBGQlUwTXNSMEZEZUVKRExFOUJRVTlETEV0QlFVOHNRMEZEV2tNc1ZVRkJZVUVzVlVGRFlrTXNWVUZCWVVFc1ZVRkRZa01zYlVKQlFYTkNRU3h0UWtGRGRFSkRMRzFDUVVGelFrRXNjVUpCU1RGQ1F5eFBRVUZQUXl4UlFVRlZWQ0lzSW1acGJHVWlPaUl2Y0hKcGRtRjBaUzkwYlhBdlptOXZMa2RQUlM5emNtTXZhbk12WlhoMEwzVjBhV3d1YW5NaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtyZXF1aXJlKFwia25vY2tvdXQtc29ydGFibGVcIikscmVxdWlyZShcIi4vYmluZGluZ3MvanF1ZXJ5dWktc3Bpbm5lci5qc1wiKSxyZXF1aXJlKFwiLi9iaW5kaW5ncy9qcXVlcnl1aS10YWJzLmpzXCIpLHJlcXVpcmUoXCIuL2JpbmRpbmdzL2NvbG9ycGlja2VyLmpzXCIpLHJlcXVpcmUoXCIuL2JpbmRpbmdzL2Jsb2Nrcy5qc1wiKSxyZXF1aXJlKFwiLi9iaW5kaW5ncy9jc3N0ZXh0LmpzXCIpLHJlcXVpcmUoXCIuL2JpbmRpbmdzL2JpbmQtaWZyYW1lLmpzXCIpLHJlcXVpcmUoXCIuL2JpbmRpbmdzL2V4dGRyb3BwYWJsZS5qc1wiKSxyZXF1aXJlKFwiLi9iaW5kaW5ncy9wcmVsb2FkZXIuanNcIikscmVxdWlyZShcIi4vYmluZGluZ3MvZmlsZXVwbG9hZC5qc1wiKSxyZXF1aXJlKFwiLi9iaW5kaW5ncy92aXJ0dWFscy5qc1wiKSxyZXF1aXJlKFwiLi9iaW5kaW5ncy93eXNpd3lncy5qc1wiKSxyZXF1aXJlKFwiLi9iaW5kaW5ncy9zY3JvbGxmaXguanNcIikscmVxdWlyZShcIi4vYmluZGluZ3MvaWYtc3Vicy5qc1wiKSxyZXF1aXJlKFwiLi9iaW5kaW5ncy9leHRzb3J0YWJsZXMuanNcIikscmVxdWlyZShcIi4vYmluZGluZ3MvZXZlbnRhYmxlLmpzXCIpLHJlcXVpcmUoXCIuL2JpbmRpbmdzL3Rvb2x0aXBzLmpzXCIpLHJlcXVpcmUoXCIuL2JpbmRpbmdzL2V4dGVuZGVyLXBhZ2luYXRpb24uanNcIikscmVxdWlyZShcIi4vYmluZGluZ3MvdmFsaWRhdGVkLXZhbHVlLmpzXCIpLHJlcXVpcmUoXCIuL2JpbmRpbmdzL3Njcm9sbGludG92aWV3LmpzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW10dkxXSnBibVJwYm1kekxtcHpJbDBzSW01aGJXVnpJanBiSW5KbGNYVnBjbVVpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEdGQlJVRkJMRkZCUVZFc2NVSkJSVkpCTEZGQlFWRXNhME5CUTFKQkxGRkJRVkVzSzBKQlExSkJMRkZCUVZFc05rSkJRMUpCTEZGQlFWRXNkMEpCUTFKQkxGRkJRVkVzZVVKQlExSkJMRkZCUVZFc05rSkJRMUpCTEZGQlFWRXNPRUpCUTFKQkxGRkJRVkVzTWtKQlExSkJMRkZCUVZFc05FSkJRMUpCTEZGQlFWRXNNRUpCUTFKQkxGRkJRVkVzTUVKQlExSkJMRkZCUVZFc01rSkJRMUpCTEZGQlFWRXNlVUpCUTFKQkxGRkJRVkVzT0VKQlExSkJMRkZCUVZFc01rSkJRMUpCTEZGQlFWRXNNRUpCUTFKQkxGRkJRVkVzY1VOQlExSkJMRkZCUVZFc2FVTkJRMUpCTEZGQlFWRWlMQ0ptYVd4bElqb2lMM0J5YVhaaGRHVXZkRzF3TDJadmJ5NUhUMFV2YzNKakwycHpMMnR2TFdKcGJtUnBibWR6TG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIgJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsa289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxrb2pxdWk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua29qcXVpOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsLmtvanF1aTpudWxsLHRlbXBsYXRlQ29udmVydGVyPXJlcXVpcmUoXCIuL2NvbnZlcnRlci9tYWluLmpzXCIpLGNvbnNvbGU9cmVxdWlyZShcImNvbnNvbGUtYnJvd3NlcmlmeVwiKSxpbml0aWFsaXplVmlld21vZGVsPXJlcXVpcmUoXCIuL3ZpZXdtb2RlbC5qc1wiKSx0ZW1wbGF0ZVN5c3RlbT1yZXF1aXJlKFwiLi9iaW5kaW5ncy9jaG9vc2UtdGVtcGxhdGUuanNcIik7aWYoISQudWkudmVyc2lvbi5tYXRjaCgvXjFcXC4xMVxcLi4qJC8pKXRocm93XCJVc3VwcG9ydGVkIGpRdWVyeSBVSSB2ZXJzaW9uIGRldGVjdGVkOiBcIiskLnVpLnZlcnNpb24rXCIgKHdlIG9ubHkgc3VwcG9ydCAxLjExLiopXCI7dmFyIHBsdWdpbnNDYWxsPWZ1bmN0aW9uKGUsdCxuLG8pe3ZhciBpLGEscixkLGw7bD1bXSx2b2lkIDAhPT1vJiZvPyhpPWUubGVuZ3RoLTEsYT0wLHI9LTEpOihpPTAsYT1lLmxlbmd0aC0xLHI9MSk7Zm9yKHZhciBzPWk7cyE9YStyO3MrPXIpdm9pZCAwIT09ZVtzXVt0XSYmdm9pZCAwIT09KGQ9ZVtzXVt0XS5hcHBseShlW3NdLG4pKSYmbC5wdXNoKGQpO3JldHVybiBsfSxvcmlnRGlzcG9zZUNhbGxiYWNrPWtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2s7a28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjaz1mdW5jdGlvbihlLHQpe29yaWdEaXNwb3NlQ2FsbGJhY2soZSxmdW5jdGlvbihlKXt0cnl7dChlKX1jYXRjaChlKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBjb25zb2xlLmRlYnVnJiZjb25zb2xlLmRlYnVnKFwiQ2F1Z2h0IHVuZXhwZWN0ZWQgZGlzcG9zZSBjYWxsYmFjayBleGNlcHRpb25cIixlKX19KX07dmFyIF90ZW1wbGF0ZVVybENvbnZlcnRlcixiaW5kaW5nUGx1Z2luTWFrZXI9ZnVuY3Rpb24oZSl7cmV0dXJue3ZpZXdNb2RlbDpmdW5jdGlvbih0KXt0cnl7ZShcImFwcGx5QmluZGluZ3NcIixrby5hcHBseUJpbmRpbmdzLmJpbmQodm9pZCAwLHQpKX1jYXRjaChlKXt0aHJvdyBjb25zb2xlLndhcm4oZSxlLnN0YWNrKSxlfX0sZGlzcG9zZTpmdW5jdGlvbigpe3RyeXtlKFwidW5hcHBseUJpbmRpbmdzXCIsa28uY2xlYW5Ob2RlLmJpbmQodGhpcyxnbG9iYWwuZG9jdW1lbnQuYm9keSkpfWNhdGNoKGUpe3Rocm93IGNvbnNvbGUud2FybihlLGUuc3RhY2spLGV9fX19LHRlbXBsYXRlQ3JlYXRvcj1mdW5jdGlvbihlLHQsbixvKXt2YXIgaT1uO2Zvcih2b2lkIDAhPT1uJiZ2b2lkIDAhPT1vJiYoXCJvYmplY3RcIj09dHlwZW9mIHQmJlwicmVwbGFjZWRodG1sXCI9PXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpfHwoaSs9XCItXCIrbykpO251bGw9PWl8fGUuZXhpc3RzKGkpOylpPVwiYW5vbnltb3VzLVwiK01hdGguZmxvb3IoMWU1Kk1hdGgucmFuZG9tKCkrMSk7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQmJlwicmVwbGFjZWRodG1sXCI9PXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKXt2YXIgYT0kKHQpLHI9JChcInJlcGxhY2VkaGVhZFwiLGEpLGQ9JChcInJlcGxhY2VkYm9keVwiLGEpO2UuYWRkZXIoaStcIi1oZWFkXCIsci5odG1sKCl8fFwiXCIpLGUuYWRkZXIoaStcIi1zaG93XCIsZC5odG1sKCl8fFwiXCIpLGUuYWRkZXIoaStcIi1wcmV2aWV3XCIsYS5odG1sKCkpLGUuYWRkZXIoaStcIi13eXNpd3lnXCIsYS5odG1sKCkpLHIuY2hpbGRyZW4oKS5kZXRhY2goKSxyLmh0bWwoXCJcXHgzYyEtLSBrbyBibG9jazogY29udGVudCAtLVxceDNlXFx4M2MhLS0gL2tvIC0tXFx4M2VcIiksci5iZWZvcmUoXCJcXHgzYyEtLSBrbyB3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6ICdoZWFkJyB9IC0tXFx4M2VcIiksci5hZnRlcihcIlxceDNjIS0tIC9rbyAtLVxceDNlXCIpLGQuaHRtbChcIlxceDNjIS0tIGtvIGJsb2NrOiBjb250ZW50IC0tXFx4M2VcXHgzYyEtLSAva28gLS1cXHgzZVwiKSxlLmFkZGVyKGkrXCItaWZyYW1lXCIsYVswXS5vdXRlckhUTUwpfWVsc2VcIm9iamVjdFwiPT10eXBlb2YgdD9lLmFkZGVyKGksdC5vdXRlckhUTUwpOmUuYWRkZXIoaSx0KTtyZXR1cm4gaX07ZnVuY3Rpb24gX3ZpZXdNb2RlbFBsdWdpbkluc3RhbmNlKGUpe3ZhciB0O3JldHVybnt2aWV3TW9kZWw6ZnVuY3Rpb24obil7dD1lKG4pfSxpbml0OmZ1bmN0aW9uKCl7dm9pZCAwIT09dCYmdm9pZCAwIT09dC5pbml0JiZ0LmluaXQoKX0sZGlzcG9zZTpmdW5jdGlvbigpe3ZvaWQgMCE9PXQmJnZvaWQgMCE9PXQuZGlzcG9zZSYmdC5kaXNwb3NlKCl9fX12YXIgdGVtcGxhdGVMb2FkZXI9ZnVuY3Rpb24oZSx0LG4sbyxpLGEpe2NvbnNvbGUuaW5mbyhcIlRFTVBMQVRFIExPQURFUlwiKTt2YXIgcj1rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYy50ZW1wbGF0ZVVybENvbnZlcnRlcixkPW47JC5hamF4KHt1cmw6dCxtZXRob2Q6XCJHRVRcIixzdWNjZXNzOmZ1bmN0aW9uKHQsbixsKXt0ZW1wbGF0ZUNvbXBpbGVyKGUscixcInRlbXBsYXRlXCIsdCxvLGQsaSxhKS5pbml0KCl9LGVycm9yOmZ1bmN0aW9uKGUsdCxuKXtjb25zb2xlLmVycm9yKFwiY2Fubm90IHJldHJpZXZlIEhUTUwgZGF0YSBmcm9tIHRlbXBsYXRlXCIpLCQoXCIubW8tc3RhbmRhbG9uZVwiKS5odG1sKFwiPGgxPmVycm9yPC9oMT48aDI+XCIrbitcIjwvaDI+XCIpfX0pfSx0ZW1wbGF0ZUNvbXBpbGVyPWZ1bmN0aW9uKGUsdCxuLG8saSxhLHIsZCl7dmFyIGw9by5tYXRjaCgvXihbXFxTXFxzXSopKFs8XWh0bWxbXj5dKj5bXFxTXFxzXSo8XFwvaHRtbD4pKFtcXFNcXHNdKikkL2kpO2lmKG51bGw9PT1sKXRocm93XCJVbmFibGUgdG8gZmluZCA8aHRtbD4gb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIGluIHRoZSB0ZW1wbGF0ZVwiO3ZhciBzPWxbMV0sYz17XCI8aHRtbFwiOjAsXCI8aGVhZFwiOjAsXCI8Ym9keVwiOjAsXCI8L2h0bWxcIjowLFwiPC9ib2R5XCI6MCxcIjwvaGVhZFwiOjB9LHU9bFsyXS5yZXBsYWNlKC8oPFxcLz8pKGh0bWx8aGVhZHxib2R5KShbXj5dKj4pL2dpLGZ1bmN0aW9uKGUsdCxuLG8pe3JldHVybiBjWyh0K24pLnRvTG93ZXJDYXNlKCldKz0xLHQrXCJyZXBsYWNlZFwiK24rb30pO2Zvcih2YXIgbSBpbiBjKWlmKGMuaGFzT3duUHJvcGVydHkobSkmJjEhPWNbbV0pe2lmKDA9PT1jW21dKXRocm93XCJFUlJPUjogbWlzc2luZyBtYW5kYXRvcnkgZWxlbWVudCBcIittK1wiPlwiO2lmKGNbbV0+MSl0aHJvd1wiRVJST1I6IG11bHRpcGxlIGVsZW1lbnQgXCIrbStcIj4gb2Njb3VyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQgKGZvdW5kIFwiK2NbbV0rXCIgb2Njb3VyZW5jZXMpXCJ9dmFyIHA9bFszXSxiPVtdLGg9W107aWYodm9pZCAwIT09cilmb3IodmFyIGc9MDtnPHIubGVuZ3RoO2crKylcImZ1bmN0aW9uXCI9PXR5cGVvZiByW2ddP2gucHVzaChfdmlld01vZGVsUGx1Z2luSW5zdGFuY2UocltnXSkpOmgucHVzaChyW2ddKTt2YXIgdj1bXSxmPXthZGRlcjpmdW5jdGlvbihlLHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93XCJUZW1wbGF0ZSBzeXN0ZW06IGNhbm5vdCBjcmVhdGUgbmV3IHRlbXBsYXRlIFwiK2U7dmFyIG49dC5tYXRjaCgvKGRhdGEpPy1rby1bXiA9Ol0qL2cpO24mJmNvbnNvbGUuZXJyb3IoXCJFUlJPUjogZm91bmQgdW5leHBlY3RlZCAta28tIGF0dHJpYnV0ZSBpbiBjb21waWxlZCB0ZW1wbGF0ZVwiLGUsXCIsIHlvdSBwcm9iYWJseSBtaXNwZWxsZWQgaXQ6XCIsbiksdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoZSx0KSx2LnB1c2goZSl9LGV4aXN0czpmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09dGVtcGxhdGVTeXN0ZW0uZ2V0VGVtcGxhdGVDb250ZW50KGUpfSxkaXNwb3NlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXYubGVuZ3RoLTE7ZT49MDtlLS0pdGVtcGxhdGVTeXN0ZW0ucmVtb3ZlVGVtcGxhdGUodltlXSl9fTtrby5iaW5kaW5nSGFuZGxlcnMuYmxvY2sudGVtcGxhdGVFeGlzdHM9Zi5leGlzdHM7Zm9yKHZhciB5PXRlbXBsYXRlQ3JlYXRvci5iaW5kKHZvaWQgMCxmKSx3PWUoXCJ0cmFuc2xhdGVUZW1wbGF0ZVwiLHRlbXBsYXRlQ29udmVydGVyLnRyYW5zbGF0ZVRlbXBsYXRlLmJpbmQodm9pZCAwLG4sdSx0LHkpKSxrPWUoXCJnZW5lcmF0ZU1vZGVsXCIsdGVtcGxhdGVDb252ZXJ0ZXIud3JhcHBlZFJlc3VsdE1vZGVsLmJpbmQodm9pZCAwLHcpKSxDPXt9LHg9cGx1Z2luc0NhbGwoaCxcIndpZGdldFwiLFskLGtvLGtvanF1aV0pLEU9MDtFPHgubGVuZ3RoO0UrKylDW3hbRV0ud2lkZ2V0XT14W0VdO2IucHVzaC5hcHBseShiLGUoXCJnZW5lcmF0ZUVkaXRvcnNcIix0ZW1wbGF0ZUNvbnZlcnRlci5nZW5lcmF0ZUVkaXRvcnMuYmluZCh2b2lkIDAsdyxDLHQseSxcIiskcm9vdC5jb250ZW50TGlzdGVuZXJzKClcIikpKTt2YXIgUz0hMTtpZihudWxsIT1pKXt2YXIgTTtNPVwic3RyaW5nXCI9PXR5cGVvZiBpP2tvLnV0aWxzLnBhcnNlSnNvbihpKTppLDI9PWUoXCJjaGVja01vZGVsXCIsdGVtcGxhdGVDb252ZXJ0ZXIuY2hlY2tNb2RlbC5iaW5kKHZvaWQgMCxrLl91bndyYXAoKSxiLE0pKSYmKGNvbnNvbGUuZXJyb3IoXCJUcnlpbmcgdG8gY29tcGlsZSBhbiBpbmNvbXBhdGlibGUgdGVtcGxhdGUgdmVyc2lvbiFcIixrLl91bndyYXAoKSxiLE0pLFM9ITApO3RyeXtrLl93cmFwKE0pfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5qZWN0IG1vZGVsIGNvbnRlbnQhXCIsZSksUz0hMH19dmFyIFQ9cyt0ZW1wbGF0ZVN5c3RlbS5nZXRUZW1wbGF0ZUNvbnRlbnQobitcIi1pZnJhbWVcIikucmVwbGFjZSgvKDxcXC8/KXJlcGxhY2VkKGh0bWx8aGVhZHxib2R5KShbXj5dKj4pL2dpLGZ1bmN0aW9uKGUsdCxuLG8pe3JldHVybiB0K24rb30pK3AsTD1rby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGw7a28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsPVQ7dmFyIEk9e2Rpc3Bvc2U6ZnVuY3Rpb24oKXtrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGw9TH19O2gucHVzaChJKSxoLnB1c2goZik7dmFyIEQ9ZShcImluaXRpYWxpemVWaWV3bW9kZWxcIixpbml0aWFsaXplVmlld21vZGVsLmJpbmQodGhpcyxrLGIsdCxkKSk7RC5tZXRhZGF0YT1hO3JldHVybiB2b2lkIDAhPT1ELm1ldGFkYXRhLmVkaXRvcnZlcnNpb24mJlwiMC4xNy40XCIhPT1ELm1ldGFkYXRhLmVkaXRvcnZlcnNpb24mJmNvbnNvbGUubG9nKFwiVGhlIG1vZGVsIGJlaW5nIGxvYWRlZCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYSBkaWZmZXJlbnQgZWRpdG9yIHZlcnNpb25cIixELm1ldGFkYXRhLmVkaXRvcnZlcnNpb24sXCJydW50aW1lOlwiLFwiMC4xNy40XCIpLEQubWV0YWRhdGEuZWRpdG9ydmVyc2lvbj1cIjAuMTcuNFwiLHZvaWQgMCE9PXcudmVyc2lvbiYmKHZvaWQgMCE9PUQubWV0YWRhdGEudGVtcGxhdGV2ZXJzaW9uJiZELm1ldGFkYXRhLnRlbXBsYXRldmVyc2lvbiE9PXcudmVyc2lvbiYmY29uc29sZS5sb2coXCJUaGUgbW9kZWwgYmVpbmcgbG9hZGVkIGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBhIGRpZmZlcmVudCB0ZW1wbGF0ZSB2ZXJzaW9uXCIsRC5tZXRhZGF0YS50ZW1wbGF0ZXZlcnNpb24sXCJydW50aW1lOlwiLHcudmVyc2lvbiksRC5tZXRhZGF0YS50ZW1wbGF0ZXZlcnNpb249dy52ZXJzaW9uKSx0ZW1wbGF0ZVN5c3RlbS5pbml0KCksaC5wdXNoKGJpbmRpbmdQbHVnaW5NYWtlcihlKSkscGx1Z2luc0NhbGwoaCxcInZpZXdNb2RlbFwiLFtEXSksUyYmJChcIiNpbmNvbXBhdGlibGUtdGVtcGxhdGVcIikuZGlhbG9nKHttb2RhbDohMCxhcHBlbmRUbzpcIiNtby1ib2R5XCIsYnV0dG9uczp7T2s6ZnVuY3Rpb24oKXskKHRoaXMpLmRpYWxvZyhcImNsb3NlXCIpfX19KSx7bW9kZWw6RCxpbml0OmZ1bmN0aW9uKCl7cGx1Z2luc0NhbGwoaCxcImluaXRcIix2b2lkIDAsITApfSxkaXNwb3NlOmZ1bmN0aW9uKCl7cGx1Z2luc0NhbGwoaCxcImRpc3Bvc2VcIix2b2lkIDAsITApfX19LGNoZWNrRmVhdHVyZT1mdW5jdGlvbihlLHQpe2lmKCF0KCkpdGhyb3cgY29uc29sZS53YXJuKFwiTWlzc2luZyBmZWF0dXJlXCIsZSksXCJNaXNzaW5nIGZlYXR1cmUgXCIrZX0saXNDb21wYXRpYmxlPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBjaGVja0ZlYXR1cmUoXCJtYXRjaE1lZGlhXCIsZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09Z2xvYmFsLm1hdGNoTWVkaWF9KSxjaGVja0ZlYXR1cmUoXCJYTUxIdHRwUmVxdWVzdCAyXCIsZnVuY3Rpb24oKXtyZXR1cm5cIlhNTEh0dHBSZXF1ZXN0XCJpbiBnbG9iYWwmJlwid2l0aENyZWRlbnRpYWxzXCJpbiBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0fSksY2hlY2tGZWF0dXJlKFwiRVM1IHN0cmljdFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXN9KCl9KSxjaGVja0ZlYXR1cmUoXCJDU1MgYm9yZGVyUmFkaXVzXCIsZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09Z2xvYmFsLmRvY3VtZW50LmJvZHkuc3R5bGUuYm9yZGVyUmFkaXVzfSksY2hlY2tGZWF0dXJlKFwiQ1NTIGJveFNoYWRvd1wiLGZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PWdsb2JhbC5kb2N1bWVudC5ib2R5LnN0eWxlLmJveFNoYWRvd30pLGNoZWNrRmVhdHVyZShcIkNTUyBib3hTaXppbmdcIixmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT1nbG9iYWwuZG9jdW1lbnQuYm9keS5zdHlsZS5ib3hTaXppbmd9KSxjaGVja0ZlYXR1cmUoXCJDU1MgYmFja2dyb3VuZFNpemVcIixmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT1nbG9iYWwuZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZX0pLGNoZWNrRmVhdHVyZShcIkNTUyBiYWNrZ3JvdW5kT3JpZ2luXCIsZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09Z2xvYmFsLmRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZE9yaWdpbn0pLGNoZWNrQmFkQnJvd3NlckV4dGVuc2lvbnMoKSwhMH1jYXRjaChlKXtyZXR1cm4hMX19LGNoZWNrQmFkQnJvd3NlckV4dGVuc2lvbnM9ZnVuY3Rpb24oKXt2YXIgZT1cImNoZWNrYmFkYnJvd3NlcnNmcmFtZVwiLHQ9a28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsO2tvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbD0nPCFET0NUWVBFIGh0bWw+XFxyXFxuPGh0bWw+XFxyXFxuPGhlYWQ+PHRpdGxlPkE8L3RpdGxlPlxcclxcbjwvaGVhZD5cXHJcXG48Ym9keT48cCBzdHlsZT1cImNvbG9yOiBibHVlXCIgYWxpZ249XCJyaWdodFwiIGRhdGEtYmluZD1cInN0eWxlOiB7IGNvbG9yOiBcXCdyZWRcXCcgfVwiPkI8L3A+PGRpdiBkYXRhLWJpbmQ9XCJ0ZXh0OiBjb250ZW50XCI+PC9kaXY+PC9ib2R5PlxcclxcbjwvaHRtbD5cXHJcXG4nLCQoXCJib2R5XCIpLmFwcGVuZCgnPGlmcmFtZSBpZD1cIicrZSsnXCIgZGF0YS1iaW5kPVwiYmluZElmcmFtZTogJGRhdGFcIj48L2lmcmFtZT4nKTt2YXIgbj1nbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSk7a28uYXBwbHlCaW5kaW5ncyh7Y29udGVudDpcImR1bW15IGNvbnRlbnRcIn0sbik7dmFyIG89bi5jb250ZW50V2luZG93LmRvY3VtZW50LmRvY3R5cGUsaT1cIjwhRE9DVFlQRSBcIitvLm5hbWUrKG8ucHVibGljSWQ/JyBQVUJMSUMgXCInK28ucHVibGljSWQrJ1wiJzpcIlwiKSsoIW8ucHVibGljSWQmJm8uc3lzdGVtSWQ/XCIgU1lTVEVNXCI6XCJcIikrKG8uc3lzdGVtSWQ/JyBcIicrby5zeXN0ZW1JZCsnXCInOlwiXCIpK1wiPlwiK1wiXFxuXCIrbi5jb250ZW50V2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7a28uY2xlYW5Ob2RlKG4pLGtvLnJlbW92ZU5vZGUobiksa28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsPXQ7dmFyIGE9JzwhRE9DVFlQRSBodG1sPlxcbjxodG1sPjxoZWFkPjx0aXRsZT5BPC90aXRsZT5cXG48L2hlYWQ+XFxuPGJvZHk+PHAgYWxpZ249XCJyaWdodFwiIHN0eWxlPVwiY29sb3I6IHJlZDtcIiBkYXRhLWJpbmQ9XCJzdHlsZTogeyBjb2xvcjogXFwncmVkXFwnIH1cIj5CPC9wPjxkaXYgZGF0YS1iaW5kPVwidGV4dDogY29udGVudFwiPmR1bW15IGNvbnRlbnQ8L2Rpdj5cXG5cXG48L2JvZHk+PC9odG1sPicscj0nPCFET0NUWVBFIGh0bWw+XFxuPGh0bWw+PGhlYWQ+PHRpdGxlPkE8L3RpdGxlPlxcbjwvaGVhZD5cXG48Ym9keT48cCBzdHlsZT1cImNvbG9yOiByZWQ7XCIgZGF0YS1iaW5kPVwic3R5bGU6IHsgY29sb3I6IFxcJ3JlZFxcJyB9XCIgYWxpZ249XCJyaWdodFwiPkI8L3A+PGRpdiBkYXRhLWJpbmQ9XCJ0ZXh0OiBjb250ZW50XCI+ZHVtbXkgY29udGVudDwvZGl2PlxcblxcbjwvYm9keT48L2h0bWw+JyxkPSc8IURPQ1RZUEUgaHRtbD5cXG48aHRtbD48aGVhZD48dGl0bGU+QTwvdGl0bGU+XFxuPC9oZWFkPlxcbjxib2R5PjxwIHN0eWxlPVwiY29sb3I6IHJlZDtcIiBhbGlnbj1cInJpZ2h0XCIgZGF0YS1iaW5kPVwic3R5bGU6IHsgY29sb3I6IFxcJ3JlZFxcJyB9XCI+QjwvcD48ZGl2IGRhdGEtYmluZD1cInRleHQ6IGNvbnRlbnRcIj5kdW1teSBjb250ZW50PC9kaXY+XFxuXFxuPC9ib2R5PjwvaHRtbD4nO2lmKGEhPT1pJiZyIT09aSYmZCE9PWkpdGhyb3cgY29uc29sZS5pbmZvKFwiQmFkQnJvd3Nlci5GcmFtZUNvbnRlbnRDaGVja1wiLGkubGVuZ3RoLGEubGVuZ3RoLHIubGVuZ3RoLGQubGVuZ3RoLGk9PWEsaT09cixpPT1kKSxjb25zb2xlLmluZm8oaSksXCJVbmV4cGVjdGVkIGZyYW1lIGNvbnRlbnQuIE1pc2JlaGF2aW5nIGJyb3dzZXI6IFwiK2kubGVuZ3RoK1wiL1wiK2EubGVuZ3RoK1wiL1wiK3IubGVuZ3RoK1wiL1wiK2QubGVuZ3RofSxmaXhQYWdlRXZlbnRzPWZ1bmN0aW9uKCl7Z2xvYmFsLmFkZEV2ZW50TGlzdGVuZXImJihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdcIixmdW5jdGlvbihlKXsoZT1lfHxnbG9iYWwuZXZlbnQpLnByZXZlbnREZWZhdWx0KCl9LCExKSxnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLGZ1bmN0aW9uKGUpeyhlPWV8fGdsb2JhbC5ldmVudCkucHJldmVudERlZmF1bHQoKX0sITEpLGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIixmdW5jdGlvbihlKXsoZT1lfHxnbG9iYWwuZXZlbnQpLnByZXZlbnREZWZhdWx0KCl9LCExKSxnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIixmdW5jdGlvbihlKXsoZT1lfHxnbG9iYWwuZXZlbnQpLnByZXZlbnREZWZhdWx0KCl9LCExKSxnbG9iYWwuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKX0sITEpKSxnbG9iYWwuZG9jdW1lbnQub25kcmFnc3RhcnQmJihnbG9iYWwuZG9jdW1lbnQub25kcmFnc3RhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0pfTttb2R1bGUuZXhwb3J0cz17Y29tcGlsZTp0ZW1wbGF0ZUNvbXBpbGVyLGxvYWQ6dGVtcGxhdGVMb2FkZXIsaXNDb21wYXRpYmxlOmlzQ29tcGF0aWJsZSxmaXhQYWdlRXZlbnRzOmZpeFBhZ2VFdmVudHN9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5SbGJYQnNZWFJsTFd4dllXUmxjaTVxY3lKZExDSnVZVzFsY3lJNld5SWtJaXdpZDJsdVpHOTNJaXdpWjJ4dlltRnNJaXdpYTI4aUxDSnJiMnB4ZFdraUxDSjBaVzF3YkdGMFpVTnZiblpsY25SbGNpSXNJbkpsY1hWcGNtVWlMQ0pqYjI1emIyeGxJaXdpYVc1cGRHbGhiR2w2WlZacFpYZHRiMlJsYkNJc0luUmxiWEJzWVhSbFUzbHpkR1Z0SWl3aWRXa2lMQ0oyWlhKemFXOXVJaXdpYldGMFkyZ2lMQ0p3YkhWbmFXNXpRMkZzYkNJc0luQnNkV2RwYm5NaUxDSnRaWFJvYjJST1lXMWxJaXdpWVhKbmN5SXNJbkpsZG1WeWMyVWlMQ0p6ZEdGeWRDSXNJbVZ1WkNJc0ltUnBabVlpTENKeVpYTWlMQ0p5WlhOMWJIUnpJaXdpYkdWdVozUm9JaXdpYVNJc0ltRndjR3g1SWl3aWNIVnphQ0lzSW05eWFXZEVhWE53YjNObFEyRnNiR0poWTJzaUxDSjFkR2xzY3lJc0ltUnZiVTV2WkdWRWFYTndiM05oYkNJc0ltRmtaRVJwYzNCdmMyVkRZV3hzWW1GamF5SXNJbTV2WkdVaUxDSmpZV3hzWW1GamF5SXNJbVVpTENKa1pXSjFaeUlzSWw5MFpXMXdiR0YwWlZWeWJFTnZiblpsY25SbGNpSXNJbUpwYm1ScGJtZFFiSFZuYVc1TllXdGxjaUlzSW5CbGNtWnZjbTFoYm1ObFFYZGhjbVZEWVd4c1pYSWlMQ0oyYVdWM1RXOWtaV3dpTENKaGNIQnNlVUpwYm1ScGJtZHpJaXdpWW1sdVpDSXNJblZ1WkdWbWFXNWxaQ0lzSW1WeWNpSXNJbmRoY200aUxDSnpkR0ZqYXlJc0ltUnBjM0J2YzJVaUxDSmpiR1ZoYms1dlpHVWlMQ0owYUdseklpd2laRzlqZFcxbGJuUWlMQ0ppYjJSNUlpd2lkR1Z0Y0d4aGRHVkRjbVZoZEc5eUlpd2lkR1Z0Y0d4aGRHVlFiSFZuYVc0aUxDSm9kRzFzVDNKRmJHVnRaVzUwSWl3aWIzQjBhVzl1WVd4T1lXMWxJaXdpZEdWdGNHeGhkR1ZOYjJSbElpd2lkRzF3VG1GdFpTSXNJblJoWjA1aGJXVWlMQ0owYjB4dmQyVnlRMkZ6WlNJc0ltVjRhWE4wY3lJc0lrMWhkR2dpTENKbWJHOXZjaUlzSW5KaGJtUnZiU0lzSWlSbGJDSXNJaVJvWldGa0lpd2lKR0p2WkhraUxDSmhaR1JsY2lJc0ltaDBiV3dpTENKamFHbHNaSEpsYmlJc0ltUmxkR0ZqYUNJc0ltSmxabTl5WlNJc0ltRm1kR1Z5SWl3aWIzVjBaWEpJVkUxTUlpd2lYM1pwWlhkTmIyUmxiRkJzZFdkcGJrbHVjM1JoYm1ObElpd2ljR3gxWjJsdVJuVnVZM1JwYjI0aUxDSnBibk4wWVc1alpTSXNJbWx1YVhRaUxDSjBaVzF3YkdGMFpVeHZZV1JsY2lJc0luUmxiWEJzWVhSbFJtbHNaVTVoYldVaUxDSjBaVzF3YkdGMFpVMWxkR0ZrWVhSaElpd2lhbk52Y21wemIyNGlMQ0psZUhSbGJuTnBiMjV6SWl3aVoyRnNiR1Z5ZVZWeWJDSXNJbWx1Wm04aUxDSjBaVzF3YkdGMFpWVnliRU52Ym5abGNuUmxjaUlzSW1KcGJtUnBibWRJWVc1a2JHVnljeUlzSW5kNWMybDNlV2RUY21NaUxDSnRaWFJoWkdGMFlTSXNJbUZxWVhnaUxDSjFjbXdpTENKdFpYUm9iMlFpTENKemRXTmpaWE56SWl3aWRHVnRjR3hoZEdWamIyUmxJaXdpZEdWNGRGTjBZWFIxY3lJc0ltcHhXRWhTSWl3aWRHVnRjR3hoZEdWRGIyMXdhV3hsY2lJc0ltVnljbTl5SWl3aVpYSnliM0pVYUhKdmQyNGlMQ0owWlcxd2JHRjBaVTVoYldVaUxDSndjbVZtYVhnaUxDSmlZWE5wWTFOMGNuVmpkSFZ5WlNJc0lqeG9kRzFzSWl3aVBHaGxZV1FpTENJOFltOWtlU0lzSWp3dmFIUnRiQ0lzSWp3dlltOWtlU0lzSWp3dmFHVmhaQ0lzSW5KbGNHeGhZMlVpTENKd01TSXNJbkF5SWl3aWNETWlMQ0psYkdVaUxDSm9ZWE5QZDI1UWNtOXdaWEowZVNJc0luQnZjM1JtYVhnaUxDSmliRzlqYTBSbFpuTWlMQ0pqY21WaGRHVmtWR1Z0Y0d4aGRHVnpJaXdpZEdWdGNHeGhkR1Z6VUd4MVoybHVJaXdpYVdRaUxDSjBjbUZ6YUNJc0ltRmtaRlJsYlhCc1lYUmxJaXdpWjJWMFZHVnRjR3hoZEdWRGIyNTBaVzUwSWl3aWNtVnRiM1psVkdWdGNHeGhkR1VpTENKMFpXMXdiR0YwWlVWNGFYTjBjeUlzSW0xNVZHVnRjR3hoZEdWRGNtVmhkRzl5SWl3aWRHVnRjR3hoZEdWRVpXWWlMQ0owY21GdWMyeGhkR1ZVWlcxd2JHRjBaU0lzSW1OdmJuUmxiblFpTENKM2NtRndjR1ZrVW1WemRXeDBUVzlrWld3aUxDSjNhV1JuWlhSeklpd2lkMmxrWjJWMFVHeDFaMmx1Y3lJc0luZHBJaXdpZDJsa1oyVjBJaXdpWjJWdVpYSmhkR1ZGWkdsMGIzSnpJaXdpYVc1amIyMXdZWFJwWW14bFZHVnRjR3hoZEdVaUxDSjFibmR5WVhCd1pXUWlMQ0p3WVhKelpVcHpiMjRpTENKamFHVmphMDF2WkdWc0lpd2lYM1Z1ZDNKaGNDSXNJbDkzY21Gd0lpd2laWGdpTENKcFpuSmhiV1ZVY0d3aUxDSnZjbWxuYVVaeVlXMWxWSEJzSWl3aVltbHVaRWxtY21GdFpTSXNJblJ3YkNJc0ltbEdjbUZ0WlZCc2RXZHBiaUlzSW1Wa2FYUnZjblpsY25OcGIyNGlMQ0pzYjJjaUxDSjBaVzF3YkdGMFpYWmxjbk5wYjI0aUxDSmthV0ZzYjJjaUxDSnRiMlJoYkNJc0ltRndjR1Z1WkZSdklpd2lZblYwZEc5dWN5SXNJazlySWl3aWJXOWtaV3dpTENKamFHVmphMFpsWVhSMWNtVWlMQ0ptWldGMGRYSmxJaXdpWm5WdVl5SXNJbWx6UTI5dGNHRjBhV0pzWlNJc0ltMWhkR05vVFdWa2FXRWlMQ0pZVFV4SWRIUndVbVZ4ZFdWemRDSXNJbk4wZVd4bElpd2lZMmhsWTJ0Q1lXUkNjbTkzYzJWeVJYaDBaVzV6YVc5dWN5SXNJbVY0WTJWd2RHbHZiaUlzSW05eWFXZFVjR3dpTENKaGNIQmxibVFpTENKbWNtRnRaVVZzSWl3aVoyVjBSV3hsYldWdWRFSjVTV1FpTENKamIyNTBaVzUwVjJsdVpHOTNJaXdpWkc5amRIbHdaU0lzSW01aGJXVWlMQ0p3ZFdKc2FXTkpaQ0lzSW5ONWMzUmxiVWxrSWl3aVpHOWpkVzFsYm5SRmJHVnRaVzUwSWl3aWNtVnRiM1psVG05a1pTSXNJbVY0Y0dWamRHVmtJaXdpWlhod1pXTjBaV1F5SWl3aVpYaHdaV04wWldReklpd2labWw0VUdGblpVVjJaVzUwY3lJc0ltRmtaRVYyWlc1MFRHbHpkR1Z1WlhJaUxDSmxkbVZ1ZENJc0luQnlaWFpsYm5SRVpXWmhkV3gwSWl3aWIyNWtjbUZuYzNSaGNuUWlMQ0p0YjJSMWJHVWlMQ0psZUhCdmNuUnpJaXdpWTI5dGNHbHNaU0lzSW14dllXUWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUjBFc1NVRkJTVUVzUlVGQmRVSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVhOQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlpTeFBRVUZKTEV0QlF6TkhReXhIUVVGM1FpeHZRa0ZCV0VZc1QwRkJlVUpCTEU5QlFWY3NSMEZCYzBJc2IwSkJRVmhETEU5QlFYbENRU3hQUVVGWExFZEJRVWtzUzBGRGNFZEZMRTlCUVRSQ0xHOUNRVUZZU0N4UFFVRjVRa0VzVDBGQlpTeFBRVUZ6UWl4dlFrRkJXRU1zVDBGQmVVSkJMRTlCUVdVc1QwRkJTU3hMUVVOb1NFY3NhMEpCUVc5Q1F5eFJRVUZSTEhWQ1FVTTFRa01zVVVGQlZVUXNVVUZCVVN4elFrRkRiRUpGTEc5Q1FVRnpRa1lzVVVGQlVTeHJRa0ZET1VKSExHVkJRV2xDU0N4UlFVRlJMR2xEUVVVM1FpeEpRVUZMVGl4RlFVRkZWU3hIUVVGSFF5eFJRVUZSUXl4TlFVRk5MR1ZCUVdkQ0xFdEJRVTBzTUVOQlFUQkRXaXhGUVVGRlZTeEhRVUZIUXl4UlFVRlJMRFJDUVVseVJ5eEpRVUZKUlN4WlFVRmpMRk5CUVZORExFVkJRVk5ETEVWQlFWbERMRVZCUVUxRExFZEJRM0JFTEVsQlFVbERMRVZCUVU5RExFVkJRVXRETEVWQlFVMURMRVZCUVV0RExFVkJRek5DUVN4RlFVRlZMRkZCUTJFc1NVRkJXa3dzUjBGQk1rSkJMRWRCUTNCRFF5eEZRVUZSU2l4RlFVRlJVeXhQUVVGVExFVkJRM3BDU2l4RlFVRk5MRVZCUTA1RExFZEJRVkVzU1VGRlVrWXNSVUZCVVN4RlFVTlNReXhGUVVGTlRDeEZRVUZSVXl4UFFVRlRMRVZCUTNaQ1NDeEZRVUZQTEVkQlJWUXNTVUZCU3l4SlFVRkpTU3hGUVVGSlRpeEZRVUZQVFN4SFFVRkxUQ3hGUVVGTlF5eEZRVUZOU1N4SFFVRkxTaXhQUVVOR0xFbEJRVE5DVGl4RlFVRlJWU3hIUVVGSFZDeFRRVVZFTEV0QlJHNUNUU3hGUVVGTlVDeEZRVUZSVlN4SFFVRkhWQ3hIUVVGWlZTeE5RVUZOV0N4RlFVRlJWU3hIUVVGSlVpeExRVU5tVFN4RlFVRlJTU3hMUVVGTFRDeEhRVWRxUkN4UFFVRlBReXhIUVV0TVN5eHZRa0ZCYzBKNFFpeEhRVUZIZVVJc1RVRkJUVU1zWjBKQlFXZENReXh0UWtGRGJrUXpRaXhIUVVGSGVVSXNUVUZCVFVNc1owSkJRV2RDUXl4dFFrRkJjVUlzVTBGQlUwTXNSVUZCVFVNc1IwRlRNMFJNTEc5Q1FVRnZRa2tzUlVGU1JpeFRRVUZUUVN4SFFVTjZRaXhKUVVORlF5eEZRVUZUUkN4SFFVTlVMRTFCUVU5RkxFZEJSWEZDTEcxQ1FVRnFRakZDTEZGQlFWRXlRaXhQUVVGeFFqTkNMRkZCUVZFeVFpeE5RVUZOTEN0RFFVRm5SRVFzVDBGTk5VY3NTVUUwUlVsRkxITkNRVFZGUVVNc2JVSkJRWEZDTEZOQlFWTkRMRWRCUTJoRExFMUJRVThzUTBGRFRFTXNWVUZCVnl4VFFVRlRRU3hIUVVOc1FpeEpRVU5GUkN4RlFVRjFRaXhuUWtGQmFVSnNReXhIUVVGSGIwTXNZMEZCWTBNc1ZVRkJTME1zUlVGQlYwZ3NTVUZEZWtVc1RVRkJUMGtzUjBGRlVDeE5RVVJCYmtNc1VVRkJVVzlETEV0QlFVdEVMRVZCUVV0QkxFVkJRVWxGTEU5QlEyaENSaXhKUVVkV1J5eFJRVUZUTEZkQlExQXNTVUZEUlZJc1JVRkJkVUlzYTBKQlFXMUNiRU1zUjBGQlJ6SkRMRlZCUVZWT0xFdEJRVXRQTEV0QlFVMDNReXhQUVVGUE9FTXNVMEZCVTBNc1QwRkRiRVlzVFVGQlQxQXNSMEZGVUN4TlFVUkJia01zVVVGQlVXOURMRXRCUVV0RUxFVkJRVXRCTEVWQlFVbEZMRTlCUTJoQ1JpeE5RVTFXVVN4blFrRkJhMElzVTBGQlUwTXNSVUZCWjBKRExFVkJRV1ZETEVWQlFXTkRMRWRCUXpGRkxFbEJRVWxETEVWQlFWVkdMRVZCUzJRc1UwRktNa0lzU1VGQmFFSkJMRkZCUVhORUxFbEJRV2hDUXl4SlFVTnVRaXhwUWtGQmFrSkdMRWRCUVc5RkxHZENRVUYyUTBFc1JVRkJZMGtzVVVGQlVVTXNaMEpCUVdsRFJpeEhRVUZYTEVsQlFVMUVMRWxCUnpOSExFMUJRVTlETEVkQlFUaERTaXhGUVVGbFR5eFBRVUZQU0N4SlFVTm9Sa0VzUlVGQlZTeGhRVUZsU1N4TFFVRkxReXhOUVVGMVFpeEpRVUZvUWtRc1MwRkJTMFVzVTBGQmNVSXNSMEZIYWtVc1IwRkJORUlzYVVKQlFXcENWQ3hIUVVGdlJTeG5Ra0ZCZGtOQkxFVkJRV05KTEZGQlFWRkRMR05CUVdsRExFTkJRemRHTEVsQlFVbExMRVZCUVUwNVJDeEZRVUZGYjBRc1IwRkRVbGNzUlVGQlVTOUVMRVZCUVVVc1pVRkJaMEk0UkN4SFFVTXhRa1VzUlVGQlVXaEZMRVZCUVVVc1pVRkJaMEk0UkN4SFFVTTVRbGdzUlVGQlpXTXNUVUZCVFZZc1JVRkJWU3hSUVVGVFVTeEZRVUZOUnl4UlFVRlZMRWxCUTNoRVppeEZRVUZsWXl4TlFVRk5WaXhGUVVGVkxGRkJRVk5UTEVWQlFVMUZMRkZCUVZVc1NVRkRlRVJtTEVWQlFXVmpMRTFCUVUxV0xFVkJRVlVzVjBGQldVOHNSVUZCU1Vrc1VVRkRMME5tTEVWQlFXVmpMRTFCUVUxV0xFVkJRVlVzVjBGQldVOHNSVUZCU1Vrc1VVRkhMME5JTEVWQlFVMUpMRmRCUVZkRExGTkJRMnBDVEN4RlFVRk5SeXhMUVVGTExITkVRVU5ZU0N4RlFVRk5UU3hQUVVGUExEaEVRVU5pVGl4RlFVRk5UeXhOUVVGTkxITkNRVU5hVGl4RlFVRk5SU3hMUVVGTExITkVRVVZZWml4RlFVRmxZeXhOUVVGTlZpeEZRVUZWTEZWQlFWZFBMRVZCUVVrc1IwRkJSMU1zWlVGRmFFSXNhVUpCUVdwQ2JrSXNSVUZEYUVKRUxFVkJRV1ZqTEUxQlFVMVdMRVZCUVZOSUxFVkJRV050UWl4WFFVVTFRM0JDTEVWQlFXVmpMRTFCUVUxV0xFVkJRVk5JTEVkQlIyaERMRTlCUVU5SExFZEJTVlFzVTBGQlUybENMSGxDUVVGNVFrTXNSMEZEYUVNc1NVRkJTVU1zUlVGRFNpeE5RVUZQTEVOQlEweHdReXhWUVVGWExGTkJRVk5CTEVkQlEyeENiME1zUlVGQlYwUXNSVUZCWlc1RExFbEJSVFZDY1VNc1MwRkJUU3huUWtGRGIwSXNTVUZCWWtRc1VVRkJjVVFzU1VGQmJFSkJMRVZCUVZORExFMUJRWE5DUkN4RlFVRlRReXhSUVVWNFJqbENMRkZCUVZNc1owSkJRMmxDTEVsQlFXSTJRaXhSUVVGM1JDeEpRVUZ5UWtFc1JVRkJVemRDTEZOQlFYbENOa0lzUlVGQlV6ZENMRmxCSzBNdlJpeEpRVUZKSzBJc1pVRkJhVUlzVTBGQlUzWkRMRVZCUVhkQ2QwTXNSVUZCYTBKRExFVkJRV3RDUXl4RlFVRlZReXhGUVVGWlF5eEhRVU01UnpGRkxGRkJRVkV5UlN4TFFVRkxMRzFDUVVkaUxFbEJRVWxETEVWQlFYVkNhRVlzUjBGQlIybEdMR2RDUVVGblFrTXNWMEZCVjBZc2NVSkJSWEpFUnl4RlFVRlpVaXhGUVVsb1FqbEZMRVZCUVVWMVJpeExRVUZMTEVOQlEweERMRWxCUVZWWUxFVkJRMVpaTEU5QlFWVXNUVUZEVmtNc1VVRkpSaXhUUVVGdFFrTXNSVUZCWTBNc1JVRkJXVU1zUjBGRGFrTkRMR2xDUVVGcFFucEVMRVZCUVhkQ09FTXNSVUZCYzBJc1YwRkJXVkVzUlVGQlkxb3NSVUZCVlU4c1JVRkJWVTRzUlVGQldVTXNSMEZETDBoT0xGRkJURXB2UWl4TlFWRkdMRk5CUVdsQ1JpeEZRVUZQUkN4RlFVRlpTU3hIUVVOc1EzcEdMRkZCUVZGM1JpeE5RVUZOTERKRFFVTmtMMFlzUlVGQlJTeHJRa0ZCYTBKclJTeExRVUZMTEhGQ1FVRjFRamhDTEVWQlFXTXNZVUZOT1VSR0xHbENRVUZ0UWl4VFFVRlRla1FzUlVGQmQwSTRReXhGUVVGelFtTXNSVUZCWTA0c1JVRkJZMW9zUlVGQlZVOHNSVUZCVlU0c1JVRkJXVU1zUjBGSGVFa3NTVUZCU1RWRUxFVkJRVTF6UlN4RlFVRmhMMFVzVFVGQlRTeDFSRUZETjBJc1IwRkJXU3hQUVVGU1V5eEZRVUZqTEV0QlFVMHNhVVZCUTNoQ0xFbEJRVWsyUlN4RlFVRlROMFVzUlVGQlNTeEhRVVZpT0VVc1JVRkJhVUlzUTBGQlJVTXNVVUZCVXl4RlFVRkhReXhSUVVGVExFVkJRVWRETEZGQlFWTXNSVUZCUjBNc1UwRkJWU3hGUVVGSFF5eFRRVUZWTEVWQlFVZERMRk5CUVZVc1IwRkRNMFoyUXl4RlFVRlBOME1zUlVGQlNTeEhRVUZIY1VZc1VVRkJVU3h0UTBGQmIwTXNVMEZCVXpsR0xFVkJRVThyUml4RlFVRkpReXhGUVVGSlF5eEhRVVZ3Uml4UFFVUkJWaXhIUVVGblFsRXNSVUZCUjBNc1IwRkJTVzVFTEdkQ1FVRnJRaXhGUVVOc1EydEVMRVZCUVVzc1YwRkJZVU1zUlVGQlMwTXNTVUZGYUVNc1NVRkJTeXhKUVVGSlF5eExRVUZQV0N4RlFVRm5RaXhIUVVGSlFTeEZRVUZsV1N4bFFVRmxSQ3hKUVVGcFF5eEhRVUYyUWxnc1JVRkJaVmNzUjBGQlZ5eERRVU53Unl4SFFVRTBRaXhKUVVGNFFsZ3NSVUZCWlZjc1IwRkJXU3hMUVVGTkxHOURRVUZ2UTBFc1JVRkJTU3hKUVVNM1JTeEhRVUZKV0N4RlFVRmxWeXhIUVVGUExFVkJRVWNzUzBGQlRTd3lRa0ZCTWtKQkxFVkJRVWtzTUVOQlFUQkRXQ3hGUVVGbFZ5eEhRVUZMTEdkQ1FVVnNTU3hKUVVGSlJTeEZRVUZWTTBZc1JVRkJTU3hIUVVOa05FWXNSVUZCV1N4SFFVdGFia2NzUlVGQlZTeEhRVVZrTEZGQlFUQkNMRWxCUVdaclJTeEZRVU5VTEVsQlFVc3NTVUZCU1hoRUxFVkJRVWtzUlVGQlIwRXNSVUZCU1hkRUxFVkJRVmQ2UkN4UFFVRlJReXhKUVVOVUxHMUNRVUZxUW5kRUxFVkJRVmQ0UkN4SFFVTndRbFlzUlVGQlVWa3NTMEZCU3poRExIbENRVUY1UWxFc1JVRkJWM2hFTEV0QlJXcEVWaXhGUVVGUldTeExRVUZMYzBRc1JVRkJWM2hFTEVsQlN6bENMRWxCUVVrd1JpeEZRVUZ0UWl4SFFVTnVRa01zUlVGQmEwSXNRMEZEY0VKc1JDeE5RVUZQTEZOQlFWTnRSQ3hGUVVGSmJFUXNSMEZEYkVJc1IwRkJiMElzYVVKQlFWUkJMRVZCUVcxQ0xFdEJRVTBzSzBOQlFXbEVhMFFzUlVGRGNrWXNTVUZCU1VNc1JVRkJVVzVFTEVWQlFVdDBSQ3hOUVVGTkxIVkNRVU51UW5sSExFZEJRMFk1Unl4UlFVRlJkMFlzVFVGQlRTdzRSRUZCSzBSeFFpeEZRVUZKTEN0Q1FVRm5RME1zUjBGRmJrZzFSeXhsUVVGbE5rY3NXVUZCV1VZc1JVRkJTV3hFTEVkQlF5OUNaMFFzUlVGQmFVSjRSaXhMUVVGTE1FWXNTVUZGZUVJeFJDeFBRVUZSTEZOQlFWTXdSQ3hIUVVWbUxGbEJRV3RDTEVsQlJGUXpSeXhsUVVGbE9FY3NiVUpCUVcxQ1NDeEpRVWszUTNaRkxGRkJRVk1zVjBGRFVDeEpRVUZMTEVsQlFVbHlRaXhGUVVGSk1FWXNSVUZCYVVJelJpeFBRVUZUTEVWQlFVZERMRWRCUVVzc1JVRkJSMEVzU1VGRGFFUm1MR1ZCUVdVclJ5eGxRVUZsVGl4RlFVRnBRakZHTEUxQlMzSkVja0lzUjBGQlIybEdMR2RDUVVGMVFpeE5RVUZGY1VNc1pVRkJhVUpPTEVWQlFXZENla1FzVDBGak4wUXNTVUZZUVN4SlFVRkpaMFVzUlVGQmIwSjRSU3huUWtGQlowSldMRlZCUVV0RExFVkJRVmN3UlN4SFFVZHdSRkVzUlVGQlkzUkdMRVZCUVhWQ0xHOUNRVUZ4UW1oRExHdENRVUZyUW5WSUxHdENRVUZyUW5CR0xGVkJRVXRETEVWQlFWZDNSQ3hGUVVGakwwSXNSVUZCVFdsQ0xFVkJRWE5DZFVNc1NVRkhlRXBITEVWQlFWVjRSaXhGUVVGMVFpeG5Ra0ZCYVVKb1F5eHJRa0ZCYTBKNVNDeHRRa0ZCYlVKMFJpeFZRVUZMUXl4RlFVRlhhMFlzU1VGSGRrZEpMRVZCUVZVc1IwRkRWa01zUlVGQlowSnVTQ3haUVVGWlF5eEZRVUZUTEZOQlFWVXNRMEZCUTJRc1JVRkJSMGNzUjBGQlNVTXNVMEZEYkVRMlNDeEZRVUZMTEVWQlFVZEJMRVZCUVV0RUxFVkJRV042Unl4UFFVRlJNRWNzU1VGRE1VTkdMRVZCUVZGRExFVkJRV05ETEVkQlFVbERMRkZCUVZWR0xFVkJRV05ETEVkQlJYQkVhRUlzUlVGQlZYWkdMRXRCUVV0RUxFMUJRVTEzUml4RlFVRlhOVVVzUlVGQmRVSXNhMEpCUVcxQ2FFTXNhMEpCUVd0Q09FZ3NaMEpCUVdkQ00wWXNWVUZCUzBNc1JVRkJWMnRHTEVWQlFXRkpMRVZCUVZNMVF5eEZRVUZ6UW5WRExFVkJkRVJ3U2l3clFrRjNSSEJDTEVsQlFVbFZMRWRCUVhWQ0xFVkJRek5DTEVkQlFVa3NUVUZCVDNKRUxFVkJRU3RETEVOQlEzaEVMRWxCUVVselJDeEZRVVZHUVN4RlFVUnhRaXhwUWtGQlduUkVMRVZCUTBjMVJTeEhRVUZIZVVJc1RVRkJUVEJITEZWQlFWVjJSQ3hIUVVWdVFrRXNSVUZOVHl4SFFVWkVNVU1zUlVGQmRVSXNZVUZCWTJoRExHdENRVUZyUW10SkxGZEJRVmN2Uml4VlFVRkxReXhGUVVGWGIwWXNSVUZCVVZjc1ZVRkJWM1pDTEVWQlFWZHZRaXhOUVVkc1NUbElMRkZCUVZGM1JpeE5RVUZOTEhORVFVRjFSRGhDTEVWQlFWRlhMRlZCUVZkMlFpeEZRVUZYYjBJc1IwRkRia2RFTEVkQlFYVkNMRWRCUjNwQ0xFbEJRMFZRTEVWQlFWRlpMRTFCUVUxS0xFZEJRMlFzVFVGQlQwc3NSMEZEVUc1SkxGRkJRVkYzUml4TlFVRk5MR3REUVVGdFF6SkRMRWRCUTJwRVRpeEhRVUYxUWl4SFFVc3pRaXhKUVVGSlR5eEZRVUZaZWtNc1JVRkJVM3BHTEdWQlFXVTRSeXh0UWtGQmJVSjBRaXhGUVVGbExGZEJRVmRUTEZGQlFWRXNNa05CUVRSRExGTkJRVk01Uml4RlFVRlBLMFlzUlVGQlNVTXNSVUZCU1VNc1IwRkRMMG9zVDBGQlQwWXNSVUZCUzBNc1JVRkJTME1zU1VGRFpFY3NSVUZIUkRSQ0xFVkJRV2RDZWtrc1IwRkJSMmxHTEdkQ1FVRm5RbmxFTEZkQlFWZERMRWxCUTJ4RU0wa3NSMEZCUjJsR0xHZENRVUZuUW5sRUxGZEJRVmRETEVsQlFVMUlMRVZCUTNCRExFbEJRVWxKTEVWQlFXVXNRMEZEYWtKc1J5eFJRVUZUTEZkQlExQXhReXhIUVVGSGFVWXNaMEpCUVdkQ2VVUXNWMEZCVjBNc1NVRkJUVVlzU1VGSmVFTTVTQ3hGUVVGUldTeExRVUZMY1Vnc1IwRkRZbXBKTEVWQlFWRlpMRXRCUVV0NVJpeEhRVWRpTEVsQlFVazNSU3hGUVVGWlJDeEZRVUYxUWl4elFrRkJkVUkzUWl4dlFrRkJiMEpuUXl4TFFVRkxUeXhMUVVGTk9FVXNSVUZCVTFvc1JVRkJWemxDTEVWQlFYTkNSaXhKUVVWMlNUTkRMRVZCUVZWblJDeFRRVUZYUVN4RlFXMURja0lzV1VFdlFtZEVMRWxCUVhKRGFFUXNSVUZCVldkRUxGTkJRVk13UkN4bFFVUm9RaXhYUVVOcFJERkhMRVZCUVZWblJDeFRRVUZUTUVRc1pVRkRhRVo2U1N4UlFVRlJNRWtzU1VGQlNTd3dSVUZCTWtVelJ5eEZRVUZWWjBRc1UwRkJVekJFTEdOQlFXVXNWMEZHTjBjc1ZVRkpaREZITEVWQlFWVm5SQ3hUUVVGVE1FUXNZMEZLVEN4alFVMXhRaXhKUVVGNFFuSkNMRVZCUVZsb1NDeGxRVU0yUWl4SlFVRjJRekpDTEVWQlFWVm5SQ3hUUVVGVE5FUXNhVUpCUVcxRE5VY3NSVUZCVldkRUxGTkJRVk0wUkN4clFrRkJiMEoyUWl4RlFVRlphRWdzVTBGRGJFaEtMRkZCUVZFd1NTeEpRVUZKTERSRlFVRTJSVE5ITEVWQlFWVm5SQ3hUUVVGVE5FUXNaMEpCUVdsQ0xGZEJRVmwyUWl4RlFVRlphRWdzVTBGRmRrb3lRaXhGUVVGVlowUXNVMEZCVXpSRUxHZENRVUZyUW5aQ0xFVkJRVmxvU0N4VFFVZHVSRVlzWlVGQlpXdEZMRTlCUjJZM1JDeEZRVUZSV1N4TFFVRkxWU3h0UWtGQmJVSkRMRWxCUldoRGVFSXNXVUZCV1VNc1JVRkJVeXhaUVVGaExFTkJRVU4zUWl4SlFVVXZRamhHTEVkQlEwWndTU3hGUVVGRkxEQkNRVUV3UW0xS0xFOUJRVThzUTBGRGFrTkRMRTlCUVU4c1JVRkRVRU1zVTBGQlZTeFhRVU5XUXl4UlFVRlRMRU5CUTFCRExFZEJRVWtzVjBGRFJuWktMRVZCUVVVclF5eE5RVUZOYjBjc1QwRkJUeXhoUVUxb1FpeERRVU5NU3l4TlFVRlBiRWdzUlVGRFVIRkRMRXRCUVUwc1YwRkRTamxFTEZsQlFWbERMRVZCUVZNc1dVRkJVVEpDTEVkQlFWY3NTVUZGTVVOSkxGRkJRVk1zVjBGRFVHaERMRmxCUVZsRExFVkJRVk1zWlVGQlZ6SkNMRWRCUVZjc1RVRlBOME5uU0N4aFFVRmxMRk5CUVZORExFVkJRVk5ETEVkQlEyNURMRWxCUVV0QkxFbEJSVWdzVFVGRVFYQktMRkZCUVZGdlF5eExRVUZMTEd0Q1FVRnRRaXRITEVkQlF6RkNMRzFDUVVGeFFrRXNSMEZKTTBKRkxHRkJRV1VzVjBGRGFrSXNTVUU0UWtVc1QwRXpRa0ZJTEdGQlFXRXNZVUZCWXl4WFFVTjZRaXhaUVVGdFF5eEpRVUZ5UW5aS0xFOUJRVTh5U2l4aFFVVjJRa29zWVVGQllTeHRRa0ZCYjBJc1YwRkRMMElzVFVGQlR5eHRRa0ZCYjBKMlNpeFJRVUZWTEc5Q1FVRnhRaXhKUVVGSlFTeFBRVUZQTkVvc2FVSkJSWFpGVEN4aFFVRmhMR0ZCUVdNc1YwRkRla0lzVDBGQlR5eFhRVU5NTEZsQlFYTkNMRWxCUVZJeFJ5eExRVVJVTEV0QlNWUXdSeXhoUVVGaExHMUNRVUZ2UWl4WFFVTXZRaXhaUVVFMFJDeEpRVUU1UTNaS0xFOUJRVTg0UXl4VFFVRlRReXhMUVVGTE9FY3NUVUZCYjBJc1pVRkZla1JPTEdGQlFXRXNaMEpCUVdsQ0xGZEJRelZDTEZsQlFYbEVMRWxCUVRORGRrb3NUMEZCVHpoRExGTkJRVk5ETEV0QlFVczRSeXhOUVVGcFFpeFpRVVYwUkU0c1lVRkJZU3huUWtGQmFVSXNWMEZETlVJc1dVRkJlVVFzU1VGQk0wTjJTaXhQUVVGUE9FTXNVMEZCVTBNc1MwRkJTemhITEUxQlFXbENMRmxCUlhSRVRpeGhRVUZoTEhGQ1FVRnpRaXhYUVVOcVF5eFpRVUU0UkN4SlFVRm9SSFpLTEU5QlFVODRReXhUUVVGVFF5eExRVUZMT0Vjc1RVRkJjMElzYVVKQlJUTkVUaXhoUVVGaExIVkNRVUYzUWl4WFFVTnVReXhaUVVGblJTeEpRVUZzUkhaS0xFOUJRVTg0UXl4VFFVRlRReXhMUVVGTE9FY3NUVUZCZDBJc2JVSkJSVGRFUXl3MlFrRkRUeXhGUVVOUUxFMUJRVTlETEVkQlExQXNUMEZCVHl4SlFVbFFSQ3d3UWtGQk5FSXNWMEZET1VJc1NVRkJTVFZETEVWQlFVc3NkMEpCUTB3NFF5eEZRVUZWTDBvc1IwRkJSMmxHTEdkQ1FVRm5RbmxFTEZkQlFWZERMRWxCUXpWRE0wa3NSMEZCUjJsR0xHZENRVUZuUW5sRUxGZEJRVmRETEVsQlFVMHNjMDVCUTNCRE9Va3NSVUZCUlN4UlFVRlJiVXNzVDBGQlR5eGxRVUZwUWk5RExFVkJRVXNzTmtOQlEzWkRMRWxCUVVsblJDeEZRVUZWYkVzc1QwRkJUemhETEZOQlFWTnhTQ3hsUVVGbGFrUXNSMEZETjBOcVNDeEhRVUZIYjBNc1kwRkJZeXhEUVVGRmMwWXNVVUZCVXl4cFFrRkJiVUoxUXl4SFFVY3ZReXhKUVVGSmNra3NSVUZCVDNGSkxFVkJRVkZGTEdOQlFXTjBTQ3hUUVVGVGRVZ3NVVUZMZEVNeFF5eEZRVXBWTEdGQlFXVTVSaXhGUVVGTGVVa3NUVUZETDBKNlNTeEZRVUZMTUVrc1UwRkJWeXhaUVVGak1Va3NSVUZCU3pCSkxGTkJRVmNzU1VGQlRTeE5RVU51UkRGSkxFVkJRVXN3U1N4VlFVRlpNVWtzUlVGQlN6SkpMRk5CUVZjc1ZVRkJXU3hMUVVNNVF6TkpMRVZCUVVzeVNTeFRRVUZYTEV0QlFVOHpTU3hGUVVGTE1ra3NVMEZCVnl4SlFVRk5MRWxCUVUwc1NVRkRPVUlzUzBGQlQwNHNSVUZCVVVVc1kwRkJZM1JJTEZOQlFWTXlTQ3huUWtGQlowSndSeXhWUVVNNVJYQkZMRWRCUVVjeVF5eFZRVUZWYzBnc1IwRkRZbXBMTEVkQlFVZDVTeXhYUVVGWFVpeEhRVU5rYWtzc1IwRkJSMmxHTEdkQ1FVRm5RbmxFTEZkQlFWZERMRWxCUVUxdlFpeEZRVVZ3UXl4SlFVRkpWeXhGUVVGWExIRk9RVU5ZUXl4RlFVRlpMSEZPUVVOYVF5eEZRVUZaTEhGT1FVTm9RaXhIUVVGSlJpeEpRVUZoYUVRc1IwRkJWMmxFTEVsQlFXTnFSQ3hIUVVGWGEwUXNTVUZCWTJ4RUxFVkJSMnBGTEUxQlJrRjBTQ3hSUVVGUk1rVXNTMEZCU3l3clFrRkJaME15UXl4RlFVRlJkRWNzVDBGQlVYTktMRVZCUVZOMFNpeFBRVUZSZFVvc1JVRkJWWFpLTEU5QlFWRjNTaXhGUVVGVmVFb3NUMEZCVVhOSExFZEJRVmRuUkN4RlFVRlZhRVFzUjBGQlYybEVMRVZCUVZkcVJDeEhRVUZYYTBRc1IwRkRlRXQ0U3l4UlFVRlJNa1VzUzBGQlN6SkRMRWRCUTFBc2EwUkJRV3RFUVN4RlFVRlJkRWNzVDBGQlR5eEpRVUZKYzBvc1JVRkJVM1JLTEU5QlFVOHNTVUZCU1hWS0xFVkJRVlYyU2l4UFFVRlBMRWxCUVVsM1NpeEZRVUZWZUVvc1VVRkpPVWg1U2l4alFVRm5RaXhYUVVka09Vc3NUMEZCVHl0TExHMUNRVVZVTDBzc1QwRkJUeXRMTEdsQ1FVRnBRaXhQUVVGUkxGTkJRVk5vU2l4SlFVVjJRMEVzUlVGQlNVRXNSMEZCU3k5Q0xFOUJRVTluVEN4UFFVTmtReXh0UWtGRFJDeEhRVU5JYWt3c1QwRkJUeXRMTEdsQ1FVRnBRaXhaUVVGaExGTkJRVk5vU2l4SlFVVTFRMEVzUlVGQlNVRXNSMEZCU3k5Q0xFOUJRVTluVEN4UFFVTmtReXh0UWtGRFJDeEhRVU5JYWt3c1QwRkJUeXRMTEdsQ1FVRnBRaXhYUVVGWkxGTkJRVk5vU2l4SlFVY3pRMEVzUlVGQlNVRXNSMEZCU3k5Q0xFOUJRVTluVEN4UFFVTmtReXh0UWtGRFJDeEhRVU5JYWt3c1QwRkJUeXRMTEdsQ1FVRnBRaXhQUVVGUkxGTkJRVk5vU2l4SlFVVjJRMEVzUlVGQlNVRXNSMEZCU3k5Q0xFOUJRVTluVEN4UFFVTmtReXh0UWtGRFJDeEhRVU5JYWt3c1QwRkJUemhETEZOQlFWTkRMRXRCUVV0blNTeHBRa0ZCYVVJc1QwRkJVU3hUUVVGVGFFb3NSMEZIY2tSQkxFVkJRVVZyU2l4dFFrRkRSQ3hKUVVWRWFrd3NUMEZCVHpoRExGTkJRVk52U1N4alFVTnNRbXhNTEU5QlFVODRReXhUUVVGVGIwa3NXVUZCWXl4WFFVVTFRaXhQUVVGUExFdEJTMkpETEU5QlFVOURMRkZCUVZVc1EwRkRaa01zVVVGQlUzcEdMR2xDUVVOVU1FWXNTMEZCVFRWSExHVkJRMDVuUml4aFFVRmpRU3hoUVVOa2IwSXNZMEZCWlVFaUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwzUmxiWEJzWVhSbExXeHZZV1JsY2k1cWN5SjkiLCJcInVzZSBzdHJpY3RcIjt2YXIgY29uc29sZT1yZXF1aXJlKFwiY29uc29sZS1icm93c2VyaWZ5XCIpLF9jYWxsPWZ1bmN0aW9uKGUpe3JldHVybiBlKCl9LGxvZ3M9W10sX3RpbWVkQ2FsbD1mdW5jdGlvbihlLG8pe3ZhciB0LGw9KG5ldyBEYXRlKS5nZXRUaW1lKCk7XCJvYmplY3RcIj09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUudGltZSYmY29uc29sZS50aW1lKGUpLHQ9X2NhbGwobyksXCJvYmplY3RcIj09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUudGltZSYmY29uc29sZS50aW1lRW5kKGUpO3ZhciBuPShuZXcgRGF0ZSkuZ2V0VGltZSgpLWw7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIGNvbnNvbGV8fGNvbnNvbGUudGltZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgY29uc29sZS5kZWJ1ZyYmY29uc29sZS5kZWJ1ZyhlLFwidG9va1wiLG4sXCJtc1wiKSxsb2dzLnB1c2goe25hbWU6ZSx0aW1lOm59KSxsb2dzLmxlbmd0aD4xMDAmJmxvZ3MudW5zaGlmdCgpLHR9O21vZHVsZS5leHBvcnRzPXt0aW1lZENhbGw6X3RpbWVkQ2FsbCxsb2dzOmxvZ3N9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5ScGJXVmtMV05oYkd3dWFuTWlYU3dpYm1GdFpYTWlPbHNpWTI5dWMyOXNaU0lzSW5KbGNYVnBjbVVpTENKZlkyRnNiQ0lzSW5kb1lYUlViME5oYkd3aUxDSnNiMmR6SWl3aVgzUnBiV1ZrUTJGc2JDSXNJbTVoYldVaUxDSnlaWE1pTENKemRHRnlkQ0lzSWtSaGRHVWlMQ0puWlhSVWFXMWxJaXdpZEdsdFpTSXNJblJwYldWRmJtUWlMQ0prYVdabUlpd2laR1ZpZFdjaUxDSndkWE5vSWl3aWJHVnVaM1JvSWl3aWRXNXphR2xtZENJc0ltMXZaSFZzWlNJc0ltVjRjRzl5ZEhNaUxDSjBhVzFsWkVOaGJHd2lYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUlVFc1NVRkJTVUVzVVVGQlZVTXNVVUZCVVN4elFrRkZiRUpETEUxQlFWRXNVMEZCVTBNc1IwRkRia0lzVDBGQlQwRXNTMEZIVEVNc1MwRkJUeXhIUVVWUVF5eFhRVUZoTEZOQlFWTkRMRVZCUVUxSUxFZEJRemxDTEVsQlFVbEpMRVZCUTBGRExFZEJRVkVzU1VGQlNVTXNUVUZCVDBNc1ZVRkRSQ3hwUWtGQldGWXNVMEZCZFVKQkxGRkJRVkZYTEUxQlFVMVlMRkZCUVZGWExFdEJRVXRNTEVkQlF6ZEVReXhGUVVGTlRDeE5RVUZOUXl4SFFVTlZMR2xDUVVGWVNDeFRRVUYxUWtFc1VVRkJVVmNzVFVGQlRWZ3NVVUZCVVZrc1VVRkJVVTRzUjBGRGFFVXNTVUZCU1U4c1IwRkJUeXhKUVVGSlNpeE5RVUZQUXl4VlFVRlpSaXhGUVZGc1F5eE5RVkJ6UWl4cFFrRkJXRklzVTBGQmQwSkJMRkZCUVZGWExFMUJRV3RETEcxQ1FVRnFRbGdzVVVGQlVXTXNUMEZCY1VKa0xGRkJRVkZqTEUxQlFVMVNMRVZCUVUwc1QwRkJVVThzUlVGQlRTeE5RVU16U0ZRc1MwRkJTMWNzUzBGQlN5eERRVU5TVkN4TFFVRk5RU3hGUVVOT1N5eExRVUZOUlN4SlFVZEtWQ3hMUVVGTFdTeFBRVUZUTEV0QlFVdGFMRXRCUVV0aExGVkJRM0pDVml4SFFVZFVWeXhQUVVGUFF5eFJRVUZWTEVOQlEyWkRMRlZCUVZkbUxGZEJRMWhFTEV0QlFVMUJJaXdpWm1sc1pTSTZJaTl3Y21sMllYUmxMM1J0Y0M5bWIyOHVSMDlGTDNOeVl5OXFjeTkwYVcxbFpDMWpZV3hzTG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIga289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCx1bmRvTWFuYWdlcj1yZXF1aXJlKFwiLi91bmRvbWFuYWdlci5qc1wiKSx1bmRvc2VyaWFsaXplcj1yZXF1aXJlKFwiLi91bmRvc2VyaWFsaXplci5qc1wiKSxhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlcj1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24obil7bi5jb250ZW50TGlzdGVuZXJzKG4uY29udGVudExpc3RlbmVycygpKzIpO3ZhciBvPXVuZG9NYW5hZ2VyKG4uY29udGVudCx7bGV2ZWxzOjEwMCx1bmRvTGFiZWw6a28uY29tcHV0ZWQoZnVuY3Rpb24oKXtyZXR1cm4gbi50KFwiVW5kbyAoI0NPVU5UIylcIil9KSxyZWRvTGFiZWw6a28uY29tcHV0ZWQoZnVuY3Rpb24oKXtyZXR1cm4gbi50KFwiUmVkb1wiKX0pfSk7cmV0dXJuIG4udW5kbz1vLnVuZG9Db21tYW5kLG4udW5kby5leGVjdXRlPWUuYmluZChuLFwidW5kb1wiLG4udW5kby5leGVjdXRlKSxuLnJlZG89by5yZWRvQ29tbWFuZCxuLnJlZG8uZXhlY3V0ZT1lLmJpbmQobixcInJlZG9cIixuLnJlZG8uZXhlY3V0ZSksbi51bmRvUmVzZXQ9ZS5iaW5kKG4sXCJ1bmRvUmVzZXRcIixvLnJlc2V0KSxuLnNldFVuZG9Nb2RlTWVyZ2U9by5zZXRNb2RlTWVyZ2Usbi5zZXRVbmRvTW9kZU9uY2U9by5zZXRNb2RlT25jZSxvLnNldE1vZGVJZ25vcmUoKSxvLnNldFVuZG9BY3Rpb25NYWtlcih1bmRvc2VyaWFsaXplci5tYWtlVW5kb0FjdGlvbi5iaW5kKHZvaWQgMCxuLmNvbnRlbnQpKSx1bmRvc2VyaWFsaXplci53YXRjaEVuYWJsZWQoITApLHtwYXVzZTpmdW5jdGlvbigpe28uc2V0TW9kZUlnbm9yZSgpfSxydW46ZnVuY3Rpb24oKXtvLnNldE1vZGVPbmNlKCl9LGluaXQ6ZnVuY3Rpb24oKXtvLnNldE1vZGVPbmNlKCl9LGRpc3Bvc2U6ZnVuY3Rpb24oKXtuLmNvbnRlbnRMaXN0ZW5lcnMobi5jb250ZW50TGlzdGVuZXJzKCktMiksdW5kb3NlcmlhbGl6ZXIud2F0Y2hFbmFibGVkKCExKSxvLmRpc3Bvc2UoKX19fX07bW9kdWxlLmV4cG9ydHM9YWRkVW5kb1N0YWNrRXh0ZW5zaW9uTWFrZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJblZ1Wkc5dFlXbHVMbXB6SWwwc0ltNWhiV1Z6SWpwYkltdHZJaXdpZDJsdVpHOTNJaXdpWjJ4dlltRnNJaXdpZFc1a2IwMWhibUZuWlhJaUxDSnlaWEYxYVhKbElpd2lkVzVrYjNObGNtbGhiR2w2WlhJaUxDSmhaR1JWYm1SdlUzUmhZMnRGZUhSbGJuTnBiMjVOWVd0bGNpSXNJbkJsY21admNtMWhibU5sUVhkaGNtVkRZV3hzWlhJaUxDSjJhV1YzVFc5a1pXd2lMQ0pqYjI1MFpXNTBUR2x6ZEdWdVpYSnpJaXdpZFc1a2IxSmxaRzlUZEdGamF5SXNJbU52Ym5SbGJuUWlMQ0pzWlhabGJITWlMQ0oxYm1SdlRHRmlaV3dpTENKamIyMXdkWFJsWkNJc0luUWlMQ0p5WldSdlRHRmlaV3dpTENKMWJtUnZJaXdpZFc1a2IwTnZiVzFoYm1RaUxDSmxlR1ZqZFhSbElpd2lZbWx1WkNJc0luSmxaRzhpTENKeVpXUnZRMjl0YldGdVpDSXNJblZ1Wkc5U1pYTmxkQ0lzSW5KbGMyVjBJaXdpYzJWMFZXNWtiMDF2WkdWTlpYSm5aU0lzSW5ObGRFMXZaR1ZOWlhKblpTSXNJbk5sZEZWdVpHOU5iMlJsVDI1alpTSXNJbk5sZEUxdlpHVlBibU5sSWl3aWMyVjBUVzlrWlVsbmJtOXlaU0lzSW5ObGRGVnVaRzlCWTNScGIyNU5ZV3RsY2lJc0ltMWhhMlZWYm1SdlFXTjBhVzl1SWl3aWRXNWtaV1pwYm1Wa0lpd2lkMkYwWTJoRmJtRmliR1ZrSWl3aWNHRjFjMlVpTENKeWRXNGlMQ0pwYm1sMElpd2laR2x6Y0c5elpTSXNJbTF2WkhWc1pTSXNJbVY0Y0c5eWRITWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUlVFc1NVRkJTVUVzUjBGQmQwSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRlhMRWRCUVhOQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlZ5eEhRVUZKTEV0QlEzQkhReXhaUVVGalF5eFJRVUZSTEc5Q1FVTjBRa01zWlVGQmFVSkVMRkZCUVZFc2RVSkJSWHBDUlN3eVFrRkJOa0lzVTBGQlUwTXNSMEZEZUVNc1QwRkJUeXhUUVVGVFF5eEhRVVZrUVN4RlFVRlZReXhwUWtGQmFVSkVMRVZCUVZWRExHMUNRVUZ4UWl4SFFVY3hSQ3hKUVVGSlF5eEZRVUZuUWxBc1dVRkJXVXNzUlVGQlZVY3NVVUZCVXl4RFFVTnFSRU1zVDBGQlVTeEpRVU5TUXl4VlFVRlhZaXhIUVVGSFl5eFRRVUZUTEZkQlFXRXNUMEZCVDA0c1JVRkJWVThzUlVGQlJTeHZRa0ZEZGtSRExGVkJRVmRvUWl4SFFVRkhZeXhUUVVGVExGZEJRV0VzVDBGQlQwNHNSVUZCVlU4c1JVRkJSU3haUVdGNlJDeFBRVmhCVUN4RlFVRlZVeXhMUVVGUFVDeEZRVUZqVVN4WlFVTXZRbFlzUlVGQlZWTXNTMEZCUzBVc1VVRkJWVm9zUlVGQmRVSmhMRXRCUVV0YUxFVkJRVmNzVDBGQlVVRXNSVUZCVlZNc1MwRkJTMFVzVTBGRGRrWllMRVZCUVZWaExFdEJRVTlZTEVWQlFXTlpMRmxCUXk5Q1pDeEZRVUZWWVN4TFFVRkxSaXhSUVVGVldpeEZRVUYxUW1Fc1MwRkJTMW9zUlVGQlZ5eFBRVUZSUVN4RlFVRlZZU3hMUVVGTFJpeFRRVU4yUmxnc1JVRkJWV1VzVlVGQldXaENMRVZCUVhWQ1lTeExRVUZMV2l4RlFVRlhMRmxCUVdGRkxFVkJRV05qTEU5QlEzaEdhRUlzUlVGQlZXbENMR2xDUVVGdFFtWXNSVUZCWTJkQ0xHRkJRek5EYkVJc1JVRkJWVzFDTEdkQ1FVRnJRbXBDTEVWQlFXTnJRaXhaUVVNeFEyeENMRVZCUVdOdFFpeG5Ra0ZEWkc1Q0xFVkJRV052UWl4dFFrRkJiVUo2UWl4bFFVRmxNRUlzWlVGQlpWZ3NWVUZCUzFrc1JVRkJWM2hDTEVWQlFWVkhMRlZCUTNwR1RpeGxRVUZsTkVJc1kwRkJZU3hIUVVWeVFpeERRVU5NUXl4TlFVRlBMRmRCUTB4NFFpeEZRVUZqYlVJc2FVSkJSV2hDVFN4SlFVRkxMRmRCUTBoNlFpeEZRVUZqYTBJc1pVRkZhRUpSTEV0QlFVMHNWMEZEU2pGQ0xFVkJRV05yUWl4bFFVVm9RbE1zVVVGQlV5eFhRVU5RTjBJc1JVRkJWVU1zYVVKQlFXbENSQ3hGUVVGVlF5eHRRa0ZCY1VJc1IwRkRNVVJLTEdWQlFXVTBRaXhqUVVGaExFZEJRelZDZGtJc1JVRkJZekpDTEdOQlQzUkNReXhQUVVGUFF5eFJRVUZWYWtNaUxDSm1hV3hsSWpvaUwzQnlhWFpoZEdVdmRHMXdMMlp2Ynk1SFQwVXZjM0pqTDJwekwzVnVaRzl0WVc1aFoyVnlMM1Z1Wkc5dFlXbHVMbXB6SW4wPSIsIlwidXNlIHN0cmljdFwiO3ZhciBrbz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5rbzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbC5rbzpudWxsLHJlYWN0b3I9cmVxdWlyZShcImtvLXJlYWN0b3IvZGlzdC9rby1yZWFjdG9yLm1pbi5qc1wiKSxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIiksdW5kb01hbmFnZXI9ZnVuY3Rpb24oZSxvKXt2YXIgbix0PWtvLm9ic2VydmFibGVBcnJheSgpLGk9a28ub2JzZXJ2YWJsZUFycmF5KCkscj0wLGQ9MCxsPXtsZXZlbHM6MTAwLHVuZG9MYWJlbDpcInVuZG8gKCNDT1VOVCMpXCIscmVkb0xhYmVsOlwicmVkbyAoI0NPVU5UIylcIn07bz1cIm9iamVjdFwiPT10eXBlb2Ygbz9rby51dGlscy5leHRlbmQobCxvKTpsO3ZhciB1PWZ1bmN0aW9uKGUpezE9PXI/YShlLGkpOjI9PXI/YShlLHQpOjA9PXImJihhKGUsdCksaS5yZW1vdmVBbGwoKSl9LGE9ZnVuY3Rpb24oZSx0KXtpZih0KCkubGVuZ3RoPjApe3ZhciBpPShyPXQoKVt0KCkubGVuZ3RoLTFdLGQ9ZSx2b2lkIDAhPT1yLm1lcmdlZEFjdGlvbj9yLm1lcmdlZEFjdGlvbihkKTpudWxsKTtpZihudWxsIT09aSlyZXR1cm4gdm9pZCh0KClbdCgpLmxlbmd0aC0xXT1pKX12YXIgcixkO3QoKS5sZW5ndGg+PW8ubGV2ZWxzJiZ0LnNoaWZ0KCksbj10LHQucHVzaChlKX0sYz1mdW5jdGlvbihlLG8sdCl7cmV0dXJue25hbWU6a28uY29tcHV0ZWQoZnVuY3Rpb24oKXtyZXR1cm4ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShlKS5yZXBsYWNlKC8jQ09VTlQjLyx0KCkubGVuZ3RoKX0pLGVuYWJsZWQ6a28uY29tcHV0ZWQoZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXQoKS5sZW5ndGh9KSxleGVjdXRlOmZ1bmN0aW9uKCl7dmFyIGU9dC5wb3AoKTtpZihlKXt2YXIgaT1yO3I9bzt2YXIgbD1kO2Q9MyxlKCkscyhuKSxkPWwscj1pfXJldHVybiEwfX19LHM9ZnVuY3Rpb24oZSl7aWYodm9pZCAwPT09ZSl0aHJvd1wiVW5leHBlY3RlZCBvcGVyYXRpb246IHN0YWNrIGNsZWFuZXIgY2FsbGVkIHdpdGggdW5kZWZpbmVkIHN0YWNrXCI7ZSgpLmxlbmd0aD4wJiZ2b2lkIDAhPT1lKClbZSgpLmxlbmd0aC0xXS5tZXJnZWRBY3Rpb24mJmRlbGV0ZSBlKClbZSgpLmxlbmd0aC0xXS5tZXJnZWRBY3Rpb259LGY9ZnVuY3Rpb24oZSxvKXt2YXIgbj1mdW5jdGlvbihlLG8pe2UoKSxvKCl9LmJpbmQodm9pZCAwLGUsbyk7cmV0dXJuIHZvaWQgMCE9PWUubWVyZ2VkQWN0aW9uJiYobi5tZXJnZWRBY3Rpb249ZS5tZXJnZWRBY3Rpb24pLG59LG09ZnVuY3Rpb24oZSxvLG4pe2lmKHZvaWQgMCE9PW8pZShvKTtlbHNle2lmKCFuKXRocm93XCJVbmV4cGVjdGVkIGNvbmRpdGlvbjogbm8gaXRlbSBhbmQgbm8gY2hpbGQub2xkVmFsdWVzIVwiO2lmKFwiZGVsZXRlZFwiPT1uLnN0YXR1cyllLnNwbGljZShuLmluZGV4LDAsbi52YWx1ZSk7ZWxzZXtpZihcImFkZGVkXCIhPW4uc3RhdHVzKXRocm93XCJVbnN1cHBvcnRlZCBpdGVtLnN0YXR1czogXCIrbi5zdGF0dXM7ZS5zcGxpY2Uobi5pbmRleCwxKX19fSx2PWZ1bmN0aW9uKGUsbyxuLHQsaSl7cmV0dXJuIGUuYmluZCh2b2lkIDAsbix0LGkpfSxnPShcImZ1bmN0aW9uXCI9PXR5cGVvZiByZWFjdG9yP3JlYWN0b3I6a28ud2F0Y2gpKGUse2RlcHRoOi0xLG9sZFZhbHVlczoxLG11dGFibGU6ITAsdGFnRmllbGRzOiEwfSxmdW5jdGlvbihlLG8sbil7dmFyIHQ9dm9pZCAwIT09by5vbGRWYWx1ZXM/by5vbGRWYWx1ZXNbMF06dm9pZCAwLGk9dihtLGUsbyx0LG4pOzEhPWQmJigzPT1kP3ZvaWQgMCE9PWkmJihpLm1lcmdlZEFjdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZS5tZXJnZU1lJiZlLm1lcmdlTWU/ZihlLHRoaXMpOm51bGx9LGkubWVyZ2VNZT0hMCk6dm9pZCAwIT09aSYmKG8ub2xkVmFsdWVzJiYyPT1kJiYoaS5tZXJnZWRBY3Rpb249ZnVuY3Rpb24oZSxvLG4pe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBuLm1lcmdlYWJsZUFjdGlvbiYmZT09bi5tZXJnZWFibGVBY3Rpb24uY2hpbGQ/dGhpczpudWxsfS5iaW5kKGksbyxuKSxpLm1lcmdlYWJsZUFjdGlvbj17Y2hpbGQ6byxpdGVtOm59KSxuJiZcImRlbGV0ZWRcIj09bi5zdGF0dXM/aS5tZXJnZWRBY3Rpb249ZnVuY3Rpb24oZSxvLG4pe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBuLm1lcmdlYWJsZU1vdmUmJm8udmFsdWU9PW4ubWVyZ2VhYmxlTW92ZS5pdGVtLnZhbHVlP2Yobix0aGlzKTpudWxsfS5iaW5kKGksbyxuKTpuJiZcImFkZGVkXCI9PW4uc3RhdHVzP2kubWVyZ2VhYmxlTW92ZT17Y2hpbGQ6byxpdGVtOm59Om4mJmNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIGl0ZW0uc3RhdHVzXCIsbi5zdGF0dXMpKSx2b2lkIDAhPT1pJiZ1KGkpKX0se30pO3JldHVybntwdXNoOnUsdW5kb0NvbW1hbmQ6YyhvLnVuZG9MYWJlbCwxLHQpLHJlZG9Db21tYW5kOmMoby5yZWRvTGFiZWwsMixpKSxyZXNldDpmdW5jdGlvbigpe3QucmVtb3ZlQWxsKCksaS5yZW1vdmVBbGwoKX0sc2V0TW9kZU9uY2U6ZnVuY3Rpb24oKXtkPTIscyh0KX0sc2V0TW9kZU1lcmdlOmZ1bmN0aW9uKCl7ZD0zLHModCl9LHNldE1vZGVOb3JtYWw6ZnVuY3Rpb24oKXtkPTAscyh0KX0sc2V0TW9kZUlnbm9yZTpmdW5jdGlvbigpe2Q9MSxzKHQpfSxzZXRVbmRvQWN0aW9uTWFrZXI6ZnVuY3Rpb24oZSl7dj1lfSxkaXNwb3NlOmZ1bmN0aW9uKCl7Zy5kaXNwb3NlKCl9fX07bW9kdWxlLmV4cG9ydHM9dW5kb01hbmFnZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJblZ1Wkc5dFlXNWhaMlZ5TG1weklsMHNJbTVoYldWeklqcGJJbXR2SWl3aWQybHVaRzkzSWl3aVoyeHZZbUZzSWl3aWNtVmhZM1J2Y2lJc0luSmxjWFZwY21VaUxDSmpiMjV6YjJ4bElpd2lkVzVrYjAxaGJtRm5aWElpTENKdGIyUmxiQ0lzSW05d2RHbHZibk1pTENKc1lYTjBVSFZ6YUdWa1UzUmhZMnNpTENKMWJtUnZVM1JoWTJzaUxDSnZZbk5sY25aaFlteGxRWEp5WVhraUxDSnlaV1J2VTNSaFkyc2lMQ0p6ZEdGMFpTSXNJbTF2WkdVaUxDSmtaV1poZFd4MFQzQjBhVzl1Y3lJc0lteGxkbVZzY3lJc0luVnVaRzlNWVdKbGJDSXNJbkpsWkc5TVlXSmxiQ0lzSW5WMGFXeHpJaXdpWlhoMFpXNWtJaXdpWDNCMWMyZ2lMQ0poWTNScGIyNGlMQ0pmY0hWemFFbHVkQ0lzSW5KbGJXOTJaVUZzYkNJc0ltMTVVM1JoWTJzaUxDSnNaVzVuZEdnaUxDSnRaWEpuWldRaUxDSndjbVYySWl3aWJtVjNRV04wYVc5dUlpd2liV1Z5WjJWa1FXTjBhVzl1SWl3aWMyaHBablFpTENKd2RYTm9JaXdpWDNoa2IwTnZiVzFoYm1RaUxDSnNZV0psYkNJc0luZHZjbXRUZEdGMFpTSXNJbk4wWVdOcklpd2libUZ0WlNJc0ltTnZiWEIxZEdWa0lpd2lkVzUzY21Gd1QySnpaWEoyWVdKc1pTSXNJbkpsY0d4aFkyVWlMQ0psYm1GaWJHVmtJaXdpWlhobFkzVjBaU0lzSW5CdmNDSXNJbkJ5WlhaVGRHRjBaU0lzSW05c1pFMXZaR1VpTENKZmNtVnRiM1psVFdWeVoyVmtRV04wYVc5dUlpd2lYMk52YldKcGJtVmtSblZ1WTNScGIyNGlMQ0ptYVhKemRDSXNJbk5sWTI5dVpDSXNJbkpsY3lJc0ltWXhJaXdpWmpJaUxDSmlhVzVrSWl3aWRXNWtaV1pwYm1Wa0lpd2laWGhsWTNWMFpWVnVaRzlCWTNScGIyNGlMQ0pqYUdsc1pDSXNJblpoYkhWbElpd2lhWFJsYlNJc0luTjBZWFIxY3lJc0luTndiR2xqWlNJc0ltbHVaR1Y0SWl3aWJXRnJaVlZ1Wkc5QlkzUnBiMjRpTENKMWJtUnZSblZ1WXlJc0luQmhjbVZ1ZEhNaUxDSnZiR1JXWVd3aUxDSjNZWFJqYUNJc0ltUmxjSFJvSWl3aWIyeGtWbUZzZFdWeklpd2liWFYwWVdKc1pTSXNJblJoWjBacFpXeGtjeUlzSW1GamRDSXNJbTFsY21kbFRXVWlMQ0owYUdseklpd2liMnhrUTJocGJHUWlMQ0p2YkdSSmRHVnRJaXdpYldWeVoyVmhZbXhsUVdOMGFXOXVJaXdpYldWeVoyVmhZbXhsVFc5MlpTSXNJbmRoY200aUxDSjFibVJ2UTI5dGJXRnVaQ0lzSW5KbFpHOURiMjF0WVc1a0lpd2ljbVZ6WlhRaUxDSnpaWFJOYjJSbFQyNWpaU0lzSW5ObGRFMXZaR1ZOWlhKblpTSXNJbk5sZEUxdlpHVk9iM0p0WVd3aUxDSnpaWFJOYjJSbFNXZHViM0psSWl3aWMyVjBWVzVrYjBGamRHbHZiazFoYTJWeUlpd2liV0ZyWlhJaUxDSmthWE53YjNObElpd2liVzlrZFd4bElpd2laWGh3YjNKMGN5SmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNZVUZGUVN4SlFVRkpRU3hIUVVGM1FpeHZRa0ZCV0VNc1QwRkJlVUpCTEU5QlFWY3NSMEZCYzBJc2IwSkJRVmhETEU5QlFYbENRU3hQUVVGWExFZEJRVWtzUzBGRGNFZERMRkZCUVZWRExGRkJRVkVzY1VOQlEyeENReXhSUVVGVlJDeFJRVUZSTEhOQ1FWZHNRa1VzV1VGQll5eFRRVUZWUXl4RlFVRlBReXhIUVVOcVF5eEpRVVZKUXl4RlFVWkJReXhGUVVGWlZpeEhRVUZIVnl4clFrRkRaa01zUlVGQldWb3NSMEZCUjFjc2EwSkJTMlpGTEVWQlNHTXNSVUZUWkVNc1JVRktZeXhGUVUxa1F5eEZRVUZwUWl4RFFVTnVRa01zVDBGQlVTeEpRVU5TUXl4VlFVRlhMR2xDUVVOWVF5eFZRVUZYTEd0Q1FVbFlWaXhGUVVSdlFpeHBRa0ZCV0VFc1JVRkRRMUlzUjBGQlIyMUNMRTFCUVUxRExFOUJRVTlNTEVWQlFXZENVQ3hIUVVWb1EwOHNSVUZIV2l4SlFVRkpUU3hGUVVGUkxGTkJRVlZETEVkQmRFSkdMRWRCZDBKa1ZDeEZRVU5HVlN4RlFVRlRSQ3hGUVVGUlZpeEhRWGhDUkN4SFFYbENVRU1zUlVGRFZGVXNSVUZCVTBRc1JVRkJVVm9zUjBFMVFrZ3NSMEUyUWt4SExFbEJRMVJWTEVWQlFWTkVMRVZCUVZGYUxFZEJRMnBDUlN4RlFVRlZXU3hqUVZWV1JDeEZRVUZYTEZOQlFWVkVMRVZCUVZGSExFZEJTUzlDTEVkQlFVbEJMRWxCUVZWRExFOUJRVk1zUlVGQlJ5eERRVU40UWl4SlFVRkpReXhIUVZoclFrTXNSVUZYUTBnc1NVRkJWVUVzU1VGQlZVTXNUMEZCVXl4SFFWaDRRa2NzUlVGWE5FSlFMRTlCVm5wQ0xFbEJRWFJDVFN4RlFVRkxSU3hoUVVOUVJpeEZRVUZMUlN4aFFVRmhSQ3hIUVVOaUxFMUJWVm9zUjBGQlpTeFBRVUZZUml4RlFVVkdMRmxCUkVGR0xFbEJRVlZCTEVsQlFWVkRMRTlCUVZNc1IwRkJTME1zUjBGa2VFSXNTVUZCVlVNc1JVRkJUVU1zUlVGclFqRkNTaXhKUVVGVlF5eFJRVUZWYkVJc1JVRkJVVkVzVVVGQlVWTXNSVUZCVVUwc1VVRkRhRVIwUWl4RlFVRnJRbWRDTEVWQlEyeENRU3hGUVVGUlR5eExRVUZMVml4SlFVZFlWeXhGUVVGakxGTkJRVk5ETEVWQlFVOURMRVZCUVZkRExFZEJRek5ETEUxQlFVOHNRMEZEVEVNc1MwRkJUWEpETEVkQlFVZHpReXhUUVVGVExGZEJRMmhDTEU5QlFVOTBReXhIUVVGSGJVSXNUVUZCVFc5Q0xHbENRVUZwUWt3c1IwRkJUMDBzVVVGQlVTeFZRVUZYU2l4SlFVRlJWaXhWUVVWeVJXVXNVVUZCVTNwRExFZEJRVWR6UXl4VFFVRlRMRmRCUTI1Q0xFOUJRVEJDTEVsQlFXNUNSaXhKUVVGUlZpeFRRVVZxUW1kQ0xGRkJRVk1zVjBGRFVDeEpRVUZKY0VJc1JVRkJVMk1zUlVGQlRVOHNUVUZEYmtJc1IwRkJTWEpDTEVWQlFWRXNRMEZEVml4SlFVRkpjMElzUlVGQldTOUNMRVZCUTJoQ1FTeEZRVUZSYzBJc1JVRkRVaXhKUVVGSlZTeEZRVUZWTDBJc1JVRkRaRUVzUlVGb1JWTXNSVUZyUlZSUkxFbEJSVUYzUWl4RlFVRnZRbkpETEVkQlEzQkNTeXhGUVVGUEswSXNSVUZEVUdoRExFVkJRVkVyUWl4RlFVVldMRTlCUVU4c1MwRkxWRVVzUlVGQmMwSXNVMEZCVTNKQ0xFZEJRMnBETEZGQlFYTkNMRWxCUVZoQkxFVkJRWGRDTEV0QlFVMHNhMFZCUlhKRFFTeEpRVUZWUXl4UFFVRlRMRkZCUVRaRUxFbEJRV3BFUkN4SlFVRlZRU3hKUVVGVlF5eFBRVUZUTEVkQlFVZEpMSEZDUVVVeFJFd3NTVUZCVlVFc1NVRkJWVU1zVDBGQlV5eEhRVUZIU1N4alFVbDJRMmxDTEVWQlFXOUNMRk5CUVZORExFVkJRVTlETEVkQlEzUkRMRWxCUVVsRExFVkJRVTBzVTBGQlZVTXNSVUZCU1VNc1IwRkRkRUpFTEVsQlEwRkRMRXRCUTBORExGVkJRVXRETEVWQlFWZE9MRVZCUVU5RExFZEJTVEZDTEZsQlNHdERMRWxCUVhaQ1JDeEZRVUZOYkVJc1pVRkRabTlDTEVWQlFVbHdRaXhoUVVGbGEwSXNSVUZCVFd4Q0xHTkJSWEJDYjBJc1IwRkhURXNzUlVGQmIwSXNVMEZCVTBNc1JVRkJUME1zUlVGQlQwTXNSMEZGTjBNc1VVRkJjVUlzU1VGQlZrUXNSVUZEVkVRc1JVRkJUVU1zVDBGRFJDeERRVUZCTEVsQlFVbERMRVZCVTFRc1MwRkJUU3gzUkVGU1RpeEhRVUZ0UWl4WFFVRm1RU3hGUVVGTFF5eFBRVU5RU0N4RlFVRk5TU3hQUVVGUFJpeEZRVUZMUnl4TlFVRlBMRVZCUVVkSUxFVkJRVXRFTEZkQlF6VkNMRU5CUVVFc1IwRkJiVUlzVTBGQlprTXNSVUZCUzBNc1QwRkhaQ3hMUVVGTkxEUkNRVUUwUWtRc1JVRkJTME1zVDBGR2RrTklMRVZCUVUxSkxFOUJRVTlHTEVWQlFVdEhMRTFCUVU4c1RVRmhNMEpETEVWQlNuZENMRk5CUVZORExFVkJRVlZETEVWQlFWTlNMRVZCUVU5VExFVkJRVkZRTEVkQlEzSkZMRTlCUVU5TExFVkJRVk5XTEZWQlFVdERMRVZCUVZkRkxFVkJRVTlUTEVWQlFWRlFMRWxCZDBVM1ExSXNSMEZFTUVJc2JVSkJRVmd2UXl4UlFVRjNRa0VzVVVGQlZVZ3NSMEZCUjJ0RkxFOUJRM2hETTBRc1JVRktTeXhEUVVGRk5FUXNUMEZCVVN4RlFVRkhReXhWUVVGWExFVkJRVWRETEZOQlFWTXNSVUZCY1VORExGZEJRVmNzUjBFdlJIUkdMRk5CUVZOT0xFVkJRVk5TTEVWQlFVOUZMRWRCUlRGRExFbEJRVWxQTEU5QlFXMURMRWxCUVc1Q1ZDeEZRVUZOV1N4VlFVRXlRbG9zUlVGQlRWa3NWVUZCVlN4UlFVRkxaQ3hGUVVOMFJXbENMRVZCUVUxVUxFVkJRV1ZRTEVWQlFXMUNVeXhGUVVGVFVpeEZRVUZQVXl4RlFVRlJVQ3hIUVRkSWNFUXNSMEVyU0ZvMVF5eEpRVGRJVnl4SFFTdElXRUVzVDBGRmFVSXNTVUZCVW5sRUxFbEJRMVJCTEVWQlFVbDZReXhoUVVGbExGTkJRVk5FTEVkQlF6RkNMRmxCUVdsRExFbEJRWFJDUVN4RlFVRlZNa01zVTBGQk1rSXpReXhGUVVGVk1rTXNVVUZEYWtSNlFpeEZRVUZyUW14Q0xFVkJRVmMwUXl4TlFVTjRRaXhOUVVWb1FrWXNSVUZCU1VNc1UwRkJWU3hSUVVkSExFbEJRVkpFTEVsQlEweG1MRVZCUVUxWkxGZEJOVWxCTEVkQk5FbGhkRVFzU1VGRGNrSjVSQ3hGUVVGSmVrTXNZVUZCWlN4VFFVRlRORU1zUlVGQlZVTXNSVUZCVXpsRExFZEJRemRETEUxQlFYZERMR2xDUVVFM1FrRXNSVUZCVlN0RExHbENRVUVyUWtZc1IwRkJXVGRETEVWQlFWVXJReXhuUWtGQlowSndRaXhOUVVWcVJtbENMRXRCUTBzc1RVRkRaSEJDTEV0QlFVdHJRaXhGUVVGTFppeEZRVUZQUlN4SFFVTnVRbUVzUlVGQlNVc3NaMEpCUVd0Q0xFTkJRVVZ3UWl4TlFVRlBRU3hGUVVGUFJTeExRVUZOUVN4SlFWRXhRMEVzUjBGQmRVSXNWMEZCWmtFc1JVRkJTME1zVDBGSFpsa3NSVUZCU1hwRExHRkJRV1VzVTBGQlV6UkRMRVZCUVZWRExFVkJRVk01UXl4SFFVazNReXhOUVVGelF5eHBRa0ZCTTBKQkxFVkJRVlZuUkN4bFFVRTJRa1lzUlVGQlVXeENMRTlCUVZNMVFpeEZRVUZWWjBRc1kwRkJZMjVDTEV0QlFVdEVMRTFCUjNaR1ZpeEZRVUZyUW14Q0xFVkJRVmMwUXl4TlFVc3ZRaXhOUVVOUWNFSXNTMEZCUzJ0Q0xFVkJRVXRtTEVWQlFVOUZMRWRCUTFaQkxFZEJRWFZDTEZOQlFXWkJMRVZCUVV0RExFOUJSM1JDV1N4RlFVRkpUU3hqUVVGblFpeERRVUZGY2tJc1RVRkJUMEVzUlVGQlQwVXNTMEZCVFVFc1IwRkRha05CTEVkQlExUnlSQ3hSUVVGUmVVVXNTMEZCU3l3d1FrRkJNa0p3UWl4RlFVRkxReXhqUVVsb1F5eEpRVUZTV1N4SFFVRnhRbXhFTEVWQlFVMXJSQ3hMUVVzeFFpeEpRVWxrTEUxQlFVOHNRMEZEVEhaRExFdEJRVTFZTEVWQlEwNHdSQ3haUVVGaE9VTXNSVUZCV1hwQ0xFVkJRVkZUTEZWQmRFMW1MRVZCYzAxNVExQXNSMEZETTBSelJTeFpRVUZoTDBNc1JVRkJXWHBDTEVWQlFWRlZMRlZCZEUxbUxFVkJjMDE1UTA0c1IwRkRNMFJ4UlN4TlFVRlBMRmRCUVdGMlJTeEZRVUZWWXl4WlFVRmhXaXhGUVVGVldTeGhRVVZ5UkRCRUxGbEJRV0VzVjBGQllYQkZMRVZCY0UxYUxFVkJiMDA0UW1kRExFVkJRVzlDY0VNc1NVRkRhRVY1UlN4aFFVRmpMRmRCUVdGeVJTeEZRWEJOV2l4RlFXOU5LMEpuUXl4RlFVRnZRbkJETEVsQlEyeEZNRVVzWTBGQlpTeFhRVUZoZEVVc1JVRjRUVm9zUlVGM1RXZERaME1zUlVGQmIwSndReXhKUVVOd1JUSkZMR05CUVdVc1YwRkJZWFpGTEVWQmVFMWFMRVZCZDAxblEyZERMRVZCUVc5Q2NFTXNTVUZEY0VVMFJTeHRRa0ZCYjBJc1UwRkJVME1zUjBGQlUzcENMRVZCUVdsQ2VVSXNSMEZEZGtSRExGRkJRVk1zVjBGQmIwVjBReXhGUVVGSmMwTXNZVUZKY2taRExFOUJRVTlETEZGQlFWVndSaUlzSW1acGJHVWlPaUl2Y0hKcGRtRjBaUzkwYlhBdlptOXZMa2RQUlM5emNtTXZhbk12ZFc1a2IyMWhibUZuWlhJdmRXNWtiMjFoYm1GblpYSXVhbk1pZlE9PSIsIlwidXNlIHN0cmljdFwiO3ZhciBsaXN0ZW5lcix3YXRjaEVuYWJsZWQsa289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIiksX3JlZmVyZW5jZT1mdW5jdGlvbihlLG4pe2Zvcih2YXIgdCxvLHI9MCxhPWU7cjxuLmxlbmd0aDspc3dpdGNoKG4uY2hhckF0KHIpKXtjYXNlXCIoXCI6XCIpXCI9PW4uY2hhckF0KHIrMSkmJihhPWEoKSkscis9MjticmVhaztjYXNlXCJbXCI6bz1uLmluZGV4T2YoXCJdXCIsciksYT1hW24uc3Vic3RyaW5nKHIrMSxvKV0scj1vKzE7YnJlYWs7Y2FzZVwiLlwiOi0xPT0odD1uLmluZGV4T2YoXCIoXCIscikpJiYodD1uLmxlbmd0aCksLTE9PShvPW4uaW5kZXhPZihcIltcIixyKSkmJihvPW4ubGVuZ3RoKSxvPU1hdGgubWluKHQsbyksYT1hW24uc3Vic3RyaW5nKHIrMSxvKV0scj1vfXJldHVybiBhfSxfZ2V0UGF0aD1mdW5jdGlvbihlLG4pe2Zvcih2YXIgdCxvPVwiXCIscj0wO3I8PWUubGVuZ3RoO3IrKylpZih0PXI8ZS5sZW5ndGg/ZVtyXTpuLGtvLmlzT2JzZXJ2YWJsZSh0KSYmKG8rPVwiKClcIiksdm9pZCAwIT09dC5fZmllbGROYW1lKW8rPVwiLlwiK3QuX2ZpZWxkTmFtZTtlbHNle2lmKCEocj4wJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlW3ItMV0ucG9wKSl0aHJvdyBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBwYXJlbnQgd2l0aCBubyBfZmllbGROYW1lIGFuZCBubyBwYXJlbnQgYXJyYXlcIixyLGUpLFwiVW5leHBlY3RlZCBwYXJlbnQgd2l0aCBubyBfZmllbGROYW1lIGFuZCBubyBwYXJlbnQgYXJyYXlcIjt2YXIgYT1rby5pc09ic2VydmFibGUoZVtyLTFdKT9rby51dGlscy5wZWVrT2JzZXJ2YWJsZShlW3ItMV0pOmVbci0xXSxpPWtvLnV0aWxzLmFycmF5SW5kZXhPZihhLHQpO2lmKC0xPT1pKXRocm93IGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIG9iamVjdCBub3QgZm91bmQgaW4gcGFyZW50IGFycmF5XCIsYSx0LHIsZS5sZW5ndGgsa28udG9KUyhhKSxrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHQpKSxcIlVuZXhwZWN0ZWQgb2JqZWN0IG5vdCBmb3VuZCBpbiBwYXJlbnQgYXJyYXlcIjtvKz1cIltcIitpK1wiXVwifXJldHVybiBvfSxtYWtlRGVyZWZlcmVuY2VkVW5kb0FjdGlvbj1mdW5jdGlvbihlLG4sdCxvLHIpe2UoX3JlZmVyZW5jZShuLHQpLG8scil9LF9zZXRMaXN0ZW5lcj1mdW5jdGlvbihlKXtsaXN0ZW5lcj1lfSxtYWtlVW5kb0FjdGlvbkRlcmVmZXJlbmNlZD1mdW5jdGlvbihlLG4sdCxvLHIsYSl7dHJ5e3ZhciBpPV9nZXRQYXRoKHQsbyk7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHImJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHJ8fChyPWtvLnRvSlMocikpLHZvaWQgMCE9PWEmJihcIm9iamVjdFwiPT10eXBlb2YgYS52YWx1ZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgYS52YWx1ZSkpYT1rby50b0pTKGEpO2lmKHZvaWQgMCE9PWxpc3RlbmVyKXRyeXtsaXN0ZW5lcihpLG8scixhKX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIlVuZG9zZXJpYWxpemVyIGlnbm9yaW5nIGV4Y2VwdGlvbiBpbiBsaXN0ZW5lciBjYWxsYmFja1wiKX1yZXR1cm4gbWFrZURlcmVmZXJlbmNlZFVuZG9BY3Rpb24uYmluZCh2b2lkIDAsbixlLGkscixhKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKFwiRXhjZXB0aW9uIHByb2Nlc3NpbmcgdW5kb1wiLGUsdCxvLGEpfX0sX3dhdGNoRW5hYmxlZD1mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXJldHVybiB3YXRjaEVuYWJsZWQ7d2F0Y2hFbmFibGVkPWV9O21vZHVsZS5leHBvcnRzPXtkZXJlZmVyZW5jZTpfZ2V0UGF0aCxyZWZlcmVuY2U6X3JlZmVyZW5jZSxtYWtlVW5kb0FjdGlvbjptYWtlVW5kb0FjdGlvbkRlcmVmZXJlbmNlZCxzZXRMaXN0ZW5lcjpfc2V0TGlzdGVuZXIsd2F0Y2hFbmFibGVkOl93YXRjaEVuYWJsZWR9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5WdVpHOXpaWEpwWVd4cGVtVnlMbXB6SWwwc0ltNWhiV1Z6SWpwYklteHBjM1JsYm1WeUlpd2lkMkYwWTJoRmJtRmliR1ZrSWl3aWEyOGlMQ0ozYVc1a2IzY2lMQ0puYkc5aVlXd2lMQ0pqYjI1emIyeGxJaXdpY21WeGRXbHlaU0lzSWw5eVpXWmxjbVZ1WTJVaUxDSnRiMlJsYkNJc0luQmhkR2dpTENKd01TSXNJbkF5SWl3aWNDSXNJbTBpTENKc1pXNW5kR2dpTENKamFHRnlRWFFpTENKcGJtUmxlRTltSWl3aWMzVmljM1J5YVc1bklpd2lUV0YwYUNJc0ltMXBiaUlzSWw5blpYUlFZWFJvSWl3aWNHRnlaVzUwY3lJc0ltTm9hV3hrSWl3aWF5SXNJbWx6VDJKelpYSjJZV0pzWlNJc0lsOW1hV1ZzWkU1aGJXVWlMQ0p3YjNBaUxDSmxjbkp2Y2lJc0luQmhjbVZ1ZEVGeWNtRjVJaXdpZFhScGJITWlMQ0p3WldWclQySnpaWEoyWVdKc1pTSXNJbkJ2Y3lJc0ltRnljbUY1U1c1a1pYaFBaaUlzSW5SdlNsTWlMQ0oxYm5keVlYQlBZbk5sY25aaFlteGxJaXdpYldGclpVUmxjbVZtWlhKbGJtTmxaRlZ1Wkc5QlkzUnBiMjRpTENKMWJtUnZSblZ1WXlJc0luWmhiSFZsSWl3aWFYUmxiU0lzSWw5elpYUk1hWE4wWlc1bGNpSXNJbXhwYzNSbGJtWjFibU1pTENKdFlXdGxWVzVrYjBGamRHbHZia1JsY21WbVpYSmxibU5sWkNJc0ltOXNaRlpoYkNJc0ltVWlMQ0pzYjJjaUxDSmlhVzVrSWl3aWRXNWtaV1pwYm1Wa0lpd2lYM2RoZEdOb1JXNWhZbXhsWkNJc0ltNWxkMVpoYkNJc0ltMXZaSFZzWlNJc0ltVjRjRzl5ZEhNaUxDSmtaWEpsWm1WeVpXNWpaU0lzSW5KbFptVnlaVzVqWlNJc0ltMWhhMlZWYm1SdlFXTjBhVzl1SWl3aWMyVjBUR2x6ZEdWdVpYSWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUTBFc1NVRjFSVWxCTEZOQmFVTkJReXhoUVhoSFFVTXNSMEZCZDBJc2IwSkJRVmhETEU5QlFYbENRU3hQUVVGWExFZEJRWE5DTEc5Q1FVRllReXhQUVVGNVFrRXNUMEZCVnl4SFFVRkpMRXRCUTNCSFF5eFJRVUZWUXl4UlFVRlJMSE5DUVVsc1FrTXNWMEZCWVN4VFFVRlRReXhGUVVGUFF5eEhRVWt2UWl4SlFVaEJMRWxCUTBsRExFVkJRVWxETEVWQlJFcERMRVZCUVVrc1JVRkZTa01zUlVGQlNVd3NSVUZEUkVrc1JVRkJTVWdzUlVGQlMwc3NVVUZEWkN4UFFVRlJUQ3hGUVVGTFRTeFBRVUZQU0N4SlFVTnNRaXhKUVVGTExFbEJRM1ZDTEV0QlFYUkNTQ3hGUVVGTFRTeFBRVUZQU0N4RlFVRkpMRXRCUTJ4Q1F5eEZRVUZKUVN4TFFVbE9SQ3hIUVVGTExFVkJRMHdzVFVGRFJpeEpRVUZMTEVsQlEwaEVMRVZCUVV0R0xFVkJRVXRQTEZGQlFWRXNTVUZCUzBvc1IwRkRka0pETEVWQlFVbEJMRVZCUVVWS0xFVkJRVXRSTEZWQlFWVk1MRVZCUVVrc1JVRkJSMFFzU1VGRE5VSkRMRVZCUVVsRUxFVkJRVXNzUlVGRFZDeE5RVU5HTEVsQlFVc3NTMEZGVVN4SlFVUllSQ3hGUVVGTFJDeEZRVUZMVHl4UlFVRlJMRWxCUVV0S0xFMUJRMVJHTEVWQlFVdEVMRVZCUVV0TExGTkJSV0lzU1VGRVdFZ3NSVUZCUzBZc1JVRkJTMDhzVVVGQlVTeEpRVUZMU2l4TlFVTlVSQ3hGUVVGTFJpeEZRVUZMU3l4UlFVTjRRa2dzUlVGQlMwOHNTMEZCUzBNc1NVRkJTVlFzUlVGQlNVTXNSMEZEYkVKRkxFVkJRVWxCTEVWQlFVVktMRVZCUVV0UkxGVkJRVlZNTEVWQlFVa3NSVUZCUjBRc1NVRkROVUpETEVWQlFVbEVMRVZCVFZZc1QwRkJUMFVzUjBGSFRFOHNVMEZCVnl4VFFVRlRReXhGUVVGVFF5eEhRVWN2UWl4SlFVWkJMRWxCUTBsV0xFVkJSRUZJTEVWQlFVOHNSMEZGUm1Nc1JVRkJTU3hGUVVGSFFTeEhRVUZMUml4RlFVRlJVQ3hQUVVGUlV5eEpRVWR1UXl4SFFVWkJXQ3hGUVVGSlZ5eEZRVUZKUml4RlFVRlJVQ3hQUVVGVFR5eEZRVUZSUlN4SFFVRkxSQ3hGUVVOc1EzQkNMRWRCUVVkelFpeGhRVUZoV2l4TFFVRkpTQ3hIUVVGUkxGZEJRMG9zU1VGQmFrSkhMRVZCUVVWaExGZEJRMWhvUWl4SFFVRlJMRWxCUVUxSExFVkJRVVZoTEdWQlExZ3NRMEZCUVN4TFFVRkpSaXhGUVVGSkxFZEJRV3RETEcxQ1FVRjBRa1lzUlVGQlVVVXNSVUZCU1N4SFFVRkhSeXhMUVZsNFF5eE5RVVJCY2tJc1VVRkJVWE5DTEUxQlFVMHNNa1JCUVRSRVNpeEZRVUZIUml4SFFVTjJSU3d5UkVGWVRpeEpRVUZKVHl4RlFVRmpNVUlzUjBGQlIzTkNMR0ZCUVdGSUxFVkJRVkZGTEVWQlFVa3NTVUZCVFhKQ0xFZEJRVWN5UWl4TlFVRk5ReXhsUVVGbFZDeEZRVUZSUlN4RlFVRkpMRWxCUVUxR0xFVkJRVkZGTEVWQlFVa3NSMEZEZEVkUkxFVkJRVTAzUWl4SFFVRkhNa0lzVFVGQlRVY3NZVUZCWVVvc1JVRkJZV2hDTEVkQlF6ZERMRWxCUVZrc1IwRkJVbTFDTEVWQlMwWXNUVUZFUVRGQ0xGRkJRVkZ6UWl4TlFVRk5MRGhEUVVFclEwTXNSVUZCWVdoQ0xFVkJRVWRYTEVWQlFVZEdMRVZCUVZGUUxFOUJRVkZhTEVkQlFVY3JRaXhMUVVGTFRDeEhRVUZqTVVJc1IwRkJSekpDTEUxQlFVMUxMR2xDUVVGcFFuUkNMRWxCUXpGSkxEaERRVXBPU0N4SFFVRlJMRWxCUVUxelFpeEZRVUZOTEVsQlZ6RkNMRTlCUVU5MFFpeEhRVWRNTUVJc01rSkJRVFpDTEZOQlFWTkRMRVZCUVZVMVFpeEZRVUZQUXl4RlFVRk5ORUlzUlVGQlQwTXNSMEZGZEVWR0xFVkJSRmszUWl4WFFVRlhReXhGUVVGUFF5eEhRVU5rTkVJc1JVRkJUME1zU1VGTGNrSkRMR0ZCUVdVc1UwRkJVME1zUjBGRE1VSjRReXhUUVVGWGQwTXNSMEZKVkVNc01rSkJRVFpDTEZOQlFWTnFReXhGUVVGUE5FSXNSVUZCVldZc1JVRkJVME1zUlVGQlQyOUNMRVZCUVZGS0xFZEJRMnBHTEVsQlEwVXNTVUZCU1RkQ0xFVkJRVTlYTEZOQlFWTkRMRVZCUVZORExFZEJTVGRDTEVkQlJITkNMR2xDUVVGWWIwSXNSMEZCZVVNc2JVSkJRVmhCTEVsQlFYVkNRU3hGUVVGVGVFTXNSMEZCUnl0Q0xFdEJRVXRUTEZOQlF6ZEVMRWxCUVZSS0xFbEJRU3RETEdsQ1FVRm1RU3hGUVVGTFJDeFBRVUUwUXl4dFFrRkJaa01zUlVGQlMwUXNUMEZGYUVaRExFVkJSR053UXl4SFFVRkhLMElzUzBGQlMwc3NSMEZKZUVJc1VVRkJkMElzU1VGQlluUkRMRk5CUTFRc1NVRkRSVUVzVTBGQlUxTXNSVUZCVFdFc1JVRkJUMjlDTEVWQlFWRktMRWRCUXpsQ0xFMUJRVTlMTEVkQlExQjBReXhSUVVGUmRVTXNTVUZCU1N3d1JFRkphRUlzVDBGQlQxUXNNa0pCUVRKQ1ZTeFZRVUZMUXl4RlFVRlhWaXhGUVVGVk5VSXNSVUZCVDBNc1JVRkJUV2xETEVWQlFWRktMRWRCUTJwR0xFMUJRVTlMTEVkQlJWQjBReXhSUVVGUmMwSXNUVUZCVFN3MFFrRkJOa0puUWl4RlFVRkhkRUlzUlVGQlUwTXNSVUZCVDJkQ0xFdEJTemxFVXl4alFVRm5RaXhUUVVGVFF5eEhRVU16UWl4UlFVRnpRaXhKUVVGWVFTeEZRVWRVTEU5QlFVOHZReXhoUVVaUVFTeGhRVUZsSzBNc1IwRkxia0pETEU5QlFVOURMRkZCUVZVc1EwRkRaa01zV1VGQllTOUNMRk5CUTJKblF5eFZRVUZYTjBNc1YwRkRXRGhETEdWQlFXZENXaXd5UWtGRGFFSmhMRmxCUVdGbUxHRkJRMkowUXl4aFFVRmpPRU1pTENKbWFXeGxJam9pTDNCeWFYWmhkR1V2ZEcxd0wyWnZieTVIVDBVdmMzSmpMMnB6TDNWdVpHOXRZVzVoWjJWeUwzVnVaRzl6WlhKcFlXeHBlbVZ5TG1wekluMD0iLCJcInVzZSBzdHJpY3RcIjt2YXIgJD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5qUXVlcnk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwualF1ZXJ5Om51bGwsa289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cua286XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWwua286bnVsbCxjb25zb2xlPXJlcXVpcmUoXCJjb25zb2xlLWJyb3dzZXJpZnlcIikscGVyZm9ybWFuY2VBd2FyZUNhbGxlcj1yZXF1aXJlKFwiLi90aW1lZC1jYWxsLmpzXCIpLnRpbWVkQ2FsbCx0b2FzdHI9cmVxdWlyZShcInRvYXN0clwiKTtmdW5jdGlvbiBpbml0aWFsaXplRWRpdG9yKGUsbyx0LGwpe3ZhciByPXtnYWxsZXJ5UmVjZW50OmtvLm9ic2VydmFibGVBcnJheShbXSksZ2FsbGVyeVJlbW90ZTprby5vYnNlcnZhYmxlQXJyYXkoW10pLHNlbGVjdGVkQmxvY2s6a28ub2JzZXJ2YWJsZShudWxsKSxzZWxlY3RlZEl0ZW06a28ub2JzZXJ2YWJsZShudWxsKSxzZWxlY3RlZFRvb2w6a28ub2JzZXJ2YWJsZSgwKSxzZWxlY3RlZEltYWdlVGFiOmtvLm9ic2VydmFibGUoMCksZHJhZ2dpbmc6a28ub2JzZXJ2YWJsZSghMSksZHJhZ2dpbmdJbWFnZTprby5vYnNlcnZhYmxlKCExKSxnYWxsZXJ5TG9hZGVkOmtvLm9ic2VydmFibGUoITEpLHNob3dQcmV2aWV3RnJhbWU6a28ub2JzZXJ2YWJsZSghMSkscHJldmlld01vZGU6a28ub2JzZXJ2YWJsZShcIm1vYmlsZVwiKSxzaG93VG9vbGJveDprby5vYnNlcnZhYmxlKCEwKSxzaG93VGhlbWU6a28ub2JzZXJ2YWJsZSghMSksc2hvd0dhbGxlcnk6a28ub2JzZXJ2YWJsZSghMSksZGVidWc6a28ub2JzZXJ2YWJsZSghMSksY29udGVudExpc3RlbmVyczprby5vYnNlcnZhYmxlKDApLGxvZ29QYXRoOlwicnMvaW1nL21vc2FpY28zMi5wbmdcIixsb2dvVXJsOlwiLlwiLGxvZ29BbHQ6XCJtb3NhaWNvXCJ9O3JldHVybiByLmNvbnRlbnQ9ZSxyLmJsb2NrRGVmcz1vLHIubm90aWZpZXI9dG9hc3RyLHIudHQ9ZnVuY3Rpb24oZSxvKXtpZih2b2lkIDAhPT1vKWZvcih2YXIgdCBpbiBvKW8uaGFzT3duUHJvcGVydHkodCkmJihlPWUucmVwbGFjZShuZXcgUmVnRXhwKFwiX19cIit0K1wiX19cIixcImdcIiksb1t0XSkpO3JldHVybiBlfSxyLnQ9ci50dCxyLnV0PWZ1bmN0aW9uKGUsbyl7cmV0dXJuIG99LHIudGVtcGxhdGVQYXRoPXQsci5yZW1vdGVVcmxQcm9jZXNzb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHIucmVtb3RlRmlsZVByb2Nlc3Nvcj1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZS51cmwmJihlLnVybD1yLnJlbW90ZVVybFByb2Nlc3NvcihlLnVybCkpLHZvaWQgMCE9PWUudGh1bWJuYWlsVXJsJiYoZS50aHVtYm5haWxVcmw9ci5yZW1vdGVVcmxQcm9jZXNzb3IoZS50aHVtYm5haWxVcmwpKSxlfSxyLmxvYWRHYWxsZXJ5PWZ1bmN0aW9uKCl7ci5nYWxsZXJ5TG9hZGVkKFwibG9hZGluZ1wiKTt2YXIgZT1sfHxcIi91cGxvYWQvXCI7JC5nZXRKU09OKGUsZnVuY3Rpb24oZSl7Zm9yKHZhciBvPTA7bzxlLmZpbGVzLmxlbmd0aDtvKyspZS5maWxlc1tvXT1yLnJlbW90ZUZpbGVQcm9jZXNzb3IoZS5maWxlc1tvXSk7ci5nYWxsZXJ5TG9hZGVkKGUuZmlsZXMubGVuZ3RoKSxyLmdhbGxlcnlSZW1vdGUoZS5maWxlcy5yZXZlcnNlKCkpfSkuZmFpbChmdW5jdGlvbigpe3IuZ2FsbGVyeUxvYWRlZCghMSksci5ub3RpZmllci5lcnJvcihyLnQoXCJVbmV4cGVjdGVkIGVycm9yIGxpc3RpbmcgZmlsZXNcIikpfSl9LHIuZmlsZVRvSW1hZ2U9ZnVuY3Rpb24oZSxvLHQpe3JldHVybiBlLnVybH0sci5yZW1vdmVCbG9jaz1mdW5jdGlvbihlLG8pe2tvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoci5zZWxlY3RlZEJsb2NrKT09a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShlKSYmci5zZWxlY3RCbG9jayhudWxsLCEwKTt2YXIgdD1vLmJsb2Nrcy5yZW1vdmUoZSk7cmV0dXJuIHIubm90aWZpZXIuaW5mbyhyLnQoXCJCbG9jayByZW1vdmVkOiB1c2UgdW5kbyBidXR0b24gdG8gcmVzdG9yZSBpdC4uLlwiKSksdH0sci5kdXBsaWNhdGVCbG9jaz1mdW5jdGlvbihlLG8pe3ZhciB0PWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZSksbD1rby50b0pTKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoby5ibG9ja3MpW3RdKTt2b2lkIDAhPT1sLmlkJiYobC5pZD1cIlwiKSxvLmJsb2Nrcy5zcGxpY2UodCsxLDAsbCl9LHIubW92ZUJsb2NrPWZ1bmN0aW9uKGUsbyx0KXt2YXIgbD1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKGUpLG49a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvLmJsb2Nrcyk7aWYodCYmbD4wfHwhdCYmbDxuLmxlbmd0aC0xKXt2YXIgYT1sKyh0Py0xOjEpLGM9blthXTtyLnN0YXJ0TXVsdGlwbGUoKSxvLmJsb2Nrcy5zcGxpY2UoYSwxKSxvLmJsb2Nrcy5zcGxpY2UobCwwLGMpLHIuc3RvcE11bHRpcGxlKCl9fSxyLmxvYWREZWZhdWx0QmxvY2tzPWZ1bmN0aW9uKCl7dmFyIGU9a28udG9KUyhyLmNvbnRlbnQoKS5tYWluQmxvY2tzKTtlLmJsb2Nrcz1bXTtmb3IodmFyIG89a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShyLmJsb2NrRGVmcyksdD0wO3Q8by5sZW5ndGg7dCsrKXt2YXIgbD1rby50b0pTKG9bdF0pO2wuaWQ9XCJibG9ja19cIit0LGUuYmxvY2tzLnB1c2gobCl9cGVyZm9ybWFuY2VBd2FyZUNhbGxlcihcInNldE1haW5CbG9ja3NcIixyLmNvbnRlbnQoKS5tYWluQmxvY2tzLl93cmFwLmJpbmQoci5jb250ZW50KCkubWFpbkJsb2NrcyxlKSl9LHIuYWRkSW1hZ2U9ZnVuY3Rpb24oZSl7dmFyIG89JChcIiNtYWluLXd5c2l3eWctYXJlYSAuc2VsZWN0YWJsZS1pbWcuc2VsZWN0ZWRpdGVtXCIpO3JldHVybiAxPT1vLmxlbmd0aCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJnZvaWQgMCE9PWUudXJsJiYoa28uY29udGV4dEZvcihvWzBdKS5fc3JjKGUudXJsKSwhMCl9LHIuYWRkQmxvY2s9ZnVuY3Rpb24oZSxvKXt2YXIgdCxsLG49ci5zZWxlY3RlZEJsb2NrKCk7aWYobnVsbCE9PW4pZm9yKHZhciBhPXIuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKS5sZW5ndGgtMTthPj0wO2EtLSlpZihyLmNvbnRlbnQoKS5tYWluQmxvY2tzKCkuYmxvY2tzKClbYV0oKT09bil7dD1hO2JyZWFrfXZvaWQgMCE9PXQ/KGw9dCsxLHIuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3Muc3BsaWNlKGwsMCxlKSxyLm5vdGlmaWVyLmluZm8oci50KFwiTmV3IGJsb2NrIGFkZGVkIGFmdGVyIHRoZSBzZWxlY3RlZCBvbmUgKF9fcG9zX18pXCIse3BvczpsfSkpKTooci5jb250ZW50KCkubWFpbkJsb2NrcygpLmJsb2Nrcy5wdXNoKGUpLGw9ci5jb250ZW50KCkubWFpbkJsb2NrcygpLmJsb2NrcygpLmxlbmd0aC0xLHIubm90aWZpZXIuaW5mbyhyLnQoXCJOZXcgYmxvY2sgYWRkZWQgYXQgdGhlIG1vZGVsIGJvdHRvbSAoX19wb3NfXylcIix7cG9zOmx9KSkpO3ZhciBjPXIuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKVtsXSgpO3JldHVybiByLnNlbGVjdEJsb2NrKGMsITApLCExfSxyLmZpbmRPYmplY3RzT2ZUeXBlPWZ1bmN0aW9uKGUsbyl7dmFyIHQ9W10sbD1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKGUpO2Zvcih2YXIgciBpbiBsKWlmKGwuaGFzT3duUHJvcGVydHkocikpe3ZhciBuPWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobFtyXSk7aWYoci5tYXRjaCgvQmxvY2tzJC8pKWZvcih2YXIgYT1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKG4uYmxvY2tzKSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBpPWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYVtjXSk7bnVsbCE9PW8mJmtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoaS50eXBlKSE9b3x8dC5wdXNoKGkpfWVsc2VcIm9iamVjdFwiPT10eXBlb2YgbiYmbnVsbCE9PW4mJihudWxsIT09byYma28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShuLnR5cGUpIT1vfHx0LnB1c2gobikpfXJldHVybiB0fSxyLnBsYWNlaG9sZGVySGVscGVyPXtlbGVtZW50OmZ1bmN0aW9uKGUpe3JldHVybiAkKGVbMF0ub3V0ZXJIVE1MKS5yZW1vdmVDbGFzcyhcInVpLWRyYWdnYWJsZVwiKS5hZGRDbGFzcyhcInNvcnRhYmxlLXBsYWNlaG9sZGVyXCIpLmNzcyhcImRpc3BsYXlcIixcImJsb2NrXCIpLmNzcyhcInBvc2l0aW9uXCIsXCJyZWxhdGl2ZVwiKS5jc3MoXCJ3aWR0aFwiLFwiMTAwJVwiKS5jc3MoXCJoZWlnaHRcIixcImF1dG9cIikuY3NzKFwib3BhY2l0eVwiLFwiLjhcIilbMF19LHVwZGF0ZTpmdW5jdGlvbihlLG8pe319LHIuc3RhcnRNdWx0aXBsZT1mdW5jdGlvbigpe3ZvaWQgMCE9PXIuc2V0VW5kb01vZGVNZXJnZSYmci5zZXRVbmRvTW9kZU1lcmdlKCl9LHIuc3RvcE11bHRpcGxlPWZ1bmN0aW9uKCl7dm9pZCAwIT09ci5zZXRVbmRvTW9kZU9uY2UmJnIuc2V0VW5kb01vZGVPbmNlKCl9LHIubG9jYWxHbG9iYWxTd2l0Y2g9ZnVuY3Rpb24oZSxvKXt2YXIgdD1lKCk7cmV0dXJuIGUobnVsbD09PXQ/bygpOm51bGwpLCExfSxyLnNlbGVjdEl0ZW09ZnVuY3Rpb24oZSxvLHQpe3ZhciBsPWtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKGUpO3JldHVybiB2b2lkIDAhPT10JiZyLnNlbGVjdEJsb2NrKHQsITEsITApLGwhPW8mJihlKG8pLG51bGwhPT1vJiYwPT09ci5zZWxlY3RlZFRvb2woKSYmci5zZWxlY3RlZFRvb2woMSkpLCExfS5iaW5kKHIsci5zZWxlY3RlZEl0ZW0pLHIuaXNTZWxlY3RlZEl0ZW09ZnVuY3Rpb24oZSl7cmV0dXJuIHIuc2VsZWN0ZWRJdGVtKCk9PWV9LHIuc2VsZWN0QmxvY2s9ZnVuY3Rpb24oZSxvLHQsbCl7dmFyIG49a28udXRpbHMucGVla09ic2VydmFibGUoZSk7bHx8ci5zZWxlY3RJdGVtKG51bGwpLG4hPW8mJihlKG8pLHIuc2hvd0dhbGxlcnkoITEpLG51bGw9PT1vfHx0fHwwIT09ci5zZWxlY3RlZFRvb2woKXx8ci5zZWxlY3RlZFRvb2woMSkpfS5iaW5kKHIsci5zZWxlY3RlZEJsb2NrKSxyLmNvdW50U3Vic2NyaXB0aW9ucz1mdW5jdGlvbihlLG8pe3ZhciB0PTA7Zm9yKHZhciBsIGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eShsKSl7dmFyIG49ZVtsXTtpZihrby5pc09ic2VydmFibGUobikmJih2b2lkIDAhPT1uLl9kZWZhdWx0Q29tcHV0ZWQmJih2b2lkIDAhPT1vJiZjb25zb2xlLmxvZyhvK1wiL1wiK2wrXCIvX1wiLG4uX2RlZmF1bHRDb21wdXRlZC5nZXRTdWJzY3JpcHRpb25zQ291bnQoKSksdCs9bi5fZGVmYXVsdENvbXB1dGVkLmdldFN1YnNjcmlwdGlvbnNDb3VudCgpKSx2b2lkIDAhPT1vJiZjb25zb2xlLmxvZyhvK1wiL1wiK2wrXCIvLVwiLG4uZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkpLHQrPW4uZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCksbj1rby51dGlscy51bndyYXBPYnNlcnZhYmxlKG4pKSxcIm9iamVjdFwiPT10eXBlb2YgbiYmbnVsbCE9PW4pe3ZhciBhPXIuY291bnRTdWJzY3JpcHRpb25zKG4sdm9pZCAwIT09bz9vK1wiL1wiK2wrXCJAXCI6dm9pZCAwKTt2b2lkIDAhPT1vJiZjb25zb2xlLmxvZyhvK1wiL1wiK2wrXCJAXCIsYSksdCs9YX19cmV0dXJuIHR9LHIubG9vcFN1YnNjcmlwdGlvbnNDb3VudD1mdW5jdGlvbigpe3ZhciBlPXIuY291bnRTdWJzY3JpcHRpb25zKHIuY29udGVudCgpKTtnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdWJzY3JpcHRpb25zQ291bnRcIikuaW5uZXJIVE1MPWUsZ2xvYmFsLnNldFRpbWVvdXQoci5sb29wU3Vic2NyaXB0aW9uc0NvdW50LDFlMyl9LHIuZXhwb3J0PWZ1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoXCJleHBvcnRIVE1MXCIsci5leHBvcnRIVE1MKX0sci5leHBvcnRIVE1MPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJ2aWV3TW9kZWwuZXhwb3J0SFRNTFwiKTt2YXIgZT1cImV4cG9ydGZyYW1lXCI7JChcImJvZHlcIikuYXBwZW5kKCc8aWZyYW1lIGlkPVwiJytlKydcIiBkYXRhLWJpbmQ9XCJiaW5kSWZyYW1lOiAkZGF0YVwiPjwvaWZyYW1lPicpO3ZhciBvPWdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTtrby5hcHBseUJpbmRpbmdzKHIsbyksa28uY2xlYW5Ob2RlKG8pLHIuaW5saW5lJiZyLmlubGluZShvLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpO3ZhciB0PW8uY29udGVudFdpbmRvdy5kb2N1bWVudC5kb2N0eXBlLGw9XCI8IURPQ1RZUEUgXCIrdC5uYW1lKyh0LnB1YmxpY0lkPycgUFVCTElDIFwiJyt0LnB1YmxpY0lkKydcIic6XCJcIikrKCF0LnB1YmxpY0lkJiZ0LnN5c3RlbUlkP1wiIFNZU1RFTVwiOlwiXCIpKyh0LnN5c3RlbUlkPycgXCInK3Quc3lzdGVtSWQrJ1wiJzpcIlwiKStcIj5cIitcIlxcblwiK28uY29udGVudFdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO2tvLnJlbW92ZU5vZGUobyksbD0obD0obD0obD0obD0obD0obD0obD0obD0obD0obD0obD0obD1sLnJlcGxhY2UoLzxzY3JpcHQgKFtePl0qICk/dHlwZT1cInRleHRcXC9odG1sXCJbXj5dKj5bXFxzXFxTXSo/PFxcL3NjcmlwdD4vZ20sXCJcIikpLnJlcGxhY2UoLzwhLS0ga28gKCg/IS0tKS4pKj8gLS0+L2csXCJcIikpLnJlcGxhY2UoLzwhLS0gXFwva28gLS0+L2csXCJcIikpLnJlcGxhY2UoLyBkYXRhLWJpbmQ9XCJbXlwiXSpcIi9nbSxcIlwiKSkucmVwbGFjZSgvIGRhdGEtbWNlLShocmVmfHNyY3xzdHlsZSk9XCJbXlwiXSpcIi9nbSxcIlwiKSkucmVwbGFjZSgvIHN0eWxlPVwiW15cIl0qXCIoW14+XSopIHJlcGxhY2VkKHN0eWxlPVwiW15cIl0qXCIpL2dtLFwiJDEgJDJcIikpLnJlcGxhY2UoLyByZXBsYWNlZChzdHlsZT1cIlteXCJdKlwiKShbXj5dKikgc3R5bGU9XCJbXlwiXSpcIi9nbSxcIiAkMSQyXCIpKS5yZXBsYWNlKC8gcmVwbGFjZWQoc3R5bGU9XCJbXlwiXSpcIikvZ20sXCIgJDFcIikpLnJlcGxhY2UoLyBodHRwLWVxdWl2PVwiW15cIl0qXCIoW14+XSopIHJlcGxhY2VkKGh0dHAtZXF1aXY9XCJbXlwiXSpcIikvZ20sXCIkMSAkMlwiKSkucmVwbGFjZSgvIHJlcGxhY2VkKGh0dHAtZXF1aXY9XCJbXlwiXSpcIikoW14+XSopIGh0dHAtZXF1aXY9XCJbXlwiXSpcIi9nbSxcIiAkMSQyXCIpKS5yZXBsYWNlKC8gcmVwbGFjZWQoaHR0cC1lcXVpdj1cIlteXCJdKlwiKS9nbSxcIiAkMVwiKSkucmVwbGFjZSgvJmx0OyUvZyxcIjwlXCIpKS5yZXBsYWNlKC8lJmd0Oy9nLFwiJT5cIik7dmFyIG49KGw9bC5yZXBsYWNlKC88cmVwbGFjZWRjY1tePl0qIGNvbmRpdGlvbj1cIihbXlwiXSopXCJbXj5dKj4oW1xcc1xcU10qPyk8XFwvcmVwbGFjZWRjYz4vZyxmdW5jdGlvbihlLG8sdCl7dmFyIGw9XCJcXHgzYyEtLVtpZiBcIitvLnJlcGxhY2UoLyZhbXA7LyxcIiZcIikrXCJdPlwiO3JldHVybiBsKz10LnJlcGxhY2UoLzwhLS0gY2M6YmM6KFtBLVphLXo6XSopIC0tPig8XFwvY2M+KT88IS0tIGNjOmFjOlxcMSAtLT4vZyxcIjwvJDE+XCIpLnJlcGxhY2UoLz48XFwvY2M+PCEtLSBjYzpzYyAtLT4vZyxcIi8+XCIpLnJlcGxhY2UoLzwhLS0gY2M6Ym86KFtBLVphLXo6XSopIC0tPjxjYy9nLFwiPCQxXCIpLnJlcGxhY2UoL14uKjwhLS0gY2M6c3RhcnQgLS0+LyxcIlwiKS5yZXBsYWNlKC88IS0tIGNjOmVuZCAtLT4uKiQvLFwiXCIpLGwrPVwiPCFbZW5kaWZdLS1cXHgzZVwifSkpLm1hdGNoKC8gZGF0YS1bXiA9XSsoPVwiW15cIl0rXCIpPyAvKXx8bC5tYXRjaCgvIHJlcGxhY2VkKFtePSBdKj0pLyk7cmV0dXJuIG4mJmNvbnNvbGUud2FybihcIk91dHB1dCBIVE1MIGNvbnRhaW5zIHVuZXhwZWN0ZWQgZGF0YS0gYXR0cmlidXRlcyBvciByZXBsYWNlZCBhdHRyaWJ1dGVzXCIsbiksbH0sci5leHBvcnRIVE1MdG9UZXh0YXJlYT1mdW5jdGlvbihlKXskKGUpLnZhbChyLmV4cG9ydEhUTUwoKSl9LHIuZXhwb3J0SlNPTnRvVGV4dGFyZWE9ZnVuY3Rpb24oZSl7JChlKS52YWwoci5leHBvcnRKU09OKCkpfSxyLmltcG9ydEpTT05mcm9tVGV4dGFyZWE9ZnVuY3Rpb24oZSl7ci5pbXBvcnRKU09OKCQoZSkudmFsKCkpfSxyLmV4cG9ydE1ldGFkYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGtvLnRvSlNPTihyLm1ldGFkYXRhKX0sci5leHBvcnRKU09OPWZ1bmN0aW9uKCl7cmV0dXJuIGtvLnRvSlNPTihyLmNvbnRlbnQpfSxyLmV4cG9ydEpTPWZ1bmN0aW9uKCl7cmV0dXJuIGtvLnRvSlMoci5jb250ZW50KX0sci5pbXBvcnRKU09OPWZ1bmN0aW9uKGUpe3ZhciBvPWtvLnV0aWxzLnBhcnNlSnNvbihlKTtyLmNvbnRlbnQuX3dyYXAobyl9LHIuZXhwb3J0VGhlbWU9ZnVuY3Rpb24oKXt2YXIgZT17fSxvPXIuY29udGVudCgpLnRoZW1lKCksdD1mdW5jdGlvbihlLG8sbCl7Zm9yKHZhciByIGluIGwpaWYobC5oYXNPd25Qcm9wZXJ0eShyKSl7dmFyIG49a28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShsW3JdKTtudWxsIT09biYmXCJvYmplY3RcIj09dHlwZW9mIG4/dChyK1wiLlwiLG8sbik6b1tlK3JdPW59fTt0KFwiXCIsZSxvKTt2YXIgbD1cIlwiO2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJlwidHlwZVwiIT1uJiYobCs9bitcIjogXCIrZVtuXStcIjtcXG5cIik7cmV0dXJuIGx9LHIubG9hZEltYWdlPWZ1bmN0aW9uKGUpe3IuZ2FsbGVyeVJlY2VudC51bnNoaWZ0KGUpLHIuc2VsZWN0ZWRJbWFnZVRhYigwKX0sci5zZWxlY3RJbWFnZT1mdW5jdGlvbihlKXtyLnNob3dHYWxsZXJ5KCEwKX0sci5kaWFsb2c9ZnVuY3Rpb24oZSxvKXskKGUpLmRpYWxvZyhvKX0sci5sb2c9ZnVuY3Rpb24oZSxvKXt9LHJ9dG9hc3RyLm9wdGlvbnM9e2Nsb3NlQnV0dG9uOiExLGRlYnVnOiExLHBvc2l0aW9uQ2xhc3M6XCJ0b2FzdC1ib3R0b20tZnVsbC13aWR0aFwiLHRhcmdldDpcIiNtby1ib2R5XCIsb25jbGljazpudWxsLHNob3dEdXJhdGlvbjpcIjMwMFwiLGhpZGVEdXJhdGlvbjpcIjEwMDBcIix0aW1lT3V0OlwiNTAwMFwiLGV4dGVuZGVkVGltZU91dDpcIjEwMDBcIixzaG93RWFzaW5nOlwic3dpbmdcIixoaWRlRWFzaW5nOlwibGluZWFyXCIsc2hvd01ldGhvZDpcImZhZGVJblwiLGhpZGVNZXRob2Q6XCJmYWRlT3V0XCJ9LG1vZHVsZS5leHBvcnRzPWluaXRpYWxpemVFZGl0b3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJblpwWlhkdGIyUmxiQzVxY3lKZExDSnVZVzFsY3lJNld5SWtJaXdpZDJsdVpHOTNJaXdpWjJ4dlltRnNJaXdpYTI4aUxDSmpiMjV6YjJ4bElpd2ljbVZ4ZFdseVpTSXNJbkJsY21admNtMWhibU5sUVhkaGNtVkRZV3hzWlhJaUxDSjBhVzFsWkVOaGJHd2lMQ0owYjJGemRISWlMQ0pwYm1sMGFXRnNhWHBsUldScGRHOXlJaXdpWTI5dWRHVnVkQ0lzSW1Kc2IyTnJSR1ZtY3lJc0luUm9kVzFpVUdGMGFFTnZiblpsY25SbGNpSXNJbWRoYkd4bGNubFZjbXdpTENKMmFXVjNUVzlrWld3aUxDSm5ZV3hzWlhKNVVtVmpaVzUwSWl3aWIySnpaWEoyWVdKc1pVRnljbUY1SWl3aVoyRnNiR1Z5ZVZKbGJXOTBaU0lzSW5ObGJHVmpkR1ZrUW14dlkyc2lMQ0p2WW5ObGNuWmhZbXhsSWl3aWMyVnNaV04wWldSSmRHVnRJaXdpYzJWc1pXTjBaV1JVYjI5c0lpd2ljMlZzWldOMFpXUkpiV0ZuWlZSaFlpSXNJbVJ5WVdkbmFXNW5JaXdpWkhKaFoyZHBibWRKYldGblpTSXNJbWRoYkd4bGNubE1iMkZrWldRaUxDSnphRzkzVUhKbGRtbGxkMFp5WVcxbElpd2ljSEpsZG1sbGQwMXZaR1VpTENKemFHOTNWRzl2YkdKdmVDSXNJbk5vYjNkVWFHVnRaU0lzSW5Ob2IzZEhZV3hzWlhKNUlpd2laR1ZpZFdjaUxDSmpiMjUwWlc1MFRHbHpkR1Z1WlhKeklpd2liRzluYjFCaGRHZ2lMQ0pzYjJkdlZYSnNJaXdpYkc5bmIwRnNkQ0lzSW01dmRHbG1hV1Z5SWl3aWRIUWlMQ0pyWlhraUxDSndZWEpoYlU5aWFpSXNJbkJ5YjNBaUxDSm9ZWE5QZDI1UWNtOXdaWEowZVNJc0luSmxjR3hoWTJVaUxDSlNaV2RGZUhBaUxDSjBJaXdpZFhRaUxDSmpZWFJsWjI5eWVTSXNJblJsYlhCc1lYUmxVR0YwYUNJc0luSmxiVzkwWlZWeWJGQnliMk5sYzNOdmNpSXNJblZ5YkNJc0luSmxiVzkwWlVacGJHVlFjbTlqWlhOemIzSWlMQ0ptYVd4bFQySnFJaXdpZEdoMWJXSnVZV2xzVlhKc0lpd2liRzloWkVkaGJHeGxjbmtpTENKblpYUktVMDlPSWl3aVpHRjBZU0lzSW1raUxDSm1hV3hsY3lJc0lteGxibWQwYUNJc0luSmxkbVZ5YzJVaUxDSm1ZV2xzSWl3aVpYSnliM0lpTENKbWFXeGxWRzlKYldGblpTSXNJbTlpYWlJc0ltVjJaVzUwSWl3aWRXa2lMQ0p5WlcxdmRtVkNiRzlqYXlJc0luQmhjbVZ1ZENJc0luVjBhV3h6SWl3aWRXNTNjbUZ3VDJKelpYSjJZV0pzWlNJc0luTmxiR1ZqZEVKc2IyTnJJaXdpY21Weklpd2lZbXh2WTJ0eklpd2ljbVZ0YjNabElpd2lhVzVtYnlJc0ltUjFjR3hwWTJGMFpVSnNiMk5ySWl3aWFXNWtaWGdpTENKcFpIZ2lMQ0oxYm5keVlYQndaV1FpTENKMGIwcFRJaXdpYVdRaUxDSnpjR3hwWTJVaUxDSnRiM1psUW14dlkyc2lMQ0oxY0NJc0luQmhjbVZ1ZEVKc2IyTnJjeUlzSW1SbGMzUkpibVJsZUNJc0ltUmxjM1JDYkc5amF5SXNJbk4wWVhKMFRYVnNkR2x3YkdVaUxDSnpkRzl3VFhWc2RHbHdiR1VpTENKc2IyRmtSR1ZtWVhWc2RFSnNiMk5yY3lJc0ltMWhhVzVDYkc5amEzTWlMQ0pwYm5CMWRDSXNJbkIxYzJnaUxDSmZkM0poY0NJc0ltSnBibVFpTENKaFpHUkpiV0ZuWlNJc0ltbHRaeUlzSW5ObGJHVmpkR1ZrU1cxbklpd2lZMjl1ZEdWNGRFWnZjaUlzSWw5emNtTWlMQ0poWkdSQ2JHOWpheUlzSW1admRXNWtJaXdpY0c5eklpd2ljMlZzWldOMFpXUWlMQ0poWkdSbFpDSXNJbVpwYm1SUFltcGxZM1J6VDJaVWVYQmxJaXdpZEhsd1pTSXNJblpoYkNJc0ltMWhkR05vSWl3aVkyOXVkR1Z1ZEhNaUxDSmpJaXdpY0d4aFkyVm9iMnhrWlhKSVpXeHdaWElpTENKbGJHVnRaVzUwSWl3aVkzVnljbVZ1ZEVsMFpXMGlMQ0p2ZFhSbGNraFVUVXdpTENKeVpXMXZkbVZEYkdGemN5SXNJbUZrWkVOc1lYTnpJaXdpWTNOeklpd2lkWEJrWVhSbElpd2lZMjl1ZEdGcGJtVnlJaXdpY0NJc0luTmxkRlZ1Wkc5TmIyUmxUV1Z5WjJVaUxDSnpaWFJWYm1SdlRXOWtaVTl1WTJVaUxDSnNiMk5oYkVkc2IySmhiRk4zYVhSamFDSXNJbWRzYjJKaGJGQnliM0FpTENKamRYSnlaVzUwSWl3aWMyVnNaV04wU1hSbGJTSXNJblpoYkhWbFFXTmpaWE56YjNJaUxDSnBkR1Z0SWl3aVlteHZZMnNpTENKd1pXVnJUMkp6WlhKMllXSnNaU0lzSW1selUyVnNaV04wWldSSmRHVnRJaXdpWkc5T2IzUlRaV3hsWTNRaUxDSmtiMDV2ZEZWdWMyVnNaV04wU1hSbGJTSXNJbU52ZFc1MFUzVmljMk55YVhCMGFXOXVjeUlzSW0xdlpHVnNJaXdpYVhOUFluTmxjblpoWW14bElpd2lYMlJsWm1GMWJIUkRiMjF3ZFhSbFpDSXNJbXh2WnlJc0ltZGxkRk4xWW5OamNtbHdkR2x2Ym5ORGIzVnVkQ0lzSW5SdmRDSXNJblZ1WkdWbWFXNWxaQ0lzSW14dmIzQlRkV0p6WTNKcGNIUnBiMjV6UTI5MWJuUWlMQ0pqYjNWdWRDSXNJbVJ2WTNWdFpXNTBJaXdpWjJWMFJXeGxiV1Z1ZEVKNVNXUWlMQ0pwYm01bGNraFVUVXdpTENKelpYUlVhVzFsYjNWMElpd2laWGh3YjNKMElpd2laWGh3YjNKMFNGUk5UQ0lzSW1Gd2NHVnVaQ0lzSW1aeVlXMWxSV3dpTENKaGNIQnNlVUpwYm1ScGJtZHpJaXdpWTJ4bFlXNU9iMlJsSWl3aWFXNXNhVzVsSWl3aVkyOXVkR1Z1ZEZkcGJtUnZkeUlzSW01dlpHVWlMQ0prYjJOMGVYQmxJaXdpYm1GdFpTSXNJbkIxWW14cFkwbGtJaXdpYzNsemRHVnRTV1FpTENKa2IyTjFiV1Z1ZEVWc1pXMWxiblFpTENKeVpXMXZkbVZPYjJSbElpd2lkSEpoYzJnaUxDSmpiMjVrYVhScGIyNGlMQ0ppYjJSNUlpd2laR1FpTENKM1lYSnVJaXdpWlhod2IzSjBTRlJOVEhSdlZHVjRkR0Z5WldFaUxDSjBaWGgwWVhKbFlXbGtJaXdpWlhod2IzSjBTbE5QVG5SdlZHVjRkR0Z5WldFaUxDSmxlSEJ2Y25SS1UwOU9JaXdpYVcxd2IzSjBTbE5QVG1aeWIyMVVaWGgwWVhKbFlTSXNJbWx0Y0c5eWRFcFRUMDRpTENKbGVIQnZjblJOWlhSaFpHRjBZU0lzSW5SdlNsTlBUaUlzSW0xbGRHRmtZWFJoSWl3aVpYaHdiM0owU2xNaUxDSnFjMjl1SWl3aWNHRnljMlZLYzI5dUlpd2laWGh3YjNKMFZHaGxiV1VpTENKbWJHRjBJaXdpYlc5a0lpd2lkR2hsYldVaUxDSmZaWGh3YjNKMElpd2ljSEpsWm1sNElpd2lZU0lzSW05MWRIQjFkQ0lzSW14dllXUkpiV0ZuWlNJc0luVnVjMmhwWm5RaUxDSnpaV3hsWTNSSmJXRm5aU0lzSW1ScFlXeHZaeUlzSW5ObGJHVmpkRzl5SWl3aWIzQjBhVzl1Y3lJc0ltMXpaeUlzSW1Oc2IzTmxRblYwZEc5dUlpd2ljRzl6YVhScGIyNURiR0Z6Y3lJc0luUmhjbWRsZENJc0ltOXVZMnhwWTJzaUxDSnphRzkzUkhWeVlYUnBiMjRpTENKb2FXUmxSSFZ5WVhScGIyNGlMQ0owYVcxbFQzVjBJaXdpWlhoMFpXNWtaV1JVYVcxbFQzVjBJaXdpYzJodmQwVmhjMmx1WnlJc0ltaHBaR1ZGWVhOcGJtY2lMQ0p6YUc5M1RXVjBhRzlrSWl3aWFHbGtaVTFsZEdodlpDSXNJbTF2WkhWc1pTSXNJbVY0Y0c5eWRITWlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJMR0ZCUjBFc1NVRkJTVUVzUlVGQmRVSXNiMEpCUVZoRExFOUJRWGxDUVN4UFFVRmxMRTlCUVhOQ0xHOUNRVUZZUXl4UFFVRjVRa0VzVDBGQlpTeFBRVUZKTEV0QlF6TkhReXhIUVVGM1FpeHZRa0ZCV0VZc1QwRkJlVUpCTEU5QlFWY3NSMEZCYzBJc2IwSkJRVmhETEU5QlFYbENRU3hQUVVGWExFZEJRVWtzUzBGRGNFZEZMRkZCUVZWRExGRkJRVkVzYzBKQlEyeENReXgxUWtGQmVVSkVMRkZCUVZFc2JVSkJRVzFDUlN4VlFVVndSRU1zVDBGQlUwZ3NVVUZCVVN4VlFXbENja0lzVTBGQlUwa3NhVUpCUVdsQ1F5eEZRVUZUUXl4RlFVRlhReXhGUVVGdlFrTXNSMEZEYUVVc1NVRkJTVU1zUlVGQldTeERRVU5rUXl4alFVRmxXaXhIUVVGSFlTeG5Ra0ZCWjBJc1NVRkRiRU5ETEdOQlFXVmtMRWRCUVVkaExHZENRVUZuUWl4SlFVTnNRMFVzWTBGQlpXWXNSMEZCUjJkQ0xGZEJRVmNzVFVGRE4wSkRMR0ZCUVdOcVFpeEhRVUZIWjBJc1YwRkJWeXhOUVVNMVFrVXNZVUZCWTJ4Q0xFZEJRVWRuUWl4WFFVRlhMRWRCUXpWQ1J5eHBRa0ZCYTBKdVFpeEhRVUZIWjBJc1YwRkJWeXhIUVVOb1Ewa3NVMEZCVlhCQ0xFZEJRVWRuUWl4WlFVRlhMRWRCUTNoQ1N5eGpRVUZsY2tJc1IwRkJSMmRDTEZsQlFWY3NSMEZETjBKTkxHTkJRV1YwUWl4SFFVRkhaMElzV1VGQlZ5eEhRVU0zUWs4c2FVSkJRV3RDZGtJc1IwRkJSMmRDTEZsQlFWY3NSMEZEYUVOUkxGbEJRV0Y0UWl4SFFVRkhaMElzVjBGQlZ5eFZRVU16UWxNc1dVRkJZWHBDTEVkQlFVZG5RaXhaUVVGWExFZEJRek5DVlN4VlFVRlhNVUlzUjBGQlIyZENMRmxCUVZjc1IwRkRla0pYTEZsQlFXRXpRaXhIUVVGSFowSXNXVUZCVnl4SFFVTXpRbGtzVFVGQlR6VkNMRWRCUVVkblFpeFpRVUZYTEVkQlEzSkNZU3hwUWtGQmEwSTNRaXhIUVVGSFowSXNWMEZCVnl4SFFVTm9RMk1zVTBGQlZTeDFRa0ZEVmtNc1VVRkJVeXhKUVVOVVF5eFJRVUZUTEZkQk5HcENXQ3hQUVhocVFrRnlRaXhGUVVGVlNpeFJRVUZWUVN4RlFVTndRa2tzUlVGQlZVZ3NWVUZCV1VFc1JVRkZkRUpITEVWQlFWVnpRaXhUUVVGWE5VSXNUMEZIY2tKTkxFVkJRVlYxUWl4SFFVRkxMRk5CUVZORExFVkJRVXRETEVkQlF6TkNMRkZCUVhkQ0xFbEJRV0pCTEVWQlExUXNTVUZCU3l4SlFVRkpReXhMUVVGUlJDeEZRVU5ZUVN4RlFVRlRSU3hsUVVGbFJDeExRVU14UWtZc1JVRkJUVUVzUlVGQlNVa3NVVUZCVVN4SlFVRkpReXhQUVVGUExFdEJRVTlJTEVWQlFVOHNTMEZCVFN4TFFVRk5SQ3hGUVVGVFF5eExRVVYwUlN4UFFVRlBSaXhIUVU5VWVFSXNSVUZCVlRoQ0xFVkJRVWs1UWl4RlFVRlZkVUlzUjBGTGVFSjJRaXhGUVVGVkswSXNSMEZCU3l4VFFVRlRReXhGUVVGVlVpeEhRVU5vUXl4UFFVRlBRU3hIUVVkVWVFSXNSVUZCVldsRExHRkJRV1Z1UXl4RlFVVjZRa1VzUlVGQlZXdERMRzFDUVVGeFFpeFRRVUZUUXl4SFFVTjBReXhQUVVGUFFTeEhRVWRVYmtNc1JVRkJWVzlETEc5Q1FVRnpRaXhUUVVGVFF5eEhRVTEyUXl4WlFVd3lRaXhKUVVGb1FrRXNSVUZCVVVZc1RVRkRha0pGTEVWQlFWRkdMRWxCUVUxdVF5eEZRVUZWYTBNc2JVSkJRVzFDUnl4RlFVRlJSaXhYUVVOcVFpeEpRVUY2UWtVc1JVRkJVVU1zWlVGRGFrSkVMRVZCUVZGRExHRkJRV1YwUXl4RlFVRlZhME1zYlVKQlFXMUNSeXhGUVVGUlF5eGxRVVYyUkVRc1IwRkpWSEpETEVWQlFWVjFReXhaUVVGakxGZEJRM1JDZGtNc1JVRkJWVmNzWTBGQll5eFhRVU40UWl4SlFVRkpkMElzUlVGQlRYQkRMRWRCUVRCQ0xGZEJSWEJEWWl4RlFVRkZjMFFzVVVGQlVVd3NSVUZCU3l4VFFVRlRUU3hIUVVOMFFpeEpRVUZMTEVsQlFVbERMRVZCUVVrc1JVRkJSMEVzUlVGQlNVUXNSVUZCUzBVc1RVRkJUVU1zVDBGQlVVWXNTVUZEY2tORUxFVkJRVXRGTEUxQlFVMUVMRWRCUVVzeFF5eEZRVUZWYjBNc2IwSkJRVzlDU3l4RlFVRkxSU3hOUVVGTlJDeEpRVU16UkRGRExFVkJRVlZYTEdOQlFXTTRRaXhGUVVGTFJTeE5RVUZOUXl4UlFVVnVRelZETEVWQlFWVkhMR05CUVdOelF5eEZRVUZMUlN4TlFVRk5SU3hoUVVOc1EwTXNTMEZCU3l4WFFVTk9PVU1zUlVGQlZWY3NaVUZCWXl4SFFVTjRRbGdzUlVGQlZYTkNMRk5CUVZONVFpeE5RVUZOTDBNc1JVRkJWVGhDTEVWQlFVVXNjME5CUzNwRE9VSXNSVUZCVldkRUxGbEJRV01zVTBGQlUwTXNSVUZCUzBNc1JVRkJUME1zUjBGRk0wTXNUMEZCVDBZc1JVRkJTV1FzUzBGSlltNURMRVZCUVZWdlJDeFpRVUZqTEZOQlFWTllMRVZCUVUxWkxFZEJSMjVEYUVVc1IwRkJSMmxGTEUxQlFVMURMR2xDUVVGcFFuWkVMRVZCUVZWSkxHZENRVU53UTJZc1IwRkJSMmxGTEUxQlFVMURMR2xDUVVGcFFtUXNTVUZGTVVKNlF5eEZRVUZWZDBRc1dVRkJXU3hOUVVGTkxFZEJSVGxDTEVsQlFVbERMRVZCUVUxS0xFVkJRVTlMTEU5QlFVOURMRTlCUVU5c1FpeEhRVXN2UWl4UFFVaEJla01zUlVGQlZYTkNMRk5CUVZOelF5eExRVU5xUWpWRUxFVkJRVlU0UWl4RlFVRkZMRzlFUVVWUU1rSXNSMEZKVkhwRUxFVkJRVlUyUkN4bFFVRnBRaXhUUVVGVFF5eEZRVUZQVkN4SFFVTjZReXhKUVVGSlZTeEZRVUZOTVVVc1IwRkJSMmxGTEUxQlFVMURMR2xDUVVGcFFrOHNSMEZGYUVORkxFVkJRVmt6UlN4SFFVRkhORVVzUzBGQlN6VkZMRWRCUVVkcFJTeE5RVUZOUXl4cFFrRkJhVUpHTEVWQlFVOUxMRkZCUVZGTExGTkJSWEpETEVsQlFXcENReXhGUVVGVlJTeExRVUZ2UWtZc1JVRkJWVVVzUjBGQlN5eEpRVVY0UkdJc1JVRkJUMHNzVDBGQlQxTXNUMEZCVDBvc1JVRkJUU3hGUVVGSExFVkJRVWRETEVsQlNXNURhRVVzUlVGQlZXOUZMRlZCUVZrc1UwRkJVMDRzUlVGQlQxUXNSVUZCVVdkQ0xFZEJRelZETEVsQlFVbE9MRVZCUVUweFJTeEhRVUZIYVVVc1RVRkJUVU1zYVVKQlFXbENUeXhIUVVOb1ExRXNSVUZCWldwR0xFZEJRVWRwUlN4TlFVRk5ReXhwUWtGQmFVSkdMRVZCUVU5TExGRkJRM0JFTEVkQlFVdFhMRWRCUVUxT0xFVkJRVTBzU1VGQlVVMHNSMEZCVFU0c1JVRkJUVThzUlVGQllURkNMRTlCUVZNc1JVRkJTU3hEUVVNM1JDeEpRVUZKTWtJc1JVRkJXVklzUjBGQlQwMHNSMEZCVFN4RlFVRkpMRWRCUXpkQ1J5eEZRVUZaUml4RlFVRmhReXhIUVVNM1FuWkZMRVZCUVZWNVJTeG5Ra0ZEVm5CQ0xFVkJRVTlMTEU5QlFVOVRMRTlCUVU5SkxFVkJRVmNzUjBGRGFFTnNRaXhGUVVGUFN5eFBRVUZQVXl4UFFVRlBTaXhGUVVGTExFVkJRVWRUTEVkQlF6ZENlRVVzUlVGQlZUQkZMR2xDUVV0a01VVXNSVUZCVlRKRkxHdENRVUZ2UWl4WFFVYzFRaXhKUVVGSmJFSXNSVUZCVFhCRkxFZEJRVWMwUlN4TFFVRkxha1VzUlVGQlZVb3NWVUZCVldkR0xGbEJRM1JEYmtJc1JVRkJTVU1zVDBGQlV5eEhRVVZpTEVsQlJFRXNTVUZCU1cxQ0xFVkJRVkY0Uml4SFFVRkhhVVVzVFVGQlRVTXNhVUpCUVdsQ2RrUXNSVUZCVlVnc1YwRkRka00yUXl4RlFVRkpMRVZCUVVkQkxFVkJRVWx0UXl4RlFVRk5ha01zVDBGQlVVWXNTVUZCU3l4RFFVTnlReXhKUVVGSlR5eEZRVUZOTlVRc1IwRkJSelJGTEV0QlFVdFpMRVZCUVUxdVF5eEpRVVY0UWs4c1JVRkJTV2xDTEVkQlFVc3NVMEZCVjNoQ0xFVkJRM0JDWlN4RlFVRkpReXhQUVVGUGIwSXNTMEZCU3pkQ0xFZEJSV3hDZWtRc2RVSkJRMFVzWjBKQlEwRlJMRVZCUTBkS0xGVkJRMEZuUml4WFFVRlhSeXhOUVVGTlF5eExRVUZMYUVZc1JVRkJWVW9zVlVGQlZXZEdMRmRCUVZsdVFpeExRVXMzUkhwRUxFVkJRVlZwUml4VFFVRlhMRk5CUVZORExFZEJRelZDTEVsQlFVbERMRVZCUVdOcVJ5eEZRVUZGTEcxRVFVTndRaXhQUVVOM1FpeEhRVUYwUW1sSExFVkJRVmwyUXl4UlFVTkZMR2xDUVVGUWMwTXNVVUZEV1N4SlFVRmFRU3hGUVVGSkwwTXNUVUZGV0RsRExFZEJRVWNyUml4WFFVRlhSQ3hGUVVGWkxFbEJRVWxGTEV0QlFVdElMRVZCUVVrdlF5eE5RVU5vUXl4SlFVOVlia01zUlVGQlZYTkdMRk5CUVZjc1UwRkJVM0pETEVWQlFVdERMRWRCUldwRExFbEJSVWx4UXl4RlFYZENRVU1zUlVFeFFrRkRMRVZCUVZkNlJpeEZRVUZWU1N4blFrRkhla0lzUjBGQmFVSXNUMEZCWW5GR0xFVkJSVVlzU1VGRFJTeEpRVUZKTDBNc1JVRkRSakZETEVWQlEwZEtMRlZCUTBGblJpeGhRVU5CYkVJc1UwRkJVMlFzVDBGQlV5eEZRVU4yUWtZc1IwRkJTeXhGUVVOTVFTeEpRVVZCTEVkQlEwVXhReXhGUVVOSFNpeFZRVU5CWjBZc1lVRkRRV3hDTEZOQlEwRm9RaXhOUVVGUkswTXNSVUZEV0N4RFFVTkJSaXhGUVVGUk4wTXNSVUZEVWl4WFFVdGxMRWxCUVZZMlF5eEhRVU5VUXl4RlFVRk5SQ3hGUVVGUkxFVkJRMlIyUml4RlFVTkhTaXhWUVVOQlowWXNZVUZEUVd4Q0xFOUJRVTlUTEU5QlFVOXhRaXhGUVVGTExFVkJRVWQyUXl4SFFVTjZRbXBFTEVWQlFWVnpRaXhUUVVGVGMwTXNTMEZEYWtJMVJDeEZRVUZWT0VJc1JVRkJSU3h0UkVGQmIwUXNRMEZET1VRd1JDeEpRVUZMUVN4UFFVbFVlRVlzUlVGRFIwb3NWVUZEUVdkR0xHRkJRMEZzUWl4UFFVRlBiMElzUzBGQlN6ZENMRWRCUTJaMVF5eEZRVU5GZUVZc1JVRkRSMG9zVlVGRFFXZEdMR0ZCUTBGc1FpeFRRVUZUWkN4UFFVRlRMRVZCUTNaQ05VTXNSVUZCVlhOQ0xGTkJRVk56UXl4TFFVTnFRalZFTEVWQlFWVTRRaXhGUVVGRkxHZEVRVUZwUkN4RFFVTXpSREJFTEVsQlFVdEJMRTFCUzFnc1NVRkJTVVVzUlVGQlVURkdMRVZCUTFSS0xGVkJRMEZuUml4aFFVTkJiRUlzVTBGRFFUaENMRXRCUjBnc1QwRkdRWGhHTEVWQlFWVjNSQ3haUVVGWmEwTXNSMEZCVHl4SlFVVjBRaXhIUVVsVU1VWXNSVUZCVlRKR0xHdENRVUZ2UWl4VFFVRlRiRVFzUlVGQlRXMUVMRWRCUXpORExFbEJRVWx1UXl4RlFVRk5MRWRCUTA1U0xFVkJRVTAxUkN4SFFVRkhhVVVzVFVGQlRVTXNhVUpCUVdsQ1pDeEhRVU53UXl4SlFVRkxMRWxCUVVsbUxFdEJRVkYxUWl4RlFVTm1MRWRCUVVsQkxFVkJRVWwwUWl4bFFVRmxSQ3hIUVVGUExFTkJRelZDTEVsQlFVbHRSU3hGUVVGTmVFY3NSMEZCUjJsRkxFMUJRVTFETEdsQ1FVRnBRazRzUlVGQlNYWkNMRWxCUlhoRExFZEJRVWxCTEVWQlFVdHZSU3hOUVVGTkxGZEJSV0lzU1VGRVFTeEpRVUZKUXl4RlFVRlhNVWNzUjBGQlIybEZMRTFCUVUxRExHbENRVUZwUW5ORExFVkJRVWx1UXl4UlFVTndRMmhDTEVWQlFVa3NSVUZCUjBFc1JVRkJTWEZFTEVWQlFWTnVSQ3hQUVVGUlJpeEpRVUZMTEVOQlEzaERMRWxCUVVselJDeEZRVUZKTTBjc1IwRkJSMmxGTEUxQlFVMURMR2xDUVVGcFFuZERMRVZCUVZOeVJDeEpRVU01UWl4UFFVRlVhMFFzUjBGQmFVSjJSeXhIUVVGSGFVVXNUVUZCVFVNc2FVSkJRV2xDZVVNc1JVRkJSVW9zVDBGQlUwRXNSMEZEZUVSdVF5eEZRVUZKY1VJc1MwRkJTMnRDTEU5QlIxVXNhVUpCUVZCSUxFZEJRVEpDTEU5QlFWSkJMRWxCUTNSQ0xFOUJRVlJFTEVkQlFXbENka2NzUjBGQlIybEZMRTFCUVUxRExHbENRVUZwUW5ORExFVkJRVWxFTEU5QlFWTkJMRWRCUXpGRWJrTXNSVUZCU1hGQ0xFdEJRVXRsTEVsQlIycENMRTlCUVU5d1F5eEhRV3RDVkhwRUxFVkJRVlZwUnl4clFrRkJiMElzUTBGRE5VSkRMRkZCUVZNc1UwRkJVME1zUjBGRGFFSXNUMEZCVDJwSUxFVkJRVVZwU0N4RlFVRlpMRWRCUVVkRExGZEJRM0pDUXl4WlFVRlpMR2RDUVVOYVF5eFRRVUZUTEhkQ1FVTlVReXhKUVVGSkxGVkJRVmNzVTBGRFprRXNTVUZCU1N4WFFVRlpMRmxCUTJoQ1FTeEpRVUZKTEZGQlFWTXNVVUZEWWtFc1NVRkJTU3hUUVVGVkxGRkJRMlJCTEVsQlFVa3NWVUZCVnl4TlFVRk5MRWxCUlRGQ1F5eFBRVUZSTEZOQlFWTkRMRVZCUVZkRExFMUJUemxDTVVjc1JVRkJWWGxGTEdOQlFXZENMR2RDUVVOclFpeEpRVUV2UW5wRkxFVkJRVlV5Unl4clFrRkRia0l6Unl4RlFVRlZNa2NzYjBKQlJXUXpSeXhGUVVGVk1FVXNZVUZCWlN4blFrRkRhMElzU1VGQk9VSXhSU3hGUVVGVk5FY3NhVUpCUTI1Q05VY3NSVUZCVlRSSExHMUNRVWxrTlVjc1JVRkJWVFpITEd0Q1FVRnZRaXhUUVVGVGJrWXNSVUZCVFc5R0xFZEJRek5ETEVsQlFVbERMRVZCUVZWeVJpeEpRVWRrTEU5QlJuTkNRU3hGUVVGT0xFOUJRVnB4Uml4RlFVRjFRa1FzU1VGRGFrSXNUMEZEU0N4SFFVbFVPVWNzUlVGQlZXZElMRmRCUVdFc1UwRkJVME1zUlVGQlpVTXNSVUZCVFVNc1IwRkRia1FzU1VGQlNYUkNMRVZCUVUxNFJ5eEhRVUZIYVVVc1RVRkJUVGhFTEdWQlFXVklMRWRCVVd4RExGbEJVSEZDTEVsQlFWWkZMRWRCUVhWQ2JrZ3NSVUZCVlhkRUxGbEJRVmt5UkN4SFFVRlBMRWRCUVU4c1IwRkRiRVYwUWl4SFFVRlBjVUlzU1VGRFZFUXNSVUZCWTBNc1IwRkZSQ3hQUVVGVVFTeEhRVUU0UXl4SlFVRTNRbXhJTEVWQlFWVlBMR2RDUVVNM1FsQXNSVUZCVlU4c1lVRkJZU3hMUVVWd1FpeEhRVU5RZVVVc1MwRkJTMmhHTEVWQlFWZEJMRVZCUVZWTkxHTkJSVFZDVGl4RlFVRlZjVWdzWlVGQmFVSXNVMEZCVTBnc1IwRkRiRU1zVDBGQlQyeElMRVZCUVZWTkxHZENRVUZyUWpSSExFZEJSM0pEYkVnc1JVRkJWWGRFTEZsQlFXTXNVMEZEZEVKNVJDeEZRVU5CUXl4RlFVTkJTU3hGUVVOQlF5eEhRVVZCTEVsQlFVa3hRaXhGUVVGTmVFY3NSMEZCUjJsRkxFMUJRVTA0UkN4bFFVRmxTQ3hIUVVNM1FrMHNSMEZCYlVKMlNDeEZRVUZWWjBnc1YwRkJWeXhOUVVONlEyNUNMRWRCUVU5eFFpeEpRVU5VUkN4RlFVRmpReXhIUVVWa2JFZ3NSVUZCVldkQ0xHRkJRVmtzUjBGRFZDeFBRVUZVYTBjc1IwRkJhMEpKTEVkQlFUUkRMRWxCUVRkQ2RFZ3NSVUZCVlU4c1owSkJRemREVUN4RlFVRlZUeXhoUVVGaExFdEJSVE5DZVVVc1MwRkJTMmhHTEVWQlFWZEJMRVZCUVZWSkxHVkJSelZDU2l4RlFVRlZkMGdzYlVKQlFYRkNMRk5CUVZORExFVkJRVTk0Unl4SFFVTTNReXhKUVVGSmQwTXNSVUZCVFN4RlFVTldMRWxCUVVzc1NVRkJTUzlDTEV0QlFWRXJSaXhGUVVObUxFZEJRVWxCTEVWQlFVMDVSaXhsUVVGbFJDeEhRVUZQTEVOQlF6bENMRWxCUVVsblJpeEZRVUZKWlN4RlFVRk5MMFlzUjBGbFpDeEhRV1JKY2tNc1IwRkJSM0ZKTEdGQlFXRm9RaXhWUVVObExFbEJRWFJDUVN4RlFVRkZhVUlzZDBKQlExTXNTVUZCVkRGSExFZEJRMVF6UWl4UlFVRlJjMGtzU1VGRFRqTkhMRVZCUVZFc1NVRkJUVk1zUlVGQlR5eExRVU55UW1kR0xFVkJRVVZwUWl4cFFrRkJhVUpGTEhsQ1FVVjJRbkJGTEVkQlFVOXBSQ3hGUVVGRmFVSXNhVUpCUVdsQ1JTdzRRa0ZGVWl4SlFVRlVOVWNzUjBGRFZETkNMRkZCUVZGelNTeEpRVUZKTTBjc1JVRkJVU3hKUVVGTlV5eEZRVUZQTEV0QlFVMW5SaXhGUVVGRmJVSXNlVUpCUXpORGNFVXNSMEZCVDJsRUxFVkJRVVZ0UWl4M1FrRkRWRzVDTEVWQlFVbHlTQ3hIUVVGSGFVVXNUVUZCVFVNc2FVSkJRV2xDYlVRc1NVRkZhRUlzYVVKQlFVeEJMRWRCUVhWQ0xFOUJRVTVCTEVWQlFWa3NRMEZEZEVNc1NVRkJTVzlDTEVWQlFVMDVTQ3hGUVVGVmQwZ3NiVUpCUTJ4Q1pDeFBRVU5uUWl4SlFVRlVla1lzUlVGQmRVSkJMRVZCUVZFc1NVRkJUVk1zUlVGQlR5eFRRVUZOY1Vjc1VVRkZka01zU1VGQlZEbEhMRWRCUTFRelFpeFJRVUZSYzBrc1NVRkJTVE5ITEVWQlFWRXNTVUZCVFZNc1JVRkJUeXhKUVVGTGIwY3NSMEZEZUVOeVJTeEhRVUZQY1VVc1IwRkhZaXhQUVVGUGNrVXNSMEZKVkhwRUxFVkJRVlZuU1N4MVFrRkJlVUlzVjBGRGFrTXNTVUZCU1VNc1JVRkJVV3BKTEVWQlFWVjNTQ3h0UWtGQmJVSjRTQ3hGUVVGVlNpeFhRVU51UkZJc1QwRkJUemhKTEZOQlFWTkRMR1ZCUVdVc2MwSkJRWE5DUXl4VlFVRlpTQ3hGUVVOcVJUZEpMRTlCUVU5cFNpeFhRVUZYY2trc1JVRkJWV2RKTEhWQ1FVRjNRaXhOUVVkMFJHaEpMRVZCUVZWelNTeFBRVUZUTEZkQlJXcENMRTlCUkdNNVNTeDFRa0ZCZFVJc1lVRkJZMUVzUlVGQlZYVkpMR0ZCZDBJdlJIWkpMRVZCUVZWMVNTeFhRVUZoTEZkQlEzSkNha29zVVVGQlVYTkpMRWxCUVVrc2QwSkJRMW9zU1VGQlNURkVMRVZCUVVzc1kwRkRWR2hHTEVWQlFVVXNVVUZCVVhOS0xFOUJRMUlzWlVGQmFVSjBSU3hGUVVGTExEWkRRVVY0UWl4SlFVRkpkVVVzUlVGQlZYSktMRTlCUVU4NFNTeFRRVUZUUXl4bFFVRmxha1VzUjBGRE4wTTNSU3hIUVVGSGNVb3NZMEZCWXpGSkxFVkJRVmQ1U1N4SFFVVTFRbkJLTEVkQlFVZHpTaXhWUVVGVlJpeEhRVVZVZWtrc1JVRkJWVFJKTEZGQlFWRTFTU3hGUVVGVk5Fa3NUMEZCVDBnc1JVRkJVVWtzWTBGQlkxZ3NWVUZKTjBRc1NVRkJTVmtzUlVGQlQwd3NSVUZCVVVrc1kwRkJZMWdzVTBGQlUyRXNVVUZSZEVOdVNpeEZRVTVHTEdGQlEwRnJTaXhGUVVGTFJTeE5RVU5LUml4RlFVRkxSeXhUUVVGWExGbEJRV05JTEVWQlFVdEhMRk5CUVZjc1NVRkJUU3hOUVVOdVJFZ3NSVUZCUzBjc1ZVRkJXVWdzUlVGQlMwa3NVMEZCVnl4VlFVRlpMRXRCUXpsRFNpeEZRVUZMU1N4VFFVRlhMRXRCUVU5S0xFVkJRVXRKTEZOQlFWY3NTVUZCVFN4SlFVTTVReXhKUVVWVkxFdEJRVTlVTEVWQlFWRkpMR05CUVdOWUxGTkJRVk5wUWl4blFrRkJaMEl2UXl4VlFVTnNSUzlITEVkQlFVY3JTaXhYUVVGWFdDeEhRWGREWkRkSkxFZEJSRUZCTEVkQlNrRkJMRWRCU2tGQkxFZEJTa0ZCTEVkQlNFRkJMRWRCU2tGQkxFZEJURUZCTEVkQlNFRkJMRWRCUmtGQkxFZEJSa0ZCTEVkQlJFRkJMRWRCVEVGQkxFVkJRVlZCTEVWQlFWRm5ReXhSUVVOb1Fpd3JSRUZEUVN4TFFVZG5Ra0VzVVVGQlVTd3lRa0ZCTkVJc1MwRkRjRU5CTEZGQlFWRXNhVUpCUVd0Q0xFdEJSVEZDUVN4UlFVRlJMSFZDUVVGM1FpeExRVVZvUTBFc1VVRkJVU3gxUTBGQmQwTXNTMEZIYUVSQkxGRkJRMmhDTEd0RVFVTkJMRlZCUjJkQ1FTeFJRVU5vUWl4clJFRkRRU3hWUVVWblFrRXNVVUZCVVN3MlFrRkJPRUlzVVVGSGRFTkJMRkZCUTJoQ0xEUkVRVU5CTEZWQlJXZENRU3hSUVVOb1FpdzBSRUZEUVN4VlFVVm5Ra0VzVVVGQlVTeHJRMEZCYlVNc1VVRkpNME5CTEZGQlFWRXNVMEZCVlN4UFFVTnNRa0VzVVVGQlVTeFRRVUZWTEUxQlRYQkRMRWxCUVVsNVNDeEhRVVJLZWtvc1JVRkJPRUpCTEVWQmVrWnNRbWRETEZGQlExWXNjMFZCUTBFc1UwRkJVMnRGTEVWQlFVOTNSQ3hGUVVGWFF5eEhRVU42UWl4SlFVRkpReXhGUVVGTExHTkJRV0ZHTEVWQlFWVXhTQ3hSUVVGUkxGRkJRVk1zUzBGQlR5eExRVmQ0UkN4UFFWWkJORWdzUjBGQlRVUXNSVUZEU0ROSUxGRkJRME1zZVVSQlEwRXNVMEZGUkVFc1VVRkJVU3g1UWtGQk1FSXNUVUZEYkVOQkxGRkJRVkVzYTBOQlFXMURMRTlCUXpORFFTeFJRVUZSTEhWQ1FVRjNRaXhKUVVOb1EwRXNVVUZCVVN4eFFrRkJjMElzU1VGRGFrTTBTQ3hIUVVGTkxIRkNRVGhGUVRGRUxFMUJRVTBzTmtKQlEyUnNSeXhGUVVGUmEwY3NUVUZCVFN4elFrRlJhRUlzVDBGUVNYVkVMRWRCUTBZdlNpeFJRVUZSYlVzc1MwRkRUaXd3UlVGRFFVb3NSMEZKUjNwS0xFZEJSMVJKTEVWQlFWVXdTaXh4UWtGQmRVSXNVMEZCVTBNc1IwRkRlRU42U3l4RlFVRkZlVXNzUjBGQldUbEVMRWxCUVVrM1JpeEZRVUZWZFVrc1pVRkhPVUoyU1N4RlFVRlZORW9zY1VKQlFYVkNMRk5CUVZORUxFZEJRM2hEZWtzc1JVRkJSWGxMTEVkQlFWazVSQ3hKUVVGSk4wWXNSVUZCVlRaS0xHVkJSemxDTjBvc1JVRkJWVGhLTEhWQ1FVRjVRaXhUUVVGVFNDeEhRVU14UXpOS0xFVkJRVlVyU2l4WFFVRlhOMHNzUlVGQlJYbExMRWRCUVZrNVJDeFJRVWR5UXpkR0xFVkJRVlZuU3l4bFFVRnBRaXhYUVVWNlFpeFBRVVJYTTBzc1IwRkJSelJMTEU5QlFVOXFTeXhGUVVGVmEwc3NWMEZKYWtOc1N5eEZRVUZWTmtvc1YwRkJZU3hYUVVWeVFpeFBRVVJYZUVzc1IwRkJSelJMTEU5QlFVOXFTeXhGUVVGVlNpeFZRVWxxUTBrc1JVRkJWVzFMTEZOQlFWY3NWMEZEYmtJc1QwRkJUemxMTEVkQlFVYzBSU3hMUVVGTGFrVXNSVUZCVlVvc1ZVRkhNMEpKTEVWQlFWVXJTaXhYUVVGaExGTkJRVk5MTEVkQlF6bENMRWxCUVVsd1J5eEZRVUZaTTBVc1IwRkJSMmxGTEUxQlFVMHJSeXhWUVVGVlJDeEhRVU51UTNCTExFVkJRVlZLTEZGQlFWRnRSaXhOUVVGTlppeEpRVWN4UW1oRkxFVkJRVlZ6U3l4WlFVRmpMRmRCUTNSQ0xFbEJRVWxETEVWQlFVOHNSMEZEVUVNc1JVRkJUWGhMTEVWQlFWVktMRlZCUVZVMlN5eFJRVVV4UWtNc1JVRkJWU3hUUVVGVFF5eEZRVUZSU2l4RlFVRk5ReXhIUVVOdVF5eEpRVUZMTEVsQlFVazVTU3hMUVVGUk9Fa3NSVUZEWml4SFFVRkpRU3hGUVVGSk4wa3NaVUZCWlVRc1IwRkJUeXhEUVVNMVFpeEpRVUZKYTBvc1JVRkJTWFpNTEVkQlFVZHBSU3hOUVVGTlF5eHBRa0ZCYVVKcFNDeEZRVUZKT1Vrc1NVRkROVUlzVDBGQlRtdEtMRWRCUVRCQ0xHbENRVUZNUVN4RlFVTjJRa1lzUlVGQlVXaEtMRVZCUVU4c1NVRkJTelpKTEVWQlFVMUxMRWRCUlRGQ1RDeEZRVUZMU1N4RlFVRlRha29zUjBGQlVXdEtMRWxCU3psQ1JpeEZRVUZSTEVkQlFVbElMRVZCUVUxRExFZEJSV3hDTEVsQlFVbExMRVZCUVZNc1IwRkRZaXhKUVVGTExFbEJRVWx1U2l4TFFVRlJOa2tzUlVGRFdFRXNSVUZCU3pWSkxHVkJRV1ZFTEVsQlFXbENMRkZCUVZKQkxFbEJReTlDYlVvc1IwRkJWVzVLTEVWQlFVOHNTMEZCVHpaSkxFVkJRVXMzU1N4SFFVRlJMRTlCUjNwRExFOUJRVTl0U2l4SFFWRlVOMHNzUlVGQlZUaExMRlZCUVZrc1UwRkJVelZHTEVkQlJUZENiRVlzUlVGQlZVTXNZMEZCWXpoTExGRkJRVkUzUml4SFFVVm9RMnhHTEVWQlFWVlJMR2xDUVVGcFFpeEpRVXMzUWxJc1JVRkJWV2RNTEZsQlFXTXNVMEZCVXpOR0xFZEJReTlDY2tZc1JVRkJWV2RDTEdGQlFWa3NTVUZIZUVKb1FpeEZRVUZWYVV3c1QwRkJVeXhUUVVGVFF5eEZRVUZWUXl4SFFVTndRMnBOTEVWQlFVVm5UU3hIUVVGVlJDeFBRVUZQUlN4SlFVbHlRbTVNTEVWQlFWVTBTQ3hKUVVGTkxGTkJRVk0xUml4RlFVRlZiMG9zUzBGclFqVkNjRXdzUlVGb2JVSlVUaXhQUVVGUGVVd3NVVUZCVlN4RFFVTm1SU3hoUVVGaExFVkJRMkp3U3l4UFFVRlBMRVZCUTFCeFN5eGpRVUZsTERCQ1FVTm1ReXhQUVVGUkxGZEJRMUpETEZGQlFWTXNTMEZEVkVNc1lVRkJZeXhOUVVOa1F5eGhRVUZqTEU5QlEyUkRMRkZCUVZNc1QwRkRWRU1zWjBKQlFXbENMRTlCUTJwQ1F5eFhRVUZaTEZGQlExcERMRmRCUVZrc1UwRkRXa01zVjBGQldTeFRRVU5hUXl4WFFVRlpMRmRCYzJ4Q1pFTXNUMEZCVDBNc1VVRkJWWFpOSWl3aVptbHNaU0k2SWk5d2NtbDJZWFJsTDNSdGNDOW1iMjh1UjA5RkwzTnlZeTlxY3k5MmFXVjNiVzlrWld3dWFuTWlmUT09Il19
